#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RC

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InputCore_structs.hpp"
#include "RC_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "SpRuntime_classes.hpp"
#include "CinematicCamera_classes.hpp"
#include "Foliage_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CriWareRuntime_classes.hpp"
#include "Text3D_classes.hpp"


namespace SDK
{

// Class RC.RCUserWidget
// 0x0000 (0x0270 - 0x0270)
class URCUserWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUserWidget">();
	}
	static class URCUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUserWidget>();
	}
};
static_assert(alignof(URCUserWidget) == 0x000008, "Wrong alignment on URCUserWidget");
static_assert(sizeof(URCUserWidget) == 0x000270, "Wrong size on URCUserWidget");

// Class RC.RCUiWidget
// 0x0028 (0x0298 - 0x0270)
class URCUiWidget : public URCUserWidget
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidgetAnimation*>               WidgetAnimation;                                   // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  IsWidgetAnimationLoop;                             // 0x0288(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnHideFinished();
	void OnHideStarted();
	void OnScreenHide();
	void OnScreenShow();
	void OnShowFinished();
	void OnShowStarted();
	void PlayWidgetAnimation(class UWidgetAnimation* InOneShotAnimation, class UWidgetAnimation* InLoopAnimation, const TArray<class UWidgetAnimation*>& InOneShotAnimationArray, const TArray<class UWidgetAnimation*>& InLoopAnimationArray);
	void StopWidgetAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiWidget">();
	}
	static class URCUiWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiWidget>();
	}
};
static_assert(alignof(URCUiWidget) == 0x000008, "Wrong alignment on URCUiWidget");
static_assert(sizeof(URCUiWidget) == 0x000298, "Wrong size on URCUiWidget");
static_assert(offsetof(URCUiWidget, WidgetAnimation) == 0x000278, "Member 'URCUiWidget::WidgetAnimation' has a wrong offset!");
static_assert(offsetof(URCUiWidget, IsWidgetAnimationLoop) == 0x000288, "Member 'URCUiWidget::IsWidgetAnimationLoop' has a wrong offset!");

// Class RC.RCUiWidgetBase
// 0x0040 (0x02D8 - 0x0298)
class URCUiWidgetBase : public URCUiWidget
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnablePause;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPause;                                          // 0x02B1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0xE];                                      // 0x02B2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MPCPath;                                           // 0x02C0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTimeOfMaterial;                                // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWidgetPause();
	bool LoadCheck();
	void MoveToCenter();
	void RegistTutorial();
	void ReleaseWidget();
	void SetPosition(const struct FVector2D& In2DPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiWidgetBase">();
	}
	static class URCUiWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiWidgetBase>();
	}
};
static_assert(alignof(URCUiWidgetBase) == 0x000008, "Wrong alignment on URCUiWidgetBase");
static_assert(sizeof(URCUiWidgetBase) == 0x0002D8, "Wrong size on URCUiWidgetBase");
static_assert(offsetof(URCUiWidgetBase, bEnablePause) == 0x0002B0, "Member 'URCUiWidgetBase::bEnablePause' has a wrong offset!");
static_assert(offsetof(URCUiWidgetBase, bIsPause) == 0x0002B1, "Member 'URCUiWidgetBase::bIsPause' has a wrong offset!");
static_assert(offsetof(URCUiWidgetBase, MPCPath) == 0x0002C0, "Member 'URCUiWidgetBase::MPCPath' has a wrong offset!");
static_assert(offsetof(URCUiWidgetBase, bUseTimeOfMaterial) == 0x0002D0, "Member 'URCUiWidgetBase::bUseTimeOfMaterial' has a wrong offset!");

// Class RC.RCNzUiFinalePGLayoutWidget
// 0x0050 (0x0328 - 0x02D8)
class URCNzUiFinalePGLayoutWidget final : public URCUiWidgetBase
{
public:
	TArray<class URCNzUiFinalePageGuideWidget*>   PageGuideList;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentPageIdx;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              pgOverlaySize;                                     // 0x02EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              pgOverlayLocation;                                 // 0x02F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiButtonGuideParts*                  BtnGuidePartsL;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  BtnGuidePartsR;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetPGLayoutLocationAndSize(struct FVector2D* Location, struct FVector2D* Size);
	bool InitializeButtonGuide(ERCInputKeyType keyL, ERCInputKeyType keyR);
	void InitializePGLayoutWidget(const TArray<EPageGuideType>& PageList);
	void MovePage(const int32 targetIdx);
	void OnButtonGuideClick(ERCInputKeyType KeyType);
	void UpdatePageGuide(const TArray<EPageGuideType>& PageList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePGLayoutWidget">();
	}
	static class URCNzUiFinalePGLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePGLayoutWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePGLayoutWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePGLayoutWidget");
static_assert(sizeof(URCNzUiFinalePGLayoutWidget) == 0x000328, "Wrong size on URCNzUiFinalePGLayoutWidget");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, PageGuideList) == 0x0002D8, "Member 'URCNzUiFinalePGLayoutWidget::PageGuideList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, CurrentPageIdx) == 0x0002E8, "Member 'URCNzUiFinalePGLayoutWidget::CurrentPageIdx' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, pgOverlaySize) == 0x0002EC, "Member 'URCNzUiFinalePGLayoutWidget::pgOverlaySize' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, pgOverlayLocation) == 0x0002F4, "Member 'URCNzUiFinalePGLayoutWidget::pgOverlayLocation' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, BtnGuidePartsL) == 0x000300, "Member 'URCNzUiFinalePGLayoutWidget::BtnGuidePartsL' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePGLayoutWidget, BtnGuidePartsR) == 0x000308, "Member 'URCNzUiFinalePGLayoutWidget::BtnGuidePartsR' has a wrong offset!");

// Class RC.RCActor
// 0x0068 (0x0288 - 0x0220)
class ARCActor : public AActor
{
public:
	class FName                                   ActorName;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialize;                                       // 0x0228(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleActor;                                     // 0x022A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPause;                                            // 0x022B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPauseCancel;                                      // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCActorCollisionPrisetInfo>    CollisonPrisetList;                                // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnLevelLoadEnd;                                    // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelUnLoadEnd;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x28];                                     // 0x0260(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetActorName();
	bool IsPause();
	bool IsPauseCancelFlag();
	bool IsVisibility();
	void SetPause(bool bInPause, bool bDirect);
	void SetPauseCancelFlag(bool bInPauseCancel);
	void SetVisibility(bool bInVisible, bool bDirect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActor">();
	}
	static class ARCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCActor>();
	}
};
static_assert(alignof(ARCActor) == 0x000008, "Wrong alignment on ARCActor");
static_assert(sizeof(ARCActor) == 0x000288, "Wrong size on ARCActor");
static_assert(offsetof(ARCActor, ActorName) == 0x000220, "Member 'ARCActor::ActorName' has a wrong offset!");
static_assert(offsetof(ARCActor, bInitialize) == 0x000228, "Member 'ARCActor::bInitialize' has a wrong offset!");
static_assert(offsetof(ARCActor, bVisible) == 0x000229, "Member 'ARCActor::bVisible' has a wrong offset!");
static_assert(offsetof(ARCActor, bVisibleActor) == 0x00022A, "Member 'ARCActor::bVisibleActor' has a wrong offset!");
static_assert(offsetof(ARCActor, bPause) == 0x00022B, "Member 'ARCActor::bPause' has a wrong offset!");
static_assert(offsetof(ARCActor, bPauseCancel) == 0x00022C, "Member 'ARCActor::bPauseCancel' has a wrong offset!");
static_assert(offsetof(ARCActor, CollisonPrisetList) == 0x000230, "Member 'ARCActor::CollisonPrisetList' has a wrong offset!");
static_assert(offsetof(ARCActor, OnLevelLoadEnd) == 0x000240, "Member 'ARCActor::OnLevelLoadEnd' has a wrong offset!");
static_assert(offsetof(ARCActor, OnLevelUnLoadEnd) == 0x000250, "Member 'ARCActor::OnLevelUnLoadEnd' has a wrong offset!");

// Class RC.RCSpiritMiniGameManager
// 0x0038 (0x02C0 - 0x0288)
class ARCSpiritMiniGameManager final : public ARCActor
{
public:
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpiritNiagaraActor;                                // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpiritNiagaraActorFollowCamera;                   // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSpiritMiniGameCheckPointType               CurrentCheckPoint;                                 // 0x0299(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCSpiritMiniGameCheckPoint*>    CheckPointArray;                                   // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHitWanderingSpirit;                               // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCWanderingSpiritHitData              HitData;                                           // 0x02B4(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSpiritMiniGameManager">();
	}
	static class ARCSpiritMiniGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSpiritMiniGameManager>();
	}
};
static_assert(alignof(ARCSpiritMiniGameManager) == 0x000008, "Wrong alignment on ARCSpiritMiniGameManager");
static_assert(sizeof(ARCSpiritMiniGameManager) == 0x0002C0, "Wrong size on ARCSpiritMiniGameManager");
static_assert(offsetof(ARCSpiritMiniGameManager, SpiritNiagaraActor) == 0x000290, "Member 'ARCSpiritMiniGameManager::SpiritNiagaraActor' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameManager, bSpiritNiagaraActorFollowCamera) == 0x000298, "Member 'ARCSpiritMiniGameManager::bSpiritNiagaraActorFollowCamera' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameManager, CurrentCheckPoint) == 0x000299, "Member 'ARCSpiritMiniGameManager::CurrentCheckPoint' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameManager, CheckPointArray) == 0x0002A0, "Member 'ARCSpiritMiniGameManager::CheckPointArray' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameManager, bHitWanderingSpirit) == 0x0002B0, "Member 'ARCSpiritMiniGameManager::bHitWanderingSpirit' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameManager, HitData) == 0x0002B4, "Member 'ARCSpiritMiniGameManager::HitData' has a wrong offset!");

// Class RC.RC3DWidgetComponent
// 0x0000 (0x05B0 - 0x05B0)
class URC3DWidgetComponent final : public UWidgetComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RC3DWidgetComponent">();
	}
	static class URC3DWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URC3DWidgetComponent>();
	}
};
static_assert(alignof(URC3DWidgetComponent) == 0x000010, "Wrong alignment on URC3DWidgetComponent");
static_assert(sizeof(URC3DWidgetComponent) == 0x0005B0, "Wrong size on URC3DWidgetComponent");

// Class RC.RCLevelSequenceActor
// 0x0030 (0x02D8 - 0x02A8)
class ARCLevelSequenceActor : public ALevelSequenceActor
{
public:
	class FName                                   SrquencerName;                                     // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0xC];                                      // 0x02B0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopStartRate;                                     // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopEndRate;                                       // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x14];                                     // 0x02C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLevelSequenceActor">();
	}
	static class ARCLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCLevelSequenceActor>();
	}
};
static_assert(alignof(ARCLevelSequenceActor) == 0x000008, "Wrong alignment on ARCLevelSequenceActor");
static_assert(sizeof(ARCLevelSequenceActor) == 0x0002D8, "Wrong size on ARCLevelSequenceActor");
static_assert(offsetof(ARCLevelSequenceActor, SrquencerName) == 0x0002A8, "Member 'ARCLevelSequenceActor::SrquencerName' has a wrong offset!");
static_assert(offsetof(ARCLevelSequenceActor, LoopStartRate) == 0x0002BC, "Member 'ARCLevelSequenceActor::LoopStartRate' has a wrong offset!");
static_assert(offsetof(ARCLevelSequenceActor, LoopEndRate) == 0x0002C0, "Member 'ARCLevelSequenceActor::LoopEndRate' has a wrong offset!");

// Class RC.RCShinigamiLevelSequenceActor
// 0x0058 (0x0330 - 0x02D8)
class ARCShinigamiLevelSequenceActor final : public ARCLevelSequenceActor
{
public:
	bool                                          bSpawn;                                            // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSequenceShinigamiTransformTypeLSA          TransformType;                                     // 0x02D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x02F0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	ERCSequenceShinigamiFollowType                FollowType;                                        // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSequenceShinigamiFollowTarget              FollowTarget;                                      // 0x0321(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_322[0x6];                                      // 0x0322(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FollowTargetActor;                                 // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiLevelSequenceActor">();
	}
	static class ARCShinigamiLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCShinigamiLevelSequenceActor>();
	}
};
static_assert(alignof(ARCShinigamiLevelSequenceActor) == 0x000010, "Wrong alignment on ARCShinigamiLevelSequenceActor");
static_assert(sizeof(ARCShinigamiLevelSequenceActor) == 0x000330, "Wrong size on ARCShinigamiLevelSequenceActor");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, bSpawn) == 0x0002D8, "Member 'ARCShinigamiLevelSequenceActor::bSpawn' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, TransformType) == 0x0002D9, "Member 'ARCShinigamiLevelSequenceActor::TransformType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, Actor) == 0x0002E0, "Member 'ARCShinigamiLevelSequenceActor::Actor' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, Transform) == 0x0002F0, "Member 'ARCShinigamiLevelSequenceActor::Transform' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, FollowType) == 0x000320, "Member 'ARCShinigamiLevelSequenceActor::FollowType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, FollowTarget) == 0x000321, "Member 'ARCShinigamiLevelSequenceActor::FollowTarget' has a wrong offset!");
static_assert(offsetof(ARCShinigamiLevelSequenceActor, FollowTargetActor) == 0x000328, "Member 'ARCShinigamiLevelSequenceActor::FollowTargetActor' has a wrong offset!");

// Class RC.RCAutoPlay
// 0x00B8 (0x00E8 - 0x0030)
class URCAutoPlay final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& InitPosition, const struct FRotator& InitRotate, float Alpha, const struct FVector& DistPosition, float RotAlpha, const struct FRotator& DistRotate, float HeadingAlpha, const struct FRotator& Heading)> Tick;                                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& InitPosition, const struct FRotator& InitRotate, float Alpha, const struct FVector& DistPosition, float RotAlpha, const struct FRotator& DistRotate, float HeadingAlpha, const struct FRotator& Heading)> Completed;                                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URCAutoPlay* AutoPlay(const class UObject* WorldContextObject, class AActor* Target, class AActor* Dist, float Duration, bool IgnoreZ, ERCAutoPlayCompletionPred Completion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAutoPlay">();
	}
	static class URCAutoPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAutoPlay>();
	}
};
static_assert(alignof(URCAutoPlay) == 0x000008, "Wrong alignment on URCAutoPlay");
static_assert(sizeof(URCAutoPlay) == 0x0000E8, "Wrong size on URCAutoPlay");
static_assert(offsetof(URCAutoPlay, Tick) == 0x0000C8, "Member 'URCAutoPlay::Tick' has a wrong offset!");
static_assert(offsetof(URCAutoPlay, Completed) == 0x0000D8, "Member 'URCAutoPlay::Completed' has a wrong offset!");

// Class RC.RCNzUiFinaleIndexClearWidget
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiFinaleIndexClearWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x02E0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         showTime;                                          // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              HiddenFinishDelegate;                              // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              IndexClearPlaySEDelegate;                          // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void PlayIndexClearShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleIndexClearWidget">();
	}
	static class URCNzUiFinaleIndexClearWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleIndexClearWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleIndexClearWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleIndexClearWidget");
static_assert(sizeof(URCNzUiFinaleIndexClearWidget) == 0x000310, "Wrong size on URCNzUiFinaleIndexClearWidget");
static_assert(offsetof(URCNzUiFinaleIndexClearWidget, AN_Start) == 0x0002D8, "Member 'URCNzUiFinaleIndexClearWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexClearWidget, TimerHandle) == 0x0002E0, "Member 'URCNzUiFinaleIndexClearWidget::TimerHandle' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexClearWidget, showTime) == 0x0002E8, "Member 'URCNzUiFinaleIndexClearWidget::showTime' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexClearWidget, HiddenFinishDelegate) == 0x0002F0, "Member 'URCNzUiFinaleIndexClearWidget::HiddenFinishDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexClearWidget, IndexClearPlaySEDelegate) == 0x000300, "Member 'URCNzUiFinaleIndexClearWidget::IndexClearPlaySEDelegate' has a wrong offset!");

// Class RC.AttbAsset
// 0x0020 (0x0048 - 0x0028)
class UAttbAsset final : public UObject
{
public:
	TArray<int32>                                 presetValue;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FString>                         ObjectValue;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttbAsset">();
	}
	static class UAttbAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttbAsset>();
	}
};
static_assert(alignof(UAttbAsset) == 0x000008, "Wrong alignment on UAttbAsset");
static_assert(sizeof(UAttbAsset) == 0x000048, "Wrong size on UAttbAsset");
static_assert(offsetof(UAttbAsset, presetValue) == 0x000028, "Member 'UAttbAsset::presetValue' has a wrong offset!");
static_assert(offsetof(UAttbAsset, ObjectValue) == 0x000038, "Member 'UAttbAsset::ObjectValue' has a wrong offset!");

// Class RC.RCAutoPlayActor
// 0x0120 (0x0340 - 0x0220)
class ARCAutoPlayActor final : public AActor
{
public:
	uint8                                         Pad_220[0x80];                                     // 0x0220(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& InitPosition, const struct FRotator& InitRotate, float Alpha, const struct FVector& DistPosition, float RotAlpha, const struct FRotator& DistRotate, float HeadingAlpha, const struct FRotator& Heading)> TickPin;                                           // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& InitPosition, const struct FRotator& InitRotate, float Alpha, const struct FVector& DistPosition, float RotAlpha, const struct FRotator& DistRotate, float HeadingAlpha, const struct FRotator& Heading)> CompletedPin;                                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x80];                                     // 0x02C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ARCAutoPlayActor* AutoPlayActor(const class UObject* WorldContextObject, class AActor* Target, class AActor* Dist, float Duration, bool IgnoreZ, ERCAutoPlayCompletionPred Completion);
	static class ARCAutoPlayActor* AutoPlayActor2(const class UObject* WorldContextObject, class AActor* Target, const struct FVector& InDistPos, const struct FRotator& InDistRot, float Duration, bool IgnoreZ, ERCAutoPlayCompletionPred Completion);

	void Abort();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAutoPlayActor">();
	}
	static class ARCAutoPlayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAutoPlayActor>();
	}
};
static_assert(alignof(ARCAutoPlayActor) == 0x000008, "Wrong alignment on ARCAutoPlayActor");
static_assert(sizeof(ARCAutoPlayActor) == 0x000340, "Wrong size on ARCAutoPlayActor");
static_assert(offsetof(ARCAutoPlayActor, TickPin) == 0x0002A0, "Member 'ARCAutoPlayActor::TickPin' has a wrong offset!");
static_assert(offsetof(ARCAutoPlayActor, CompletedPin) == 0x0002B0, "Member 'ARCAutoPlayActor::CompletedPin' has a wrong offset!");

// Class RC.RCGrassTransformer
// 0x0060 (0x0280 - 0x0220)
class ARCGrassTransformer : public AActor
{
public:
	class URCInteractiveFoliageComponent*         Component;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FRCGrassTransformParameter> TransformParameters;                               // 0x0228(0x0050)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bRemoveGrassFreshlyDeformedWhenStopUpdateInstance; // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartUpdate();
	void StartUpdateManagement();
	void StopUpdateInstance(int32 InstanceIndex);
	void StopUpdateManagement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassTransformer">();
	}
	static class ARCGrassTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassTransformer>();
	}
};
static_assert(alignof(ARCGrassTransformer) == 0x000008, "Wrong alignment on ARCGrassTransformer");
static_assert(sizeof(ARCGrassTransformer) == 0x000280, "Wrong size on ARCGrassTransformer");
static_assert(offsetof(ARCGrassTransformer, Component) == 0x000220, "Member 'ARCGrassTransformer::Component' has a wrong offset!");
static_assert(offsetof(ARCGrassTransformer, TransformParameters) == 0x000228, "Member 'ARCGrassTransformer::TransformParameters' has a wrong offset!");
static_assert(offsetof(ARCGrassTransformer, bRemoveGrassFreshlyDeformedWhenStopUpdateInstance) == 0x000278, "Member 'ARCGrassTransformer::bRemoveGrassFreshlyDeformedWhenStopUpdateInstance' has a wrong offset!");

// Class RC.RCGrassRippleDeformer
// 0x0050 (0x02D0 - 0x0280)
class ARCGrassRippleDeformer final : public ARCGrassTransformer
{
public:
	float                                         Radius;                                            // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleSpeed;                                       // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleInterval;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Waveform;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Attenuation;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedScale;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DeformCurve;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RippleRadius;                                      // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         RippleGenerateTimer;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeformTimer;                                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateGrassTransform();
	void UpdateRippleRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassRippleDeformer">();
	}
	static class ARCGrassRippleDeformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassRippleDeformer>();
	}
};
static_assert(alignof(ARCGrassRippleDeformer) == 0x000008, "Wrong alignment on ARCGrassRippleDeformer");
static_assert(sizeof(ARCGrassRippleDeformer) == 0x0002D0, "Wrong size on ARCGrassRippleDeformer");
static_assert(offsetof(ARCGrassRippleDeformer, Radius) == 0x000280, "Member 'ARCGrassRippleDeformer::Radius' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, Thickness) == 0x000284, "Member 'ARCGrassRippleDeformer::Thickness' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, RippleSpeed) == 0x000288, "Member 'ARCGrassRippleDeformer::RippleSpeed' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, RippleInterval) == 0x00028C, "Member 'ARCGrassRippleDeformer::RippleInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, Waveform) == 0x000290, "Member 'ARCGrassRippleDeformer::Waveform' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, Attenuation) == 0x000298, "Member 'ARCGrassRippleDeformer::Attenuation' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, SpeedScale) == 0x0002A0, "Member 'ARCGrassRippleDeformer::SpeedScale' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, DeformCurve) == 0x0002A8, "Member 'ARCGrassRippleDeformer::DeformCurve' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, RippleRadius) == 0x0002B0, "Member 'ARCGrassRippleDeformer::RippleRadius' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, RippleGenerateTimer) == 0x0002C0, "Member 'ARCGrassRippleDeformer::RippleGenerateTimer' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, UpdateInterval) == 0x0002C4, "Member 'ARCGrassRippleDeformer::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassRippleDeformer, DeformTimer) == 0x0002C8, "Member 'ARCGrassRippleDeformer::DeformTimer' has a wrong offset!");

// Class RC.RCCSVData
// 0x0008 (0x0030 - 0x0028)
class URCCSVData : public UObject
{
public:
	class UDataTable*                             DataTablePtr;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDataTable(class UDataTable* pDataTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCSVData">();
	}
	static class URCCSVData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCSVData>();
	}
};
static_assert(alignof(URCCSVData) == 0x000008, "Wrong alignment on URCCSVData");
static_assert(sizeof(URCCSVData) == 0x000030, "Wrong size on URCCSVData");
static_assert(offsetof(URCCSVData, DataTablePtr) == 0x000028, "Member 'URCCSVData::DataTablePtr' has a wrong offset!");

// Class RC.RCText3DActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCText3DActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetText(class FName InActorName);
	static class ARCText3DActor* GetText3DActor(class FName InActorName);
	static class FName GetTextID(class FName InActorName);
	static bool IsVisibility(class FName InActorName);
	static void SetTextID(class FName InActorName, class FName InTextID);
	static void SetVisibility(class FName InActorName, bool bInVisible, bool bDirect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCText3DActorBFL">();
	}
	static class URCText3DActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCText3DActorBFL>();
	}
};
static_assert(alignof(URCText3DActorBFL) == 0x000008, "Wrong alignment on URCText3DActorBFL");
static_assert(sizeof(URCText3DActorBFL) == 0x000028, "Wrong size on URCText3DActorBFL");

// Class RC.RCBackDropActor
// 0x00A0 (0x02C0 - 0x0220)
class ARCBackDropActor final : public AActor
{
public:
	uint8                                         Pad_220[0xA0];                                     // 0x0220(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPoint(const struct FVector& Pos, float W, float H, int32 Xbrock, int32 Ybrock);
	void Bake(int32 brockSize);
	void MakeScanMap(const struct FVector& Pos, int32 startX, int32 startY, int32 endX, int32 endY, int32 BrockSizeX, int32 BrockSizeY);
	bool NeedScap();
	void Reflesh();
	float RGBA2Hight(const struct FVector4& col);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBackDropActor">();
	}
	static class ARCBackDropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCBackDropActor>();
	}
};
static_assert(alignof(ARCBackDropActor) == 0x000008, "Wrong alignment on ARCBackDropActor");
static_assert(sizeof(ARCBackDropActor) == 0x0002C0, "Wrong size on ARCBackDropActor");

// Class RC.CascadeRainDataData
// 0x0050 (0x0080 - 0x0030)
class UCascadeRainDataData final : public URCCSVData
{
public:
	TMap<class FName, struct FCascadeRainDataTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CascadeRainDataData">();
	}
	static class UCascadeRainDataData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCascadeRainDataData>();
	}
};
static_assert(alignof(UCascadeRainDataData) == 0x000008, "Wrong alignment on UCascadeRainDataData");
static_assert(sizeof(UCascadeRainDataData) == 0x000080, "Wrong size on UCascadeRainDataData");
static_assert(offsetof(UCascadeRainDataData, Data) == 0x000030, "Member 'UCascadeRainDataData::Data' has a wrong offset!");

// Class RC.RCCharacter
// 0x0060 (0x0520 - 0x04C0)
class ARCCharacter : public ACharacter
{
public:
	class FName                                   CharacterName;                                     // 0x04B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialize;                                       // 0x04C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x04C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleCharacter;                                 // 0x04C2(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleIsCollision;                               // 0x04C3(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPause;                                            // 0x04C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPauseCancel;                                      // 0x04C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSimulatePhysics;                                  // 0x04C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C7[0x1];                                      // 0x04C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisonPrisetName;                                // 0x04C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int8>                                  CastShadowDefaultValues;                           // 0x04D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           MeshComponentNames;                                // 0x04E0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x30];                                     // 0x04F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPause();
	bool IsPauseCancelFlag();
	bool IsSimulatePhysicsFlag();
	bool IsVisibility();
	void SetPause(bool bPauseFlag, bool bDirectFlag);
	void SetPauseCancelFlag(bool bInPauseCancel);
	void SetSimulatePhysicsFlag(bool bInSimulatePhysics, bool bInDirect);
	void SetVisibility(bool bVisibleFlag, bool bDirectFlag, bool bIsCollision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacter">();
	}
	static class ARCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacter>();
	}
};
static_assert(alignof(ARCCharacter) == 0x000010, "Wrong alignment on ARCCharacter");
static_assert(sizeof(ARCCharacter) == 0x000520, "Wrong size on ARCCharacter");
static_assert(offsetof(ARCCharacter, CharacterName) == 0x0004B8, "Member 'ARCCharacter::CharacterName' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bInitialize) == 0x0004C0, "Member 'ARCCharacter::bInitialize' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bVisible) == 0x0004C1, "Member 'ARCCharacter::bVisible' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bVisibleCharacter) == 0x0004C2, "Member 'ARCCharacter::bVisibleCharacter' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bVisibleIsCollision) == 0x0004C3, "Member 'ARCCharacter::bVisibleIsCollision' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bPause) == 0x0004C4, "Member 'ARCCharacter::bPause' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bPauseCancel) == 0x0004C5, "Member 'ARCCharacter::bPauseCancel' has a wrong offset!");
static_assert(offsetof(ARCCharacter, bSimulatePhysics) == 0x0004C6, "Member 'ARCCharacter::bSimulatePhysics' has a wrong offset!");
static_assert(offsetof(ARCCharacter, CollisonPrisetName) == 0x0004C8, "Member 'ARCCharacter::CollisonPrisetName' has a wrong offset!");
static_assert(offsetof(ARCCharacter, CastShadowDefaultValues) == 0x0004D0, "Member 'ARCCharacter::CastShadowDefaultValues' has a wrong offset!");
static_assert(offsetof(ARCCharacter, MeshComponentNames) == 0x0004E0, "Member 'ARCCharacter::MeshComponentNames' has a wrong offset!");

// Class RC.RCCharacterScript
// 0x0190 (0x06B0 - 0x0520)
class ARCCharacterScript : public ARCCharacter
{
public:
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCScriptActorComponent*                ScriptActorComp;                                   // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0538(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x053C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartPlayer;                                    // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartPlayerEnable;                              // 0x0541(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLevelSetting;                                   // 0x0542(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_543[0x1];                                      // 0x0543(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0544(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OldDeltaTime;                                      // 0x0550(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveLength;                                        // 0x0554(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PreDirection;                                      // 0x0558(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DirectionAmount;                                   // 0x0564(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartDirectionComplement;                         // 0x0568(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionComplementSpeed;                          // 0x056C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDirectionAmount;                                // 0x0570(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartAntiDirectionComplement;                     // 0x0574(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionRate;                                     // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DirectionComplementSpeedRate;                      // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x24];                                     // 0x0580(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCScriptActorTurnSettings             TurnSettings;                                      // 0x05A4(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCScriptActorTurnInfo                 TurnInfo;                                          // 0x05B8(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCScriptActorTurnData                 TurnData;                                          // 0x05E4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTurnable;                                         // 0x05F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFootIK;                                           // 0x05F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F6[0x2];                                      // 0x05F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCScriptActorHitReactionSettings      HitReactionSettings;                               // 0x05F8(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCScriptActorHitReactionData          HitReactionData;                                   // 0x0628(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugScriptDraw;                                  // 0x063C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwari;                                         // 0x063D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTalk;                                             // 0x063E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerLookAtFace;                                 // 0x063F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TalkLabelName;                                     // 0x0640(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelifTextId;                                       // 0x0648(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BalloonFrameType;                                  // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BalloonType;                                       // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TalkLength;                                        // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SelifLength;                                       // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonLength;                                     // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonHeightOffset;                               // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonAngleOffset;                                // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonLengthOffset;                               // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DrawLayerName;                                     // 0x0670(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoading;                                        // 0x0678(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_679[0x3];                                      // 0x0679(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LoadAfterPosition;                                 // 0x067C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTalkEnable;                                       // 0x0688(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelifDraw;                                        // 0x0689(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBalloonDraw;                                      // 0x068A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68B[0x1];                                      // 0x068B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerLength;                                      // 0x068C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CenterLength;                                      // 0x0690(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCActorQuestType                             QuestType;                                         // 0x0694(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_695[0x3];                                      // 0x0695(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestTitleName;                                    // 0x0698(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNowPlayerLookAtFace;                              // 0x06A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWalkSpline;                                       // 0x06A1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A2[0xE];                                      // 0x06A2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BackupMovePosition();
	void EndTurn();
	struct FVector GetActorLocationBalloon();
	struct FVector GetActorLocationFoot();
	float GetDirectionAmount();
	struct FRCScriptActorFootIKData GetFootIKData();
	float GetMaxVelocityLengthInFrames();
	const float GetMoveSpeed();
	bool IsMoveEnd();
	void ResetMove();
	void RestoreMoveList();
	void RestoreMovePosition(float SpeedScale);
	void RestoreRotationYaw(float SpeedScale, bool bDirect);
	void SetMovePause(bool bInMovePause);
	void SetMoveSpeed(float InWalkSpeed, float InRunSpeed);
	void SetOrientRotationtoMovementFlag(bool bFlag);
	void SetPositionYaw(const struct FVector& InPosition, float InYaw);
	void SetTransformPlayerStartName(class FName InPlayerStartTagName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void SetTransformTargetPointName(class FName InPointName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void StartMoveFromPlayer(float InLength, float InAngle, float InHeight, float SpeedScale, bool bEndPlayerYaw, float TurnSpeedScale);
	void StartMoveFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bEndChangeYaw, const struct FVector& EndChangeYawPosition, bool bPlayerCheck, float TurnSpeedScale);
	void StartMoveFromPositionList(const TArray<struct FRCScriptActorMoveInfo>& InMoveInfoList, int32 StartMoveInfoNum, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	void StartMoveFromSplineName(class FName InSplineName, float StartDistanceRange, bool bReverse, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	void StartMoveFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, bool bEndChangeYaw, float InOffsetYaw, float InChangeYawSpeedScale, bool bPlayerCheck, float TurnSpeedScale);
	void StartRotationFromCharacter(class FName InTargetCharacterName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bDirect);
	void StartRotationFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationYaw(float Yaw, float SpeedScale, bool bDirect);
	void StartTurn(const float InAngle, float InSpeedScale);
	void StartTurnFromCharacter(class FName InTargetCharacterName, float InSpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw);
	void StartTurnFromPosition(const struct FVector& InPosition, float InSpeedScale, float InOffsetYaw);
	void StartTurnFromTargetPointName(class FName InPointName, float InSpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw);
	void StartTurnWorldDirection(const struct FVector& InTurnDirection, float InSpeedScale);
	void StartTurnYaw(float InYaw, float InSpeedScale);
	void StopMove();
	void StopRotation();

	class URCCharacterMovementComponent* GetRCCharacterMovementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterScript">();
	}
	static class ARCCharacterScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterScript>();
	}
};
static_assert(alignof(ARCCharacterScript) == 0x000010, "Wrong alignment on ARCCharacterScript");
static_assert(sizeof(ARCCharacterScript) == 0x0006B0, "Wrong size on ARCCharacterScript");
static_assert(offsetof(ARCCharacterScript, ScriptActorComp) == 0x000530, "Member 'ARCCharacterScript::ScriptActorComp' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, HalfHeight) == 0x000538, "Member 'ARCCharacterScript::HalfHeight' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, Radius) == 0x00053C, "Member 'ARCCharacterScript::Radius' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bIsStartPlayer) == 0x000540, "Member 'ARCCharacterScript::bIsStartPlayer' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bIsStartPlayerEnable) == 0x000541, "Member 'ARCCharacterScript::bIsStartPlayerEnable' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bIsLevelSetting) == 0x000542, "Member 'ARCCharacterScript::bIsLevelSetting' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, Velocity) == 0x000544, "Member 'ARCCharacterScript::Velocity' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, OldDeltaTime) == 0x000550, "Member 'ARCCharacterScript::OldDeltaTime' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, MoveLength) == 0x000554, "Member 'ARCCharacterScript::MoveLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, PreDirection) == 0x000558, "Member 'ARCCharacterScript::PreDirection' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, DirectionAmount) == 0x000564, "Member 'ARCCharacterScript::DirectionAmount' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bStartDirectionComplement) == 0x000568, "Member 'ARCCharacterScript::bStartDirectionComplement' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, DirectionComplementSpeed) == 0x00056C, "Member 'ARCCharacterScript::DirectionComplementSpeed' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, MaxDirectionAmount) == 0x000570, "Member 'ARCCharacterScript::MaxDirectionAmount' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bStartAntiDirectionComplement) == 0x000574, "Member 'ARCCharacterScript::bStartAntiDirectionComplement' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, DirectionRate) == 0x000578, "Member 'ARCCharacterScript::DirectionRate' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, DirectionComplementSpeedRate) == 0x00057C, "Member 'ARCCharacterScript::DirectionComplementSpeedRate' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, TurnSettings) == 0x0005A4, "Member 'ARCCharacterScript::TurnSettings' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, TurnInfo) == 0x0005B8, "Member 'ARCCharacterScript::TurnInfo' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, TurnData) == 0x0005E4, "Member 'ARCCharacterScript::TurnData' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bTurnable) == 0x0005F4, "Member 'ARCCharacterScript::bTurnable' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bFootIK) == 0x0005F5, "Member 'ARCCharacterScript::bFootIK' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, HitReactionSettings) == 0x0005F8, "Member 'ARCCharacterScript::HitReactionSettings' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, HitReactionData) == 0x000628, "Member 'ARCCharacterScript::HitReactionData' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bDebugScriptDraw) == 0x00063C, "Member 'ARCCharacterScript::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bKakiwari) == 0x00063D, "Member 'ARCCharacterScript::bKakiwari' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bTalk) == 0x00063E, "Member 'ARCCharacterScript::bTalk' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bPlayerLookAtFace) == 0x00063F, "Member 'ARCCharacterScript::bPlayerLookAtFace' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, TalkLabelName) == 0x000640, "Member 'ARCCharacterScript::TalkLabelName' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, SelifTextId) == 0x000648, "Member 'ARCCharacterScript::SelifTextId' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonFrameType) == 0x000650, "Member 'ARCCharacterScript::BalloonFrameType' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonType) == 0x000654, "Member 'ARCCharacterScript::BalloonType' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, TalkLength) == 0x000658, "Member 'ARCCharacterScript::TalkLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, SelifLength) == 0x00065C, "Member 'ARCCharacterScript::SelifLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonLength) == 0x000660, "Member 'ARCCharacterScript::BalloonLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonHeightOffset) == 0x000664, "Member 'ARCCharacterScript::BalloonHeightOffset' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonAngleOffset) == 0x000668, "Member 'ARCCharacterScript::BalloonAngleOffset' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, BalloonLengthOffset) == 0x00066C, "Member 'ARCCharacterScript::BalloonLengthOffset' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, DrawLayerName) == 0x000670, "Member 'ARCCharacterScript::DrawLayerName' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bIsLoading) == 0x000678, "Member 'ARCCharacterScript::bIsLoading' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, LoadAfterPosition) == 0x00067C, "Member 'ARCCharacterScript::LoadAfterPosition' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bTalkEnable) == 0x000688, "Member 'ARCCharacterScript::bTalkEnable' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bSelifDraw) == 0x000689, "Member 'ARCCharacterScript::bSelifDraw' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bBalloonDraw) == 0x00068A, "Member 'ARCCharacterScript::bBalloonDraw' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, PlayerLength) == 0x00068C, "Member 'ARCCharacterScript::PlayerLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, CenterLength) == 0x000690, "Member 'ARCCharacterScript::CenterLength' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, QuestType) == 0x000694, "Member 'ARCCharacterScript::QuestType' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, QuestTitleName) == 0x000698, "Member 'ARCCharacterScript::QuestTitleName' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bNowPlayerLookAtFace) == 0x0006A0, "Member 'ARCCharacterScript::bNowPlayerLookAtFace' has a wrong offset!");
static_assert(offsetof(ARCCharacterScript, bWalkSpline) == 0x0006A1, "Member 'ARCCharacterScript::bWalkSpline' has a wrong offset!");

// Class RC.RCCharacterRender
// 0x02B0 (0x0960 - 0x06B0)
class ARCCharacterRender : public ARCCharacterScript
{
public:
	class FName                                   CharacterId;                                       // 0x06B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseCharacterId;                                   // 0x06B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSameBaseCharacterId;                           // 0x06C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x3];                                      // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CurrentPreset;                                     // 0x06C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNameList;                                      // 0x06C8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           SocketNameList;                                    // 0x06D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class URCDitherFadeComponent*                 DitherFadeComp;                                    // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         MeshArray;                                         // 0x06F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         CharacterPartsList;                                // 0x0700(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           CharacterStaticMeshPartsList;                      // 0x0710(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_720[0x11];                                     // 0x0720(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyColorByTick;                                 // 0x0731(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_732[0x2];                                      // 0x0732(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CurrentAmbientLightColor;                          // 0x0734(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CurrentDirectionalLightColor;                      // 0x0744(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PreAmbientLightColor;                              // 0x0754(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PreDirectionalLightColor;                          // 0x0764(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PostAmbientLightColor;                             // 0x0774(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PostDirectionalLightColor;                         // 0x0784(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MapAmbientLightColor;                              // 0x0794(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MapDirectionalLightColor;                          // 0x07A4(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B4[0xC];                                      // 0x07B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentWetIntensity;                               // 0x07C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreWetIntensity;                                   // 0x07C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostWetIntensity;                                  // 0x07C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0xC];                                      // 0x07CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentEmissiveIntensity;                          // 0x07D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreEmissiveIntensity;                              // 0x07DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostEmissiveIntensity;                             // 0x07E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E4[0xC];                                      // 0x07E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTranslucentIntensity;                       // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreTranslucentIntensity;                           // 0x07F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostTranslucentIntensity;                          // 0x07F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FC[0xC];                                      // 0x07FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCCharacterRimLightChangeInfo> RimLightChangeInfoArray;                           // 0x0808(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0x10];                                     // 0x0818(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterialArray;                              // 0x0828(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentDitherAlpha;                                // 0x0838(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERCStencilType>                        DefaultStencilTypeArray;                           // 0x0840(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<ERCStencilType>                        DefaultStaticMeshStencilTypeArray;                 // 0x0850(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_860[0x18];                                     // 0x0860(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URCRainSplashEffectComponent*           RainEffectComp;                                    // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x4];                                      // 0x0880(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   KakiwariId;                                        // 0x0884(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraNearFade;                                   // 0x088C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraNearFadeOriginalFlag;                       // 0x088D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88E[0x2];                                      // 0x088E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraNearFadeOriginalLengthMin;                   // 0x0890(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraNearFadeOriginalLengthMax;                   // 0x0894(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BodyColorPaletteId;                                // 0x0898(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FaceColorPaletteId;                                // 0x08A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SoliderNumberId;                                   // 0x08A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EyeId;                                             // 0x08B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SkinId;                                            // 0x08B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BodyMaterialStartIndex;                            // 0x08C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BodyMaterialEndIndex;                              // 0x08C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FaceMaterialStartIndex;                            // 0x08C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FaceMaterialEndIndex;                              // 0x08CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SoldierNumberMaterialIndex;                        // 0x08D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SoliderNumberTexPath;                              // 0x08D4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SoliderNumberMaskTexPath;                          // 0x08DC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EyeTexPath;                                        // 0x08E4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SkinTexPath;                                       // 0x08EC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnLoad;                                           // 0x08F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnvironmentMaterialChange;                        // 0x08F5(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F6[0x2];                                      // 0x08F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BodyMeshName;                                      // 0x08F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FaceMeshName;                                      // 0x0908(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchIntegrationMob;                             // 0x0918(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_919[0x3];                                      // 0x0919(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharaMobSpecificMobID;                             // 0x091C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CharaMobSpecificIdleMotionName;                    // 0x0924(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CharaMobSpecificMoveMotionName;                    // 0x092C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_934[0x4];                                      // 0x0934(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCapsuleIndirectShadowMinVisibility;         // 0x0938(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93C[0x4];                                      // 0x093C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           UseAppearanceTexturePathArray;                     // 0x0940(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayerCollisionSetupDisable;                      // 0x0950(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_951[0xF];                                      // 0x0951(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeColorOfMaterials(const struct FLinearColor& InAmbientColor, const struct FLinearColor& InDirectionalColor, const float InDurationSec);
	void ChangeParameterOfEmissiveMaterials(const float InEmissiveIntensityValue, const float InDurationSec);
	void ChangeParameterOfRainMaterials(const float InRainIntensityValue, const float InWetIntensityValue, const float InWetDurationSec);
	void ChangeParameterOfRimLightMaterials(const struct FLinearColor& InOutlineColor, const float InOutlineCoverageValue, const float InOutlineSmoothValue, const float InRimLightDurationSec);
	void ChangeParameterOfTranslucentMaterials(const float InTranslucentIntensityValue, const float InDurationSec);
	bool GetFinishChangeRimLight();
	bool IsCameraFadeEnable();
	bool IsFadeEnd();
	void SetCameraFadeEnable(bool bFlag);
	void SetDither(const float InDitherAlphaValue);
	void SetFakeSpeed(float FakeSpeed);
	void SetupBgCharacterMaterial(const float InDurationSec);
	void SetUseFakeSpeedFlag(bool bUseFakeSpeed);
	void StartFadeIn(float InTime, bool InDirect);
	void StartFadeOut(float InTime, bool InDirect);
	void UndoParameterOfRimLightMaterials(const float InRimLightDurationSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterRender">();
	}
	static class ARCCharacterRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterRender>();
	}
};
static_assert(alignof(ARCCharacterRender) == 0x000010, "Wrong alignment on ARCCharacterRender");
static_assert(sizeof(ARCCharacterRender) == 0x000960, "Wrong size on ARCCharacterRender");
static_assert(offsetof(ARCCharacterRender, CharacterId) == 0x0006B0, "Member 'ARCCharacterRender::CharacterId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BaseCharacterId) == 0x0006B8, "Member 'ARCCharacterRender::BaseCharacterId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bUseSameBaseCharacterId) == 0x0006C0, "Member 'ARCCharacterRender::bUseSameBaseCharacterId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentPreset) == 0x0006C4, "Member 'ARCCharacterRender::CurrentPreset' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BoneNameList) == 0x0006C8, "Member 'ARCCharacterRender::BoneNameList' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SocketNameList) == 0x0006D8, "Member 'ARCCharacterRender::SocketNameList' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, DitherFadeComp) == 0x0006E8, "Member 'ARCCharacterRender::DitherFadeComp' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, MeshArray) == 0x0006F0, "Member 'ARCCharacterRender::MeshArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CharacterPartsList) == 0x000700, "Member 'ARCCharacterRender::CharacterPartsList' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CharacterStaticMeshPartsList) == 0x000710, "Member 'ARCCharacterRender::CharacterStaticMeshPartsList' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bApplyColorByTick) == 0x000731, "Member 'ARCCharacterRender::bApplyColorByTick' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentAmbientLightColor) == 0x000734, "Member 'ARCCharacterRender::CurrentAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentDirectionalLightColor) == 0x000744, "Member 'ARCCharacterRender::CurrentDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PreAmbientLightColor) == 0x000754, "Member 'ARCCharacterRender::PreAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PreDirectionalLightColor) == 0x000764, "Member 'ARCCharacterRender::PreDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PostAmbientLightColor) == 0x000774, "Member 'ARCCharacterRender::PostAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PostDirectionalLightColor) == 0x000784, "Member 'ARCCharacterRender::PostDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, MapAmbientLightColor) == 0x000794, "Member 'ARCCharacterRender::MapAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, MapDirectionalLightColor) == 0x0007A4, "Member 'ARCCharacterRender::MapDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentWetIntensity) == 0x0007C0, "Member 'ARCCharacterRender::CurrentWetIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PreWetIntensity) == 0x0007C4, "Member 'ARCCharacterRender::PreWetIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PostWetIntensity) == 0x0007C8, "Member 'ARCCharacterRender::PostWetIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentEmissiveIntensity) == 0x0007D8, "Member 'ARCCharacterRender::CurrentEmissiveIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PreEmissiveIntensity) == 0x0007DC, "Member 'ARCCharacterRender::PreEmissiveIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PostEmissiveIntensity) == 0x0007E0, "Member 'ARCCharacterRender::PostEmissiveIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentTranslucentIntensity) == 0x0007F0, "Member 'ARCCharacterRender::CurrentTranslucentIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PreTranslucentIntensity) == 0x0007F4, "Member 'ARCCharacterRender::PreTranslucentIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, PostTranslucentIntensity) == 0x0007F8, "Member 'ARCCharacterRender::PostTranslucentIntensity' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, RimLightChangeInfoArray) == 0x000808, "Member 'ARCCharacterRender::RimLightChangeInfoArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, DynamicMaterialArray) == 0x000828, "Member 'ARCCharacterRender::DynamicMaterialArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CurrentDitherAlpha) == 0x000838, "Member 'ARCCharacterRender::CurrentDitherAlpha' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, DefaultStencilTypeArray) == 0x000840, "Member 'ARCCharacterRender::DefaultStencilTypeArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, DefaultStaticMeshStencilTypeArray) == 0x000850, "Member 'ARCCharacterRender::DefaultStaticMeshStencilTypeArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, RainEffectComp) == 0x000878, "Member 'ARCCharacterRender::RainEffectComp' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, KakiwariId) == 0x000884, "Member 'ARCCharacterRender::KakiwariId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bCameraNearFade) == 0x00088C, "Member 'ARCCharacterRender::bCameraNearFade' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bCameraNearFadeOriginalFlag) == 0x00088D, "Member 'ARCCharacterRender::bCameraNearFadeOriginalFlag' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CameraNearFadeOriginalLengthMin) == 0x000890, "Member 'ARCCharacterRender::CameraNearFadeOriginalLengthMin' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CameraNearFadeOriginalLengthMax) == 0x000894, "Member 'ARCCharacterRender::CameraNearFadeOriginalLengthMax' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BodyColorPaletteId) == 0x000898, "Member 'ARCCharacterRender::BodyColorPaletteId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, FaceColorPaletteId) == 0x0008A0, "Member 'ARCCharacterRender::FaceColorPaletteId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SoliderNumberId) == 0x0008A8, "Member 'ARCCharacterRender::SoliderNumberId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, EyeId) == 0x0008B0, "Member 'ARCCharacterRender::EyeId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SkinId) == 0x0008B8, "Member 'ARCCharacterRender::SkinId' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BodyMaterialStartIndex) == 0x0008C0, "Member 'ARCCharacterRender::BodyMaterialStartIndex' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BodyMaterialEndIndex) == 0x0008C4, "Member 'ARCCharacterRender::BodyMaterialEndIndex' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, FaceMaterialStartIndex) == 0x0008C8, "Member 'ARCCharacterRender::FaceMaterialStartIndex' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, FaceMaterialEndIndex) == 0x0008CC, "Member 'ARCCharacterRender::FaceMaterialEndIndex' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SoldierNumberMaterialIndex) == 0x0008D0, "Member 'ARCCharacterRender::SoldierNumberMaterialIndex' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SoliderNumberTexPath) == 0x0008D4, "Member 'ARCCharacterRender::SoliderNumberTexPath' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SoliderNumberMaskTexPath) == 0x0008DC, "Member 'ARCCharacterRender::SoliderNumberMaskTexPath' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, EyeTexPath) == 0x0008E4, "Member 'ARCCharacterRender::EyeTexPath' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, SkinTexPath) == 0x0008EC, "Member 'ARCCharacterRender::SkinTexPath' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bOnLoad) == 0x0008F4, "Member 'ARCCharacterRender::bOnLoad' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bEnvironmentMaterialChange) == 0x0008F5, "Member 'ARCCharacterRender::bEnvironmentMaterialChange' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, BodyMeshName) == 0x0008F8, "Member 'ARCCharacterRender::BodyMeshName' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, FaceMeshName) == 0x000908, "Member 'ARCCharacterRender::FaceMeshName' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bSwitchIntegrationMob) == 0x000918, "Member 'ARCCharacterRender::bSwitchIntegrationMob' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CharaMobSpecificMobID) == 0x00091C, "Member 'ARCCharacterRender::CharaMobSpecificMobID' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CharaMobSpecificIdleMotionName) == 0x000924, "Member 'ARCCharacterRender::CharaMobSpecificIdleMotionName' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, CharaMobSpecificMoveMotionName) == 0x00092C, "Member 'ARCCharacterRender::CharaMobSpecificMoveMotionName' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, DefaultCapsuleIndirectShadowMinVisibility) == 0x000938, "Member 'ARCCharacterRender::DefaultCapsuleIndirectShadowMinVisibility' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, UseAppearanceTexturePathArray) == 0x000940, "Member 'ARCCharacterRender::UseAppearanceTexturePathArray' has a wrong offset!");
static_assert(offsetof(ARCCharacterRender, bPlayerCollisionSetupDisable) == 0x000950, "Member 'ARCCharacterRender::bPlayerCollisionSetupDisable' has a wrong offset!");

// Class RC.RCOptionChara
// 0x0030 (0x0990 - 0x0960)
class ARCOptionChara : public ARCCharacterRender
{
public:
	uint8                                         Pad_960[0x4];                                      // 0x0960(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_near;                                            // 0x0964(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_far;                                             // 0x0968(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96C[0x24];                                     // 0x096C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOptionChara">();
	}
	static class ARCOptionChara* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCOptionChara>();
	}
};
static_assert(alignof(ARCOptionChara) == 0x000010, "Wrong alignment on ARCOptionChara");
static_assert(sizeof(ARCOptionChara) == 0x000990, "Wrong size on ARCOptionChara");
static_assert(offsetof(ARCOptionChara, m_near) == 0x000964, "Member 'ARCOptionChara::m_near' has a wrong offset!");
static_assert(offsetof(ARCOptionChara, m_far) == 0x000968, "Member 'ARCOptionChara::m_far' has a wrong offset!");

// Class RC.RCOptionCharaShinigami
// 0x00D0 (0x0A60 - 0x0990)
class ARCOptionCharaShinigami final : public ARCOptionChara
{
public:
	uint8                                         Pad_990[0x18];                                     // 0x0990(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         sWarpRange;                                        // 0x09A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         sYumacapcelRange;                                  // 0x09AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         sYumaRange;                                        // 0x09B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         sYumaThinkRange;                                   // 0x09B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         sYumaMaxRange;                                     // 0x09B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         sfNiunireTime;                                     // 0x09BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         sfThinkTime;                                       // 0x09C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         sAddsped;                                          // 0x09C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_run_shikii;                                      // 0x09C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         tiltrot;                                           // 0x09CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         tiltime;                                           // 0x09D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Waitme;                                            // 0x09D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_MaxV;                                            // 0x09D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAI;                                            // 0x09DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9DD[0x83];                                     // 0x09DD(0x0083)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetShinigamiFrame();
	float GetShinigamiSpeed();
	int32 GetShinigamiStat();
	int32 GetShinigamiTilt();
	bool IsUseAI();
	void RemoveSsite();
	void SetUseAI(bool bFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOptionCharaShinigami">();
	}
	static class ARCOptionCharaShinigami* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCOptionCharaShinigami>();
	}
};
static_assert(alignof(ARCOptionCharaShinigami) == 0x000010, "Wrong alignment on ARCOptionCharaShinigami");
static_assert(sizeof(ARCOptionCharaShinigami) == 0x000A60, "Wrong size on ARCOptionCharaShinigami");
static_assert(offsetof(ARCOptionCharaShinigami, sWarpRange) == 0x0009A8, "Member 'ARCOptionCharaShinigami::sWarpRange' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sYumacapcelRange) == 0x0009AC, "Member 'ARCOptionCharaShinigami::sYumacapcelRange' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sYumaRange) == 0x0009B0, "Member 'ARCOptionCharaShinigami::sYumaRange' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sYumaThinkRange) == 0x0009B4, "Member 'ARCOptionCharaShinigami::sYumaThinkRange' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sYumaMaxRange) == 0x0009B8, "Member 'ARCOptionCharaShinigami::sYumaMaxRange' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sfNiunireTime) == 0x0009BC, "Member 'ARCOptionCharaShinigami::sfNiunireTime' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sfThinkTime) == 0x0009C0, "Member 'ARCOptionCharaShinigami::sfThinkTime' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, sAddsped) == 0x0009C4, "Member 'ARCOptionCharaShinigami::sAddsped' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, m_run_shikii) == 0x0009C8, "Member 'ARCOptionCharaShinigami::m_run_shikii' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, tiltrot) == 0x0009CC, "Member 'ARCOptionCharaShinigami::tiltrot' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, tiltime) == 0x0009D0, "Member 'ARCOptionCharaShinigami::tiltime' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, Waitme) == 0x0009D4, "Member 'ARCOptionCharaShinigami::Waitme' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, m_MaxV) == 0x0009D8, "Member 'ARCOptionCharaShinigami::m_MaxV' has a wrong offset!");
static_assert(offsetof(ARCOptionCharaShinigami, bUseAI) == 0x0009DC, "Member 'ARCOptionCharaShinigami::bUseAI' has a wrong offset!");

// Class RC.RCMenuWidget
// 0x0008 (0x02E0 - 0x02D8)
class URCMenuWidget : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuWidget">();
	}
	static class URCMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuWidget>();
	}
};
static_assert(alignof(URCMenuWidget) == 0x000008, "Wrong alignment on URCMenuWidget");
static_assert(sizeof(URCMenuWidget) == 0x0002E0, "Wrong size on URCMenuWidget");

// Class RC.RCMenuButton
// 0x0040 (0x0320 - 0x02E0)
class URCMenuButton : public URCMenuWidget
{
public:
	class UTextLayoutWidget*                      Caption;                                           // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Text;                                              // 0x02E8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsDisabled;                                       // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDecided;                                         // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeDecide();
	void OnChangeDisable();
	void OnChangeNormal();
	void OnChangeSelect();
	void OnDecideHideStarted();
	void OnDisableHideStarted();
	void OnDisableShowStarted();
	void OnNormalHideStarted();
	void OnNormalShowStarted();
	void OnSelectHideStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuButton">();
	}
	static class URCMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuButton>();
	}
};
static_assert(alignof(URCMenuButton) == 0x000008, "Wrong alignment on URCMenuButton");
static_assert(sizeof(URCMenuButton) == 0x000320, "Wrong size on URCMenuButton");
static_assert(offsetof(URCMenuButton, Caption) == 0x0002E0, "Member 'URCMenuButton::Caption' has a wrong offset!");
static_assert(offsetof(URCMenuButton, Text) == 0x0002E8, "Member 'URCMenuButton::Text' has a wrong offset!");
static_assert(offsetof(URCMenuButton, bIsDisabled) == 0x000300, "Member 'URCMenuButton::bIsDisabled' has a wrong offset!");
static_assert(offsetof(URCMenuButton, OnDecided) == 0x000308, "Member 'URCMenuButton::OnDecided' has a wrong offset!");

// Class RC.RCEvaluationTitleStart
// 0x0020 (0x0340 - 0x0320)
class URCEvaluationTitleStart final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Active;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_InActive;                                       // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Pressed;                                        // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentMouseSelect;                              // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEvaluationTitleStart">();
	}
	static class URCEvaluationTitleStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEvaluationTitleStart>();
	}
};
static_assert(alignof(URCEvaluationTitleStart) == 0x000008, "Wrong alignment on URCEvaluationTitleStart");
static_assert(sizeof(URCEvaluationTitleStart) == 0x000340, "Wrong size on URCEvaluationTitleStart");
static_assert(offsetof(URCEvaluationTitleStart, AN_Active) == 0x000320, "Member 'URCEvaluationTitleStart::AN_Active' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleStart, AN_InActive) == 0x000328, "Member 'URCEvaluationTitleStart::AN_InActive' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleStart, AN_Pressed) == 0x000330, "Member 'URCEvaluationTitleStart::AN_Pressed' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleStart, isCurrentMouseSelect) == 0x000338, "Member 'URCEvaluationTitleStart::isCurrentMouseSelect' has a wrong offset!");

// Class RC.RCBackDropBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCBackDropBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBackDropBPFunctionLibrary">();
	}
	static class URCBackDropBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBackDropBPFunctionLibrary>();
	}
};
static_assert(alignof(URCBackDropBPFunctionLibrary) == 0x000008, "Wrong alignment on URCBackDropBPFunctionLibrary");
static_assert(sizeof(URCBackDropBPFunctionLibrary) == 0x000028, "Wrong size on URCBackDropBPFunctionLibrary");

// Class RC.RCUiOptionKeyBoxWarning
// 0x0010 (0x02E8 - 0x02D8)
class URCUiOptionKeyBoxWarning final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Off;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On;                                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKeyBoxWarning">();
	}
	static class URCUiOptionKeyBoxWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKeyBoxWarning>();
	}
};
static_assert(alignof(URCUiOptionKeyBoxWarning) == 0x000008, "Wrong alignment on URCUiOptionKeyBoxWarning");
static_assert(sizeof(URCUiOptionKeyBoxWarning) == 0x0002E8, "Wrong size on URCUiOptionKeyBoxWarning");
static_assert(offsetof(URCUiOptionKeyBoxWarning, AN_Off) == 0x0002D8, "Member 'URCUiOptionKeyBoxWarning::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiOptionKeyBoxWarning, AN_On) == 0x0002E0, "Member 'URCUiOptionKeyBoxWarning::AN_On' has a wrong offset!");

// Class RC.CascadeRainDataElement
// 0x0020 (0x0048 - 0x0028)
class UCascadeRainDataElement final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CascadeRainDataElement">();
	}
	static class UCascadeRainDataElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCascadeRainDataElement>();
	}
};
static_assert(alignof(UCascadeRainDataElement) == 0x000008, "Wrong alignment on UCascadeRainDataElement");
static_assert(sizeof(UCascadeRainDataElement) == 0x000048, "Wrong size on UCascadeRainDataElement");

// Class RC.RCNzUiFinalePieceLayoutWidget
// 0x00D8 (0x03B0 - 0x02D8)
class URCNzUiFinalePieceLayoutWidget final : public URCUiWidgetBase
{
public:
	class URCNzUiFinalePieceNameWidget*           PieceName;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceDetailWidget*         PieceDetail;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PieceSListParentLocation;                          // 0x02E8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PieceSListParentSize;                              // 0x02F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCNzUiFinalePieceList_PieceBase*> PieceSList;                                        // 0x0300(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCNzUiFinalePieceList_PieceBase*> PieceLList;                                        // 0x0310(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Default;                                        // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPieceListVisible;                                // 0x0338(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PieceListPieceNum;                                 // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     RockNumTextureList;                                // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     SmallRockNumTextureList;                           // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 RockNumTexturePath;                                // 0x0360(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SmallRockNumTexturePath;                           // 0x0370(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  BtnGuideParts;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ButtonGuideBaseImage;                              // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isHoverdPieceList;                                 // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PieceLockImgNum;                                   // 0x0394(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnlockAnimPlayPieceListIdx;                        // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         delayUnlockAnimTiming;                             // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const class FString& PieceTitle, class UTexture2D* PieceImg, int32 lockNum, bool isUsed, bool isUnlockAnim)> ChangedSelectPieceDelegate;                        // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallChangeSelectPieceDelegate(const struct FRCNzFinalePieceObjectInfo& Info, bool isUnlock);
	void FinishUnlockAnimPieceLList();
	void FinishUnlockSListAnim();
	struct FRCNzFinalePieceObjectInfo GetCurrentSelectedInfo();
	int32 GetCurrentSelectedPieceIdx();
	bool GetIsHoverdPieceList();
	int32 GetOneLinePieceItemNum();
	TArray<class URCNzUiFinalePieceList_PieceBase*> GetPieceListItemLArray();
	float GetPieceListLAngle();
	struct FVector2D GetPieceListLParentSize();
	struct FVector2D GetPieceListLScale();
	void GetPieceSListParentLocAndSize(struct FVector2D* Loc, struct FVector2D* Size);
	void GetPieceSLocAndSize(int32 idx, struct FVector2D* Loc, struct FVector2D* Size);
	TArray<int32> GetPlayUnlockAnimPieceLList(bool* Result);
	class UTexture2D* GetRockNumTexture(int32 RockNum, bool isSmall);
	void InitializePieceLayout();
	bool IsDetailPieceListMode();
	bool IsVisiblePieceList();
	struct FRCNzFinalePieceObjectInfo LoadPieceImage(class ARCNzFinaleManagerBase* FinaleManager, const struct FRCNzFinalePieceObjectInfo& targetInfo, bool isSmall);
	void OpenPieceSelectWindow();
	void PieceLayoutOpenEvent();
	void PlayUnLockSE();
	void SetDelayUnLockAnimTime(float Time);
	void SetIsHoverdPieceList(bool Val);
	void StartFinish();
	void StartOpen();
	void StartUnlockAnimPieceList(const TArray<int32>& pieceList);
	void StartUnlockAnimPieceSlist(const TArray<int32>& pieceList);
	void UdpatePieceLayoutBtnGuide(ERCInputKeyType KeyType);
	void UnlockCurrentSelectPiece();
	void UpdateSelectPieceIdx(int32 idx);
	void WaitingOpen();

	struct FVector2D GetPieceLCenterPosition(int32 ind) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceLayoutWidget">();
	}
	static class URCNzUiFinalePieceLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceLayoutWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePieceLayoutWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePieceLayoutWidget");
static_assert(sizeof(URCNzUiFinalePieceLayoutWidget) == 0x0003B0, "Wrong size on URCNzUiFinalePieceLayoutWidget");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceName) == 0x0002D8, "Member 'URCNzUiFinalePieceLayoutWidget::PieceName' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceDetail) == 0x0002E0, "Member 'URCNzUiFinalePieceLayoutWidget::PieceDetail' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceSListParentLocation) == 0x0002E8, "Member 'URCNzUiFinalePieceLayoutWidget::PieceSListParentLocation' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceSListParentSize) == 0x0002F4, "Member 'URCNzUiFinalePieceLayoutWidget::PieceSListParentSize' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceSList) == 0x000300, "Member 'URCNzUiFinalePieceLayoutWidget::PieceSList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceLList) == 0x000310, "Member 'URCNzUiFinalePieceLayoutWidget::PieceLList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, AN_Start) == 0x000320, "Member 'URCNzUiFinalePieceLayoutWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, AN_Finish) == 0x000328, "Member 'URCNzUiFinalePieceLayoutWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, AN_Default) == 0x000330, "Member 'URCNzUiFinalePieceLayoutWidget::AN_Default' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, isPieceListVisible) == 0x000338, "Member 'URCNzUiFinalePieceLayoutWidget::isPieceListVisible' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceListPieceNum) == 0x00033C, "Member 'URCNzUiFinalePieceLayoutWidget::PieceListPieceNum' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, RockNumTextureList) == 0x000340, "Member 'URCNzUiFinalePieceLayoutWidget::RockNumTextureList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, SmallRockNumTextureList) == 0x000350, "Member 'URCNzUiFinalePieceLayoutWidget::SmallRockNumTextureList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, RockNumTexturePath) == 0x000360, "Member 'URCNzUiFinalePieceLayoutWidget::RockNumTexturePath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, SmallRockNumTexturePath) == 0x000370, "Member 'URCNzUiFinalePieceLayoutWidget::SmallRockNumTexturePath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, BtnGuideParts) == 0x000380, "Member 'URCNzUiFinalePieceLayoutWidget::BtnGuideParts' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, ButtonGuideBaseImage) == 0x000388, "Member 'URCNzUiFinalePieceLayoutWidget::ButtonGuideBaseImage' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, isHoverdPieceList) == 0x000390, "Member 'URCNzUiFinalePieceLayoutWidget::isHoverdPieceList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, PieceLockImgNum) == 0x000394, "Member 'URCNzUiFinalePieceLayoutWidget::PieceLockImgNum' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, UnlockAnimPlayPieceListIdx) == 0x000398, "Member 'URCNzUiFinalePieceLayoutWidget::UnlockAnimPlayPieceListIdx' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, delayUnlockAnimTiming) == 0x00039C, "Member 'URCNzUiFinalePieceLayoutWidget::delayUnlockAnimTiming' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceLayoutWidget, ChangedSelectPieceDelegate) == 0x0003A0, "Member 'URCNzUiFinalePieceLayoutWidget::ChangedSelectPieceDelegate' has a wrong offset!");

// Class RC.RainBrock
// 0x0000 (0x0220 - 0x0220)
class ARainBrock final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RainBrock">();
	}
	static class ARainBrock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARainBrock>();
	}
};
static_assert(alignof(ARainBrock) == 0x000008, "Wrong alignment on ARainBrock");
static_assert(sizeof(ARainBrock) == 0x000220, "Wrong size on ARainBrock");

// Class RC.RCUiOptionBarVolume
// 0x0028 (0x0300 - 0x02D8)
class URCUiOptionBarVolume final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SynchronizeToSlider(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarVolume">();
	}
	static class URCUiOptionBarVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarVolume>();
	}
};
static_assert(alignof(URCUiOptionBarVolume) == 0x000008, "Wrong alignment on URCUiOptionBarVolume");
static_assert(sizeof(URCUiOptionBarVolume) == 0x000300, "Wrong size on URCUiOptionBarVolume");

// Class RC.RainDataData
// 0x0050 (0x0080 - 0x0030)
class URainDataData final : public URCCSVData
{
public:
	TMap<class FName, struct FRainDataTableRow>   Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RainDataData">();
	}
	static class URainDataData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URainDataData>();
	}
};
static_assert(alignof(URainDataData) == 0x000008, "Wrong alignment on URainDataData");
static_assert(sizeof(URainDataData) == 0x000080, "Wrong size on URainDataData");
static_assert(offsetof(URainDataData, Data) == 0x000030, "Member 'URainDataData::Data' has a wrong offset!");

// Class RC.RainDataElement
// 0x0020 (0x0048 - 0x0028)
class URainDataElement final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RainDataElement">();
	}
	static class URainDataElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URainDataElement>();
	}
};
static_assert(alignof(URainDataElement) == 0x000008, "Wrong alignment on URainDataElement");
static_assert(sizeof(URainDataElement) == 0x000048, "Wrong size on URainDataElement");

// Class RC.RCAchievementBFL
// 0x0000 (0x0028 - 0x0028)
class URCAchievementBFL final : public UBlueprintFunctionLibrary
{
public:
	static void Unlock(ERCAchievementID InAchievementID);
	static void UnlockByOperationID(ERCAchievementOperationID InAchievementOperationID, int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementBFL">();
	}
	static class URCAchievementBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementBFL>();
	}
};
static_assert(alignof(URCAchievementBFL) == 0x000008, "Wrong alignment on URCAchievementBFL");
static_assert(sizeof(URCAchievementBFL) == 0x000028, "Wrong size on URCAchievementBFL");

// Class RC.RCInputBFL
// 0x0000 (0x0028 - 0x0028)
class URCInputBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeInputMode(ERCInputMode InInputMode, class FName InModeName);
	static float GetAmatanMoveFront();
	static float GetAmatanMoveTurn();
	static float GetCameraMovePitch(bool bInSurvey);
	static float GetCameraMoveYaw(bool bInSurvey);
	static float GetCameraMoveZoon();
	static bool GetCursolPointerInfo(ERCInputCursolInfoType* OutInputType, struct FVector2D* OutScreenPosition, struct FVector2D* OutMove, bool bInSurvey);
	static bool GetDrawKey(struct FKey* OutKey, ERCInputButtonType OutKyeType, ERCInputKeyType KyeType);
	static bool GetFinaleCursolPointerInfo(ERCInputCursolInfoType* OutInputType, struct FVector2D* OutScreenPosition, struct FVector2D* OutMove);
	static ERCInputPlatform GetInputPlatform();
	static bool GetKey(struct FKey* OutKey, ERCInputButtonType OutKyeType, ERCInputKeyType KyeType, ERCInputHardwareType InInputHardwareType);
	static float GetLeverValue(ERCInputKeyType KyeType);
	static float GetPlayerMoveFront();
	static float GetPlayerMoveSide();
	static float GetPointerValue(ERCInputKeyType KyeType);
	static bool IsDebugGameClear();
	static bool IsDebugGameTimeUp();
	static bool IsDebugMenuTrigger();
	static bool IsDown(ERCInputKeyType KyeType);
	static bool IsMove(ERCInputKeyType KyeType);
	static bool IsPressed(ERCInputKeyType KyeType);
	static bool IsReleased(ERCInputKeyType KyeType);
	static bool IsRepeat(ERCInputKeyType KyeType);
	static void PopInputMode(class FName InModeName, bool InAllPop);
	static void PushInputMode(ERCInputMode InInputMode, class FName InModeName);
	static void ResetInputMode();
	static void SetPressedDebug(ERCInputKeyType KyeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInputBFL">();
	}
	static class URCInputBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInputBFL>();
	}
};
static_assert(alignof(URCInputBFL) == 0x000008, "Wrong alignment on URCInputBFL");
static_assert(sizeof(URCInputBFL) == 0x000028, "Wrong size on URCInputBFL");

// Class RC.RCAchievementInterface
// 0x0000 (0x0028 - 0x0028)
class URCAchievementInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementInterface">();
	}
	static class URCAchievementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementInterface>();
	}
};
static_assert(alignof(URCAchievementInterface) == 0x000008, "Wrong alignment on URCAchievementInterface");
static_assert(sizeof(URCAchievementInterface) == 0x000028, "Wrong size on URCAchievementInterface");

// Class RC.RCNzUiBattleKaiKagiSelectParts
// 0x0040 (0x0318 - 0x02D8)
class URCNzUiBattleKaiKagiSelectParts final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Next;                                           // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Prev;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               AnimArray;                                         // 0x0300(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeBattleKaiKagiSelectParts();
	void PlayAnim(ERCNzUiBattleKaiKagiSelectPartsAnimType AnimType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectParts">();
	}
	static class URCNzUiBattleKaiKagiSelectParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectParts>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectParts) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectParts");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectParts) == 0x000318, "Wrong size on URCNzUiBattleKaiKagiSelectParts");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AN_Start) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiSelectParts::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AN_Wait) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiSelectParts::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AN_Finish) == 0x0002E8, "Member 'URCNzUiBattleKaiKagiSelectParts::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AN_Next) == 0x0002F0, "Member 'URCNzUiBattleKaiKagiSelectParts::AN_Next' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AN_Prev) == 0x0002F8, "Member 'URCNzUiBattleKaiKagiSelectParts::AN_Prev' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectParts, AnimArray) == 0x000300, "Member 'URCNzUiBattleKaiKagiSelectParts::AnimArray' has a wrong offset!");

// Class RC.RCUiMenuQuestCaption
// 0x0030 (0x0308 - 0x02D8)
class URCUiMenuQuestCaption final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Quest_Caption;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_SubQuest_Caption;                             // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x20];                                     // 0x02E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestCaption">();
	}
	static class URCUiMenuQuestCaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestCaption>();
	}
};
static_assert(alignof(URCUiMenuQuestCaption) == 0x000008, "Wrong alignment on URCUiMenuQuestCaption");
static_assert(sizeof(URCUiMenuQuestCaption) == 0x000308, "Wrong size on URCUiMenuQuestCaption");
static_assert(offsetof(URCUiMenuQuestCaption, Text_Quest_Caption) == 0x0002D8, "Member 'URCUiMenuQuestCaption::Text_Quest_Caption' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestCaption, Text_SubQuest_Caption) == 0x0002E0, "Member 'URCUiMenuQuestCaption::Text_SubQuest_Caption' has a wrong offset!");

// Class RC.RCAchievementGeneric
// 0x0018 (0x0040 - 0x0028)
class URCAchievementGeneric final : public URCAchievementInterface
{
public:
	TArray<class URCAchievementProcessGeneric*>   ProcessList;                                       // 0x0028(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementGeneric">();
	}
	static class URCAchievementGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementGeneric>();
	}
};
static_assert(alignof(URCAchievementGeneric) == 0x000008, "Wrong alignment on URCAchievementGeneric");
static_assert(sizeof(URCAchievementGeneric) == 0x000040, "Wrong size on URCAchievementGeneric");
static_assert(offsetof(URCAchievementGeneric, ProcessList) == 0x000028, "Member 'URCAchievementGeneric::ProcessList' has a wrong offset!");

// Class RC.RCNzUiFinaleTimeLimitBase
// 0x0090 (0x0368 - 0x02D8)
class URCNzUiFinaleTimeLimitBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Lighting_A;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Burn_A;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_BurnOut_A;                                      // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_BurnOut_B;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isBurnOutB;                                        // 0x0300(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             Finished_AN_Lighting_A;                            // 0x0304(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Finished_AN_BurnOut_A;                             // 0x0314(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Finished_AN_BurnOut_B;                             // 0x0324(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              FinishedLightingADelegate;                         // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishedBurnOutADelegate;                          // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishedBurnOutBDelegate;                          // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Finished_AN_BurnOutA_Event();
	void Finished_AN_BurnOutB_Event();
	void Finished_AN_Lighting_A_Event();
	void InitializeTimeLimit();
	void PlayBurnAAnim();
	void PlayBurnOutAAnim();
	void PlayBurnOutBAnim();
	void PlayGameOverAnim();
	void PlayTimerStartAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleTimeLimitBase">();
	}
	static class URCNzUiFinaleTimeLimitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleTimeLimitBase>();
	}
};
static_assert(alignof(URCNzUiFinaleTimeLimitBase) == 0x000008, "Wrong alignment on URCNzUiFinaleTimeLimitBase");
static_assert(sizeof(URCNzUiFinaleTimeLimitBase) == 0x000368, "Wrong size on URCNzUiFinaleTimeLimitBase");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, AN_Lighting_A) == 0x0002D8, "Member 'URCNzUiFinaleTimeLimitBase::AN_Lighting_A' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, AN_Burn_A) == 0x0002E0, "Member 'URCNzUiFinaleTimeLimitBase::AN_Burn_A' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, AN_BurnOut_A) == 0x0002E8, "Member 'URCNzUiFinaleTimeLimitBase::AN_BurnOut_A' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, AN_BurnOut_B) == 0x0002F0, "Member 'URCNzUiFinaleTimeLimitBase::AN_BurnOut_B' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, AN_Off) == 0x0002F8, "Member 'URCNzUiFinaleTimeLimitBase::AN_Off' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, isBurnOutB) == 0x000300, "Member 'URCNzUiFinaleTimeLimitBase::isBurnOutB' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, Finished_AN_Lighting_A) == 0x000304, "Member 'URCNzUiFinaleTimeLimitBase::Finished_AN_Lighting_A' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, Finished_AN_BurnOut_A) == 0x000314, "Member 'URCNzUiFinaleTimeLimitBase::Finished_AN_BurnOut_A' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, Finished_AN_BurnOut_B) == 0x000324, "Member 'URCNzUiFinaleTimeLimitBase::Finished_AN_BurnOut_B' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, FinishedLightingADelegate) == 0x000338, "Member 'URCNzUiFinaleTimeLimitBase::FinishedLightingADelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, FinishedBurnOutADelegate) == 0x000348, "Member 'URCNzUiFinaleTimeLimitBase::FinishedBurnOutADelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitBase, FinishedBurnOutBDelegate) == 0x000358, "Member 'URCNzUiFinaleTimeLimitBase::FinishedBurnOutBDelegate' has a wrong offset!");

// Class RC.RCAchievementManager
// 0x0060 (0x0088 - 0x0028)
class URCAchievementManager final : public UObject
{
public:
	class URCAchievementInterface*                Achievement;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCAchievementCommandInfo>      AchievementCommandList;                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRCAchievementSaveInfo>         UlockAchievementList;                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementManager">();
	}
	static class URCAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementManager>();
	}
};
static_assert(alignof(URCAchievementManager) == 0x000008, "Wrong alignment on URCAchievementManager");
static_assert(sizeof(URCAchievementManager) == 0x000088, "Wrong size on URCAchievementManager");
static_assert(offsetof(URCAchievementManager, Achievement) == 0x000028, "Member 'URCAchievementManager::Achievement' has a wrong offset!");
static_assert(offsetof(URCAchievementManager, AchievementCommandList) == 0x000030, "Member 'URCAchievementManager::AchievementCommandList' has a wrong offset!");
static_assert(offsetof(URCAchievementManager, UlockAchievementList) == 0x000040, "Member 'URCAchievementManager::UlockAchievementList' has a wrong offset!");

// Class RC.RCUiMenuQuest
// 0x0028 (0x0300 - 0x02D8)
class URCUiMenuQuest : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuQuest();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuest">();
	}
	static class URCUiMenuQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuest>();
	}
};
static_assert(alignof(URCUiMenuQuest) == 0x000008, "Wrong alignment on URCUiMenuQuest");
static_assert(sizeof(URCUiMenuQuest) == 0x000300, "Wrong size on URCUiMenuQuest");
static_assert(offsetof(URCUiMenuQuest, AN_Start) == 0x0002D8, "Member 'URCUiMenuQuest::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuest, AN_Wait) == 0x0002E0, "Member 'URCUiMenuQuest::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuest, AN_Finish) == 0x0002E8, "Member 'URCUiMenuQuest::AN_Finish' has a wrong offset!");

// Class RC.RCAchievementProcessGeneric
// 0x0030 (0x0058 - 0x0028)
class URCAchievementProcessGeneric final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementProcessGeneric">();
	}
	static class URCAchievementProcessGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementProcessGeneric>();
	}
};
static_assert(alignof(URCAchievementProcessGeneric) == 0x000008, "Wrong alignment on URCAchievementProcessGeneric");
static_assert(sizeof(URCAchievementProcessGeneric) == 0x000058, "Wrong size on URCAchievementProcessGeneric");

// Class RC.RCSpiritMiniGameBFL
// 0x0000 (0x0028 - 0x0028)
class URCSpiritMiniGameBFL final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetCheckPoint();
	static int32 GetCheckPointNumber();
	static bool GetHitWanderingSpirit();
	static struct FVector GetHitWanderingSpiritPos();
	static bool GetResume();
	static class ARCSpiritMiniGameManager* GetSpiritMiniGameManager();
	static void ProcessAfterReturn();
	static void ReleaseSpiritMiniGameEnvironment();
	static void ResumeSpiritMiniGameData(const int32 InResumeCheckPointNumber);
	static void SetSpiritMiniGameEnvironment(class ARCSpiritMiniGameManager* InSpiritMiniGameManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSpiritMiniGameBFL">();
	}
	static class URCSpiritMiniGameBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSpiritMiniGameBFL>();
	}
};
static_assert(alignof(URCSpiritMiniGameBFL) == 0x000008, "Wrong alignment on URCSpiritMiniGameBFL");
static_assert(sizeof(URCSpiritMiniGameBFL) == 0x000028, "Wrong size on URCSpiritMiniGameBFL");

// Class RC.RCAchievementTest
// 0x0008 (0x0030 - 0x0028)
class URCAchievementTest final : public URCAchievementInterface
{
public:
	ERCAchievementCommand                         Command;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAchievementTest">();
	}
	static class URCAchievementTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAchievementTest>();
	}
};
static_assert(alignof(URCAchievementTest) == 0x000008, "Wrong alignment on URCAchievementTest");
static_assert(sizeof(URCAchievementTest) == 0x000030, "Wrong size on URCAchievementTest");
static_assert(offsetof(URCAchievementTest, Command) == 0x000028, "Member 'URCAchievementTest::Command' has a wrong offset!");

// Class RC.RCEventSubLevelList
// 0x0010 (0x0038 - 0x0028)
class URCEventSubLevelList final : public UObject
{
public:
	class FName                                   Filename;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCParamEventSubLevelData*              EventSubLevelList;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventSubLevelList">();
	}
	static class URCEventSubLevelList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEventSubLevelList>();
	}
};
static_assert(alignof(URCEventSubLevelList) == 0x000008, "Wrong alignment on URCEventSubLevelList");
static_assert(sizeof(URCEventSubLevelList) == 0x000038, "Wrong size on URCEventSubLevelList");
static_assert(offsetof(URCEventSubLevelList, Filename) == 0x000028, "Member 'URCEventSubLevelList::Filename' has a wrong offset!");
static_assert(offsetof(URCEventSubLevelList, EventSubLevelList) == 0x000030, "Member 'URCEventSubLevelList::EventSubLevelList' has a wrong offset!");

// Class RC.RCActionButton
// 0x0168 (0x0388 - 0x0220)
class ARCActionButton final : public AActor
{
public:
	uint8                                         Pad_220[0x28];                                     // 0x0220(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            DecorationLayoutWidget;                            // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Pressed;                                           // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Decided;                                           // 0x025C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Passed;                                            // 0x025D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E[0x2];                                      // 0x025E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   PressedKeyRaw;                                     // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapableCount;                                      // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressThreshold;                                // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                DecorationLayout;                                  // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Button;                                            // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCActionKeyType                              Expect;                                            // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Preemptive;                                        // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MockupMode;                                        // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               DefaultIcon;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SoundEnabled;                                      // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SoundID_Spawn;                                     // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundID_Pass;                                      // 0x02BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundID_Fail;                                      // 0x02C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectionMode;                                     // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              PassDispatcher;                                    // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERCActionFailureReason code)> FailDispatcher;                                    // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Times)>   PendingDispatcher;                                 // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0300(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0328(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      TexturesKeyboard;                                  // 0x0358(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x20];                                     // 0x0368(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillAfter(float in_sec);
	void OnButtonActivated();
	void OnButtonDeactivated();
	void OnChangedPauseState(bool NewPauseState);
	void OnChangeInputPlatform(ERCInputPlatform InInputPlatform);
	void OnDeadline();
	void OnFailed(ERCActionFailureReason reason);
	void OnPassed();
	void Reset();
	void SetDecision(bool ForcePasse);
	void SetExpectKey(ERCActionKeyType Key);
	void SetMockup(bool Mock);
	void SetSelectionMode(bool EnableSelection);
	void SetSoundEnabled(bool Enable);

	float GetLastDecisionTime() const;
	bool GetMockup() const;
	bool IsActivated() const;
	bool IsDecieded() const;
	bool IsPassed() const;
	bool IsPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActionButton">();
	}
	static class ARCActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCActionButton>();
	}
};
static_assert(alignof(ARCActionButton) == 0x000008, "Wrong alignment on ARCActionButton");
static_assert(sizeof(ARCActionButton) == 0x000388, "Wrong size on ARCActionButton");
static_assert(offsetof(ARCActionButton, MaterialInstance) == 0x000248, "Member 'ARCActionButton::MaterialInstance' has a wrong offset!");
static_assert(offsetof(ARCActionButton, DecorationLayoutWidget) == 0x000250, "Member 'ARCActionButton::DecorationLayoutWidget' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Pressed) == 0x000258, "Member 'ARCActionButton::Pressed' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Decided) == 0x00025C, "Member 'ARCActionButton::Decided' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Passed) == 0x00025D, "Member 'ARCActionButton::Passed' has a wrong offset!");
static_assert(offsetof(ARCActionButton, PressedKeyRaw) == 0x000260, "Member 'ARCActionButton::PressedKeyRaw' has a wrong offset!");
static_assert(offsetof(ARCActionButton, ID) == 0x000278, "Member 'ARCActionButton::ID' has a wrong offset!");
static_assert(offsetof(ARCActionButton, CapableCount) == 0x000280, "Member 'ARCActionButton::CapableCount' has a wrong offset!");
static_assert(offsetof(ARCActionButton, LongPressThreshold) == 0x000284, "Member 'ARCActionButton::LongPressThreshold' has a wrong offset!");
static_assert(offsetof(ARCActionButton, DecorationLayout) == 0x000288, "Member 'ARCActionButton::DecorationLayout' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Button) == 0x000290, "Member 'ARCActionButton::Button' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Root) == 0x000298, "Member 'ARCActionButton::Root' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Expect) == 0x0002A0, "Member 'ARCActionButton::Expect' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Preemptive) == 0x0002A1, "Member 'ARCActionButton::Preemptive' has a wrong offset!");
static_assert(offsetof(ARCActionButton, MockupMode) == 0x0002A2, "Member 'ARCActionButton::MockupMode' has a wrong offset!");
static_assert(offsetof(ARCActionButton, DefaultIcon) == 0x0002A8, "Member 'ARCActionButton::DefaultIcon' has a wrong offset!");
static_assert(offsetof(ARCActionButton, SoundEnabled) == 0x0002B0, "Member 'ARCActionButton::SoundEnabled' has a wrong offset!");
static_assert(offsetof(ARCActionButton, SoundID_Spawn) == 0x0002B4, "Member 'ARCActionButton::SoundID_Spawn' has a wrong offset!");
static_assert(offsetof(ARCActionButton, SoundID_Pass) == 0x0002BC, "Member 'ARCActionButton::SoundID_Pass' has a wrong offset!");
static_assert(offsetof(ARCActionButton, SoundID_Fail) == 0x0002C4, "Member 'ARCActionButton::SoundID_Fail' has a wrong offset!");
static_assert(offsetof(ARCActionButton, SelectionMode) == 0x0002CC, "Member 'ARCActionButton::SelectionMode' has a wrong offset!");
static_assert(offsetof(ARCActionButton, PassDispatcher) == 0x0002D0, "Member 'ARCActionButton::PassDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButton, FailDispatcher) == 0x0002E0, "Member 'ARCActionButton::FailDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButton, PendingDispatcher) == 0x0002F0, "Member 'ARCActionButton::PendingDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButton, StaticMesh) == 0x000300, "Member 'ARCActionButton::StaticMesh' has a wrong offset!");
static_assert(offsetof(ARCActionButton, Textures) == 0x000328, "Member 'ARCActionButton::Textures' has a wrong offset!");
static_assert(offsetof(ARCActionButton, TexturesKeyboard) == 0x000358, "Member 'ARCActionButton::TexturesKeyboard' has a wrong offset!");

// Class RC.RCSubLevelLoad
// 0x0030 (0x0058 - 0x0028)
class URCSubLevelLoad final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecSubLevelLoadFinishChecker();
	void ExecSubLevelUnloadFinishChecker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSubLevelLoad">();
	}
	static class URCSubLevelLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSubLevelLoad>();
	}
};
static_assert(alignof(URCSubLevelLoad) == 0x000008, "Wrong alignment on URCSubLevelLoad");
static_assert(sizeof(URCSubLevelLoad) == 0x000058, "Wrong size on URCSubLevelLoad");

// Class RC.RCActionButtonEventDispatcher
// 0x0060 (0x0280 - 0x0220)
class ARCActionButtonEventDispatcher final : public AActor
{
public:
	TMulticastInlineDelegate<void(class FName ID, class ARCActionButton* Button)> PassedDispatcher;                                  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ID, class ARCActionButton* Button, ERCActionFailureReason reason)> FailedDispatcher;                                  // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ID, class ARCActionButton* Button, int32 Times)> PendingDispatcher;                                 // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Dispatcher;                                        // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ID, class ARCActionButton* Button)> ActivateDispatcher;                                // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ID, class ARCActionButton* Button)> DeactivateDispatcher;                              // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallOnActivate(class FName ID, class ARCActionButton* Actor);
	void CallOnDeactivate(class FName ID, class ARCActionButton* Actor);
	void CallOnDeadline();
	void CallOnFailed(class FName ID, class ARCActionButton* Actor, ERCActionFailureReason reason);
	void CallOnPassed(class FName ID, class ARCActionButton* Actor);
	void CallOnPending(class FName ID, class ARCActionButton* Actor, int32 Times);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActionButtonEventDispatcher">();
	}
	static class ARCActionButtonEventDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCActionButtonEventDispatcher>();
	}
};
static_assert(alignof(ARCActionButtonEventDispatcher) == 0x000008, "Wrong alignment on ARCActionButtonEventDispatcher");
static_assert(sizeof(ARCActionButtonEventDispatcher) == 0x000280, "Wrong size on ARCActionButtonEventDispatcher");
static_assert(offsetof(ARCActionButtonEventDispatcher, PassedDispatcher) == 0x000220, "Member 'ARCActionButtonEventDispatcher::PassedDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButtonEventDispatcher, FailedDispatcher) == 0x000230, "Member 'ARCActionButtonEventDispatcher::FailedDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButtonEventDispatcher, PendingDispatcher) == 0x000240, "Member 'ARCActionButtonEventDispatcher::PendingDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButtonEventDispatcher, Dispatcher) == 0x000250, "Member 'ARCActionButtonEventDispatcher::Dispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButtonEventDispatcher, ActivateDispatcher) == 0x000260, "Member 'ARCActionButtonEventDispatcher::ActivateDispatcher' has a wrong offset!");
static_assert(offsetof(ARCActionButtonEventDispatcher, DeactivateDispatcher) == 0x000270, "Member 'ARCActionButtonEventDispatcher::DeactivateDispatcher' has a wrong offset!");

// Class RC.RCActivityBFL
// 0x0000 (0x0028 - 0x0028)
class URCActivityBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ActivityEnd();
	static void ActivityStart();
	static bool GetActivityContinue();
	static void SetActivityExecProcess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActivityBFL">();
	}
	static class URCActivityBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCActivityBFL>();
	}
};
static_assert(alignof(URCActivityBFL) == 0x000008, "Wrong alignment on URCActivityBFL");
static_assert(sizeof(URCActivityBFL) == 0x000028, "Wrong size on URCActivityBFL");

// Class RC.RCActivityManager
// 0x0028 (0x0050 - 0x0028)
class URCActivityManager final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActivityManager">();
	}
	static class URCActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCActivityManager>();
	}
};
static_assert(alignof(URCActivityManager) == 0x000008, "Wrong alignment on URCActivityManager");
static_assert(sizeof(URCActivityManager) == 0x000050, "Wrong size on URCActivityManager");

// Class RC.RCNzUiFinaleBackgroundWidget
// 0x0000 (0x02D8 - 0x02D8)
class URCNzUiFinaleBackgroundWidget final : public URCUiWidgetBase
{
public:
	void ChangeBackgroundImg(const class UTexture2D* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleBackgroundWidget">();
	}
	static class URCNzUiFinaleBackgroundWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleBackgroundWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleBackgroundWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleBackgroundWidget");
static_assert(sizeof(URCNzUiFinaleBackgroundWidget) == 0x0002D8, "Wrong size on URCNzUiFinaleBackgroundWidget");

// Class RC.RCUiMenuSkillTreeDetail
// 0x0130 (0x0408 - 0x02D8)
class URCUiMenuSkillTreeDetail final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_Num_TRank;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_SkillPoint;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_Memory_000;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_Memory_001;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_MemoryCost;                               // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_GetSkillPoint;                            // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0xA8];                                     // 0x0318(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_SkillName;                                    // 0x03C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_SkillCaption;                                 // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x38];                                     // 0x03D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTreeDetail">();
	}
	static class URCUiMenuSkillTreeDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTreeDetail>();
	}
};
static_assert(alignof(URCUiMenuSkillTreeDetail) == 0x000008, "Wrong alignment on URCUiMenuSkillTreeDetail");
static_assert(sizeof(URCUiMenuSkillTreeDetail) == 0x000408, "Wrong size on URCUiMenuSkillTreeDetail");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_TRank) == 0x0002E8, "Member 'URCUiMenuSkillTreeDetail::Text_Num_TRank' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_SkillPoint) == 0x0002F0, "Member 'URCUiMenuSkillTreeDetail::Text_Num_SkillPoint' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_Memory_000) == 0x0002F8, "Member 'URCUiMenuSkillTreeDetail::Text_Num_Memory_000' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_Memory_001) == 0x000300, "Member 'URCUiMenuSkillTreeDetail::Text_Num_Memory_001' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_MemoryCost) == 0x000308, "Member 'URCUiMenuSkillTreeDetail::Text_Num_MemoryCost' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_Num_GetSkillPoint) == 0x000310, "Member 'URCUiMenuSkillTreeDetail::Text_Num_GetSkillPoint' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_SkillName) == 0x0003C0, "Member 'URCUiMenuSkillTreeDetail::Text_SkillName' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeDetail, Text_SkillCaption) == 0x0003C8, "Member 'URCUiMenuSkillTreeDetail::Text_SkillCaption' has a wrong offset!");

// Class RC.RCWidgetActor
// 0x0008 (0x0290 - 0x0288)
class ARCWidgetActor final : public ARCActor
{
public:
	class URC3DWidgetComponent*                   WidgetComponent;                                   // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class URCUiWidgetBase* GetWidget();
	void SetActorVisibility(bool bInShow);
	void SetWidget(class URCUiWidgetBase* InWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCWidgetActor">();
	}
	static class ARCWidgetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCWidgetActor>();
	}
};
static_assert(alignof(ARCWidgetActor) == 0x000008, "Wrong alignment on ARCWidgetActor");
static_assert(sizeof(ARCWidgetActor) == 0x000290, "Wrong size on ARCWidgetActor");
static_assert(offsetof(ARCWidgetActor, WidgetComponent) == 0x000288, "Member 'ARCWidgetActor::WidgetComponent' has a wrong offset!");

// Class RC.RCNzWaruagaki_Info
// 0x0038 (0x0310 - 0x02D8)
class URCNzWaruagaki_Info final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              ShowFinishDelegate;                                // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              HiddenFinishDelegate;                              // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void PlayWaruagakiInfoShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzWaruagaki_Info">();
	}
	static class URCNzWaruagaki_Info* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzWaruagaki_Info>();
	}
};
static_assert(alignof(URCNzWaruagaki_Info) == 0x000008, "Wrong alignment on URCNzWaruagaki_Info");
static_assert(sizeof(URCNzWaruagaki_Info) == 0x000310, "Wrong size on URCNzWaruagaki_Info");
static_assert(offsetof(URCNzWaruagaki_Info, AN_Start) == 0x0002D8, "Member 'URCNzWaruagaki_Info::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Info, AN_Wait) == 0x0002E0, "Member 'URCNzWaruagaki_Info::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Info, AN_Finish) == 0x0002E8, "Member 'URCNzWaruagaki_Info::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Info, ShowFinishDelegate) == 0x0002F0, "Member 'URCNzWaruagaki_Info::ShowFinishDelegate' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Info, HiddenFinishDelegate) == 0x000300, "Member 'URCNzWaruagaki_Info::HiddenFinishDelegate' has a wrong offset!");

// Class RC.RCActorScript
// 0x0018 (0x02A0 - 0x0288)
class ARCActorScript final : public ARCActor
{
public:
	class URCScriptActorComponent*                ScriptActorComp;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0290(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugScriptDraw;                                  // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwari;                                         // 0x029D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29E[0x2];                                      // 0x029E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BackupMovePosition();
	bool IsMoveEnd();
	void ResetMove();
	void RestoreMoveList();
	void RestoreMovePosition(float SpeedScale);
	void RestoreRotationYaw(float SpeedScale, bool bDirect);
	void SetMovePause(bool bInMovePause);
	void SetMoveSpeed(float InWalkSpeed, float InRunSpeed);
	void SetPositionYaw(const struct FVector& InPosition, float InYaw);
	void SetTransformPlayerStartName(class FName InPlayerStartTagName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void SetTransformTargetPointName(class FName InPointName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void StartMoveFromPlayer(float InLength, float InAngle, float InHeight, float SpeedScale, bool bEndPlayerYaw);
	void StartMoveFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bEndChangeYaw, const struct FVector& EndChangeYawPosition);
	void StartMoveFromPositionList(const TArray<struct FRCScriptActorMoveInfo>& InMoveInfoList, int32 StartMoveInfoNum, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop);
	void StartMoveFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, bool bEndChangeYaw, float InOffsetYaw, float InChangeYawSpeedScale);
	void StartRotationFromCharacter(class FName InTargetCharacterName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bDirect);
	void StartRotationFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationYaw(float Yaw, float SpeedScale, bool bDirect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCActorScript">();
	}
	static class ARCActorScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCActorScript>();
	}
};
static_assert(alignof(ARCActorScript) == 0x000008, "Wrong alignment on ARCActorScript");
static_assert(sizeof(ARCActorScript) == 0x0002A0, "Wrong size on ARCActorScript");
static_assert(offsetof(ARCActorScript, ScriptActorComp) == 0x000288, "Member 'ARCActorScript::ScriptActorComp' has a wrong offset!");
static_assert(offsetof(ARCActorScript, Velocity) == 0x000290, "Member 'ARCActorScript::Velocity' has a wrong offset!");
static_assert(offsetof(ARCActorScript, bDebugScriptDraw) == 0x00029C, "Member 'ARCActorScript::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCActorScript, bKakiwari) == 0x00029D, "Member 'ARCActorScript::bKakiwari' has a wrong offset!");

// Class RC.RCStartupWidget
// 0x0050 (0x02C0 - 0x0270)
class URCStartupWidget : public URCUserWidget
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_StartUpLogo;                                 // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         skippableTime;                                     // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         progressTime;                                      // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isSkippable;                                       // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isTimeCount;                                       // 0x0299(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StartUpLogoImagePath;                              // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoadingImage;                                   // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	bool IsPlayingFinishAnimation();
	bool IsPlayingStartAnimation();
	bool IsPlayingWaitAnimation();
	bool IsSkip();
	void Open();
	void PlayFinishAnimation();
	void PlayStartAnimation();
	void PlayWaitAnimation();
	void SetSkippableTime(float Time);
	void SetTimeCount(bool isCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCStartupWidget">();
	}
	static class URCStartupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCStartupWidget>();
	}
};
static_assert(alignof(URCStartupWidget) == 0x000008, "Wrong alignment on URCStartupWidget");
static_assert(sizeof(URCStartupWidget) == 0x0002C0, "Wrong size on URCStartupWidget");
static_assert(offsetof(URCStartupWidget, AN_Start) == 0x000270, "Member 'URCStartupWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, AN_Wait) == 0x000278, "Member 'URCStartupWidget::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, AN_Finish) == 0x000280, "Member 'URCStartupWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, Image_StartUpLogo) == 0x000288, "Member 'URCStartupWidget::Image_StartUpLogo' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, skippableTime) == 0x000290, "Member 'URCStartupWidget::skippableTime' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, progressTime) == 0x000294, "Member 'URCStartupWidget::progressTime' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, isSkippable) == 0x000298, "Member 'URCStartupWidget::isSkippable' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, isTimeCount) == 0x000299, "Member 'URCStartupWidget::isTimeCount' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, StartUpLogoImagePath) == 0x0002A0, "Member 'URCStartupWidget::StartUpLogoImagePath' has a wrong offset!");
static_assert(offsetof(URCStartupWidget, bIsLoadingImage) == 0x0002B8, "Member 'URCStartupWidget::bIsLoadingImage' has a wrong offset!");

// Class RC.RCStartupAutoSave
// 0x0018 (0x02D8 - 0x02C0)
class URCStartupAutoSave final : public URCStartupWidget
{
public:
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHyoukaban();
	void SaveIconFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCStartupAutoSave">();
	}
	static class URCStartupAutoSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCStartupAutoSave>();
	}
};
static_assert(alignof(URCStartupAutoSave) == 0x000008, "Wrong alignment on URCStartupAutoSave");
static_assert(sizeof(URCStartupAutoSave) == 0x0002D8, "Wrong size on URCStartupAutoSave");

// Class RC.RCHUD
// 0x0010 (0x0320 - 0x0310)
class ARCHUD : public AHUD
{
public:
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrawHUDForDebug;                                  // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DebugCheckDrawHUD();
	void DebugSetDrawHUD(bool in_bDraw);
	void DebugToggleDrawHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCHUD">();
	}
	static class ARCHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCHUD>();
	}
};
static_assert(alignof(ARCHUD) == 0x000008, "Wrong alignment on ARCHUD");
static_assert(sizeof(ARCHUD) == 0x000320, "Wrong size on ARCHUD");
static_assert(offsetof(ARCHUD, bDrawHUDForDebug) == 0x000318, "Member 'ARCHUD::bDrawHUDForDebug' has a wrong offset!");

// Class RC.RCUiOptionController
// 0x0048 (0x0320 - 0x02D8)
class URCUiOptionController final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x48];                                     // 0x02D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionController">();
	}
	static class URCUiOptionController* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionController>();
	}
};
static_assert(alignof(URCUiOptionController) == 0x000008, "Wrong alignment on URCUiOptionController");
static_assert(sizeof(URCUiOptionController) == 0x000320, "Wrong size on URCUiOptionController");

// Class RC.RCUiFaderHUD
// 0x0118 (0x0438 - 0x0320)
class ARCUiFaderHUD : public ARCHUD
{
public:
	uint8                                         Pad_320[0x68];                                     // 0x0320(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class URCHUDLoadComponent*                    LoadComponent;                                     // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiShortLoadingIcon*                  ShortLoadIcon;                                     // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSavingIcon*                        SavingIcon;                                        // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiTipsScreenWidget*                  TipsScreenWidget_WithEditor;                       // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTipsScreen*                          TipsScreenWidget;                                  // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCSaveLoadLayout*                      SaveLoadLayout;                                    // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SaveLoadLayoutPriority;                            // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isSaveLoadFinished;                                // 0x03C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCFaderHUDHiddenWidgetData>    HiddenWidgetDataArray;                             // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCUiWidgetBase*>                NotHiddenWidgetArray;                              // 0x03D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllWidgetsHidden;                                 // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllWidgetsHiddenEnable;                           // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EA[0x6];                                      // 0x03EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiOptionLayout*                      OptionLayout;                                      // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OptionLayoutPriority;                              // 0x03F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OptionLayoutPath;                                  // 0x03FC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCOptionUIWrap*                        OptionOpener;                                      // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSceneChangeMediator*                 SceneChangeMediator;                               // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnMenuOpen;                                        // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMenuClose;                                       // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool CheckSaveLoadFinished();
	void FinishSceneChange();
	bool IsAllWidgetsHidden();
	bool IsAllWidgetsHiddenEnable();
	void Option_Close();
	bool Option_CreateWidget();
	bool Option_IsFinished();
	bool Option_Load();
	void Option_Release();
	void Option_Start();
	void OptionStartWrap();
	bool SaveLoadFinish();
	bool SetAllWidgetsHidden(bool bInHidden);
	void SetAllWidgetsHiddenEnable(bool bInEnable);
	void SetSaveLoadFinished(bool isFinish);
	void StartSceneChange(ERCSceneChangeType Type);
	void StartSceneChangeLoadingTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiFaderHUD">();
	}
	static class ARCUiFaderHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCUiFaderHUD>();
	}
};
static_assert(alignof(ARCUiFaderHUD) == 0x000008, "Wrong alignment on ARCUiFaderHUD");
static_assert(sizeof(ARCUiFaderHUD) == 0x000438, "Wrong size on ARCUiFaderHUD");
static_assert(offsetof(ARCUiFaderHUD, LoadComponent) == 0x000388, "Member 'ARCUiFaderHUD::LoadComponent' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, ShortLoadIcon) == 0x000390, "Member 'ARCUiFaderHUD::ShortLoadIcon' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, SavingIcon) == 0x000398, "Member 'ARCUiFaderHUD::SavingIcon' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, TipsScreenWidget_WithEditor) == 0x0003A0, "Member 'ARCUiFaderHUD::TipsScreenWidget_WithEditor' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, TipsScreenWidget) == 0x0003A8, "Member 'ARCUiFaderHUD::TipsScreenWidget' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, SaveLoadLayout) == 0x0003B8, "Member 'ARCUiFaderHUD::SaveLoadLayout' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, SaveLoadLayoutPriority) == 0x0003C0, "Member 'ARCUiFaderHUD::SaveLoadLayoutPriority' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, isSaveLoadFinished) == 0x0003C4, "Member 'ARCUiFaderHUD::isSaveLoadFinished' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, HiddenWidgetDataArray) == 0x0003C8, "Member 'ARCUiFaderHUD::HiddenWidgetDataArray' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, NotHiddenWidgetArray) == 0x0003D8, "Member 'ARCUiFaderHUD::NotHiddenWidgetArray' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, bAllWidgetsHidden) == 0x0003E8, "Member 'ARCUiFaderHUD::bAllWidgetsHidden' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, bAllWidgetsHiddenEnable) == 0x0003E9, "Member 'ARCUiFaderHUD::bAllWidgetsHiddenEnable' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OptionLayout) == 0x0003F0, "Member 'ARCUiFaderHUD::OptionLayout' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OptionLayoutPriority) == 0x0003F8, "Member 'ARCUiFaderHUD::OptionLayoutPriority' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OptionLayoutPath) == 0x0003FC, "Member 'ARCUiFaderHUD::OptionLayoutPath' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OptionOpener) == 0x000408, "Member 'ARCUiFaderHUD::OptionOpener' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, SceneChangeMediator) == 0x000410, "Member 'ARCUiFaderHUD::SceneChangeMediator' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OnMenuOpen) == 0x000418, "Member 'ARCUiFaderHUD::OnMenuOpen' has a wrong offset!");
static_assert(offsetof(ARCUiFaderHUD, OnMenuClose) == 0x000428, "Member 'ARCUiFaderHUD::OnMenuClose' has a wrong offset!");

// Class RC.RCNzUiMessageWindow
// 0x0158 (0x0430 - 0x02D8)
class URCNzUiMessageWindow final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScriptString;                                      // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         StringLine;                                        // 0x0308(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TextInterval;                                      // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HandleTimer;                                       // 0x0320(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEndOfText;                                      // 0x0328(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x1F];                                     // 0x0329(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TalkDelay;                                         // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0xC];                                      // 0x034C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoPlay;                                       // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoDelay;                                         // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      R_TextLine_01;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      R_TextLine_02;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0xB8];                                     // 0x0378(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMessage();
	void Close();
	int32 GetMessStatusInt();
	bool GetSkipTyping();
	void InitializeMessageWindow();
	void Open(class FName InNameID, class FName InFacialID);
	void SetMessageSpeed();
	void SetShakeData(float InWidthX, float InWidthY, float InInterval);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiMessageWindow">();
	}
	static class URCNzUiMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiMessageWindow>();
	}
};
static_assert(alignof(URCNzUiMessageWindow) == 0x000008, "Wrong alignment on URCNzUiMessageWindow");
static_assert(sizeof(URCNzUiMessageWindow) == 0x000430, "Wrong size on URCNzUiMessageWindow");
static_assert(offsetof(URCNzUiMessageWindow, AN_Start) == 0x0002E0, "Member 'URCNzUiMessageWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, AN_Wait) == 0x0002E8, "Member 'URCNzUiMessageWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, AN_Finish) == 0x0002F0, "Member 'URCNzUiMessageWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, ScriptString) == 0x0002F8, "Member 'URCNzUiMessageWindow::ScriptString' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, StringLine) == 0x000308, "Member 'URCNzUiMessageWindow::StringLine' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, TextInterval) == 0x000318, "Member 'URCNzUiMessageWindow::TextInterval' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, HandleTimer) == 0x000320, "Member 'URCNzUiMessageWindow::HandleTimer' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, bIsEndOfText) == 0x000328, "Member 'URCNzUiMessageWindow::bIsEndOfText' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, TalkDelay) == 0x000348, "Member 'URCNzUiMessageWindow::TalkDelay' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, bIsAutoPlay) == 0x000358, "Member 'URCNzUiMessageWindow::bIsAutoPlay' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, AutoDelay) == 0x00035C, "Member 'URCNzUiMessageWindow::AutoDelay' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, R_TextLine_01) == 0x000368, "Member 'URCNzUiMessageWindow::R_TextLine_01' has a wrong offset!");
static_assert(offsetof(URCNzUiMessageWindow, R_TextLine_02) == 0x000370, "Member 'URCNzUiMessageWindow::R_TextLine_02' has a wrong offset!");

// Class RC.RCAdvHUD
// 0x04A0 (0x08D8 - 0x0438)
class ARCAdvHUD : public ARCUiFaderHUD
{
public:
	bool                                          bAllowEditInstance;                                // 0x0438(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0439(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43A[0x2];                                      // 0x043A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ViewportSize;                                      // 0x043C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewportScale;                                     // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PlayerScreenSize;                                  // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PlayerScreenOffset;                                // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerScreenScale;                                 // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChapterNo;                                         // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SceneID;                                           // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCAdvHUDBaseComponent*>         Components;                                        // 0x0468(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bLoadCompleted;                                    // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadingCharaIntegrationIDToFaceIDDataTable;       // 0x0479(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CharaIntegrationIDToFaceIDDataTablePath;           // 0x0480(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CharaIntegrationIDToFaceIDDataTable;               // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0xA0];                                     // 0x04A0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenericWindowPriority;                             // 0x0540(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiGenericWindow*                     GenericWindowWidget;                               // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0xA8];                                     // 0x0550(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAdvHUDWidgetState                          ButtonGuideState;                                  // 0x05F8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          ButtonGuideOldState;                               // 0x05F9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        ButtonGuideRequest;                                // 0x05FA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FB[0x1];                                      // 0x05FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ButtonGuidePriority;                               // 0x05FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ButtonGuideModeID;                                 // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       ButtonGuideWidget;                                 // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDSubtitleType                         SubtitleType;                                      // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubtitleTextID;                                    // 0x0614(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSubtitleHiddenByOption;                           // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSubtitleWaitPush;                                 // 0x061D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          SubtitleState;                                     // 0x061E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          OldSubtitleState;                                  // 0x061F(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubtitlePriority;                                  // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SubtitleVoiceID;                                   // 0x0624(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubtitleDelayAtEndVoice;                           // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubtitleVoiceLength;                               // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubtitleVoiceElapsedTime;                          // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSubtitle*                          Subtitle;                                          // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDSubtitleType                         SequentialSubtitleType;                            // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SequentialSubtitleID;                              // 0x0644(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCSubtitleData                        SequentialSubtitleData;                            // 0x0650(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bSequentialSubtitle;                               // 0x0678(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialSubtitleHiddenByOption;                 // 0x0679(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialSubtitleWaitPush;                       // 0x067A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialSubtitleDisableSave;                    // 0x067B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SequentialSubtitleIndex;                           // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SequentialSubtitleDelayToNextTime;                 // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SequentialSubtitleElapsedTime;                     // 0x0684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        TopMenuRequest;                                    // 0x0688(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        WorldMenuRequest;                                  // 0x0689(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68A[0x2];                                      // 0x068A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TopMenuWidgetPriority;                             // 0x068C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTopMenu*                             TopMenuWidget;                                     // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenTopMenuWithOtherMenu;                         // 0x0698(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        MenuGuideRequest;                                  // 0x0699(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69A[0x2];                                      // 0x069A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuGuideWidgetPriority;                           // 0x069C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuGuide*                         MenuGuideWidget;                                   // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        AreaMapMenuRequest;                                // 0x06A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A9[0x3];                                      // 0x06A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AreaMapMenuWidgetPriority;                         // 0x06AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuAreaMap*                       AreaMapMenuWidget;                                 // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayedNewAreaSE;                                  // 0x06B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        KagiMenuRequest;                                   // 0x06B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BA[0x2];                                      // 0x06BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KagiMenuWidgetPriority;                            // 0x06BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuKagi*                          KagiMenuWidget;                                    // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        KagiSelectMenuRequest;                             // 0x06C8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKagiSelectNotPause;                               // 0x06C9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKagiSelectPrevPauseEnable;                        // 0x06CA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKagiSelectPrevMenuEnable;                         // 0x06CB(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKagiSelectPrevBacklogEnable;                      // 0x06CC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKagiSelectPrevCameraLock;                         // 0x06CD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CE[0x2];                                      // 0x06CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KagiSelectMenuWidgetPriority;                      // 0x06D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiMenuKagi*                          KagiSelectMenuWidget;                              // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAdvHUDWidgetRequest                        MainQuestMenuRequest;                              // 0x06F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainQuestMenuWidgetPriority;                       // 0x06F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuMainQuest*                     MainQuestMenuWidget;                               // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        SubQuestMenuRequest;                               // 0x0700(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubQuestMenuWidgetPriority;                        // 0x0704(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuSubQuest*                      SubQuestMenuWidget;                                // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        SkillSelectMenuRequest;                            // 0x0710(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_711[0x3];                                      // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillSelectMenuWidgetPriority;                     // 0x0714(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuSkillSelect*                   SkillSelectMenuWidget;                             // 0x0718(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        SkillMenuRequest;                                  // 0x0720(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillMenuWidgetPriority;                           // 0x0724(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuSkill*                         SkillMenuWidget;                                   // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkillWindowPriority;                               // 0x0730(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_734[0x4];                                      // 0x0734(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiMenuSkillWindow*                   SkillWindowWidget;                                 // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        GlossaryMenuRequest;                               // 0x0740(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_741[0x3];                                      // 0x0741(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GlossaryMenuWidgetPriority;                        // 0x0744(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuGlossaryBase*                  GlossaryMenuWidget;                                // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        CollectionMenuRequest;                             // 0x0750(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_751[0x3];                                      // 0x0751(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollectionMenuWidgetPriority;                      // 0x0754(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionLayout*                CollectionMenuWidget;                              // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        CollectionWindowRequest;                           // 0x0760(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollectionWindowPriority;                          // 0x0764(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionWindow*                CollectionWindowWidget;                            // 0x0768(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        MovieSkipRequest;                                  // 0x0770(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x3];                                      // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovieSkipWidgetPriority;                           // 0x0774(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMovieSkip*                         MovieSkipWidget;                                   // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        CharacterMenuRequest;                              // 0x0780(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_781[0x3];                                      // 0x0781(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterMenuWidgetPriority;                       // 0x0784(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuCharacterTop*                  CharacterMenuWidget;                               // 0x0788(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        NzResultRequest;                                   // 0x0790(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_791[0x3];                                      // 0x0791(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NzResultWidgetPriority;                            // 0x0794(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzResult*                            NzResultWidget;                                    // 0x0798(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FastForwardIconPriority;                           // 0x07A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A4[0x4];                                      // 0x07A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiMessageFastForward*              FastForwardIcon;                                   // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TutorialWindowPriority;                            // 0x07B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TutorialWindowPath;                                // 0x07B4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiTutorialWindow*                    TutorialWindow;                                    // 0x07C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BackLogPriority;                                   // 0x07C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiBackLog*                           BackLogWidget;                                     // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDInteractIconComponent*         InteractIconComponent;                             // 0x07D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDAdvComponent*                  AdvComponent;                                      // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDTalkComponent*                 TalkComponent;                                     // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResearchPriority;                                  // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCAdvHUDResearchComponent*             ResearchComponent;                                 // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDMapComponent*                  MapComponent;                                      // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDPauseComponent*                PauseComponent;                                    // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPlaySubTitleVoice;                               // 0x0810(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInitialized;                                     // 0x0818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTalkStarted;                                     // 0x0828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTalkEndText;                                     // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTalkFinished;                                    // 0x0848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSequentialTalkFinishedLastText;                  // 0x0858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSequentialTalkFinished;                          // 0x0868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSubtitleEndDelay;                                // 0x0878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSequentialSubtitleFinishedLastText;              // 0x0888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSequentialSubtitleFinished;                      // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSequentialSubtitleCanceled;                      // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRCAdvHUDDebugDrawWidgetData>   DebugDrawWidgetDatas;                              // 0x08B8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool bInDraw)>  OnDebugSetDrawHUD;                                 // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static bool GetPressedDecideButtonSimpleResult(ERCAdvHUDPressedDecideResult InResult);

	void AddLogAtSkip(class FName InTextID);
	void AllAccessableWidgetsClose();
	void AllAccessableWidgetsOpen();
	bool AreaMapMenuFinish();
	bool AreaMapMenuStart(bool bShortcut, class FName InLocationID);
	bool BackLogFinish();
	bool BackLogStart();
	bool BattleKagiSelectMenuStart(const TArray<class FName>& InKaiKagiIDArray, int32 InFocusIndex);
	bool BusStop_IsVisible(class ARCCheckActor* InCheckActor);
	bool BusStop_SetData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInLooksLikeUsable, bool bInAccessable, float InScale);
	bool BusStop_SetEnable(bool bInEnable);
	bool ButtonGuideCheckFinished();
	bool ButtonGuideCheckStarted();
	bool ButtonGuideFinish();
	bool ButtonGuideStart(class FName InModeID);
	bool ChangeArea_IsVisible(class ARCCheckActor* InCheckActor);
	bool ChangeArea_SetData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInDrawText, float InScale);
	bool ChangeArea_SetEnable(bool bInEnable);
	bool CharacterMenuFinish();
	bool CharacterMenuStart();
	bool CheckAccessableWidgetReady();
	bool CheckAccessedWidgetWait();
	bool CheckAllAccessableWidgetsClosed(bool bInContainClosing);
	bool CheckAllAccessableWidgetsOpened();
	bool CheckAllWidgetsClosed();
	bool CheckAreaMapMenuFinished();
	bool CheckAreaMapMenuStarted();
	bool CheckCharacterMenuClose();
	bool CheckCharacterMenuFinished();
	bool CheckCharacterMenuStarted();
	bool CheckCollectionMenuClose();
	bool CheckCollectionMenuFinished();
	bool CheckCollectionMenuStarted();
	bool CheckCollectionWindowStarted();
	bool CheckCutInAnimFinishedAnim();
	bool CheckCutInAnimLoadCompleted(class FName InCutInID);
	bool CheckCutInAnimNextEnable();
	bool CheckCutInCheckFinished();
	bool CheckCutInCheckStarted();
	bool CheckDetPointCheckFinished();
	bool CheckDetPointCheckStarted();
	bool CheckFinishedKaiKagiSelect();
	bool CheckGlossaryMenuClose();
	bool CheckGlossaryMenuFinished();
	bool CheckGlossaryMenuStarted();
	bool CheckInitialized();
	bool CheckKagiMenuClose();
	bool CheckKagiMenuFinished();
	bool CheckKagiMenuStarted();
	bool CheckKagiSelectMenuFinished();
	bool CheckKagiSelectMenuStarted();
	bool CheckMainQuestMenuClose();
	bool CheckMainQuestMenuFinished();
	bool CheckMainQuestMenuStarted();
	bool CheckMenuGuideFinished();
	bool CheckMenuGuideStarted();
	bool CheckMovieSkipFinished();
	bool CheckMovieSkipStarted();
	bool CheckNzResultClose();
	bool CheckNzResultFinished();
	bool CheckNzResultStarted();
	bool CheckResearch();
	bool CheckResearchDetail();
	bool CheckResearchModeFinished();
	bool CheckSequentialSubtitle();
	bool CheckSequentialSubtitleCloseAtAllEnd();
	bool CheckSequentialSubtitleFinished();
	bool CheckSequentialSubtitleFinishedLastText();
	bool CheckSequentialSubtitleFromSubtitleID(class FName InSubtitleID);
	bool CheckSequentialTalk();
	bool CheckSequentialTalkCloseAtAllEnd();
	bool CheckSequentialTalkFinished();
	bool CheckSequentialTalkFinishedLastText();
	bool CheckSequentialTalkFromTalkID(class FName InTalkID);
	bool CheckSequentialTalkSuspending();
	bool CheckSkillGetInterval();
	bool CheckSkillMenuClose();
	bool CheckSkillMenuFinished();
	bool CheckSkillMenuStarted();
	bool CheckSkillSelectMenuClose();
	bool CheckSkillSelectMenuFinished();
	bool CheckSkillSelectMenuStarted();
	bool CheckSubQuestMenuClose();
	bool CheckSubQuestMenuFinished();
	bool CheckSubQuestMenuStarted();
	bool CheckSubtitleEndDelay();
	bool CheckTalkEndText();
	bool CheckTalkFinished();
	bool CheckTalkSkipVoice(class FName InTextID);
	bool CheckTalkStarted();
	bool CheckTalkWindow();
	bool CheckTalkWindowClosed(ERCAdvHUDTalkWindowType InWindowType);
	bool CheckTopMenuCheckFinished();
	bool CheckTopMenuCheckStarted();
	bool CheckTopMenuClose();
	bool ClearMenuHelpText();
	bool CollectionMenuFinish();
	bool CollectionMenuFinishForFooterAnimation();
	bool CollectionMenuStart();
	bool CollectionWindowFinish();
	bool CutInAnimAllRelease();
	bool CutInAnimNext();
	bool CutInAnimRelease(class FName InCutInID);
	bool CutInAnimStart(class FName InCutInID, bool bInReleaseWBPAtFinished);
	bool CutInAnimStartLoad(class FName InCutInID);
	bool CutInFinish();
	bool CutInStart(class FName InCutInID);
	bool DetPointFinish();
	bool DetPointStart(int32 InPoint);
	bool EnterBuilding_IsVisible(class ARCCheckActor* InCheckActor);
	bool EnterBuilding_SetData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInAccessable, float InScale);
	bool EnterBuilding_SetEnable(bool bInEnable);
	bool ForceFinishKaiKagiSelect();
	class ARCCharacterRender* GetAccessedCharacter();
	class ARCCheckActor* GetAccessedCheckActor();
	class ARCPawnRender* GetAccessedNPC();
	class FName GetAreaMapID();
	bool GetAreaMapMenuCancel();
	bool GetAreaMapMenuEnableFastTravel(class FName InWorldMapID);
	bool GetAreaMapMenuGoFastTravel();
	bool GetAreaMapMenuNewAreaSePlayed();
	bool GetAreaMenuOpen();
	int32 GetBattleKagiMenuIndex();
	bool GetBusMenuCancel();
	bool GetInputMenuButtonGuideKeyType(ERCInputKeyType InKeyType);
	int32 GetKagiSelectMenuIndex();
	int32 GetKaiKagiSelectIndex();
	void GetKaiKagiSelectKaiKagiIDArray(TArray<class FName>* OutKaiKagiIDArray);
	class URCUiMovieSkip* GetMovieSkipUi();
	TArray<class FName> GetNotClosedWidgetNames();
	class FName GetSelectedMapID();
	int32 GetSequentialSubtitleVoiceCharacterID();
	int32 GetSequentialTalkVoiceCharacterID();
	bool GetSkillMenuOpen();
	int32 GetSkillSelectIndex();
	ERCAdvHUDWidgetState GetUsingTalkWidgetOldState();
	ERCAdvHUDWidgetState GetUsingTalkWidgetState();
	bool GlossaryMenuFinish();
	bool GlossaryMenuStart();
	bool IsBackLogFinish();
	bool IsBackLogStarted();
	bool IsBalloonVisible(class APawn* InPawn);
	bool IsBattleKagiMenu();
	bool IsBusMenu();
	bool IsCanGlossaryMenuClose();
	bool IsCollectionWindowFinished();
	bool IsKagiMenuLarge();
	bool IsKagiSelectMenu();
	bool IsKagiSelectMenuLarge();
	bool IsMarkerVisible(class ARCCheckActor* InCheckActor);
	bool IsTalkIconVisible(class APawn* InPawn);
	bool KagiMenuFinish();
	bool KagiMenuStart();
	bool KagiSelectMenuFinish();
	bool KagiSelectMenuStart(const TArray<class FName>& InKaiKagiIDArray, bool bInNotPause);
	bool KagiSelectMenuStart2(const TArray<class FName>& InKaiKagiIDArray, class FName InQuestionTextID, bool bInNotPause, bool bInAcceptCancel, int32 InDebugCorrectIndex);
	bool MainQuestMenuFinish();
	bool MainQuestMenuStart();
	bool MenuGuideFinish();
	bool MenuGuideStart();
	bool MovieSkipFinish();
	bool MovieSkipStart();
	bool NzResultFinish();
	bool NzResultStart(const int32 InChapterNumber);
	void OnButtonGuideClick_ADV2StepResearchBack(ERCInputKeyType InKeyType);
	void OnButtonGuideClick_ADVHolding(ERCInputKeyType InKeyType);
	bool OpenCollectionWindowStart(const TArray<class FString>& TextArray);
	ERCAdvHUDPressedDecideResult PressedDecideButton();
	bool PressedDecideButtonSimple();
	bool ResearchDetailAutoSelectCheckActorMoveStart(class ARCCheckActor* InCheckActor);
	bool ResearchDetailAutoSelectMoveStart(int32 InMarkerDataIndex);
	bool ResearchDetailCheckAutoSelectMoveFinished();
	bool ResearchDetailFinish();
	int32 ResearchDetailGetAccessedIndex();
	int32 ResearchDetailGetSelectIndex();
	bool ResearchDetailPastVisionStart(const struct FRCAdvHUDResearchDetailStartData& InStartData, bool bInPast, bool bInEnableFinish);
	bool ResearchDetailSpotSelectStart(const struct FRCAdvHUDResearchDetailStartData& InStartData);
	bool ResearchDetailStart(const struct FRCAdvHUDResearchDetailStartData& InStartData);
	bool ResearchFinish();
	bool ResearchFinishTelop_CheckFinished();
	bool ResearchFinishTelop_Start();
	bool ResearchGetKagi_CheckFinished();
	bool ResearchGetKagi_StartFromKagiID(class FName InKagiID, int32 InPhase);
	bool ResearchLocation_CheckFinished();
	bool ResearchLocation_Finish();
	bool ResearchLocation_Start(class FName InLocationID, class FName InLocationTextID);
	bool ResearchMarker_IsMarkerVisible(class ARCCheckActor* InCheckActor);
	bool ResearchMarker_SetEnable(bool bInEnable);
	bool ResearchMarker_SetMarkerData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInNameDraw, bool bInResearched, bool bInAccessable, float InScale);
	bool ResearchModeFinish();
	bool ResearchQuestionText_Finish();
	bool ResearchQuestionText_SetText(class FName InTextID);
	bool ResearchQuestionText_Start(class FName InTextID);
	bool ResearchSpotJudgeTelop_CheckFinished();
	bool ResearchSpotJudgeTelopCorrect_Start();
	bool ResearchSpotJudgeTelopMistake_Start();
	bool ResearchSpotSelectStartTelop_CheckFinished();
	bool ResearchSpotSelectStartTelop_Start();
	bool ResearchStart(bool bInShowLocation, bool bInEnableFinish, bool bInMiniMap);
	bool ResearchStartTelop_CheckFinished();
	bool ResearchStartTelop_Start();
	bool ResearchStartWithQuestionText(class FName InQuestionTextID, bool bInEnableFinish, bool bInMiniMap);
	bool ResetSkillSelectFocus();
	void ResetSubtitlePlayVoiceFlag();
	bool SequentialSubtitleCancel(bool bInStopVoice);
	bool SequentialSubtitleFinish();
	bool SequentialSubtitleStart2(class FName InSubtitleID, const struct FRCSubtitleData& InSubtitleData, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStart2NoVoice(class FName InSubtitleID, const struct FRCSubtitleData& InSubtitleData, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStartFromData2(const struct FRCSubtitleData& InSubtitleData, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStartFromDataTable(class UDataTable* InTable, class FName InSubtitleID, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStartFromDataTable_WaitPush(class UDataTable* InTable, class FName InSubtitleID, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStartFromSubtitleID(class FName InSubtitleID, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialSubtitleStartFromSubtitleIDForMovie(class FName InSubtitleID, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	bool SequentialTalkFinish();
	bool SequentialTalkForceFinish();
	bool SequentialTalkRequestSuspend();
	bool SequentialTalkResume();
	bool SequentialTalkStart2(class FName InTalkID, const struct FRCTalkData& InTalkData, bool bInForceAutoPlay);
	bool SequentialTalkStartFromData2(const struct FRCTalkData& InTalkData, bool bInForceAutoPlay);
	bool SequentialTalkStartFromDataTable(class UDataTable* InTable, class FName InTalkID, bool bInForceAutoPlay);
	bool SequentialTalkStartFromTalkID(class FName InTalkID, bool bInForceAutoPlay);
	void SetAreaMapMenuNewAreaSePlayed(bool bInPlayedNewAreaSE);
	bool SetBalloonData(class APawn* InPawn, ESCBaloonFrame InBalloonFrameType, ESCBaloonType InBalloonContentType, class FName InTextID, bool bInBalloonDraw, bool bInTextDraw);
	bool SetMarkerData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInAccessable, bool bInSubquest, float InScale, bool bInGoal);
	bool SetMenuButtonGuide(class FName InModeID, bool bPlayOpenAnim);
	bool SetMenuButtonGuideResetKeyType();
	bool SetMenuHelpText(class FName InHelpTextID);
	void SetShinigamiActor(class ARCCharacterRender* InShinigamiActor);
	bool SetTalkIconData(class APawn* InPawn, bool bInDraw, bool bInAccessable, bool bInSubquest, float InScale, bool bInGoal);
	bool SkillMenuFinish();
	bool SkillMenuStart();
	bool SkillSelectMenuFinish();
	bool SkillSelectMenuStart();
	bool StartKaiKagiSelect(const TArray<class FName>& InKaiKagiIDArray, class FName InCorrectKaiKagiID, bool bInNotPause);
	bool SubQuestMenuFinish();
	bool SubQuestMenuStart();
	bool SubtitleCancel();
	bool SubtitleFinish();
	bool SubtitleStart(class FName InNameID, class FName InTextID, float InDelayAtEndVoice);
	bool SubtitleStart_OnlyCursor();
	bool SubtitleStart_WaitPush(class FName InNameID, class FName InTextID, float InDelayAtEndVoice);
	bool SubtitleStartFromCharacterID(int32 InCharacterNameID, int32 InCharacterNameSubID, class FName InTextID, float InDelayAtEndVoice);
	bool SubtitleStartFromCharacterID_WaitPush(int32 InCharacterNameID, int32 InCharacterNameSubID, class FName InTextID, float InDelayAtEndVoice);
	bool TalkFinish();
	bool TalkForceFinish();
	bool TalkLoadCharacterData(int32 InCharacterNameID, int32 InCharacterNameSubID, int32 InCharacterFaceID, int32 InCharacterFacialID);
	bool TalkLoadCharacterData2(int32 InCharacterNameID, const TArray<int32>& InCharacterNameSubIDs, int32 InCharacterFaceID, const TArray<int32>& InCharacterFacialIDs);
	bool TalkLoadFaceData(int32 InCharacterFaceID, int32 InCharacterFacialID);
	bool TalkLoadNameplateData(int32 InCharacterNameID, int32 InCharacterNameSubID);
	bool TalkSetAuto(bool bInAutoPlay);
	bool TalkSetForceTextSpeedSettings(bool bInIsForceTextSpeed, int32 InForceTextSpeed);
	bool TalkSetGradationFilter(class FName InFilterID);
	bool TalkSetText2(int32 InCharacterFaceID, int32 InCharacterFacialID, class FName InTextID, int32 InCharacter3DID, class FName InCharacter3DFacialID, class FName InVoiceID, float InDelayAtEndText);
	bool TalkSetTextData(const struct FRCAdvHUDTalkTextData& InTextData);
	bool TalkSetTextSimple(class FName InTextID, float InDelayAtEndText);
	bool TalkStart2(ERCAdvHUDTalkWindowType InWindowType, class FName InTextID, int32 InCharacterFaceID, int32 InCharacterFacialID, bool bInAutoPlay);
	bool TalkStartSimple(ERCAdvHUDTalkWindowType InWindowType);
	bool TalkWindowClose(ERCAdvHUDTalkWindowType InWindowType);
	bool TopMenuFinish();
	bool TopMenuStart();
	void Tutorial_CloseTutorial();
	bool Tutorial_CreateWidget();
	bool Tutorial_IsFinished();
	bool Tutorial_IsShowWindow();
	bool Tutorial_Load();
	void Tutorial_RemoveTutorialWindow();
	void Tutorial_StartTutorial(class FName ID, bool isAnytimeClosable);
	void UpdateCollectionFlag(class FName CharaID);
	bool WorldMenuFinish();
	bool WorldMenuStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUD">();
	}
	static class ARCAdvHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAdvHUD>();
	}
};
static_assert(alignof(ARCAdvHUD) == 0x000008, "Wrong alignment on ARCAdvHUD");
static_assert(sizeof(ARCAdvHUD) == 0x0008D8, "Wrong size on ARCAdvHUD");
static_assert(offsetof(ARCAdvHUD, bAllowEditInstance) == 0x000438, "Member 'ARCAdvHUD::bAllowEditInstance' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bInitialized) == 0x000439, "Member 'ARCAdvHUD::bInitialized' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ViewportSize) == 0x00043C, "Member 'ARCAdvHUD::ViewportSize' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ViewportScale) == 0x000444, "Member 'ARCAdvHUD::ViewportScale' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, PlayerScreenSize) == 0x000448, "Member 'ARCAdvHUD::PlayerScreenSize' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, PlayerScreenOffset) == 0x000450, "Member 'ARCAdvHUD::PlayerScreenOffset' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, PlayerScreenScale) == 0x000458, "Member 'ARCAdvHUD::PlayerScreenScale' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ChapterNo) == 0x00045C, "Member 'ARCAdvHUD::ChapterNo' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SceneID) == 0x000460, "Member 'ARCAdvHUD::SceneID' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, Components) == 0x000468, "Member 'ARCAdvHUD::Components' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bLoadCompleted) == 0x000478, "Member 'ARCAdvHUD::bLoadCompleted' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bLoadingCharaIntegrationIDToFaceIDDataTable) == 0x000479, "Member 'ARCAdvHUD::bLoadingCharaIntegrationIDToFaceIDDataTable' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CharaIntegrationIDToFaceIDDataTablePath) == 0x000480, "Member 'ARCAdvHUD::CharaIntegrationIDToFaceIDDataTablePath' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CharaIntegrationIDToFaceIDDataTable) == 0x000498, "Member 'ARCAdvHUD::CharaIntegrationIDToFaceIDDataTable' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, GenericWindowPriority) == 0x000540, "Member 'ARCAdvHUD::GenericWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, GenericWindowWidget) == 0x000548, "Member 'ARCAdvHUD::GenericWindowWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuideState) == 0x0005F8, "Member 'ARCAdvHUD::ButtonGuideState' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuideOldState) == 0x0005F9, "Member 'ARCAdvHUD::ButtonGuideOldState' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuideRequest) == 0x0005FA, "Member 'ARCAdvHUD::ButtonGuideRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuidePriority) == 0x0005FC, "Member 'ARCAdvHUD::ButtonGuidePriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuideModeID) == 0x000600, "Member 'ARCAdvHUD::ButtonGuideModeID' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ButtonGuideWidget) == 0x000608, "Member 'ARCAdvHUD::ButtonGuideWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleType) == 0x000610, "Member 'ARCAdvHUD::SubtitleType' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleTextID) == 0x000614, "Member 'ARCAdvHUD::SubtitleTextID' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSubtitleHiddenByOption) == 0x00061C, "Member 'ARCAdvHUD::bSubtitleHiddenByOption' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSubtitleWaitPush) == 0x00061D, "Member 'ARCAdvHUD::bSubtitleWaitPush' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleState) == 0x00061E, "Member 'ARCAdvHUD::SubtitleState' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OldSubtitleState) == 0x00061F, "Member 'ARCAdvHUD::OldSubtitleState' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitlePriority) == 0x000620, "Member 'ARCAdvHUD::SubtitlePriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleVoiceID) == 0x000624, "Member 'ARCAdvHUD::SubtitleVoiceID' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleDelayAtEndVoice) == 0x00062C, "Member 'ARCAdvHUD::SubtitleDelayAtEndVoice' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleVoiceLength) == 0x000630, "Member 'ARCAdvHUD::SubtitleVoiceLength' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubtitleVoiceElapsedTime) == 0x000634, "Member 'ARCAdvHUD::SubtitleVoiceElapsedTime' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, Subtitle) == 0x000638, "Member 'ARCAdvHUD::Subtitle' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleType) == 0x000640, "Member 'ARCAdvHUD::SequentialSubtitleType' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleID) == 0x000644, "Member 'ARCAdvHUD::SequentialSubtitleID' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleData) == 0x000650, "Member 'ARCAdvHUD::SequentialSubtitleData' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSequentialSubtitle) == 0x000678, "Member 'ARCAdvHUD::bSequentialSubtitle' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSequentialSubtitleHiddenByOption) == 0x000679, "Member 'ARCAdvHUD::bSequentialSubtitleHiddenByOption' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSequentialSubtitleWaitPush) == 0x00067A, "Member 'ARCAdvHUD::bSequentialSubtitleWaitPush' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bSequentialSubtitleDisableSave) == 0x00067B, "Member 'ARCAdvHUD::bSequentialSubtitleDisableSave' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleIndex) == 0x00067C, "Member 'ARCAdvHUD::SequentialSubtitleIndex' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleDelayToNextTime) == 0x000680, "Member 'ARCAdvHUD::SequentialSubtitleDelayToNextTime' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SequentialSubtitleElapsedTime) == 0x000684, "Member 'ARCAdvHUD::SequentialSubtitleElapsedTime' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TopMenuRequest) == 0x000688, "Member 'ARCAdvHUD::TopMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, WorldMenuRequest) == 0x000689, "Member 'ARCAdvHUD::WorldMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TopMenuWidgetPriority) == 0x00068C, "Member 'ARCAdvHUD::TopMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TopMenuWidget) == 0x000690, "Member 'ARCAdvHUD::TopMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bOpenTopMenuWithOtherMenu) == 0x000698, "Member 'ARCAdvHUD::bOpenTopMenuWithOtherMenu' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MenuGuideRequest) == 0x000699, "Member 'ARCAdvHUD::MenuGuideRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MenuGuideWidgetPriority) == 0x00069C, "Member 'ARCAdvHUD::MenuGuideWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MenuGuideWidget) == 0x0006A0, "Member 'ARCAdvHUD::MenuGuideWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, AreaMapMenuRequest) == 0x0006A8, "Member 'ARCAdvHUD::AreaMapMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, AreaMapMenuWidgetPriority) == 0x0006AC, "Member 'ARCAdvHUD::AreaMapMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, AreaMapMenuWidget) == 0x0006B0, "Member 'ARCAdvHUD::AreaMapMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bPlayedNewAreaSE) == 0x0006B8, "Member 'ARCAdvHUD::bPlayedNewAreaSE' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiMenuRequest) == 0x0006B9, "Member 'ARCAdvHUD::KagiMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiMenuWidgetPriority) == 0x0006BC, "Member 'ARCAdvHUD::KagiMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiMenuWidget) == 0x0006C0, "Member 'ARCAdvHUD::KagiMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiSelectMenuRequest) == 0x0006C8, "Member 'ARCAdvHUD::KagiSelectMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bKagiSelectNotPause) == 0x0006C9, "Member 'ARCAdvHUD::bKagiSelectNotPause' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bKagiSelectPrevPauseEnable) == 0x0006CA, "Member 'ARCAdvHUD::bKagiSelectPrevPauseEnable' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bKagiSelectPrevMenuEnable) == 0x0006CB, "Member 'ARCAdvHUD::bKagiSelectPrevMenuEnable' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bKagiSelectPrevBacklogEnable) == 0x0006CC, "Member 'ARCAdvHUD::bKagiSelectPrevBacklogEnable' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, bKagiSelectPrevCameraLock) == 0x0006CD, "Member 'ARCAdvHUD::bKagiSelectPrevCameraLock' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiSelectMenuWidgetPriority) == 0x0006D0, "Member 'ARCAdvHUD::KagiSelectMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, KagiSelectMenuWidget) == 0x0006D8, "Member 'ARCAdvHUD::KagiSelectMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MainQuestMenuRequest) == 0x0006F0, "Member 'ARCAdvHUD::MainQuestMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MainQuestMenuWidgetPriority) == 0x0006F4, "Member 'ARCAdvHUD::MainQuestMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MainQuestMenuWidget) == 0x0006F8, "Member 'ARCAdvHUD::MainQuestMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubQuestMenuRequest) == 0x000700, "Member 'ARCAdvHUD::SubQuestMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubQuestMenuWidgetPriority) == 0x000704, "Member 'ARCAdvHUD::SubQuestMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SubQuestMenuWidget) == 0x000708, "Member 'ARCAdvHUD::SubQuestMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillSelectMenuRequest) == 0x000710, "Member 'ARCAdvHUD::SkillSelectMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillSelectMenuWidgetPriority) == 0x000714, "Member 'ARCAdvHUD::SkillSelectMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillSelectMenuWidget) == 0x000718, "Member 'ARCAdvHUD::SkillSelectMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillMenuRequest) == 0x000720, "Member 'ARCAdvHUD::SkillMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillMenuWidgetPriority) == 0x000724, "Member 'ARCAdvHUD::SkillMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillMenuWidget) == 0x000728, "Member 'ARCAdvHUD::SkillMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillWindowPriority) == 0x000730, "Member 'ARCAdvHUD::SkillWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, SkillWindowWidget) == 0x000738, "Member 'ARCAdvHUD::SkillWindowWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, GlossaryMenuRequest) == 0x000740, "Member 'ARCAdvHUD::GlossaryMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, GlossaryMenuWidgetPriority) == 0x000744, "Member 'ARCAdvHUD::GlossaryMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, GlossaryMenuWidget) == 0x000748, "Member 'ARCAdvHUD::GlossaryMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionMenuRequest) == 0x000750, "Member 'ARCAdvHUD::CollectionMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionMenuWidgetPriority) == 0x000754, "Member 'ARCAdvHUD::CollectionMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionMenuWidget) == 0x000758, "Member 'ARCAdvHUD::CollectionMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionWindowRequest) == 0x000760, "Member 'ARCAdvHUD::CollectionWindowRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionWindowPriority) == 0x000764, "Member 'ARCAdvHUD::CollectionWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CollectionWindowWidget) == 0x000768, "Member 'ARCAdvHUD::CollectionWindowWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MovieSkipRequest) == 0x000770, "Member 'ARCAdvHUD::MovieSkipRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MovieSkipWidgetPriority) == 0x000774, "Member 'ARCAdvHUD::MovieSkipWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MovieSkipWidget) == 0x000778, "Member 'ARCAdvHUD::MovieSkipWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CharacterMenuRequest) == 0x000780, "Member 'ARCAdvHUD::CharacterMenuRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CharacterMenuWidgetPriority) == 0x000784, "Member 'ARCAdvHUD::CharacterMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, CharacterMenuWidget) == 0x000788, "Member 'ARCAdvHUD::CharacterMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, NzResultRequest) == 0x000790, "Member 'ARCAdvHUD::NzResultRequest' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, NzResultWidgetPriority) == 0x000794, "Member 'ARCAdvHUD::NzResultWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, NzResultWidget) == 0x000798, "Member 'ARCAdvHUD::NzResultWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, FastForwardIconPriority) == 0x0007A0, "Member 'ARCAdvHUD::FastForwardIconPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, FastForwardIcon) == 0x0007A8, "Member 'ARCAdvHUD::FastForwardIcon' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TutorialWindowPriority) == 0x0007B0, "Member 'ARCAdvHUD::TutorialWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TutorialWindowPath) == 0x0007B4, "Member 'ARCAdvHUD::TutorialWindowPath' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TutorialWindow) == 0x0007C0, "Member 'ARCAdvHUD::TutorialWindow' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, BackLogPriority) == 0x0007C8, "Member 'ARCAdvHUD::BackLogPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, BackLogWidget) == 0x0007D0, "Member 'ARCAdvHUD::BackLogWidget' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, InteractIconComponent) == 0x0007D8, "Member 'ARCAdvHUD::InteractIconComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, AdvComponent) == 0x0007E0, "Member 'ARCAdvHUD::AdvComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, TalkComponent) == 0x0007E8, "Member 'ARCAdvHUD::TalkComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ResearchPriority) == 0x0007F0, "Member 'ARCAdvHUD::ResearchPriority' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, ResearchComponent) == 0x0007F8, "Member 'ARCAdvHUD::ResearchComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, MapComponent) == 0x000800, "Member 'ARCAdvHUD::MapComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, PauseComponent) == 0x000808, "Member 'ARCAdvHUD::PauseComponent' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, isPlaySubTitleVoice) == 0x000810, "Member 'ARCAdvHUD::isPlaySubTitleVoice' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnInitialized) == 0x000818, "Member 'ARCAdvHUD::OnInitialized' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnTalkStarted) == 0x000828, "Member 'ARCAdvHUD::OnTalkStarted' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnTalkEndText) == 0x000838, "Member 'ARCAdvHUD::OnTalkEndText' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnTalkFinished) == 0x000848, "Member 'ARCAdvHUD::OnTalkFinished' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSequentialTalkFinishedLastText) == 0x000858, "Member 'ARCAdvHUD::OnSequentialTalkFinishedLastText' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSequentialTalkFinished) == 0x000868, "Member 'ARCAdvHUD::OnSequentialTalkFinished' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSubtitleEndDelay) == 0x000878, "Member 'ARCAdvHUD::OnSubtitleEndDelay' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSequentialSubtitleFinishedLastText) == 0x000888, "Member 'ARCAdvHUD::OnSequentialSubtitleFinishedLastText' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSequentialSubtitleFinished) == 0x000898, "Member 'ARCAdvHUD::OnSequentialSubtitleFinished' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnSequentialSubtitleCanceled) == 0x0008A8, "Member 'ARCAdvHUD::OnSequentialSubtitleCanceled' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, DebugDrawWidgetDatas) == 0x0008B8, "Member 'ARCAdvHUD::DebugDrawWidgetDatas' has a wrong offset!");
static_assert(offsetof(ARCAdvHUD, OnDebugSetDrawHUD) == 0x0008C8, "Member 'ARCAdvHUD::OnDebugSetDrawHUD' has a wrong offset!");

// Class RC.RCUiMenuQuestImage
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuQuestImage : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestImage">();
	}
	static class URCUiMenuQuestImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestImage>();
	}
};
static_assert(alignof(URCUiMenuQuestImage) == 0x000008, "Wrong alignment on URCUiMenuQuestImage");
static_assert(sizeof(URCUiMenuQuestImage) == 0x0002F8, "Wrong size on URCUiMenuQuestImage");

// Class RC.RCUiMenuMainQuestImage
// 0x0000 (0x02F8 - 0x02F8)
class URCUiMenuMainQuestImage : public URCUiMenuQuestImage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuMainQuestImage">();
	}
	static class URCUiMenuMainQuestImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuMainQuestImage>();
	}
};
static_assert(alignof(URCUiMenuMainQuestImage) == 0x000008, "Wrong alignment on URCUiMenuMainQuestImage");
static_assert(sizeof(URCUiMenuMainQuestImage) == 0x0002F8, "Wrong size on URCUiMenuMainQuestImage");

// Class RC.RCAdvHUDBaseComponent
// 0x0010 (0x00C0 - 0x00B0)
class URCAdvHUDBaseComponent : public UActorComponent
{
public:
	class ARCAdvHUD*                              HUD;                                               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetPriority;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDBaseComponent">();
	}
	static class URCAdvHUDBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDBaseComponent>();
	}
};
static_assert(alignof(URCAdvHUDBaseComponent) == 0x000008, "Wrong alignment on URCAdvHUDBaseComponent");
static_assert(sizeof(URCAdvHUDBaseComponent) == 0x0000C0, "Wrong size on URCAdvHUDBaseComponent");
static_assert(offsetof(URCAdvHUDBaseComponent, HUD) == 0x0000B0, "Member 'URCAdvHUDBaseComponent::HUD' has a wrong offset!");
static_assert(offsetof(URCAdvHUDBaseComponent, WidgetPriority) == 0x0000B8, "Member 'URCAdvHUDBaseComponent::WidgetPriority' has a wrong offset!");

// Class RC.RCAdvHUDAdvComponent
// 0x01A8 (0x0268 - 0x00C0)
class URCAdvHUDAdvComponent final : public URCAdvHUDBaseComponent
{
public:
	bool                                          bAllowEditInstance;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerEnable;                                     // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDMarkerWidgetSet>       MarkerWidgetSets;                                  // 0x00C8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDMarkerWidgetSet>       FreeMarkerWidgetSets;                              // 0x00D8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         MarkerScale;                                       // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerTextPositionOffset;                          // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerSubquestScale;                               // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerSubquestPositionOffset;                      // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MarkerMaxNum;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingMarkerNum;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDMarkerData>            MarkerDatas;                                       // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCUiIntSubQuest*>               SubquestWidgets;                                   // 0x0118(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<class URCUiIntSubQuest*>               FreeSubquestWidgets;                               // 0x0128(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	int32                                         SubquestNumMax;                                    // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingSubquestNum;                                  // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCReSubQuest*>                  SubquestInformationWidgets;                        // 0x0140(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	int32                                         SubquestInformationWidgetPriority;                 // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiFigureInformation*               FigureInformationWidget;                           // 0x0158(0x0008)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FigureInformationWidgetPriority;                   // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DetPointWidgetPriority;                            // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DetPointWidgetPriority_NzResult;                   // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiDetPoint*                          DetPointWidget;                                    // 0x0170(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        CutInRequest;                                      // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CutInWidgetPriority;                               // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCAdvHUDCutInData>  CutInDataMap;                                      // 0x0180(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   CurrentCutInID;                                    // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDCutInType                            CurrentCutInType;                                  // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDCutInSEType                          CurrentCutInSEType;                                // 0x01D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DA[0x2];                                      // 0x01DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CutInAnimSpeedRate;                                // 0x01DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCutInDelayFinish;                                 // 0x01E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CutInDelayFinishDelayTime;                         // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CutInTimerHandle;                                  // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCAdvHUDCutInAnimData> CutInAnimDataMap;                                  // 0x01F0(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bCutInAnimReleaseWBPAtFinished;                    // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiCutIn*                             CutInWidget;                                       // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiCutIn*                             CutInFullScreenWidget;                             // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiCutInText*                         CutInTextWidget;                                   // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiCutInAnim*                         CutInAnimWidget;                                   // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckCutInAnimFinishedAnim();
	bool CheckCutInAnimLoadCompleted(class FName InCutInID);
	bool CheckCutInAnimNextEnable();
	bool CheckCutInFinished();
	bool CheckCutInStarted();
	bool CheckDetPointCheckFinished();
	bool CheckDetPointCheckStarted();
	bool CutInAnimAllRelease();
	bool CutInAnimNext();
	bool CutInAnimRelease(class FName InCutInID);
	bool CutInAnimStart(class FName InCutInID, bool bInReleaseWBPAtFinished);
	bool CutInAnimStartLoad(class FName InCutInID);
	bool CutInFinish();
	bool CutInStart(class FName InCutInID);
	bool DetPointFinish();
	bool DetPointStart(int32 InPoint, bool InIsOpenedNzResult);
	bool GetMarkerData(int32 InIndex, struct FRCAdvHUDMarkerData* OutMarkerData);
	int32 GetMarkerDataNum();
	bool IsMarkerVisible(class ARCCheckActor* InCheckActor);
	bool SetMarkerData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInAccessable, bool bInSubquest, float InScale, bool bInGoal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDAdvComponent">();
	}
	static class URCAdvHUDAdvComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDAdvComponent>();
	}
};
static_assert(alignof(URCAdvHUDAdvComponent) == 0x000008, "Wrong alignment on URCAdvHUDAdvComponent");
static_assert(sizeof(URCAdvHUDAdvComponent) == 0x000268, "Wrong size on URCAdvHUDAdvComponent");
static_assert(offsetof(URCAdvHUDAdvComponent, bAllowEditInstance) == 0x0000C0, "Member 'URCAdvHUDAdvComponent::bAllowEditInstance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, bMarkerEnable) == 0x0000C1, "Member 'URCAdvHUDAdvComponent::bMarkerEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerWidgetSets) == 0x0000C8, "Member 'URCAdvHUDAdvComponent::MarkerWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, FreeMarkerWidgetSets) == 0x0000D8, "Member 'URCAdvHUDAdvComponent::FreeMarkerWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerScale) == 0x0000E8, "Member 'URCAdvHUDAdvComponent::MarkerScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerTextPositionOffset) == 0x0000EC, "Member 'URCAdvHUDAdvComponent::MarkerTextPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerSubquestScale) == 0x0000F4, "Member 'URCAdvHUDAdvComponent::MarkerSubquestScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerSubquestPositionOffset) == 0x0000F8, "Member 'URCAdvHUDAdvComponent::MarkerSubquestPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerMaxNum) == 0x000100, "Member 'URCAdvHUDAdvComponent::MarkerMaxNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, UsingMarkerNum) == 0x000104, "Member 'URCAdvHUDAdvComponent::UsingMarkerNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, MarkerDatas) == 0x000108, "Member 'URCAdvHUDAdvComponent::MarkerDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, SubquestWidgets) == 0x000118, "Member 'URCAdvHUDAdvComponent::SubquestWidgets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, FreeSubquestWidgets) == 0x000128, "Member 'URCAdvHUDAdvComponent::FreeSubquestWidgets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, SubquestNumMax) == 0x000138, "Member 'URCAdvHUDAdvComponent::SubquestNumMax' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, UsingSubquestNum) == 0x00013C, "Member 'URCAdvHUDAdvComponent::UsingSubquestNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, SubquestInformationWidgets) == 0x000140, "Member 'URCAdvHUDAdvComponent::SubquestInformationWidgets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, SubquestInformationWidgetPriority) == 0x000150, "Member 'URCAdvHUDAdvComponent::SubquestInformationWidgetPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, FigureInformationWidget) == 0x000158, "Member 'URCAdvHUDAdvComponent::FigureInformationWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, FigureInformationWidgetPriority) == 0x000160, "Member 'URCAdvHUDAdvComponent::FigureInformationWidgetPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, DetPointWidgetPriority) == 0x000164, "Member 'URCAdvHUDAdvComponent::DetPointWidgetPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, DetPointWidgetPriority_NzResult) == 0x000168, "Member 'URCAdvHUDAdvComponent::DetPointWidgetPriority_NzResult' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, DetPointWidget) == 0x000170, "Member 'URCAdvHUDAdvComponent::DetPointWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInRequest) == 0x000178, "Member 'URCAdvHUDAdvComponent::CutInRequest' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInWidgetPriority) == 0x00017C, "Member 'URCAdvHUDAdvComponent::CutInWidgetPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInDataMap) == 0x000180, "Member 'URCAdvHUDAdvComponent::CutInDataMap' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CurrentCutInID) == 0x0001D0, "Member 'URCAdvHUDAdvComponent::CurrentCutInID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CurrentCutInType) == 0x0001D8, "Member 'URCAdvHUDAdvComponent::CurrentCutInType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CurrentCutInSEType) == 0x0001D9, "Member 'URCAdvHUDAdvComponent::CurrentCutInSEType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInAnimSpeedRate) == 0x0001DC, "Member 'URCAdvHUDAdvComponent::CutInAnimSpeedRate' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, bCutInDelayFinish) == 0x0001E0, "Member 'URCAdvHUDAdvComponent::bCutInDelayFinish' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInDelayFinishDelayTime) == 0x0001E4, "Member 'URCAdvHUDAdvComponent::CutInDelayFinishDelayTime' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInTimerHandle) == 0x0001E8, "Member 'URCAdvHUDAdvComponent::CutInTimerHandle' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInAnimDataMap) == 0x0001F0, "Member 'URCAdvHUDAdvComponent::CutInAnimDataMap' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, bCutInAnimReleaseWBPAtFinished) == 0x000240, "Member 'URCAdvHUDAdvComponent::bCutInAnimReleaseWBPAtFinished' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInWidget) == 0x000248, "Member 'URCAdvHUDAdvComponent::CutInWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInFullScreenWidget) == 0x000250, "Member 'URCAdvHUDAdvComponent::CutInFullScreenWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInTextWidget) == 0x000258, "Member 'URCAdvHUDAdvComponent::CutInTextWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDAdvComponent, CutInAnimWidget) == 0x000260, "Member 'URCAdvHUDAdvComponent::CutInAnimWidget' has a wrong offset!");

// Class RC.RCNzMTBManagerBase
// 0x00D0 (0x02F0 - 0x0220)
class ARCNzMTBManagerBase final : public AActor
{
public:
	class FName                                   SceneID;                                           // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wall2WallInterval;                                 // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wall2TorideInterval;                               // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelSpeed;                                        // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KaizinPass;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           KaikagiIDList;                                     // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         WallCount;                                         // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         KaizinList;                                        // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           KaizinMotionList_Idle;                             // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           KaizinMotionList_WallVoice;                        // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           KaizinMotionList_ShoutVoice;                       // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           KaizinMotionList_WallBreakVoice;                   // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsEndHalfway;                                      // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTutorialScene;                                   // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x2];                                      // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BgmID;                                             // 0x02AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MTBEndEventID;                                     // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissDamage;                                        // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DTTalkEvent_Normal;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DTTalkEvent_Miss;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultCount_MissKaikagi;                           // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultCount_MissAttack;                            // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ObjectPosInterval;                                 // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsEnableMoveSkip;                                  // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x1];                                      // 0x02E9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsEvaluationVersion;                               // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseLoopEventVersion;                             // 0x02EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddKaikagi(class FName NewKaikagiID);
	void ChangeKaikagiList(class FName NewKaikagiListID);
	bool CheckAnswerKaikagiID();
	void DebugSetMaxVolumeMode(bool Enable);
	class FName GetCurrentSelectKaikagiID();
	int32 GetHP();
	void IncrementResultData();
	void IncrementResultData_AttackMiss();
	void LoadDataTable();
	void SendResultData();
	bool SetDamage(int32 InDamage, int32* OldHP, int32* NewHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzMTBManagerBase">();
	}
	static class ARCNzMTBManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzMTBManagerBase>();
	}
};
static_assert(alignof(ARCNzMTBManagerBase) == 0x000008, "Wrong alignment on ARCNzMTBManagerBase");
static_assert(sizeof(ARCNzMTBManagerBase) == 0x0002F0, "Wrong size on ARCNzMTBManagerBase");
static_assert(offsetof(ARCNzMTBManagerBase, SceneID) == 0x000220, "Member 'ARCNzMTBManagerBase::SceneID' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, Wall2WallInterval) == 0x000228, "Member 'ARCNzMTBManagerBase::Wall2WallInterval' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, Wall2TorideInterval) == 0x00022C, "Member 'ARCNzMTBManagerBase::Wall2TorideInterval' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, MoveSpeed) == 0x000230, "Member 'ARCNzMTBManagerBase::MoveSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, AccelSpeed) == 0x000234, "Member 'ARCNzMTBManagerBase::AccelSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinPass) == 0x000238, "Member 'ARCNzMTBManagerBase::KaizinPass' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaikagiIDList) == 0x000240, "Member 'ARCNzMTBManagerBase::KaikagiIDList' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, WallCount) == 0x000250, "Member 'ARCNzMTBManagerBase::WallCount' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinList) == 0x000258, "Member 'ARCNzMTBManagerBase::KaizinList' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinMotionList_Idle) == 0x000268, "Member 'ARCNzMTBManagerBase::KaizinMotionList_Idle' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinMotionList_WallVoice) == 0x000278, "Member 'ARCNzMTBManagerBase::KaizinMotionList_WallVoice' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinMotionList_ShoutVoice) == 0x000288, "Member 'ARCNzMTBManagerBase::KaizinMotionList_ShoutVoice' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, KaizinMotionList_WallBreakVoice) == 0x000298, "Member 'ARCNzMTBManagerBase::KaizinMotionList_WallBreakVoice' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, IsEndHalfway) == 0x0002A8, "Member 'ARCNzMTBManagerBase::IsEndHalfway' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, IsTutorialScene) == 0x0002A9, "Member 'ARCNzMTBManagerBase::IsTutorialScene' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, BgmID) == 0x0002AC, "Member 'ARCNzMTBManagerBase::BgmID' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, MTBEndEventID) == 0x0002B4, "Member 'ARCNzMTBManagerBase::MTBEndEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, MissDamage) == 0x0002BC, "Member 'ARCNzMTBManagerBase::MissDamage' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, DTTalkEvent_Normal) == 0x0002C0, "Member 'ARCNzMTBManagerBase::DTTalkEvent_Normal' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, DTTalkEvent_Miss) == 0x0002C8, "Member 'ARCNzMTBManagerBase::DTTalkEvent_Miss' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, ResultCount_MissKaikagi) == 0x0002D0, "Member 'ARCNzMTBManagerBase::ResultCount_MissKaikagi' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, ResultCount_MissAttack) == 0x0002D4, "Member 'ARCNzMTBManagerBase::ResultCount_MissAttack' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, ObjectPosInterval) == 0x0002D8, "Member 'ARCNzMTBManagerBase::ObjectPosInterval' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, IsEnableMoveSkip) == 0x0002E8, "Member 'ARCNzMTBManagerBase::IsEnableMoveSkip' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, IsEvaluationVersion) == 0x0002EA, "Member 'ARCNzMTBManagerBase::IsEvaluationVersion' has a wrong offset!");
static_assert(offsetof(ARCNzMTBManagerBase, IsUseLoopEventVersion) == 0x0002EB, "Member 'ARCNzMTBManagerBase::IsUseLoopEventVersion' has a wrong offset!");

// Class RC.RCUiMenuAreaMapIcon
// 0x0008 (0x02E0 - 0x02D8)
class URCUiMenuAreaMapIcon : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapIcon">();
	}
	static class URCUiMenuAreaMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapIcon>();
	}
};
static_assert(alignof(URCUiMenuAreaMapIcon) == 0x000008, "Wrong alignment on URCUiMenuAreaMapIcon");
static_assert(sizeof(URCUiMenuAreaMapIcon) == 0x0002E0, "Wrong size on URCUiMenuAreaMapIcon");

// Class RC.RCUiMenuAreaMapIconArrow
// 0x0020 (0x0300 - 0x02E0)
class URCUiMenuAreaMapIconArrow final : public URCUiMenuAreaMapIcon
{
public:
	class UTextLayoutWidget*                      Txt_MoveArea;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapIconArrow">();
	}
	static class URCUiMenuAreaMapIconArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapIconArrow>();
	}
};
static_assert(alignof(URCUiMenuAreaMapIconArrow) == 0x000008, "Wrong alignment on URCUiMenuAreaMapIconArrow");
static_assert(sizeof(URCUiMenuAreaMapIconArrow) == 0x000300, "Wrong size on URCUiMenuAreaMapIconArrow");
static_assert(offsetof(URCUiMenuAreaMapIconArrow, Txt_MoveArea) == 0x0002E0, "Member 'URCUiMenuAreaMapIconArrow::Txt_MoveArea' has a wrong offset!");

// Class RC.RCAdvHUDBFL
// 0x0000 (0x0028 - 0x0028)
class URCAdvHUDBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AddLogAtSkip(class FName TextID);
	static bool AreaMapMenuFinish();
	static bool AreaMapMenuStart(bool bShortcut, class FName InLocationID);
	static bool CharacterMenuFinish();
	static bool CharacterMenuStart();
	static int32 CharaIntegrationIDToFaceID(int32 IntegrationID);
	static bool CheckAreaMapMenuFinished();
	static bool CheckAreaMapMenuStarted();
	static bool CheckCharacterMenuClose();
	static bool CheckCharacterMenuFinished();
	static bool CheckCharacterMenuStarted();
	static bool CheckCollectionMenuClose();
	static bool CheckCollectionMenuFinished();
	static bool CheckCollectionMenuStarted();
	static void CheckCutInAnimFinishedAnim(bool* bNextEnable);
	static void CheckCutInAnimLoadCompleted(bool* bLoaded, class FName CutInID);
	static void CheckCutInAnimNextEnable(bool* bNextEnable);
	static void CheckCutInCheckFinished(bool* bFinished);
	static void CheckCutInCheckStarted(bool* bStarted);
	static void CheckDetPointCheckFinished(bool* bFinished);
	static void CheckDetPointCheckStarted(bool* bStarted);
	static void CheckFinishedKaiKagiSelect(bool* bFinished);
	static bool CheckGlossaryMenuClose();
	static bool CheckGlossaryMenuFinished();
	static bool CheckGlossaryMenuStarted();
	static bool CheckInitialized();
	static bool CheckKagiMenuFinished();
	static bool CheckKagiMenuStarted();
	static bool CheckMainQuestMenuClose();
	static bool CheckMainQuestMenuFinished();
	static bool CheckMainQuestMenuStarted();
	static bool CheckMenuGuideFinished();
	static bool CheckMenuGuideStarted();
	static bool CheckNzResultClose();
	static bool CheckNzResultFinished();
	static bool CheckNzResultStarted();
	static void CheckSequentialSubtitle(bool* bRunning);
	static void CheckSequentialSubtitleCloseAtAllEnd(bool* bClose);
	static void CheckSequentialSubtitleFinished(bool* bFinished);
	static void CheckSequentialSubtitleFinishedLastText(bool* bFinished);
	static void CheckSequentialTalk(bool* bRunning);
	static void CheckSequentialTalkCloseAtAllEnd(bool* bClose);
	static void CheckSequentialTalkFinished(bool* bFinished);
	static void CheckSequentialTalkFinishedLastText(bool* bFinished);
	static bool CheckSkillGetInterval();
	static bool CheckSkillMenuClose();
	static bool CheckSkillMenuFinished();
	static bool CheckSkillMenuStarted();
	static bool CheckSkillSelectMenuClose();
	static bool CheckSkillSelectMenuFinished();
	static bool CheckSkillSelectMenuStarted();
	static bool CheckSubQuestMenuClose();
	static bool CheckSubQuestMenuFinished();
	static bool CheckSubQuestMenuStarted();
	static void CheckSubtitleEndDelay(bool* bFinished);
	static void CheckTalkEndText(bool* bEnded);
	static void CheckTalkFinished(bool* bFinished);
	static void CheckTalkStarted(bool* bStarted);
	static void CheckTalkWindow(bool* bRunning);
	static bool CheckTopMenuCheckFinished();
	static bool CheckTopMenuCheckStarted();
	static bool CheckTopMenuClose();
	static bool ClearMenuHelpText();
	static void CloseGenericWindow();
	static void CloseSkillWindow();
	static bool CollectionMenuFinish();
	static bool CollectionMenuFinishForFooterAnimation();
	static bool CollectionMenuStart();
	static void CutInAnimAllRelease(bool* bSucceeded);
	static void CutInAnimNext(bool* bSucceeded);
	static void CutInAnimRelease(bool* bSucceeded, class FName CutInID);
	static void CutInAnimStart(bool* bSucceeded, class FName CutInID, bool bInReleaseWBPAtFinished);
	static void CutInAnimStartLoad(bool* bSucceeded, class FName CutInID);
	static void CutInFinish(bool* bSucceeded);
	static void CutInStart(bool* bSucceeded, class FName CutInID);
	static void DetPointFinish(bool* bSucceeded);
	static void DetPointStart(bool* bSucceeded, int32 Point);
	static void FigureInformationStart(bool* bSucceeded, class FName CharaID, float dispTime);
	static void ForceFinishKaiKagiSelect(bool* bSucceeded);
	static class ARCAdvHUD* GetAdvHUD();
	static bool GetAreaMapMenuCancel();
	static bool GetAreaMapMenuEnableFastTravel(class FName InWorldMapID);
	static bool GetAreaMapMenuGoFastTravel();
	static bool GetAreaMapMenuNewAreaSePlayed();
	static bool GetBusMenuCancel();
	static bool GetButtonResultGenericWindow();
	static bool GetButtonResultSkillWindow();
	static bool GetInputMenuButtonGuideKeyType(ERCInputKeyType InKeyType);
	static void GetKaiKagiSelectIndex(int32* SelectedIndex);
	static void GetKaiKagiSelectKaiKagiIDArray(TArray<class FName>* KaiKagiIDArray);
	static class FName GetSelectedMapID();
	static void GetSequentialSubtitleVoiceCharacterID(int32* VoiceCharacterID);
	static void GetSequentialTalkVoiceCharacterID(int32* VoiceCharacterID);
	static bool GetSkillMenuOpen();
	static int32 GetSkillSelectIndex();
	static bool GlossaryMenuFinish();
	static bool GlossaryMenuStart();
	static bool IsCanGlossaryMenuClose();
	static bool IsFigureInformationFinished();
	static bool IsFinishedGenericWindow();
	static bool IsFinishedSaveLoadLayout();
	static bool IsFinishedSkillWindow();
	static bool IsFinishedSuquestEndInformation();
	static bool IsFinishedSuquestStartInformation();
	static bool IsKagiLarge();
	static bool IsKagiSelectMenu();
	static bool IsShowGenericWindow();
	static bool IsShowSkillWindow();
	static bool IsShowTutorialWindow();
	static bool KagiMenuFinish();
	static bool KagiMenuStart();
	static bool MainQuestMenuFinish();
	static bool MainQuestMenuStart();
	static void MakeDeleteKaiKagiIDArray(TArray<class FName>* OutDeleteKaiKagiIDArray, const TArray<class FName>& KaiKagiIDArray, class FName CorrectKaiKagiID, const TArray<class FName>& DeleteKaiKagiIDArray);
	static void MakeKaiKagiIDArrayBySkill(TArray<class FName>* OutKaiKagiIDArray, const TArray<class FName>& KaiKagiIDArray, class FName CorrectKaiKagiID, const TArray<class FName>& DeleteKaiKagiIDArray, ERCSkillFunctionType SkillFunctionType);
	static bool MenuGuideFinish();
	static bool MenuGuideStart();
	static bool NzResultFinish();
	static bool NzResultStart(const int32 InChapterNumber);
	static void OpenGenericWindow(class FName InTextID, bool bInIsSelect, bool bInIsFocusTrue, bool bInIsAcceptCancel);
	static void OpenGenericWindowMultiStrings(const TArray<class FString>& InStringArray, bool bInIsSelect, bool bInIsFocusTrue, bool bInIsAcceptCancel);
	static void OpenGenericWindowMultiTextIDs(const TArray<class FName>& InTextIDArray, bool bInIsSelect, bool bInIsFocusTrue, bool bInIsAcceptCancel);
	static void OpenSkillWindow(class FName InSkillMode, class FName InSkillID);
	static bool ResetSkillSelectFocus();
	static void ResetSubtitlePlayVoiceFlag();
	static bool SaveLoadLayoutClose();
	static bool SaveLoadSelectStart();
	static void SequentialSubtitleCancel();
	static void SequentialSubtitleFinish(bool* bSucceeded);
	static void SequentialSubtitleStart2(bool* bSucceeded, class FName SubTitleID, const struct FRCSubtitleData& SubtitleData, float DelayAtEnd, float DelayToNext, bool bCloseAtAllEnd, bool bDisableSave);
	static void SequentialSubtitleStartFromData2(bool* bSucceeded, const struct FRCSubtitleData& SubtitleData, float DelayAtEnd, float DelayToNext, bool bCloseAtAllEnd, bool bDisableSave);
	static void SequentialSubtitleStartFromDataTable(bool* bSucceeded, class UDataTable* Table, class FName SubTitleID, float DelayAtEnd, float DelayToNext, bool bCloseAtAllEnd, bool bDisableSave);
	static void SequentialSubtitleStartFromDataTable_WaitPush(bool* bSucceeded, class UDataTable* Table, class FName SubTitleID, float DelayAtEnd, float DelayToNext, bool bCloseAtAllEnd, bool bDisableSave);
	static void SequentialSubtitleStartFromSubtitleID(bool* bSucceeded, class FName SubTitleID, float DelayAtEnd, float DelayToNext, bool bCloseAtAllEnd, bool bDisableSave);
	static void SequentialSubtitleStartFromSubtitleIDForMovie(bool* bSucceeded, class FName InSubtitleID, float InDelayAtEnd, float InDelayToNext, bool bInCloseAtAllEnd, bool bInDisableSave);
	static void SequentialTalkFinish(bool* bSucceeded);
	static void SequentialTalkForceFinish(bool* bSucceeded);
	static void SequentialTalkStart2(bool* bSucceeded, class FName TalkID, const struct FRCTalkData& TalkData, bool bForceAutoPlay);
	static void SequentialTalkStartFromData2(bool* bSucceeded, const struct FRCTalkData& TalkData, bool bForceAutoPlay);
	static void SequentialTalkStartFromDataTable(bool* bSucceeded, class UDataTable* Table, class FName TalkID, bool bForceAutoPlay);
	static void SequentialTalkStartFromTalkID(bool* bSucceeded, class FName TalkID, bool bForceAutoPlay);
	static void SetAreaMapMenuNewAreaSePlayed(bool bInPlayedNewAreaSE);
	static void SetBacklogEnable(bool bInFlag);
	static bool SetMenuButtonGuide(class FName InModeID, bool bInPlayOpenAnim);
	static bool SetMenuButtonGuideResetKeyType();
	static void SetMenuEnable(bool bInFlag);
	static bool SetMenuHelpText(class FName InHelpTextID);
	static void SetPauseEnable(bool bInFlag);
	static bool SkillMenuFinish();
	static bool SkillMenuStart();
	static bool SkillSelectMenuFinish();
	static bool SkillSelectMenuStart();
	static void StartKaiKagiSelect(bool* bSucceeded, const TArray<class FName>& KaiKagiIDArray, class FName CorrectKaiKagiID, bool bNotPause);
	static void StartKaiKagiSelect2(bool* bSucceeded, class FName QuestionTextID, const TArray<class FName>& KaiKagiIDArray, class FName CorrectKaiKagiID, const TArray<class FName>& DeleteKaiKagiIDArray, bool bNotPause, bool bCancelDisable);
	static bool SubQuestMenuFinish();
	static bool SubQuestMenuStart();
	static void SubtitleFinish(bool* bSucceeded);
	static void SubtitleStart(bool* bSucceeded, class FName NameID, class FName TextID, float DelayAtEndVoice);
	static void SubtitleStart_OnlyCursor(bool* bSucceeded);
	static void SubtitleStart_WaitPush(bool* bSucceeded, class FName NameID, class FName TextID, float DelayAtEndVoice);
	static void SubtitleStartFromCharacterID(bool* bSucceeded, int32 CharacterNameID, int32 CharacterNameSubID, class FName TextID, float DelayAtEndVoice);
	static void SubtitleStartFromCharacterID_WaitPush(bool* bSucceeded, int32 CharacterNameID, int32 CharacterNameSubID, class FName TextID, float DelayAtEndVoice);
	static void SuquestEndInformationStart(bool* bSucceeded, class FName QuestID, float dispTime);
	static void SuquestStartInformationStart(bool* bSucceeded, class FName QuestID, float dispTime);
	static void TalkFinish(bool* bSucceeded);
	static void TalkForceFinish(bool* bSucceeded);
	static void TalkSetAuto(bool* bSucceeded, bool bAutoPlay);
	static void TalkSetForceTextSpeedSettings(bool* bSucceeded, bool bIsForceTextSpeed, int32 ForceTextSpeed);
	static void TalkSetGradationFilter(bool* bSucceeded, class FName FilterID);
	static void TalkSetText2(bool* bSucceeded, int32 CharacterFaceID, int32 CharacterFacialID, class FName TextID, int32 Character3DID, class FName CharacterFacial3DID, class FName VoiceID, float Delay);
	static void TalkSetTextData(bool* bSucceeded, const struct FRCAdvHUDTalkTextData& TextData);
	static void TalkSetTextSimple(bool* bSucceeded, class FName TextID, float Delay);
	static void TalkStart2(bool* bSucceeded, ERCAdvHUDTalkWindowType WindowType, class FName TextID, int32 CharacterFaceID, int32 CharacterFacialID, bool bAutoPlay);
	static void TalkStartSimple(bool* bSucceeded, ERCAdvHUDTalkWindowType WindowType);
	static int32 TextIDToFaceID(class FName TextID);
	static void UpdateCollectionFlag(class FName CharaID);
	static bool WorldMenuStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDBFL">();
	}
	static class URCAdvHUDBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDBFL>();
	}
};
static_assert(alignof(URCAdvHUDBFL) == 0x000008, "Wrong alignment on URCAdvHUDBFL");
static_assert(sizeof(URCAdvHUDBFL) == 0x000028, "Wrong size on URCAdvHUDBFL");

// Class RC.RCUiPushButton
// 0x0008 (0x02E0 - 0x02D8)
class URCUiPushButton final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Push;                                           // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiPushButton">();
	}
	static class URCUiPushButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiPushButton>();
	}
};
static_assert(alignof(URCUiPushButton) == 0x000008, "Wrong alignment on URCUiPushButton");
static_assert(sizeof(URCUiPushButton) == 0x0002E0, "Wrong size on URCUiPushButton");
static_assert(offsetof(URCUiPushButton, AN_Push) == 0x0002D8, "Member 'URCUiPushButton::AN_Push' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiListBar
// 0x0020 (0x02F8 - 0x02D8)
class URCNzUiBattleKaiKagiListBar final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_kaikagiName;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	ERCNzUiBattleKaiKagiListBarStatus GetBattleKaiKagiListBarStatus();
	void InitializeBattleKaiKagiListBar();
	bool IsPlayWaitAnimation();
	void Open();
	void SetKaiKagiName(class FName InTextID);
	void SetVisible(bool bInVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiListBar">();
	}
	static class URCNzUiBattleKaiKagiListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiListBar>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiListBar) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiListBar");
static_assert(sizeof(URCNzUiBattleKaiKagiListBar) == 0x0002F8, "Wrong size on URCNzUiBattleKaiKagiListBar");
static_assert(offsetof(URCNzUiBattleKaiKagiListBar, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiListBar::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiListBar, AN_Wait) == 0x0002E8, "Member 'URCNzUiBattleKaiKagiListBar::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiListBar, TextBlock_kaikagiName) == 0x0002F0, "Member 'URCNzUiBattleKaiKagiListBar::TextBlock_kaikagiName' has a wrong offset!");

// Class RC.RCTalkDataAsset
// 0x0050 (0x0080 - 0x0030)
class URCTalkDataAsset final : public URCCSVData
{
public:
	TMap<class FName, struct FRCTalkData>         DataMap;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTalkDataAsset">();
	}
	static class URCTalkDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTalkDataAsset>();
	}
};
static_assert(alignof(URCTalkDataAsset) == 0x000008, "Wrong alignment on URCTalkDataAsset");
static_assert(sizeof(URCTalkDataAsset) == 0x000080, "Wrong size on URCTalkDataAsset");
static_assert(offsetof(URCTalkDataAsset, DataMap) == 0x000030, "Member 'URCTalkDataAsset::DataMap' has a wrong offset!");

// Class RC.RCUiInteractIcon
// 0x0020 (0x02F8 - 0x02D8)
class URCUiInteractIcon : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void CloseSelectable();
	void CloseText();
	void FinishSelectable();
	int32 GetInteractStatusInt();
	void InitializeInteractIcon();
	void Open(bool bInShowSubQuest, bool bInMoveable);
	void OpenSelectable(bool bInShowSubQuest, bool bInMoveable, const class FString& InName);
	void OpenText(const class FString& InName);
	void StartSelectable(const class FString& InName);
	void WaitOutside();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractIcon">();
	}
	static class URCUiInteractIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractIcon>();
	}
};
static_assert(alignof(URCUiInteractIcon) == 0x000008, "Wrong alignment on URCUiInteractIcon");
static_assert(sizeof(URCUiInteractIcon) == 0x0002F8, "Wrong size on URCUiInteractIcon");

// Class RC.RCUiIntJoint
// 0x0008 (0x0300 - 0x02F8)
class URCUiIntJoint final : public URCUiInteractIcon
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBusIcon();
	void SetDoorIcon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiIntJoint">();
	}
	static class URCUiIntJoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiIntJoint>();
	}
};
static_assert(alignof(URCUiIntJoint) == 0x000008, "Wrong alignment on URCUiIntJoint");
static_assert(sizeof(URCUiIntJoint) == 0x000300, "Wrong size on URCUiIntJoint");

// Class RC.RCSubtitleDataAsset
// 0x0050 (0x0080 - 0x0030)
class URCSubtitleDataAsset final : public URCCSVData
{
public:
	TMap<class FName, struct FRCSubtitleData>     DataMap;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSubtitleDataAsset">();
	}
	static class URCSubtitleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSubtitleDataAsset>();
	}
};
static_assert(alignof(URCSubtitleDataAsset) == 0x000008, "Wrong alignment on URCSubtitleDataAsset");
static_assert(sizeof(URCSubtitleDataAsset) == 0x000080, "Wrong size on URCSubtitleDataAsset");
static_assert(offsetof(URCSubtitleDataAsset, DataMap) == 0x000030, "Member 'URCSubtitleDataAsset::DataMap' has a wrong offset!");

// Class RC.RCAdvHUDInteractIconComponent
// 0x00C8 (0x0178 - 0x00B0)
class URCAdvHUDInteractIconComponent final : public UActorComponent
{
public:
	class ARCAdvHUD*                              HUD;                                               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInteractIconHiddenByTrace;                        // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InteractIconSafeArea;                              // 0x00DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              InteractIconSafeAreaUpperLeft;                     // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              InteractIconSafeAreaLowerRight;                    // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x14];                                      // 0x00F4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccessableWidgets1xDistance;                       // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x8];                                      // 0x010C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccessableWidgetsBasePriority;                     // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AccessableWidgetPriority;                          // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x24];                                     // 0x011C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastAccessedWidgetActor;                           // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastAccessedWidgetDelayCountFlag;                 // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAccessedWidgetDelayCount;                      // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Fake3DHiddenDistanceFromCamera;                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCAdvHUDAdvComponent*                  AdvComponent;                                      // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDTalkComponent*                 TalkComponent;                                     // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDResearchComponent*             ResearchComponent;                                 // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCAdvHUDMapComponent*                  MapComponent;                                      // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool GetPressedDecideButtonSimpleResult(ERCAdvHUDPressedDecideResult InResult);

	void AllAccessableWidgetsClose();
	void AllAccessableWidgetsOpen();
	bool CheckAccessableWidgetReady();
	bool CheckAccessedWidgetWait();
	bool CheckAllAccessableWidgetsClosed(bool bInContainClosing);
	bool CheckAllAccessableWidgetsOpened();
	class ARCCharacterRender* GetAccessedCharacter();
	class ARCCheckActor* GetAccessedCheckActor();
	class ARCPawnRender* GetAccessedNPC();
	ERCAdvHUDPressedDecideResult PressedDecideButton();
	bool PressedDecideButtonSimple();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDInteractIconComponent">();
	}
	static class URCAdvHUDInteractIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDInteractIconComponent>();
	}
};
static_assert(alignof(URCAdvHUDInteractIconComponent) == 0x000008, "Wrong alignment on URCAdvHUDInteractIconComponent");
static_assert(sizeof(URCAdvHUDInteractIconComponent) == 0x000178, "Wrong size on URCAdvHUDInteractIconComponent");
static_assert(offsetof(URCAdvHUDInteractIconComponent, HUD) == 0x0000B0, "Member 'URCAdvHUDInteractIconComponent::HUD' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, bInteractIconHiddenByTrace) == 0x0000D8, "Member 'URCAdvHUDInteractIconComponent::bInteractIconHiddenByTrace' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, InteractIconSafeArea) == 0x0000DC, "Member 'URCAdvHUDInteractIconComponent::InteractIconSafeArea' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, InteractIconSafeAreaUpperLeft) == 0x0000E4, "Member 'URCAdvHUDInteractIconComponent::InteractIconSafeAreaUpperLeft' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, InteractIconSafeAreaLowerRight) == 0x0000EC, "Member 'URCAdvHUDInteractIconComponent::InteractIconSafeAreaLowerRight' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, AccessableWidgets1xDistance) == 0x000108, "Member 'URCAdvHUDInteractIconComponent::AccessableWidgets1xDistance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, AccessableWidgetsBasePriority) == 0x000114, "Member 'URCAdvHUDInteractIconComponent::AccessableWidgetsBasePriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, AccessableWidgetPriority) == 0x000118, "Member 'URCAdvHUDInteractIconComponent::AccessableWidgetPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, LastAccessedWidgetActor) == 0x000140, "Member 'URCAdvHUDInteractIconComponent::LastAccessedWidgetActor' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, bLastAccessedWidgetDelayCountFlag) == 0x000148, "Member 'URCAdvHUDInteractIconComponent::bLastAccessedWidgetDelayCountFlag' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, LastAccessedWidgetDelayCount) == 0x00014C, "Member 'URCAdvHUDInteractIconComponent::LastAccessedWidgetDelayCount' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, Fake3DHiddenDistanceFromCamera) == 0x000150, "Member 'URCAdvHUDInteractIconComponent::Fake3DHiddenDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, AdvComponent) == 0x000158, "Member 'URCAdvHUDInteractIconComponent::AdvComponent' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, TalkComponent) == 0x000160, "Member 'URCAdvHUDInteractIconComponent::TalkComponent' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, ResearchComponent) == 0x000168, "Member 'URCAdvHUDInteractIconComponent::ResearchComponent' has a wrong offset!");
static_assert(offsetof(URCAdvHUDInteractIconComponent, MapComponent) == 0x000170, "Member 'URCAdvHUDInteractIconComponent::MapComponent' has a wrong offset!");

// Class RC.RCParamAchievementData
// 0x0010 (0x0040 - 0x0030)
class URCParamAchievementData final : public URCCSVData
{
public:
	TArray<struct FRCParamAchievementTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamAchievementData">();
	}
	static class URCParamAchievementData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamAchievementData>();
	}
};
static_assert(alignof(URCParamAchievementData) == 0x000008, "Wrong alignment on URCParamAchievementData");
static_assert(sizeof(URCParamAchievementData) == 0x000040, "Wrong size on URCParamAchievementData");
static_assert(offsetof(URCParamAchievementData, Data) == 0x000030, "Member 'URCParamAchievementData::Data' has a wrong offset!");

// Class RC.RCUiMenuQuestDetail
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuQuestDetail : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestDetail">();
	}
	static class URCUiMenuQuestDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestDetail>();
	}
};
static_assert(alignof(URCUiMenuQuestDetail) == 0x000008, "Wrong alignment on URCUiMenuQuestDetail");
static_assert(sizeof(URCUiMenuQuestDetail) == 0x0002E8, "Wrong size on URCUiMenuQuestDetail");

// Class RC.RCAdvHUDMapComponent
// 0x0140 (0x0200 - 0x00C0)
class URCAdvHUDMapComponent final : public URCAdvHUDBaseComponent
{
public:
	bool                                          bAllowEditInstance;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMiniMapEnable;                                    // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMiniMapHiddenByOption;                            // 0x00C2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiMiniMap*                         MiniMap;                                           // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MiniMapLocationID;                                 // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MiniMapTextID;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocationEnable;                                   // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiLocation*                        Location;                                          // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationDisplayLocationID;                         // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationDisplayTextID;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationDisplayLastLocationID;                     // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocationDisplayLastTextID;                         // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeAreaEnable;                                 // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDChangeAreaWidgetSet>   ChangeAreaWidgetSets;                              // 0x0118(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDChangeAreaWidgetSet>   FreeChangeAreaWidgetSets;                          // 0x0128(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         ChangeAreaScale;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ChangeAreaTextPositionOffset;                      // 0x013C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChangeAreaMaxNum;                                  // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingChangeAreaNum;                                // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDChangeAreaData>        ChangeAreaDatas;                                   // 0x0150(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnterBuildingEnable;                              // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDEnterBuildingWidgetSet> EnterBuildingWidgetSets;                           // 0x0168(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDEnterBuildingWidgetSet> FreeEnterBuildingWidgetSets;                       // 0x0178(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         EnterBuildingScale;                                // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              EnterBuildingTextPositionOffset;                   // 0x018C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnterBuildingMaxNum;                               // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingEnterBuildingNum;                             // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDEnterBuildingData>     EnterBuildingDatas;                                // 0x01A0(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bBusStopEnable;                                    // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDEnterBuildingWidgetSet> BusStopWidgetSets;                                 // 0x01B8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDEnterBuildingWidgetSet> FreeBusStopWidgetSets;                             // 0x01C8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         BusStopScale;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BusStopTextPositionOffset;                         // 0x01DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BusStopMaxNum;                                     // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingBusStopNum;                                   // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDEnterBuildingData>     BusStopDatas;                                      // 0x01F0(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckBusStopEnable();
	bool CheckChangeAreaEnable();
	bool CheckEnterBuildingEnable();
	bool CheckLocationEnable();
	bool CheckLocationFinished();
	bool CheckLocationRunning();
	bool CheckLocationStarted(bool bInMiniMap, bool bInLocation);
	bool CheckMiniMapEnable();
	bool CheckMiniMapEnableScene();
	bool CheckMiniMapRunning();
	void FinishLocation();
	void GetBusStopData(int32 InIndex, bool* bOutSucceeded, struct FRCAdvHUDEnterBuildingData* OutBusStopData);
	int32 GetBusStopDataNum();
	void GetChangeAreaData(int32 InIndex, bool* bOutSucceeded, struct FRCAdvHUDChangeAreaData* OutChangeAreaData);
	int32 GetChangeAreaDataNum();
	class FName GetCurrentLocationDisplayLocationID();
	class FName GetCurrentLocationDisplayTextID();
	class FName GetCurrentLocationID();
	class FName GetCurrentLocationTextID();
	class FName GetCurrentMiniMapLocationID();
	class FName GetCurrentMiniMapTextID();
	void GetEnterBuildingData(int32 InIndex, bool* bOutSucceeded, struct FRCAdvHUDEnterBuildingData* OutEnterBuildingData);
	int32 GetEnterBuildingDataNum();
	bool IsBusStopVisible(class ARCCheckActor* InCheckActor);
	bool IsChangeAreaVisible(class ARCCheckActor* InCheckActor);
	bool IsEnterBuildingVisible(class ARCCheckActor* InCheckActor);
	bool LoadLocationDataName(class FName InLocationID, class FName InLocationTextID);
	bool SetBusStopData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInLooksLikeUsable, bool bInAccessable, float InScale);
	void SetBusStopEnable(bool bInEnable);
	bool SetChangeAreaData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInDrawText, float InScale);
	void SetChangeAreaEnable(bool bInEnable);
	bool SetEnterBuildingData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInAccessable, float InScale);
	void SetEnterBuildingEnable(bool bInEnable);
	bool SetLocationDisplayLocation(class FName InLocationID, class FName InLocationTextID);
	void SetLocationEnable(bool bInEnable);
	bool SetLocationName(class FName InLocationID, class FName InLocationTextID);
	void SetMiniMapEnable(bool bInEnable);
	bool SetMiniMapLocation(class FName InLocationID, class FName InLocationTextID);
	void StartLocation(bool bInMiniMap, bool bInLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDMapComponent">();
	}
	static class URCAdvHUDMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDMapComponent>();
	}
};
static_assert(alignof(URCAdvHUDMapComponent) == 0x000008, "Wrong alignment on URCAdvHUDMapComponent");
static_assert(sizeof(URCAdvHUDMapComponent) == 0x000200, "Wrong size on URCAdvHUDMapComponent");
static_assert(offsetof(URCAdvHUDMapComponent, bAllowEditInstance) == 0x0000C0, "Member 'URCAdvHUDMapComponent::bAllowEditInstance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bMiniMapEnable) == 0x0000C1, "Member 'URCAdvHUDMapComponent::bMiniMapEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bMiniMapHiddenByOption) == 0x0000C2, "Member 'URCAdvHUDMapComponent::bMiniMapHiddenByOption' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, MiniMap) == 0x0000C8, "Member 'URCAdvHUDMapComponent::MiniMap' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, MiniMapLocationID) == 0x0000D0, "Member 'URCAdvHUDMapComponent::MiniMapLocationID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, MiniMapTextID) == 0x0000D8, "Member 'URCAdvHUDMapComponent::MiniMapTextID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bLocationEnable) == 0x0000E0, "Member 'URCAdvHUDMapComponent::bLocationEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, Location) == 0x0000E8, "Member 'URCAdvHUDMapComponent::Location' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, LocationDisplayLocationID) == 0x0000F0, "Member 'URCAdvHUDMapComponent::LocationDisplayLocationID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, LocationDisplayTextID) == 0x0000F8, "Member 'URCAdvHUDMapComponent::LocationDisplayTextID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, LocationDisplayLastLocationID) == 0x000100, "Member 'URCAdvHUDMapComponent::LocationDisplayLastLocationID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, LocationDisplayLastTextID) == 0x000108, "Member 'URCAdvHUDMapComponent::LocationDisplayLastTextID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bChangeAreaEnable) == 0x000110, "Member 'URCAdvHUDMapComponent::bChangeAreaEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, ChangeAreaWidgetSets) == 0x000118, "Member 'URCAdvHUDMapComponent::ChangeAreaWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, FreeChangeAreaWidgetSets) == 0x000128, "Member 'URCAdvHUDMapComponent::FreeChangeAreaWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, ChangeAreaScale) == 0x000138, "Member 'URCAdvHUDMapComponent::ChangeAreaScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, ChangeAreaTextPositionOffset) == 0x00013C, "Member 'URCAdvHUDMapComponent::ChangeAreaTextPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, ChangeAreaMaxNum) == 0x000144, "Member 'URCAdvHUDMapComponent::ChangeAreaMaxNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, UsingChangeAreaNum) == 0x000148, "Member 'URCAdvHUDMapComponent::UsingChangeAreaNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, ChangeAreaDatas) == 0x000150, "Member 'URCAdvHUDMapComponent::ChangeAreaDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bEnterBuildingEnable) == 0x000160, "Member 'URCAdvHUDMapComponent::bEnterBuildingEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, EnterBuildingWidgetSets) == 0x000168, "Member 'URCAdvHUDMapComponent::EnterBuildingWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, FreeEnterBuildingWidgetSets) == 0x000178, "Member 'URCAdvHUDMapComponent::FreeEnterBuildingWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, EnterBuildingScale) == 0x000188, "Member 'URCAdvHUDMapComponent::EnterBuildingScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, EnterBuildingTextPositionOffset) == 0x00018C, "Member 'URCAdvHUDMapComponent::EnterBuildingTextPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, EnterBuildingMaxNum) == 0x000194, "Member 'URCAdvHUDMapComponent::EnterBuildingMaxNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, UsingEnterBuildingNum) == 0x000198, "Member 'URCAdvHUDMapComponent::UsingEnterBuildingNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, EnterBuildingDatas) == 0x0001A0, "Member 'URCAdvHUDMapComponent::EnterBuildingDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, bBusStopEnable) == 0x0001B0, "Member 'URCAdvHUDMapComponent::bBusStopEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, BusStopWidgetSets) == 0x0001B8, "Member 'URCAdvHUDMapComponent::BusStopWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, FreeBusStopWidgetSets) == 0x0001C8, "Member 'URCAdvHUDMapComponent::FreeBusStopWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, BusStopScale) == 0x0001D8, "Member 'URCAdvHUDMapComponent::BusStopScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, BusStopTextPositionOffset) == 0x0001DC, "Member 'URCAdvHUDMapComponent::BusStopTextPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, BusStopMaxNum) == 0x0001E4, "Member 'URCAdvHUDMapComponent::BusStopMaxNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, UsingBusStopNum) == 0x0001E8, "Member 'URCAdvHUDMapComponent::UsingBusStopNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDMapComponent, BusStopDatas) == 0x0001F0, "Member 'URCAdvHUDMapComponent::BusStopDatas' has a wrong offset!");

// Class RC.RCOnlineStoreBFL
// 0x0000 (0x0028 - 0x0028)
class URCOnlineStoreBFL final : public UBlueprintFunctionLibrary
{
public:
	static void CheckInstallContents();
	static void OpenStore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOnlineStoreBFL">();
	}
	static class URCOnlineStoreBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOnlineStoreBFL>();
	}
};
static_assert(alignof(URCOnlineStoreBFL) == 0x000008, "Wrong alignment on URCOnlineStoreBFL");
static_assert(sizeof(URCOnlineStoreBFL) == 0x000028, "Wrong size on URCOnlineStoreBFL");

// Class RC.RCAdvHUDPauseComponent
// 0x0020 (0x00E0 - 0x00C0)
class URCAdvHUDPauseComponent final : public URCAdvHUDBaseComponent
{
public:
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAdvHUDPauseComponentStatus                 Status;                                            // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseEnable;                                      // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerPauseMoveTest;                              // 0x00C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMenuEnable;                                       // 0x00C7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBacklogEnable;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCGameMenuDirectAccessType                   MenyType;                                          // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseSkipEnable;                                  // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PauseDisableCount;                                 // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCUiPauseScreen*                       PauseScreenWidget;                                 // 0x00D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDPauseComponent">();
	}
	static class URCAdvHUDPauseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDPauseComponent>();
	}
};
static_assert(alignof(URCAdvHUDPauseComponent) == 0x000008, "Wrong alignment on URCAdvHUDPauseComponent");
static_assert(sizeof(URCAdvHUDPauseComponent) == 0x0000E0, "Wrong size on URCAdvHUDPauseComponent");
static_assert(offsetof(URCAdvHUDPauseComponent, Status) == 0x0000C4, "Member 'URCAdvHUDPauseComponent::Status' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, bPauseEnable) == 0x0000C5, "Member 'URCAdvHUDPauseComponent::bPauseEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, bPlayerPauseMoveTest) == 0x0000C6, "Member 'URCAdvHUDPauseComponent::bPlayerPauseMoveTest' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, bMenuEnable) == 0x0000C7, "Member 'URCAdvHUDPauseComponent::bMenuEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, bBacklogEnable) == 0x0000C8, "Member 'URCAdvHUDPauseComponent::bBacklogEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, MenyType) == 0x0000C9, "Member 'URCAdvHUDPauseComponent::MenyType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, bPauseSkipEnable) == 0x0000CA, "Member 'URCAdvHUDPauseComponent::bPauseSkipEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, PauseDisableCount) == 0x0000CC, "Member 'URCAdvHUDPauseComponent::PauseDisableCount' has a wrong offset!");
static_assert(offsetof(URCAdvHUDPauseComponent, PauseScreenWidget) == 0x0000D0, "Member 'URCAdvHUDPauseComponent::PauseScreenWidget' has a wrong offset!");

// Class RC.RCUiMenuSkillSelectButton
// 0x0030 (0x0350 - 0x0320)
class URCUiMenuSkillSelectButton final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect;                                      // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillSelectButton">();
	}
	static class URCUiMenuSkillSelectButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillSelectButton>();
	}
};
static_assert(alignof(URCUiMenuSkillSelectButton) == 0x000008, "Wrong alignment on URCUiMenuSkillSelectButton");
static_assert(sizeof(URCUiMenuSkillSelectButton) == 0x000350, "Wrong size on URCUiMenuSkillSelectButton");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_Def) == 0x000320, "Member 'URCUiMenuSkillSelectButton::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_OnCursor) == 0x000328, "Member 'URCUiMenuSkillSelectButton::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_OutCursor) == 0x000330, "Member 'URCUiMenuSkillSelectButton::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_Push) == 0x000338, "Member 'URCUiMenuSkillSelectButton::AN_Push' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_NotSelect) == 0x000340, "Member 'URCUiMenuSkillSelectButton::AN_NotSelect' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelectButton, AN_Off) == 0x000348, "Member 'URCUiMenuSkillSelectButton::AN_Off' has a wrong offset!");

// Class RC.RCAdvHUDResearchComponent
// 0x05B0 (0x0670 - 0x00C0)
class URCAdvHUDResearchComponent final : public URCAdvHUDBaseComponent
{
public:
	bool                                          bAllowEditInstance;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNazo;                                             // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDResearchModeState                    State;                                             // 0x00C2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDResearchModeState                    OldState;                                          // 0x00C3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x44];                                      // 0x00C4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCAdvHUDResearchDetailStartData       ResearchDetailStartData;                           // 0x0108(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FRCAdvHUDResearchDetailData            ResearchDetailData;                                // 0x0128(0x0078)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	ERCAdvHUDResearchDetailType                   ResearchDetailType;                                // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDResearchDetailType                   ResearchDetailOldType;                             // 0x01A1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResearchDetailDebugDrawMarker;                    // 0x01A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResearchDetailInputEnable;                        // 0x01A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResearchDetailInputRange;                          // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResearchDetailDebugDrawInputLength;                // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowLocation;                                     // 0x01AC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0xAB];                                     // 0x01AD(0x00AB)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartTelopPriority;                                // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaTelop*                     StartTelopWidget;                                  // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0xA8];                                     // 0x0268(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FinishTelopPriority;                               // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaTelop*                     FinishTelopWidget;                                 // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpotSelectStartTelopPriority;                      // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaSpotSelectTelop*           SpotSelectStartTelopWidget;                        // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpotJudgePriority;                                 // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaTelopSpotJudge*            SpotJudgeWidget;                                   // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0xA8];                                     // 0x0340(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GetKagiPriority;                                   // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaGetKagi*                   GetKagiWidget;                                     // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerEnable;                                     // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDResearchMarkerWidgetSet> MarkerWidgetSets;                                  // 0x0400(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDResearchMarkerWidgetSet> FreeMarkerWidgetSets;                              // 0x0410(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bMarker3D;                                         // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Marker3DScale;                                     // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerScale;                                       // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerHiddenByTrace;                              // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAccessableMarkerHiddenByTrace;                    // 0x042D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42E[0x2];                                      // 0x042E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MarkerMaxNum;                                      // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingMarkerNum;                                    // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDResearchMarkerData>    MarkerDatas;                                       // 0x0438(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bMarkerName2Test;                                  // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerNameMoveDebugDraw;                          // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MarkerNameDefaultPosition;                         // 0x044C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerNameBasePositionCamera;                     // 0x0454(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarkerNameBasePositionOffset;                      // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerNameMoveDistanceZUp;                         // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerNameMoveDistanceZDown;                       // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerMoveLocationZUp;                             // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerMoveLocationZDown;                           // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveArea;                             // 0x046C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveArea2;                            // 0x0474(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveAreaUpperLeft;                    // 0x047C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveAreaLowerRight;                   // 0x0484(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveArea2UpperLeft;                   // 0x048C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameNotMoveArea2LowerRight;                  // 0x0494(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameMoveFitArea;                             // 0x049C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameMoveFitAreaUpperLeft;                    // 0x04A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameMoveFitAreaLowerRight;                   // 0x04AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerNameAvoidCircleRudius;                       // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerNameSizeOffset;                              // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerNameMoveSpeed;                               // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerNameMoveSimple;                             // 0x04C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMarkerNameMoveSimpleFixedDistance;                // 0x04C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C6[0x2];                                      // 0x04C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarkerNameMoveSimpleFixedDistanceUp;               // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkerNameMoveSimpleFixedDistanceDown;             // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0xA8];                                     // 0x04D0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAdvHUDWidgetState                          PointerState;                                      // 0x0578(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          PointerOldState;                                   // 0x0579(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        PointerRequest;                                    // 0x057A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57B[0x1];                                      // 0x057B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PointerPriority;                                   // 0x057C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiChousaPointer*                   PointerWidget;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCAdvHUDResearchPointer_MouseControlData PointerMouseControlData;                           // 0x0588(0x009C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            SoftwareCursor;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            BufferCursor;                                      // 0x0630(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_638[0x10];                                     // 0x0638(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaFPSCameraLimit*            FPSCameraLimitWidget;                              // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FPSCameraLimitPriority;                            // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuestionTextPriority;                              // 0x0654(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiChousaQuestionText*              QuestionTextWidget;                                // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EndButtonGuidePriority;                            // 0x0660(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_664[0x4];                                      // 0x0664(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiChousaEndButtonGuide*            EndButtonGuideWidget;                              // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool FinishTelopCheckFinished();
	bool FinishTelopStart();
	bool GetKagiCheckFinished();
	bool GetKagiSetData_Debug(class FName InKagiImage, const class FString& InKagiName, const class FString& InKagiCaption);
	bool GetKagiSetDataFromKagiID(class FName InKagiID, int32 InPhase);
	bool GetKagiStart();
	void GetMarkerData(int32 InIndex, bool* bOutSucceeded, struct FRCAdvHUDResearchMarkerData* OutMarkerData);
	int32 GetMarkerDataNum();
	ERCAdvHUDResearchModeState GetResearchModeOldState();
	ERCAdvHUDResearchModeState GetResearchModeState();
	bool IsMarkerVisible(class ARCCheckActor* InCheckActor);
	bool LocationCheckFinished();
	bool LocationFinish();
	bool LocationStart(class FName InLocationID, class FName InLocationTextID);
	void OnChangeInputPlatform(ERCInputPlatform InInputPlatform);
	void OnMenuCloseMouseSettings();
	void OnMenuOpenMouseSettings();
	bool ResearchDetailAutoSelectCheckActorMoveStart(class ARCCheckActor* InCheckActor);
	bool ResearchDetailAutoSelectMoveStart(int32 InMarkerDataIndex);
	bool ResearchDetailCheck();
	bool ResearchDetailCheckAutoSelectMoveFinished();
	bool ResearchDetailFinish();
	int32 ResearchDetailGetAccessedIndex();
	int32 ResearchDetailGetSelectIndex();
	ERCAdvHUDResearchDetailType ResearchDetailGetType();
	bool ResearchDetailStart(const struct FRCAdvHUDResearchDetailStartData& InStartData, ERCAdvHUDResearchDetailType InType);
	bool ResearchFinish();
	bool ResearchStart(bool bInShowLocation, bool bInEnableFinish, bool bInMiniMap);
	bool ResearchStartWithQuestionText(class FName InQuestionTextID, bool bInEnableFinish, bool bInMiniMap);
	bool SetMarkerData(class ARCCheckActor* InCheckActor, class FName InTextID, bool bInDraw, bool bInNameDraw, bool bInResearched, bool bInAccessable, float InScale);
	void SetMarkerEnable(bool bInEnable);
	bool SpotJudgeTelopCorrectStart();
	bool SpotJudgeTelopMistakeStart();
	bool SpotSelectStartTelopCheckFinished();
	bool SpotSelectStartTelopStart();
	bool StartTelopCheckFinished();
	bool StartTelopStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDResearchComponent">();
	}
	static class URCAdvHUDResearchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDResearchComponent>();
	}
};
static_assert(alignof(URCAdvHUDResearchComponent) == 0x000008, "Wrong alignment on URCAdvHUDResearchComponent");
static_assert(sizeof(URCAdvHUDResearchComponent) == 0x000670, "Wrong size on URCAdvHUDResearchComponent");
static_assert(offsetof(URCAdvHUDResearchComponent, bAllowEditInstance) == 0x0000C0, "Member 'URCAdvHUDResearchComponent::bAllowEditInstance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bNazo) == 0x0000C1, "Member 'URCAdvHUDResearchComponent::bNazo' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, State) == 0x0000C2, "Member 'URCAdvHUDResearchComponent::State' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, OldState) == 0x0000C3, "Member 'URCAdvHUDResearchComponent::OldState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailStartData) == 0x000108, "Member 'URCAdvHUDResearchComponent::ResearchDetailStartData' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailData) == 0x000128, "Member 'URCAdvHUDResearchComponent::ResearchDetailData' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailType) == 0x0001A0, "Member 'URCAdvHUDResearchComponent::ResearchDetailType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailOldType) == 0x0001A1, "Member 'URCAdvHUDResearchComponent::ResearchDetailOldType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bResearchDetailDebugDrawMarker) == 0x0001A2, "Member 'URCAdvHUDResearchComponent::bResearchDetailDebugDrawMarker' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bResearchDetailInputEnable) == 0x0001A3, "Member 'URCAdvHUDResearchComponent::bResearchDetailInputEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailInputRange) == 0x0001A4, "Member 'URCAdvHUDResearchComponent::ResearchDetailInputRange' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, ResearchDetailDebugDrawInputLength) == 0x0001A8, "Member 'URCAdvHUDResearchComponent::ResearchDetailDebugDrawInputLength' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bShowLocation) == 0x0001AC, "Member 'URCAdvHUDResearchComponent::bShowLocation' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, StartTelopPriority) == 0x000258, "Member 'URCAdvHUDResearchComponent::StartTelopPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, StartTelopWidget) == 0x000260, "Member 'URCAdvHUDResearchComponent::StartTelopWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, FinishTelopPriority) == 0x000310, "Member 'URCAdvHUDResearchComponent::FinishTelopPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, FinishTelopWidget) == 0x000318, "Member 'URCAdvHUDResearchComponent::FinishTelopWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, SpotSelectStartTelopPriority) == 0x000320, "Member 'URCAdvHUDResearchComponent::SpotSelectStartTelopPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, SpotSelectStartTelopWidget) == 0x000328, "Member 'URCAdvHUDResearchComponent::SpotSelectStartTelopWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, SpotJudgePriority) == 0x000330, "Member 'URCAdvHUDResearchComponent::SpotJudgePriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, SpotJudgeWidget) == 0x000338, "Member 'URCAdvHUDResearchComponent::SpotJudgeWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, GetKagiPriority) == 0x0003E8, "Member 'URCAdvHUDResearchComponent::GetKagiPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, GetKagiWidget) == 0x0003F0, "Member 'URCAdvHUDResearchComponent::GetKagiWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerEnable) == 0x0003F8, "Member 'URCAdvHUDResearchComponent::bMarkerEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerWidgetSets) == 0x000400, "Member 'URCAdvHUDResearchComponent::MarkerWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, FreeMarkerWidgetSets) == 0x000410, "Member 'URCAdvHUDResearchComponent::FreeMarkerWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarker3D) == 0x000420, "Member 'URCAdvHUDResearchComponent::bMarker3D' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, Marker3DScale) == 0x000424, "Member 'URCAdvHUDResearchComponent::Marker3DScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerScale) == 0x000428, "Member 'URCAdvHUDResearchComponent::MarkerScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerHiddenByTrace) == 0x00042C, "Member 'URCAdvHUDResearchComponent::bMarkerHiddenByTrace' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bAccessableMarkerHiddenByTrace) == 0x00042D, "Member 'URCAdvHUDResearchComponent::bAccessableMarkerHiddenByTrace' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerMaxNum) == 0x000430, "Member 'URCAdvHUDResearchComponent::MarkerMaxNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, UsingMarkerNum) == 0x000434, "Member 'URCAdvHUDResearchComponent::UsingMarkerNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerDatas) == 0x000438, "Member 'URCAdvHUDResearchComponent::MarkerDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerName2Test) == 0x000448, "Member 'URCAdvHUDResearchComponent::bMarkerName2Test' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerNameMoveDebugDraw) == 0x000449, "Member 'URCAdvHUDResearchComponent::bMarkerNameMoveDebugDraw' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameDefaultPosition) == 0x00044C, "Member 'URCAdvHUDResearchComponent::MarkerNameDefaultPosition' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerNameBasePositionCamera) == 0x000454, "Member 'URCAdvHUDResearchComponent::bMarkerNameBasePositionCamera' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameBasePositionOffset) == 0x000458, "Member 'URCAdvHUDResearchComponent::MarkerNameBasePositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveDistanceZUp) == 0x00045C, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveDistanceZUp' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveDistanceZDown) == 0x000460, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveDistanceZDown' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerMoveLocationZUp) == 0x000464, "Member 'URCAdvHUDResearchComponent::MarkerMoveLocationZUp' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerMoveLocationZDown) == 0x000468, "Member 'URCAdvHUDResearchComponent::MarkerMoveLocationZDown' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveArea) == 0x00046C, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveArea' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveArea2) == 0x000474, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveArea2' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveAreaUpperLeft) == 0x00047C, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveAreaUpperLeft' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveAreaLowerRight) == 0x000484, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveAreaLowerRight' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveArea2UpperLeft) == 0x00048C, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveArea2UpperLeft' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameNotMoveArea2LowerRight) == 0x000494, "Member 'URCAdvHUDResearchComponent::MarkerNameNotMoveArea2LowerRight' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveFitArea) == 0x00049C, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveFitArea' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveFitAreaUpperLeft) == 0x0004A4, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveFitAreaUpperLeft' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveFitAreaLowerRight) == 0x0004AC, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveFitAreaLowerRight' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameAvoidCircleRudius) == 0x0004B4, "Member 'URCAdvHUDResearchComponent::MarkerNameAvoidCircleRudius' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameSizeOffset) == 0x0004B8, "Member 'URCAdvHUDResearchComponent::MarkerNameSizeOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveSpeed) == 0x0004C0, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveSpeed' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerNameMoveSimple) == 0x0004C4, "Member 'URCAdvHUDResearchComponent::bMarkerNameMoveSimple' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, bMarkerNameMoveSimpleFixedDistance) == 0x0004C5, "Member 'URCAdvHUDResearchComponent::bMarkerNameMoveSimpleFixedDistance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveSimpleFixedDistanceUp) == 0x0004C8, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveSimpleFixedDistanceUp' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, MarkerNameMoveSimpleFixedDistanceDown) == 0x0004CC, "Member 'URCAdvHUDResearchComponent::MarkerNameMoveSimpleFixedDistanceDown' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerState) == 0x000578, "Member 'URCAdvHUDResearchComponent::PointerState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerOldState) == 0x000579, "Member 'URCAdvHUDResearchComponent::PointerOldState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerRequest) == 0x00057A, "Member 'URCAdvHUDResearchComponent::PointerRequest' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerPriority) == 0x00057C, "Member 'URCAdvHUDResearchComponent::PointerPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerWidget) == 0x000580, "Member 'URCAdvHUDResearchComponent::PointerWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, PointerMouseControlData) == 0x000588, "Member 'URCAdvHUDResearchComponent::PointerMouseControlData' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, SoftwareCursor) == 0x000628, "Member 'URCAdvHUDResearchComponent::SoftwareCursor' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, BufferCursor) == 0x000630, "Member 'URCAdvHUDResearchComponent::BufferCursor' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, FPSCameraLimitWidget) == 0x000648, "Member 'URCAdvHUDResearchComponent::FPSCameraLimitWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, FPSCameraLimitPriority) == 0x000650, "Member 'URCAdvHUDResearchComponent::FPSCameraLimitPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, QuestionTextPriority) == 0x000654, "Member 'URCAdvHUDResearchComponent::QuestionTextPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, QuestionTextWidget) == 0x000658, "Member 'URCAdvHUDResearchComponent::QuestionTextWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, EndButtonGuidePriority) == 0x000660, "Member 'URCAdvHUDResearchComponent::EndButtonGuidePriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDResearchComponent, EndButtonGuideWidget) == 0x000668, "Member 'URCAdvHUDResearchComponent::EndButtonGuideWidget' has a wrong offset!");

// Class RC.RCAdvHUDTalkComponent
// 0x01F0 (0x02B0 - 0x00C0)
class URCAdvHUDTalkComponent final : public URCAdvHUDBaseComponent
{
public:
	bool                                          bAllowEditInstance;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x1F];                                      // 0x00C1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBalloonEnable;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDBalloonWidgetSet>      BalloonWidgetSets;                                 // 0x00E8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDBalloonWidgetSet>      FreeBalloonWidgetSets;                             // 0x00F8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         BalloonNearScale;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBalloonFar3D;                                     // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Balloon3DScale;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BalloonFarScale;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBalloonFarHiddenByTrace;                          // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BalloonNumMax;                                     // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingBalloonNum;                                   // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAdvHUDBalloonData>           BalloonDatas;                                      // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bTalkIconEnable;                                   // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCUiIntTalk*>                   TalkIconWidgets;                                   // 0x0140(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<class URCUiIntTalk*>                   FreeTalkIconWidgets;                               // 0x0150(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         TalkIconScale;                                     // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TalkIconSubquestScale;                             // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TalkIconSubquestPositionOffset;                    // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TalkIconNumMax;                                    // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UsingTalkIconNum;                                  // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDTalkIconData>          TalkIconDatas;                                     // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCAdvHUDTalkIconData>          NewTalkIconDatas;                                  // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        TalkRequest;                                       // 0x0198(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDTalkWindowType                       TalkRequestWindowType;                             // 0x0199(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDTalkWindowType                       TalkWindowType;                                    // 0x019A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19B[0x1];                                      // 0x019B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkTextID;                                        // 0x019C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkVoiceID;                                       // 0x01A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTalkSkipTyping;                                   // 0x01AC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                TalkFacial2D3DMap;                                 // 0x01B0(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          TalkWindowState;                                   // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          TalkWindowOldState;                                // 0x0201(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202[0x2];                                      // 0x0202(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TalkWindowPriority;                                // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageWindow*                   MessageWindow;                                     // 0x0208(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCCharacterRender*                     ShinigamiActor;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          ShinigamiBalloonState;                             // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          ShinigamiBalloonOldState;                          // 0x0219(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShinigamiBalloonOutside;                          // 0x021A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21B[0x1];                                      // 0x021B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShinigamiBalloonPriority;                          // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiShinigamiBalloon*                ShinigamiBalloonWidget;                            // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SequentialTalkID;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCTalkData                            SequentialTalkData;                                // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkForceAutoPlay;                      // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalk;                                   // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SequentialTalkIndex;                               // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SequentialTalkTimerHandle;                         // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkDelayToNext;                        // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkWaitCmd;                            // 0x0259(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkRequestSuspend;                     // 0x025A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkSuspending;                         // 0x025B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSequentialTalkRestart;                            // 0x025C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          SelectWindowState;                                 // 0x025D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        SelectRequest;                                     // 0x025E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F[0x1];                                      // 0x025F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectRequestNum;                                  // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SelectRequestQuestionTextID;                       // 0x0264(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCReHUDSelectData>             SelectDataArray;                                   // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bSelectStartAllWidgetHiddenEnable;                 // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiSelectWindow*                    SelectWindow;                                      // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpSelect;                                         // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDSpSelectType                         SpSelectType;                                      // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292[0x2];                                      // 0x0292(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpSelectWBPPath_EyeTracking;                       // 0x0294(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpSelectLoadingWBPPath;                            // 0x029C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWBPLoadState                         SpSelectWBPLoadState;                              // 0x02A4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiSelectWindow*                    SpSelectWindow;                                    // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckSelectFinished();
	bool CheckSelectStarted();
	bool CheckSelectWindow();
	bool CheckSequentialTalk();
	bool CheckSequentialTalkCloseAtAllEnd();
	bool CheckSequentialTalkFinished();
	bool CheckSequentialTalkFinishedLastText();
	bool CheckSequentialTalkFromTalkID(class FName InTalkID);
	bool CheckSequentialTalkSuspending();
	bool CheckTalkEndText();
	bool CheckTalkFinished();
	bool CheckTalkSkipVoice(class FName InTextID);
	bool CheckTalkStarted();
	bool CheckTalkWindow();
	bool CheckTalkWindowClosed(ERCAdvHUDTalkWindowType InWindowType);
	bool GetBalloonData(int32 InIndex, struct FRCAdvHUDBalloonData* OutBalloonData);
	int32 GetBalloonDataNum();
	int32 GetSelectedIndex();
	int32 GetSelectIndex();
	ERCAdvHUDWidgetState GetSelectWindowState();
	int32 GetSequentialTalkVoiceCharacterID();
	bool GetTalkIconData(int32 InIndex, struct FRCAdvHUDTalkIconData* OutTalkIconData);
	int32 GetTalkIconDataNum();
	ERCAdvHUDWidgetState GetUsingTalkWidgetOldState();
	ERCAdvHUDWidgetState GetUsingTalkWidgetState();
	bool IsBalloonVisible(class APawn* InPawn);
	bool IsTalkIconVisible(class APawn* InPawn);
	bool SelectFinish();
	bool SelectSetData(int32 InIndex, class FName InTextID, bool InbCheckMark);
	bool SelectStart(int32 InSelectNum, class FName InQuestionTextID);
	bool SelectStartWithDataArray(const TArray<struct FRCReHUDSelectData>& InSelectDataArray, class FName InQuestionTextID);
	bool SequentialTalkFinish();
	bool SequentialTalkRequestSuspend();
	bool SequentialTalkRestart();
	bool SequentialTalkResume();
	bool SequentialTalkStart2(class FName InTalkID, const struct FRCTalkData& InTalkData, bool bInForceAutoPlay);
	bool SequentialTalkStartFromData2(const struct FRCTalkData& InTalkData, bool bInForceAutoPlay);
	bool SequentialTalkStartFromDataTable(class UDataTable* InTable, class FName InTalkID, bool bInForceAutoPlay);
	bool SequentialTalkStartFromTalkID(class FName InTalkID, bool bInForceAutoPlay);
	bool SetBalloonData(class APawn* InPawn, ESCBaloonFrame InBalloonFrameType, ESCBaloonType InBalloonContentType, class FName InTextID, bool bInBalloonDraw, bool bInTextDraw);
	void SetShinigamiActor(class ARCCharacterRender* InShinigamiActor);
	bool SetTalkIconData(class APawn* InPawn, bool bInDraw, bool bInAccessable, bool bInSubquest, float InScale, bool bInGoal);
	bool SpSelect_CheckLoadWBPCompleted(ERCAdvHUDSpSelectType SpSelectType_0);
	bool SpSelect_ReleaseWBP(ERCAdvHUDSpSelectType SpSelectType_0);
	bool SpSelect_StartLoadWBP(ERCAdvHUDSpSelectType SpSelectType_0);
	bool SpSelect_StartWithDataArray(ERCAdvHUDSpSelectType SpSelectType_0, const TArray<struct FRCReHUDSelectData>& SelectDataArray_0, class FName QuestionTextID);
	bool TalkFinish();
	bool TalkLoadCharacterData(int32 InCharacterNameID, int32 InCharacterNameSubID, int32 InCharacterFaceID, int32 InCharacterFacialID);
	bool TalkLoadCharacterData2(int32 InCharacterNameID, const TArray<int32>& InCharacterNameSubIDs, int32 InCharacterFaceID, const TArray<int32>& InCharacterFacialIDs);
	bool TalkLoadFaceData(int32 InCharacterFaceID, int32 InCharacterFacialID);
	bool TalkLoadNameplateData(int32 InCharacterNameID, int32 InCharacterNameSubID);
	bool TalkSetAuto(bool bInAutoPlay);
	bool TalkSetForceTextSpeedSettings(bool bInIsForceTextSpeed, int32 InForceTextSpeed);
	bool TalkSetGradationFilter(class FName InFilterID);
	bool TalkSetText2(int32 InCharacterFaceID, int32 InCharacterFacialID, class FName InTextID, int32 InCharacter3DID, class FName InCharacter3DFacialID, class FName InVoiceID, float InDelayAtEndText);
	bool TalkSetTextData(const struct FRCAdvHUDTalkTextData& InTextData);
	bool TalkSetTextSimple(class FName InTextID, float InDelayAtEndText);
	bool TalkStart2(ERCAdvHUDTalkWindowType InWindowType, class FName InTextID, int32 InCharacterFaceID, int32 InCharacterFacialID, bool bInAutoPlay);
	bool TalkStartSimple(ERCAdvHUDTalkWindowType InWindowType);
	bool TalkWindowClose(ERCAdvHUDTalkWindowType InWindowType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAdvHUDTalkComponent">();
	}
	static class URCAdvHUDTalkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAdvHUDTalkComponent>();
	}
};
static_assert(alignof(URCAdvHUDTalkComponent) == 0x000008, "Wrong alignment on URCAdvHUDTalkComponent");
static_assert(sizeof(URCAdvHUDTalkComponent) == 0x0002B0, "Wrong size on URCAdvHUDTalkComponent");
static_assert(offsetof(URCAdvHUDTalkComponent, bAllowEditInstance) == 0x0000C0, "Member 'URCAdvHUDTalkComponent::bAllowEditInstance' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bBalloonEnable) == 0x0000E0, "Member 'URCAdvHUDTalkComponent::bBalloonEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, BalloonWidgetSets) == 0x0000E8, "Member 'URCAdvHUDTalkComponent::BalloonWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, FreeBalloonWidgetSets) == 0x0000F8, "Member 'URCAdvHUDTalkComponent::FreeBalloonWidgetSets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, BalloonNearScale) == 0x000108, "Member 'URCAdvHUDTalkComponent::BalloonNearScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bBalloonFar3D) == 0x00010C, "Member 'URCAdvHUDTalkComponent::bBalloonFar3D' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, Balloon3DScale) == 0x000110, "Member 'URCAdvHUDTalkComponent::Balloon3DScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, BalloonFarScale) == 0x000114, "Member 'URCAdvHUDTalkComponent::BalloonFarScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bBalloonFarHiddenByTrace) == 0x000118, "Member 'URCAdvHUDTalkComponent::bBalloonFarHiddenByTrace' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, BalloonNumMax) == 0x00011C, "Member 'URCAdvHUDTalkComponent::BalloonNumMax' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, UsingBalloonNum) == 0x000120, "Member 'URCAdvHUDTalkComponent::UsingBalloonNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, BalloonDatas) == 0x000128, "Member 'URCAdvHUDTalkComponent::BalloonDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bTalkIconEnable) == 0x000138, "Member 'URCAdvHUDTalkComponent::bTalkIconEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconWidgets) == 0x000140, "Member 'URCAdvHUDTalkComponent::TalkIconWidgets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, FreeTalkIconWidgets) == 0x000150, "Member 'URCAdvHUDTalkComponent::FreeTalkIconWidgets' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconScale) == 0x000160, "Member 'URCAdvHUDTalkComponent::TalkIconScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconSubquestScale) == 0x000164, "Member 'URCAdvHUDTalkComponent::TalkIconSubquestScale' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconSubquestPositionOffset) == 0x000168, "Member 'URCAdvHUDTalkComponent::TalkIconSubquestPositionOffset' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconNumMax) == 0x000170, "Member 'URCAdvHUDTalkComponent::TalkIconNumMax' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, UsingTalkIconNum) == 0x000174, "Member 'URCAdvHUDTalkComponent::UsingTalkIconNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkIconDatas) == 0x000178, "Member 'URCAdvHUDTalkComponent::TalkIconDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, NewTalkIconDatas) == 0x000188, "Member 'URCAdvHUDTalkComponent::NewTalkIconDatas' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkRequest) == 0x000198, "Member 'URCAdvHUDTalkComponent::TalkRequest' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkRequestWindowType) == 0x000199, "Member 'URCAdvHUDTalkComponent::TalkRequestWindowType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkWindowType) == 0x00019A, "Member 'URCAdvHUDTalkComponent::TalkWindowType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkTextID) == 0x00019C, "Member 'URCAdvHUDTalkComponent::TalkTextID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkVoiceID) == 0x0001A4, "Member 'URCAdvHUDTalkComponent::TalkVoiceID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bTalkSkipTyping) == 0x0001AC, "Member 'URCAdvHUDTalkComponent::bTalkSkipTyping' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkFacial2D3DMap) == 0x0001B0, "Member 'URCAdvHUDTalkComponent::TalkFacial2D3DMap' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkWindowState) == 0x000200, "Member 'URCAdvHUDTalkComponent::TalkWindowState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkWindowOldState) == 0x000201, "Member 'URCAdvHUDTalkComponent::TalkWindowOldState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, TalkWindowPriority) == 0x000204, "Member 'URCAdvHUDTalkComponent::TalkWindowPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, MessageWindow) == 0x000208, "Member 'URCAdvHUDTalkComponent::MessageWindow' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, ShinigamiActor) == 0x000210, "Member 'URCAdvHUDTalkComponent::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, ShinigamiBalloonState) == 0x000218, "Member 'URCAdvHUDTalkComponent::ShinigamiBalloonState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, ShinigamiBalloonOldState) == 0x000219, "Member 'URCAdvHUDTalkComponent::ShinigamiBalloonOldState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bShinigamiBalloonOutside) == 0x00021A, "Member 'URCAdvHUDTalkComponent::bShinigamiBalloonOutside' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, ShinigamiBalloonPriority) == 0x00021C, "Member 'URCAdvHUDTalkComponent::ShinigamiBalloonPriority' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, ShinigamiBalloonWidget) == 0x000220, "Member 'URCAdvHUDTalkComponent::ShinigamiBalloonWidget' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SequentialTalkID) == 0x000228, "Member 'URCAdvHUDTalkComponent::SequentialTalkID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SequentialTalkData) == 0x000230, "Member 'URCAdvHUDTalkComponent::SequentialTalkData' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkForceAutoPlay) == 0x000248, "Member 'URCAdvHUDTalkComponent::bSequentialTalkForceAutoPlay' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalk) == 0x000249, "Member 'URCAdvHUDTalkComponent::bSequentialTalk' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SequentialTalkIndex) == 0x00024C, "Member 'URCAdvHUDTalkComponent::SequentialTalkIndex' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SequentialTalkTimerHandle) == 0x000250, "Member 'URCAdvHUDTalkComponent::SequentialTalkTimerHandle' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkDelayToNext) == 0x000258, "Member 'URCAdvHUDTalkComponent::bSequentialTalkDelayToNext' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkWaitCmd) == 0x000259, "Member 'URCAdvHUDTalkComponent::bSequentialTalkWaitCmd' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkRequestSuspend) == 0x00025A, "Member 'URCAdvHUDTalkComponent::bSequentialTalkRequestSuspend' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkSuspending) == 0x00025B, "Member 'URCAdvHUDTalkComponent::bSequentialTalkSuspending' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSequentialTalkRestart) == 0x00025C, "Member 'URCAdvHUDTalkComponent::bSequentialTalkRestart' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectWindowState) == 0x00025D, "Member 'URCAdvHUDTalkComponent::SelectWindowState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectRequest) == 0x00025E, "Member 'URCAdvHUDTalkComponent::SelectRequest' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectRequestNum) == 0x000260, "Member 'URCAdvHUDTalkComponent::SelectRequestNum' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectRequestQuestionTextID) == 0x000264, "Member 'URCAdvHUDTalkComponent::SelectRequestQuestionTextID' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectDataArray) == 0x000270, "Member 'URCAdvHUDTalkComponent::SelectDataArray' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSelectStartAllWidgetHiddenEnable) == 0x000280, "Member 'URCAdvHUDTalkComponent::bSelectStartAllWidgetHiddenEnable' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SelectWindow) == 0x000288, "Member 'URCAdvHUDTalkComponent::SelectWindow' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, bSpSelect) == 0x000290, "Member 'URCAdvHUDTalkComponent::bSpSelect' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SpSelectType) == 0x000291, "Member 'URCAdvHUDTalkComponent::SpSelectType' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SpSelectWBPPath_EyeTracking) == 0x000294, "Member 'URCAdvHUDTalkComponent::SpSelectWBPPath_EyeTracking' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SpSelectLoadingWBPPath) == 0x00029C, "Member 'URCAdvHUDTalkComponent::SpSelectLoadingWBPPath' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SpSelectWBPLoadState) == 0x0002A4, "Member 'URCAdvHUDTalkComponent::SpSelectWBPLoadState' has a wrong offset!");
static_assert(offsetof(URCAdvHUDTalkComponent, SpSelectWindow) == 0x0002A8, "Member 'URCAdvHUDTalkComponent::SpSelectWindow' has a wrong offset!");

// Class RC.RCNzPuzzleAnswerBase
// 0x0018 (0x02F0 - 0x02D8)
class URCNzPuzzleAnswerBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Answer;                                         // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_UnAnswered;                                     // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AnswerTextImg;                                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializePuzzleAnswerBase();
	void SetAnswer(class FName wordText, class UTexture2D* wordTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleAnswerBase">();
	}
	static class URCNzPuzzleAnswerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleAnswerBase>();
	}
};
static_assert(alignof(URCNzPuzzleAnswerBase) == 0x000008, "Wrong alignment on URCNzPuzzleAnswerBase");
static_assert(sizeof(URCNzPuzzleAnswerBase) == 0x0002F0, "Wrong size on URCNzPuzzleAnswerBase");
static_assert(offsetof(URCNzPuzzleAnswerBase, AN_Answer) == 0x0002D8, "Member 'URCNzPuzzleAnswerBase::AN_Answer' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleAnswerBase, AN_UnAnswered) == 0x0002E0, "Member 'URCNzPuzzleAnswerBase::AN_UnAnswered' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleAnswerBase, AnswerTextImg) == 0x0002E8, "Member 'URCNzPuzzleAnswerBase::AnswerTextImg' has a wrong offset!");

// Class RC.RCUiMenuAreaMapImage
// 0x03A8 (0x0680 - 0x02D8)
class URCUiMenuAreaMapImage final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Change;                                         // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x1B8];                                    // 0x02E8(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TexturePath;                                       // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x1AC];                                    // 0x04B0(0x01AC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointerMoveSpeed;                                  // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            SoftwareCursor;                                    // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            BufferCursor;                                      // 0x0668(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x10];                                     // 0x0670(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishGenericWindow(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapImage">();
	}
	static class URCUiMenuAreaMapImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapImage>();
	}
};
static_assert(alignof(URCUiMenuAreaMapImage) == 0x000008, "Wrong alignment on URCUiMenuAreaMapImage");
static_assert(sizeof(URCUiMenuAreaMapImage) == 0x000680, "Wrong size on URCUiMenuAreaMapImage");
static_assert(offsetof(URCUiMenuAreaMapImage, AN_Change) == 0x0002D8, "Member 'URCUiMenuAreaMapImage::AN_Change' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapImage, AN_Off) == 0x0002E0, "Member 'URCUiMenuAreaMapImage::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapImage, TexturePath) == 0x0004A0, "Member 'URCUiMenuAreaMapImage::TexturePath' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapImage, PointerMoveSpeed) == 0x00065C, "Member 'URCUiMenuAreaMapImage::PointerMoveSpeed' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapImage, SoftwareCursor) == 0x000660, "Member 'URCUiMenuAreaMapImage::SoftwareCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapImage, BufferCursor) == 0x000668, "Member 'URCUiMenuAreaMapImage::BufferCursor' has a wrong offset!");

// Class RC.RCAIController
// 0x0008 (0x0330 - 0x0328)
class ARCAIController final : public AAIController
{
public:
	class FName                                   AIName;                                            // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAIController">();
	}
	static class ARCAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAIController>();
	}
};
static_assert(alignof(ARCAIController) == 0x000008, "Wrong alignment on ARCAIController");
static_assert(sizeof(ARCAIController) == 0x000330, "Wrong size on ARCAIController");
static_assert(offsetof(ARCAIController, AIName) == 0x000328, "Member 'ARCAIController::AIName' has a wrong offset!");

// Class RC.RCAmatanBFL
// 0x0000 (0x0028 - 0x0028)
class URCAmatanBFL final : public UBlueprintFunctionLibrary
{
public:
	static void SwitchBackFromAmatan();
	static void SwitchToAmatan();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAmatanBFL">();
	}
	static class URCAmatanBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAmatanBFL>();
	}
};
static_assert(alignof(URCAmatanBFL) == 0x000008, "Wrong alignment on URCAmatanBFL");
static_assert(sizeof(URCAmatanBFL) == 0x000028, "Wrong size on URCAmatanBFL");

// Class RC.RCNzUiChousaFinish
// 0x0018 (0x02F0 - 0x02D8)
class URCNzUiChousaFinish final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static int32 GetNzChousaFinishPriority();

	void CloseChousaFinish();
	bool IsFinished();
	void OpenChousaFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiChousaFinish">();
	}
	static class URCNzUiChousaFinish* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiChousaFinish>();
	}
};
static_assert(alignof(URCNzUiChousaFinish) == 0x000008, "Wrong alignment on URCNzUiChousaFinish");
static_assert(sizeof(URCNzUiChousaFinish) == 0x0002F0, "Wrong size on URCNzUiChousaFinish");
static_assert(offsetof(URCNzUiChousaFinish, AN_Start) == 0x0002D8, "Member 'URCNzUiChousaFinish::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiChousaFinish, AN_Finish) == 0x0002E0, "Member 'URCNzUiChousaFinish::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiChousaFinish, AN_Wait) == 0x0002E8, "Member 'URCNzUiChousaFinish::AN_Wait' has a wrong offset!");

// Class RC.RCUiMenuSkill
// 0x0040 (0x0318 - 0x02D8)
class URCUiMenuSkill final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x28];                                     // 0x02F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkill">();
	}
	static class URCUiMenuSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkill>();
	}
};
static_assert(alignof(URCUiMenuSkill) == 0x000008, "Wrong alignment on URCUiMenuSkill");
static_assert(sizeof(URCUiMenuSkill) == 0x000318, "Wrong size on URCUiMenuSkill");
static_assert(offsetof(URCUiMenuSkill, AN_Start) == 0x0002D8, "Member 'URCUiMenuSkill::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkill, AN_Wait) == 0x0002E0, "Member 'URCUiMenuSkill::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkill, AN_Finish) == 0x0002E8, "Member 'URCUiMenuSkill::AN_Finish' has a wrong offset!");

// Class RC.RCGameModeBase
// 0x0010 (0x02D0 - 0x02C0)
class ARCGameModeBase : public AGameModeBase
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNextLevelName(class FName LevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGameModeBase">();
	}
	static class ARCGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGameModeBase>();
	}
};
static_assert(alignof(ARCGameModeBase) == 0x000008, "Wrong alignment on ARCGameModeBase");
static_assert(sizeof(ARCGameModeBase) == 0x0002D0, "Wrong size on ARCGameModeBase");

// Class RC.RCOptionUIDataAsset
// 0x0010 (0x0040 - 0x0030)
class URCOptionUIDataAsset final : public UDataAsset
{
public:
	float                                         ScreenConfirmCloseTime;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenConfirmPopupTime;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySampleSEInterval;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOptionUIDataAsset">();
	}
	static class URCOptionUIDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOptionUIDataAsset>();
	}
};
static_assert(alignof(URCOptionUIDataAsset) == 0x000008, "Wrong alignment on URCOptionUIDataAsset");
static_assert(sizeof(URCOptionUIDataAsset) == 0x000040, "Wrong size on URCOptionUIDataAsset");
static_assert(offsetof(URCOptionUIDataAsset, ScreenConfirmCloseTime) == 0x000030, "Member 'URCOptionUIDataAsset::ScreenConfirmCloseTime' has a wrong offset!");
static_assert(offsetof(URCOptionUIDataAsset, ScreenConfirmPopupTime) == 0x000034, "Member 'URCOptionUIDataAsset::ScreenConfirmPopupTime' has a wrong offset!");
static_assert(offsetof(URCOptionUIDataAsset, PlaySampleSEInterval) == 0x000038, "Member 'URCOptionUIDataAsset::PlaySampleSEInterval' has a wrong offset!");

// Class RC.RCAmatanGameMode
// 0x0000 (0x02D0 - 0x02D0)
class ARCAmatanGameMode final : public ARCGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAmatanGameMode">();
	}
	static class ARCAmatanGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAmatanGameMode>();
	}
};
static_assert(alignof(ARCAmatanGameMode) == 0x000008, "Wrong alignment on ARCAmatanGameMode");
static_assert(sizeof(ARCAmatanGameMode) == 0x0002D0, "Wrong size on ARCAmatanGameMode");

// Class RC.RCUiMenuStatus
// 0x0180 (0x0458 - 0x02D8)
class URCUiMenuStatus final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_In;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Out;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_TRank;                                    // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_TPoint;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_Next;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_SkillPoint;                               // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_Memory_000;                               // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_Memory_001;                               // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_HP_000;                                   // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Num_HP_001;                                   // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_NotSetSkill;                                   // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpUIGauge*                             TPoint_Gauge;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x118];                                    // 0x0340(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuStatus">();
	}
	static class URCUiMenuStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuStatus>();
	}
};
static_assert(alignof(URCUiMenuStatus) == 0x000008, "Wrong alignment on URCUiMenuStatus");
static_assert(sizeof(URCUiMenuStatus) == 0x000458, "Wrong size on URCUiMenuStatus");
static_assert(offsetof(URCUiMenuStatus, AN_In) == 0x0002D8, "Member 'URCUiMenuStatus::AN_In' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, AN_Wait) == 0x0002E0, "Member 'URCUiMenuStatus::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, AN_Out) == 0x0002E8, "Member 'URCUiMenuStatus::AN_Out' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_TRank) == 0x0002F0, "Member 'URCUiMenuStatus::Text_Num_TRank' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_TPoint) == 0x0002F8, "Member 'URCUiMenuStatus::Text_Num_TPoint' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_Next) == 0x000300, "Member 'URCUiMenuStatus::Text_Num_Next' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_SkillPoint) == 0x000308, "Member 'URCUiMenuStatus::Text_Num_SkillPoint' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_Memory_000) == 0x000310, "Member 'URCUiMenuStatus::Text_Num_Memory_000' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_Memory_001) == 0x000318, "Member 'URCUiMenuStatus::Text_Num_Memory_001' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_HP_000) == 0x000320, "Member 'URCUiMenuStatus::Text_Num_HP_000' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Text_Num_HP_001) == 0x000328, "Member 'URCUiMenuStatus::Text_Num_HP_001' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, Txt_NotSetSkill) == 0x000330, "Member 'URCUiMenuStatus::Txt_NotSetSkill' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatus, TPoint_Gauge) == 0x000338, "Member 'URCUiMenuStatus::TPoint_Gauge' has a wrong offset!");

// Class RC.RCAmatanHUD
// 0x0178 (0x0A50 - 0x08D8)
class ARCAmatanHUD final : public ARCAdvHUD
{
public:
	uint8                                         Pad_8D8[0x100];                                    // 0x08D8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Tablet;                                            // 0x09D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 VoiceWidget;                                       // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        FaceWidget;                                        // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                FaderWidget;                                       // 0x09F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UTexture2D*>          VoiceMap;                                          // 0x09F8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Ask(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<struct FRCReHUDSelectData>& InSelectDataArray, class FName InQuestionTextID);
	bool CheckSelectFinished();
	int32 GetSelectedIndex();
	bool SelectStartWithDataArray(const TArray<struct FRCReHUDSelectData>& InSelectDataArray, class FName InQuestionTextID);
	void SetRobotComponentVisibility(bool Show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAmatanHUD">();
	}
	static class ARCAmatanHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAmatanHUD>();
	}
};
static_assert(alignof(ARCAmatanHUD) == 0x000008, "Wrong alignment on ARCAmatanHUD");
static_assert(sizeof(ARCAmatanHUD) == 0x000A50, "Wrong size on ARCAmatanHUD");
static_assert(offsetof(ARCAmatanHUD, Tablet) == 0x0009D8, "Member 'ARCAmatanHUD::Tablet' has a wrong offset!");
static_assert(offsetof(ARCAmatanHUD, VoiceWidget) == 0x0009E0, "Member 'ARCAmatanHUD::VoiceWidget' has a wrong offset!");
static_assert(offsetof(ARCAmatanHUD, FaceWidget) == 0x0009E8, "Member 'ARCAmatanHUD::FaceWidget' has a wrong offset!");
static_assert(offsetof(ARCAmatanHUD, FaderWidget) == 0x0009F0, "Member 'ARCAmatanHUD::FaderWidget' has a wrong offset!");
static_assert(offsetof(ARCAmatanHUD, VoiceMap) == 0x0009F8, "Member 'ARCAmatanHUD::VoiceMap' has a wrong offset!");

// Class RC.RCPawn
// 0x0040 (0x02C0 - 0x0280)
class ARCPawn : public APawn
{
public:
	class FName                                   CharacterName;                                     // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialize;                                       // 0x0288(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x0289(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisiblePawn;                                      // 0x028A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleIsCollision;                               // 0x028B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPause;                                            // 0x028C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPauseCancel;                                      // 0x028D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E[0x2];                                      // 0x028E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisonPrisetName;                                // 0x0290(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x28];                                     // 0x0298(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPause();
	bool IsPauseCancelFlag();
	bool IsVisibility();
	void SetPause(bool bInPause, bool bDirect);
	void SetPauseCancelFlag(bool bInPauseCancel);
	void SetVisibility(bool bInVisible, bool bDirect, bool bIsCollision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPawn">();
	}
	static class ARCPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPawn>();
	}
};
static_assert(alignof(ARCPawn) == 0x000008, "Wrong alignment on ARCPawn");
static_assert(sizeof(ARCPawn) == 0x0002C0, "Wrong size on ARCPawn");
static_assert(offsetof(ARCPawn, CharacterName) == 0x000280, "Member 'ARCPawn::CharacterName' has a wrong offset!");
static_assert(offsetof(ARCPawn, bInitialize) == 0x000288, "Member 'ARCPawn::bInitialize' has a wrong offset!");
static_assert(offsetof(ARCPawn, bVisible) == 0x000289, "Member 'ARCPawn::bVisible' has a wrong offset!");
static_assert(offsetof(ARCPawn, bVisiblePawn) == 0x00028A, "Member 'ARCPawn::bVisiblePawn' has a wrong offset!");
static_assert(offsetof(ARCPawn, bVisibleIsCollision) == 0x00028B, "Member 'ARCPawn::bVisibleIsCollision' has a wrong offset!");
static_assert(offsetof(ARCPawn, bPause) == 0x00028C, "Member 'ARCPawn::bPause' has a wrong offset!");
static_assert(offsetof(ARCPawn, bPauseCancel) == 0x00028D, "Member 'ARCPawn::bPauseCancel' has a wrong offset!");
static_assert(offsetof(ARCPawn, CollisonPrisetName) == 0x000290, "Member 'ARCPawn::CollisonPrisetName' has a wrong offset!");

// Class RC.RCNzUiFinalePieceNameWidget
// 0x0000 (0x02D8 - 0x02D8)
class URCNzUiFinalePieceNameWidget final : public URCUiWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceNameWidget">();
	}
	static class URCNzUiFinalePieceNameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceNameWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePieceNameWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePieceNameWidget");
static_assert(sizeof(URCNzUiFinalePieceNameWidget) == 0x0002D8, "Wrong size on URCNzUiFinalePieceNameWidget");

// Class RC.RCUiMenuCommonIcon
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuCommonIcon : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCommonIcon">();
	}
	static class URCUiMenuCommonIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCommonIcon>();
	}
};
static_assert(alignof(URCUiMenuCommonIcon) == 0x000008, "Wrong alignment on URCUiMenuCommonIcon");
static_assert(sizeof(URCUiMenuCommonIcon) == 0x0002E8, "Wrong size on URCUiMenuCommonIcon");
static_assert(offsetof(URCUiMenuCommonIcon, AN_On) == 0x0002D8, "Member 'URCUiMenuCommonIcon::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonIcon, AN_Off) == 0x0002E0, "Member 'URCUiMenuCommonIcon::AN_Off' has a wrong offset!");

// Class RC.RCUiMenuWorldMapJoint
// 0x0000 (0x02E8 - 0x02E8)
class URCUiMenuWorldMapJoint final : public URCUiMenuCommonIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapJoint">();
	}
	static class URCUiMenuWorldMapJoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapJoint>();
	}
};
static_assert(alignof(URCUiMenuWorldMapJoint) == 0x000008, "Wrong alignment on URCUiMenuWorldMapJoint");
static_assert(sizeof(URCUiMenuWorldMapJoint) == 0x0002E8, "Wrong size on URCUiMenuWorldMapJoint");

// Class RC.RCPawnScript
// 0x0080 (0x0340 - 0x02C0)
class ARCPawnScript : public ARCPawn
{
public:
	class URCScriptActorComponent*                ScriptActorComp;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x02C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x02CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLevelSetting;                                   // 0x02D0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x02D4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugScriptDraw;                                  // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwari;                                         // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTalk;                                             // 0x02E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E3[0x1];                                      // 0x02E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkLabelName;                                     // 0x02E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelifTextId;                                       // 0x02EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BalloonFrameType;                                  // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BalloonType;                                       // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCCharacterBallonPositionType                BallonPositionType;                                // 0x02FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBallonPositionTypeCondition;                      // 0x02FD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FE[0x2];                                      // 0x02FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class URCParamCharacterBallonPositionData*    BallonPositionData;                                // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TalkLength;                                        // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SelifLength;                                       // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonLength;                                     // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonHeightOffset;                               // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonAngleOffset;                                // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BalloonLengthOffset;                               // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DrawLayerName;                                     // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTalkEnable;                                       // 0x0328(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelifDraw;                                        // 0x0329(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBalloonDraw;                                      // 0x032A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B[0x1];                                      // 0x032B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerLength;                                      // 0x032C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CenterLength;                                      // 0x0330(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCActorQuestType                             QuestType;                                         // 0x0334(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestTitleName;                                    // 0x0338(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BackupMovePosition();
	struct FVector GetActorLocationBalloon();
	struct FVector GetActorLocationFoot();
	bool IsMoveEnd();
	void ResetMove();
	void RestoreMoveList();
	void RestoreMovePosition(float SpeedScale);
	void RestoreRotationYaw(float SpeedScale, bool bDirect);
	void SetMovePause(bool bInMovePause);
	void SetMoveSpeed(float InWalkSpeed, float InRunSpeed);
	void SetPositionYaw(const struct FVector& InPosition, float InYaw);
	void SetTransformPlayerStartName(class FName InPlayerStartTagName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void SetTransformTargetPointName(class FName InPointName, const struct FVector& InOffsetPos, float InOffsetYaw);
	void StartMoveFromPlayer(float InLength, float InAngle, float InHeight, float SpeedScale, bool bEndPlayerYaw);
	void StartMoveFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bEndChangeYaw, const struct FVector& EndChangeYawPosition, bool bPlayerCheck);
	void StartMoveFromPositionList(const TArray<struct FRCScriptActorMoveInfo>& InMoveInfoList, int32 StartMoveInfoNum, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	void StartMoveFromSplineName(class FName InSplineName, float StartDistanceRange, bool bReverse, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	void StartMoveFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, bool bEndChangeYaw, float InOffsetYaw, float InChangeYawSpeedScale, bool bPlayerCheck);
	void StartRotationFromCharacter(class FName InTargetCharacterName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationFromPosition(const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bDirect);
	void StartRotationFromTargetPointName(class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	void StartRotationYaw(float Yaw, float SpeedScale, bool bDirect);
	void StopMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPawnScript">();
	}
	static class ARCPawnScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPawnScript>();
	}
};
static_assert(alignof(ARCPawnScript) == 0x000008, "Wrong alignment on ARCPawnScript");
static_assert(sizeof(ARCPawnScript) == 0x000340, "Wrong size on ARCPawnScript");
static_assert(offsetof(ARCPawnScript, ScriptActorComp) == 0x0002C0, "Member 'ARCPawnScript::ScriptActorComp' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, HalfHeight) == 0x0002C8, "Member 'ARCPawnScript::HalfHeight' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, Radius) == 0x0002CC, "Member 'ARCPawnScript::Radius' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bIsLevelSetting) == 0x0002D0, "Member 'ARCPawnScript::bIsLevelSetting' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, Velocity) == 0x0002D4, "Member 'ARCPawnScript::Velocity' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bDebugScriptDraw) == 0x0002E0, "Member 'ARCPawnScript::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bKakiwari) == 0x0002E1, "Member 'ARCPawnScript::bKakiwari' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bTalk) == 0x0002E2, "Member 'ARCPawnScript::bTalk' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, TalkLabelName) == 0x0002E4, "Member 'ARCPawnScript::TalkLabelName' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, SelifTextId) == 0x0002EC, "Member 'ARCPawnScript::SelifTextId' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonFrameType) == 0x0002F4, "Member 'ARCPawnScript::BalloonFrameType' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonType) == 0x0002F8, "Member 'ARCPawnScript::BalloonType' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BallonPositionType) == 0x0002FC, "Member 'ARCPawnScript::BallonPositionType' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bBallonPositionTypeCondition) == 0x0002FD, "Member 'ARCPawnScript::bBallonPositionTypeCondition' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BallonPositionData) == 0x000300, "Member 'ARCPawnScript::BallonPositionData' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, TalkLength) == 0x000308, "Member 'ARCPawnScript::TalkLength' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, SelifLength) == 0x00030C, "Member 'ARCPawnScript::SelifLength' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonLength) == 0x000310, "Member 'ARCPawnScript::BalloonLength' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonHeightOffset) == 0x000314, "Member 'ARCPawnScript::BalloonHeightOffset' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonAngleOffset) == 0x000318, "Member 'ARCPawnScript::BalloonAngleOffset' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, BalloonLengthOffset) == 0x00031C, "Member 'ARCPawnScript::BalloonLengthOffset' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, DrawLayerName) == 0x000320, "Member 'ARCPawnScript::DrawLayerName' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bTalkEnable) == 0x000328, "Member 'ARCPawnScript::bTalkEnable' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bSelifDraw) == 0x000329, "Member 'ARCPawnScript::bSelifDraw' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, bBalloonDraw) == 0x00032A, "Member 'ARCPawnScript::bBalloonDraw' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, PlayerLength) == 0x00032C, "Member 'ARCPawnScript::PlayerLength' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, CenterLength) == 0x000330, "Member 'ARCPawnScript::CenterLength' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, QuestType) == 0x000334, "Member 'ARCPawnScript::QuestType' has a wrong offset!");
static_assert(offsetof(ARCPawnScript, QuestTitleName) == 0x000338, "Member 'ARCPawnScript::QuestTitleName' has a wrong offset!");

// Class RC.RCUiStaffRollItem
// 0x0008 (0x02E0 - 0x02D8)
class URCUiStaffRollItem : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem">();
	}
	static class URCUiStaffRollItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem>();
	}
};
static_assert(alignof(URCUiStaffRollItem) == 0x000008, "Wrong alignment on URCUiStaffRollItem");
static_assert(sizeof(URCUiStaffRollItem) == 0x0002E0, "Wrong size on URCUiStaffRollItem");

// Class RC.RCUiStaffRollItem_ThreeName
// 0x0018 (0x02F8 - 0x02E0)
class URCUiStaffRollItem_ThreeName final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_ThreeName">();
	}
	static class URCUiStaffRollItem_ThreeName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_ThreeName>();
	}
};
static_assert(alignof(URCUiStaffRollItem_ThreeName) == 0x000008, "Wrong alignment on URCUiStaffRollItem_ThreeName");
static_assert(sizeof(URCUiStaffRollItem_ThreeName) == 0x0002F8, "Wrong size on URCUiStaffRollItem_ThreeName");

// Class RC.RCNzFinaleHeadingManagerBase
// 0x0000 (0x0220 - 0x0220)
class ARCNzFinaleHeadingManagerBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleHeadingManagerBase">();
	}
	static class ARCNzFinaleHeadingManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleHeadingManagerBase>();
	}
};
static_assert(alignof(ARCNzFinaleHeadingManagerBase) == 0x000008, "Wrong alignment on ARCNzFinaleHeadingManagerBase");
static_assert(sizeof(ARCNzFinaleHeadingManagerBase) == 0x000220, "Wrong size on ARCNzFinaleHeadingManagerBase");

// Class RC.RCAmatanPawnScript
// 0x0078 (0x03B8 - 0x0340)
class ARCAmatanPawnScript final : public ARCPawnScript
{
public:
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshCompo;                                 // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraCompo;                                       // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANiagaraActor*                          NiagaraActor;                                      // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AnimSequences;                                     // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ParticleSystem;                                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  Effects;                                           // 0x03A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AutoPilot(const struct FVector& NewPosition, const struct FRotator& NewRotate, bool Teleport, bool IgnoreEvent);
	void AutoPilotMove(const struct FVector& NewPosition, bool Teleport, bool IgnoreEvent);
	void AutoPilotRotate(const struct FRotator& NewRotate);
	float CalcDurationForAutoMove(class AActor* Dist);
	float CalcDurationForAutoRotationYaw(class AActor* Dist);
	class UCapsuleComponent* GetCapsuleComponent();
	float GetPostEffectWeight(int32 Index_0);
	class USkeletalMeshComponent* GetSkeletalMeshComponent();
	float Pause_Anim();
	float Play_APull();
	float Play_APush();
	void SetEffectOffset(float Distance, float Height);
	void SetPostEffectWeight(int32 Index_0, float Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAmatanPawnScript">();
	}
	static class ARCAmatanPawnScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAmatanPawnScript>();
	}
};
static_assert(alignof(ARCAmatanPawnScript) == 0x000008, "Wrong alignment on ARCAmatanPawnScript");
static_assert(sizeof(ARCAmatanPawnScript) == 0x0003B8, "Wrong size on ARCAmatanPawnScript");
static_assert(offsetof(ARCAmatanPawnScript, SkeletalMeshCompo) == 0x000360, "Member 'ARCAmatanPawnScript::SkeletalMeshCompo' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, CameraCompo) == 0x000368, "Member 'ARCAmatanPawnScript::CameraCompo' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, CapsuleComponent) == 0x000370, "Member 'ARCAmatanPawnScript::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, SkeletalMesh) == 0x000378, "Member 'ARCAmatanPawnScript::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, NiagaraActor) == 0x000380, "Member 'ARCAmatanPawnScript::NiagaraActor' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, AnimSequences) == 0x000388, "Member 'ARCAmatanPawnScript::AnimSequences' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, PhysicsAsset) == 0x000398, "Member 'ARCAmatanPawnScript::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, ParticleSystem) == 0x0003A0, "Member 'ARCAmatanPawnScript::ParticleSystem' has a wrong offset!");
static_assert(offsetof(ARCAmatanPawnScript, Effects) == 0x0003A8, "Member 'ARCAmatanPawnScript::Effects' has a wrong offset!");

// Class RC.RCUiMenuTutorialListBar
// 0x0050 (0x0370 - 0x0320)
class URCUiMenuTutorialListBar final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x28];                                     // 0x0348(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuTutorialListBar">();
	}
	static class URCUiMenuTutorialListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuTutorialListBar>();
	}
};
static_assert(alignof(URCUiMenuTutorialListBar) == 0x000008, "Wrong alignment on URCUiMenuTutorialListBar");
static_assert(sizeof(URCUiMenuTutorialListBar) == 0x000370, "Wrong size on URCUiMenuTutorialListBar");
static_assert(offsetof(URCUiMenuTutorialListBar, AN_Default) == 0x000320, "Member 'URCUiMenuTutorialListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorialListBar, AN_OnCursor) == 0x000328, "Member 'URCUiMenuTutorialListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorialListBar, AN_OnCursor_Wait) == 0x000330, "Member 'URCUiMenuTutorialListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorialListBar, AN_OutCursor) == 0x000338, "Member 'URCUiMenuTutorialListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorialListBar, Text_ListName) == 0x000340, "Member 'URCUiMenuTutorialListBar::Text_ListName' has a wrong offset!");

// Class RC.RCPlayerController
// 0x0030 (0x05A0 - 0x0570)
class ARCPlayerController : public APlayerController
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCInputManager*                        InputManager;                                      // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkip;                                             // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkipSpeed;                                         // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipButton;                                       // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkipTick;                                          // 0x058C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BufResetCount;                                     // 0x0590(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeginPlayEnd;                                     // 0x0594(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_595[0xB];                                      // 0x0595(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBeginPlayEnd();
	bool IsReady();
	void LevelBeginPlayFinishedCallback();
	void SetMouseOverEnable(bool bInMouseOverEnable);
	void SetSkipEnable(bool bInSkipEnable);

	bool IsMouseOverEnable() const;
	bool IsSkipEnable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlayerController">();
	}
	static class ARCPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPlayerController>();
	}
};
static_assert(alignof(ARCPlayerController) == 0x000008, "Wrong alignment on ARCPlayerController");
static_assert(sizeof(ARCPlayerController) == 0x0005A0, "Wrong size on ARCPlayerController");
static_assert(offsetof(ARCPlayerController, InputManager) == 0x000578, "Member 'ARCPlayerController::InputManager' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, bSkip) == 0x000580, "Member 'ARCPlayerController::bSkip' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, SkipSpeed) == 0x000584, "Member 'ARCPlayerController::SkipSpeed' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, bSkipButton) == 0x000588, "Member 'ARCPlayerController::bSkipButton' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, SkipTick) == 0x00058C, "Member 'ARCPlayerController::SkipTick' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, BufResetCount) == 0x000590, "Member 'ARCPlayerController::BufResetCount' has a wrong offset!");
static_assert(offsetof(ARCPlayerController, bBeginPlayEnd) == 0x000594, "Member 'ARCPlayerController::bBeginPlayEnd' has a wrong offset!");

// Class RC.RCAmatanPlayerController
// 0x0180 (0x0720 - 0x05A0)
class ARCAmatanPlayerController final : public ARCPlayerController
{
public:
	uint8                                         Pad_5A0[0x8];                                      // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCEventTrigger*>                Volumes;                                           // 0x05A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Answer;                                            // 0x05C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x60];                                     // 0x05D8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     CharacterBase;                                     // 0x0638(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputYaw;                                          // 0x0640(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveYaw;                                           // 0x0644(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkSpeed;                                         // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotSpeed;                                          // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedScale;                                     // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanDoArming;                                       // 0x0654(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Panels;                                            // 0x0658(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         steps;                                             // 0x065C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Goal;                                              // 0x0660(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_661[0x3];                                      // 0x0661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RetryCount;                                        // 0x0664(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanLength;                                        // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MovementLock;                                      // 0x066C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MovementLockOverride;                              // 0x066D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MovementLockOverrideTemporary;                     // 0x066E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceArmExtendable;                                // 0x066F(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NowInBlocked;                                      // 0x0670(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NowFailure;                                        // 0x0671(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Saveable;                                          // 0x0672(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CuringTimeIssued;                                  // 0x0673(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_674[0x23];                                     // 0x0674(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugScriptDraw;                                  // 0x0697(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugPositionDraw;                                // 0x0698(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_699[0x3];                                      // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugPositionLength;                               // 0x069C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugPositionHeight;                               // 0x06A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugPositionAngle;                                // 0x06A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x20];                                     // 0x06A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* Overlap, int32 Index, int32 steps, bool Clear)> PassDispatcher;                                    // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 steps, ERCAmatanPuzzleFailureCode code)> FailDispatcher;                                    // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 steps, ERCAmatanPuzzleFailureCode code, int32 last)> FailDispatcher2;                                   // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERCAmatanUIButton code)> UIDispatcher;                                      // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERCAmatanFeedbackCode code, class AActor* blocked, float Angle)> FeedbackDispatcher;                                // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ANiagaraActor*                          NiagaraBlueprint;                                  // 0x0718(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ActivateShockEffect();
	void DeactivateShockEffect();
	bool DidGoal();
	void ExtendArm();
	void Face(int32 Index_0);
	void FinishPuzzle();
	void ForbidMovementSound();
	bool ForceGoal();
	class ARCAmatanPawnScript* GetAmatanPawn();
	int32 GetRetryCount();
	bool GetSkippable();
	void LockMovement(float Timeout);
	void LockMovementInfinity();
	void LockMovementOverride();
	void LockMovementOverrideTemporary();
	void OnArmComponentOverlapped(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& R);
	void OnFailed(int32 nowsteps, ERCAmatanPuzzleFailureCode code, int32 last);
	void PermitMovementSound();
	void ResearchFinish();
	void ResearchStart(bool UsePointer);
	void Restart(float After);
	void RestartFrom(float After, class FName StartPoint);
	bool Resume();
	void SetAnswer(const TArray<int32>& NewAnswer);
	void SetEventScene(bool Event);
	void SetForceArming(bool UpdateUI);
	void SetNiagaraBlueprint(class ANiagaraActor* bp);
	void SetSaveable(bool Save);
	void SetSkippable(bool Skippable);
	void ShrinkArm();
	void StartPlay(ERCRealPlayerGameMode InGameMode);
	void StartPuzzle();
	void UnlockMovement();
	void UnlockMovementOverride();
	void UnlockMovementOverrideTemorary();
	void UnsetForceArming(bool UpdateUI);
	void Voice(class FName ID);

	bool CanExtendArm() const;
	bool GetSaveable() const;
	bool IsMovementLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAmatanPlayerController">();
	}
	static class ARCAmatanPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAmatanPlayerController>();
	}
};
static_assert(alignof(ARCAmatanPlayerController) == 0x000008, "Wrong alignment on ARCAmatanPlayerController");
static_assert(sizeof(ARCAmatanPlayerController) == 0x000720, "Wrong size on ARCAmatanPlayerController");
static_assert(offsetof(ARCAmatanPlayerController, Volumes) == 0x0005A8, "Member 'ARCAmatanPlayerController::Volumes' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, Answer) == 0x0005C8, "Member 'ARCAmatanPlayerController::Answer' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, CharacterBase) == 0x000638, "Member 'ARCAmatanPlayerController::CharacterBase' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, InputYaw) == 0x000640, "Member 'ARCAmatanPlayerController::InputYaw' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, MoveYaw) == 0x000644, "Member 'ARCAmatanPlayerController::MoveYaw' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, WalkSpeed) == 0x000648, "Member 'ARCAmatanPlayerController::WalkSpeed' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, RotSpeed) == 0x00064C, "Member 'ARCAmatanPlayerController::RotSpeed' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, MaxSpeedScale) == 0x000650, "Member 'ARCAmatanPlayerController::MaxSpeedScale' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, CanDoArming) == 0x000654, "Member 'ARCAmatanPlayerController::CanDoArming' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, Panels) == 0x000658, "Member 'ARCAmatanPlayerController::Panels' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, steps) == 0x00065C, "Member 'ARCAmatanPlayerController::steps' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, Goal) == 0x000660, "Member 'ARCAmatanPlayerController::Goal' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, RetryCount) == 0x000664, "Member 'ARCAmatanPlayerController::RetryCount' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, ScanLength) == 0x000668, "Member 'ARCAmatanPlayerController::ScanLength' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, MovementLock) == 0x00066C, "Member 'ARCAmatanPlayerController::MovementLock' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, MovementLockOverride) == 0x00066D, "Member 'ARCAmatanPlayerController::MovementLockOverride' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, MovementLockOverrideTemporary) == 0x00066E, "Member 'ARCAmatanPlayerController::MovementLockOverrideTemporary' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, ForceArmExtendable) == 0x00066F, "Member 'ARCAmatanPlayerController::ForceArmExtendable' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, NowInBlocked) == 0x000670, "Member 'ARCAmatanPlayerController::NowInBlocked' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, NowFailure) == 0x000671, "Member 'ARCAmatanPlayerController::NowFailure' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, Saveable) == 0x000672, "Member 'ARCAmatanPlayerController::Saveable' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, CuringTimeIssued) == 0x000673, "Member 'ARCAmatanPlayerController::CuringTimeIssued' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, bDebugScriptDraw) == 0x000697, "Member 'ARCAmatanPlayerController::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, bDebugPositionDraw) == 0x000698, "Member 'ARCAmatanPlayerController::bDebugPositionDraw' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, DebugPositionLength) == 0x00069C, "Member 'ARCAmatanPlayerController::DebugPositionLength' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, DebugPositionHeight) == 0x0006A0, "Member 'ARCAmatanPlayerController::DebugPositionHeight' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, DebugPositionAngle) == 0x0006A4, "Member 'ARCAmatanPlayerController::DebugPositionAngle' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, PassDispatcher) == 0x0006C8, "Member 'ARCAmatanPlayerController::PassDispatcher' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, FailDispatcher) == 0x0006D8, "Member 'ARCAmatanPlayerController::FailDispatcher' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, FailDispatcher2) == 0x0006E8, "Member 'ARCAmatanPlayerController::FailDispatcher2' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, UIDispatcher) == 0x0006F8, "Member 'ARCAmatanPlayerController::UIDispatcher' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, FeedbackDispatcher) == 0x000708, "Member 'ARCAmatanPlayerController::FeedbackDispatcher' has a wrong offset!");
static_assert(offsetof(ARCAmatanPlayerController, NiagaraBlueprint) == 0x000718, "Member 'ARCAmatanPlayerController::NiagaraBlueprint' has a wrong offset!");

// Class RC.RCNzUiFinaleDetectiveImageWidget
// 0x0060 (0x0338 - 0x02D8)
class URCNzUiFinaleDetectiveImageWidget final : public URCUiWidgetBase
{
public:
	class UCanvasPanel*                           RLParent;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LRParent;                                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LLParent;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RRParent;                                          // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            RLPageWidget;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            RRPageWidget;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            LRPageWidget;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            LLPageWidget;                                      // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              PageMoveRightFinishDelegate;                       // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PageMoveLeftFinishDelegate;                        // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void AddChildLL(class UUserWidget* targetWidget);
	void AddChildLR(class UUserWidget* targetWidget);
	void AddChildRL(class UUserWidget* targetWidget);
	void AddChildRR(class UUserWidget* targetWidget);
	void InitializeDetectiveImageWidget();
	void PlaytoLeftAnim();
	void PlayToRightAnim();
	void ResetPageWidget();
	void SetLeftPage(TSubclassOf<class UUserWidget> pageClass, const TArray<struct FRCNzUiFinaleInteractImgInfo>& PieceImgList);
	void SetRightPage(TSubclassOf<class UUserWidget> pageClass, const TArray<struct FRCNzUiFinaleInteractImgInfo>& PieceImgList);
	void StartPageTurn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleDetectiveImageWidget">();
	}
	static class URCNzUiFinaleDetectiveImageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleDetectiveImageWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleDetectiveImageWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleDetectiveImageWidget");
static_assert(sizeof(URCNzUiFinaleDetectiveImageWidget) == 0x000338, "Wrong size on URCNzUiFinaleDetectiveImageWidget");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, RLParent) == 0x0002D8, "Member 'URCNzUiFinaleDetectiveImageWidget::RLParent' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, LRParent) == 0x0002E0, "Member 'URCNzUiFinaleDetectiveImageWidget::LRParent' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, LLParent) == 0x0002E8, "Member 'URCNzUiFinaleDetectiveImageWidget::LLParent' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, RRParent) == 0x0002F0, "Member 'URCNzUiFinaleDetectiveImageWidget::RRParent' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, RLPageWidget) == 0x0002F8, "Member 'URCNzUiFinaleDetectiveImageWidget::RLPageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, RRPageWidget) == 0x000300, "Member 'URCNzUiFinaleDetectiveImageWidget::RRPageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, LRPageWidget) == 0x000308, "Member 'URCNzUiFinaleDetectiveImageWidget::LRPageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, LLPageWidget) == 0x000310, "Member 'URCNzUiFinaleDetectiveImageWidget::LLPageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, PageMoveRightFinishDelegate) == 0x000318, "Member 'URCNzUiFinaleDetectiveImageWidget::PageMoveRightFinishDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveImageWidget, PageMoveLeftFinishDelegate) == 0x000328, "Member 'URCNzUiFinaleDetectiveImageWidget::PageMoveLeftFinishDelegate' has a wrong offset!");

// Class RC.RCInstallBFL
// 0x0000 (0x0028 - 0x0028)
class URCInstallBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsInstallComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInstallBFL">();
	}
	static class URCInstallBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInstallBFL>();
	}
};
static_assert(alignof(URCInstallBFL) == 0x000008, "Wrong alignment on URCInstallBFL");
static_assert(sizeof(URCInstallBFL) == 0x000028, "Wrong size on URCInstallBFL");

// Class RC.RCUiMenuSkillTypeIcon
// 0x0008 (0x02F0 - 0x02E8)
class URCUiMenuSkillTypeIcon final : public URCUiMenuCommonIcon
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTypeIcon">();
	}
	static class URCUiMenuSkillTypeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTypeIcon>();
	}
};
static_assert(alignof(URCUiMenuSkillTypeIcon) == 0x000008, "Wrong alignment on URCUiMenuSkillTypeIcon");
static_assert(sizeof(URCUiMenuSkillTypeIcon) == 0x0002F0, "Wrong size on URCUiMenuSkillTypeIcon");

// Class RC.RCKakiwariScript
// 0x0020 (0x02A8 - 0x0288)
class ARCKakiwariScript : public ARCActor
{
public:
	class URCScriptActorComponent*                ScriptActorComp;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0290(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DrawLayerName;                                     // 0x029C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugScriptDraw;                                  // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCKakiwariScript">();
	}
	static class ARCKakiwariScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCKakiwariScript>();
	}
};
static_assert(alignof(ARCKakiwariScript) == 0x000008, "Wrong alignment on ARCKakiwariScript");
static_assert(sizeof(ARCKakiwariScript) == 0x0002A8, "Wrong size on ARCKakiwariScript");
static_assert(offsetof(ARCKakiwariScript, ScriptActorComp) == 0x000288, "Member 'ARCKakiwariScript::ScriptActorComp' has a wrong offset!");
static_assert(offsetof(ARCKakiwariScript, Velocity) == 0x000290, "Member 'ARCKakiwariScript::Velocity' has a wrong offset!");
static_assert(offsetof(ARCKakiwariScript, DrawLayerName) == 0x00029C, "Member 'ARCKakiwariScript::DrawLayerName' has a wrong offset!");
static_assert(offsetof(ARCKakiwariScript, bDebugScriptDraw) == 0x0002A4, "Member 'ARCKakiwariScript::bDebugScriptDraw' has a wrong offset!");

// Class RC.RCNzUiBattleTimer
// 0x0018 (0x02F0 - 0x02D8)
class URCNzUiBattleTimer final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Img_NzTimer;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               TimerImageMaterial;                                // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	ERCNzUiBattleTimerStatus GetBattleTimerStatus();
	void InitializeBattleTimer();
	void Open();
	void SetElapsedTime(float InElapsedTime, float InLimitTime);
	void SetTime(float InTime, float InLimitTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleTimer">();
	}
	static class URCNzUiBattleTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleTimer>();
	}
};
static_assert(alignof(URCNzUiBattleTimer) == 0x000008, "Wrong alignment on URCNzUiBattleTimer");
static_assert(sizeof(URCNzUiBattleTimer) == 0x0002F0, "Wrong size on URCNzUiBattleTimer");
static_assert(offsetof(URCNzUiBattleTimer, Img_NzTimer) == 0x0002E0, "Member 'URCNzUiBattleTimer::Img_NzTimer' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleTimer, TimerImageMaterial) == 0x0002E8, "Member 'URCNzUiBattleTimer::TimerImageMaterial' has a wrong offset!");

// Class RC.RCKakiwariRender
// 0x0038 (0x02E0 - 0x02A8)
class ARCKakiwariRender : public ARCKakiwariScript
{
public:
	class URCDitherFadeComponent*                 DitherFadeComp;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionIndex;                                       // 0x02B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInstancedStaticMeshComponent*>  MeshArray;                                         // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterialArray;                              // 0x02C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetKakiwariMotionIndex(const int32 InMotionIndex);

	const float GetKakiwariMotionIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCKakiwariRender">();
	}
	static class ARCKakiwariRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCKakiwariRender>();
	}
};
static_assert(alignof(ARCKakiwariRender) == 0x000008, "Wrong alignment on ARCKakiwariRender");
static_assert(sizeof(ARCKakiwariRender) == 0x0002E0, "Wrong size on ARCKakiwariRender");
static_assert(offsetof(ARCKakiwariRender, DitherFadeComp) == 0x0002A8, "Member 'ARCKakiwariRender::DitherFadeComp' has a wrong offset!");
static_assert(offsetof(ARCKakiwariRender, MotionIndex) == 0x0002B0, "Member 'ARCKakiwariRender::MotionIndex' has a wrong offset!");
static_assert(offsetof(ARCKakiwariRender, MeshArray) == 0x0002B8, "Member 'ARCKakiwariRender::MeshArray' has a wrong offset!");
static_assert(offsetof(ARCKakiwariRender, DynamicMaterialArray) == 0x0002C8, "Member 'ARCKakiwariRender::DynamicMaterialArray' has a wrong offset!");

// Class RC.RCUiMenuSubQuestPlace
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuSubQuestPlace final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Place;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSubQuestPlace">();
	}
	static class URCUiMenuSubQuestPlace* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSubQuestPlace>();
	}
};
static_assert(alignof(URCUiMenuSubQuestPlace) == 0x000008, "Wrong alignment on URCUiMenuSubQuestPlace");
static_assert(sizeof(URCUiMenuSubQuestPlace) == 0x0002F8, "Wrong size on URCUiMenuSubQuestPlace");
static_assert(offsetof(URCUiMenuSubQuestPlace, Text_Place) == 0x0002D8, "Member 'URCUiMenuSubQuestPlace::Text_Place' has a wrong offset!");

// Class RC.RCAnimalRender
// 0x0060 (0x0340 - 0x02E0)
class ARCAnimalRender final : public ARCKakiwariRender
{
public:
	uint8                                         Pad_2E0[0x4];                                      // 0x02E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterId;                                       // 0x02E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimalAction;                                     // 0x02EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          ActionHierarchicalInstancedMesh;                   // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          IdleHierarchicalInstancedMesh;                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSwitchMesh;                                       // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IdleMotionIndex;                                   // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActionMotionIndex;                                 // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnimalNearPlayerHide;                             // 0x030C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthAnimalVisibleMin;                            // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthAnimalVisibleMax;                            // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthAnimalAction;                                // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveAnimalVisibleOffSec;                         // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveAnimalVisibleOffCurrentSec;                  // 0x0320(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveAnimalVisibleOffDurationSec;                 // 0x0324(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x1];                                      // 0x0328(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAnimalVisibleFlag;                                // 0x0329(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       ActionDynamicMaterialArray;                        // 0x0330(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimalRender">();
	}
	static class ARCAnimalRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAnimalRender>();
	}
};
static_assert(alignof(ARCAnimalRender) == 0x000008, "Wrong alignment on ARCAnimalRender");
static_assert(sizeof(ARCAnimalRender) == 0x000340, "Wrong size on ARCAnimalRender");
static_assert(offsetof(ARCAnimalRender, CharacterId) == 0x0002E4, "Member 'ARCAnimalRender::CharacterId' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, bAnimalAction) == 0x0002EC, "Member 'ARCAnimalRender::bAnimalAction' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActionHierarchicalInstancedMesh) == 0x0002F0, "Member 'ARCAnimalRender::ActionHierarchicalInstancedMesh' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, IdleHierarchicalInstancedMesh) == 0x0002F8, "Member 'ARCAnimalRender::IdleHierarchicalInstancedMesh' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, bSwitchMesh) == 0x000300, "Member 'ARCAnimalRender::bSwitchMesh' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, IdleMotionIndex) == 0x000304, "Member 'ARCAnimalRender::IdleMotionIndex' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActionMotionIndex) == 0x000308, "Member 'ARCAnimalRender::ActionMotionIndex' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, bAnimalNearPlayerHide) == 0x00030C, "Member 'ARCAnimalRender::bAnimalNearPlayerHide' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, LengthAnimalVisibleMin) == 0x000310, "Member 'ARCAnimalRender::LengthAnimalVisibleMin' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, LengthAnimalVisibleMax) == 0x000314, "Member 'ARCAnimalRender::LengthAnimalVisibleMax' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, LengthAnimalAction) == 0x000318, "Member 'ARCAnimalRender::LengthAnimalAction' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActiveAnimalVisibleOffSec) == 0x00031C, "Member 'ARCAnimalRender::ActiveAnimalVisibleOffSec' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActiveAnimalVisibleOffCurrentSec) == 0x000320, "Member 'ARCAnimalRender::ActiveAnimalVisibleOffCurrentSec' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActiveAnimalVisibleOffDurationSec) == 0x000324, "Member 'ARCAnimalRender::ActiveAnimalVisibleOffDurationSec' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, bAnimalVisibleFlag) == 0x000329, "Member 'ARCAnimalRender::bAnimalVisibleFlag' has a wrong offset!");
static_assert(offsetof(ARCAnimalRender, ActionDynamicMaterialArray) == 0x000330, "Member 'ARCAnimalRender::ActionDynamicMaterialArray' has a wrong offset!");

// Class RC.RCAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) URCAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimInstance">();
	}
	static class URCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(URCAnimInstance) == 0x000010, "Wrong alignment on URCAnimInstance");
static_assert(sizeof(URCAnimInstance) == 0x0002C0, "Wrong size on URCAnimInstance");

// Class RC.RCNzUiFinaleWidget
// 0x0260 (0x0538 - 0x02D8)
class URCNzUiFinaleWidget final : public URCUiWidgetBase
{
public:
	class URCNzUiFinaleTimeLimitBase*             Timer;                                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleTimelimitAlertBase*          Alert;                                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceLayoutWidget*         PieceLayout;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePageMoveLayoutWidget*      PageMoveLayout;                                    // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceGetWidget*            PieceGet;                                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceCorrectWidget*        PieceCorrect;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleHeadingClearWidget*        HeadingClear;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexClearWidget*          IndexClear;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleQuestionRestWidget*        QuestionRest;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleQuestionLayoutWidget*      QuestionLayout;                                    // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleHPBar*                     HPBar;                                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleQuestionWidget*            QuestionWidget;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexListWidget*           IndexListWidget;                                   // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexListParentWidget*     IndexListParentWidget;                             // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleDetectiveTitleWidget*      DetectiveTitleWidget;                              // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceQuestionBase*         PieceQuestion;                                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceQuestionBase*         KomaDetailUI;                                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceDetailWidget*         PieceDetailWidget;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePGLayoutWidget*            PGLayoutWidget;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexBTNGuideWidget*       IndexBtnGuide;                                     // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleLowSpeedBTNGuide*          LowSpeedBtnGuide;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                InteractIconWidgetClass;                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FinaleIntteractIconWidgetPath;                     // 0x0388(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isIndex02;                                         // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPieceCorrectFlag;                                // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39A[0x6];                                      // 0x039A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Incorrect;                                      // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LockPieceNameStr;                                  // 0x03B8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void()>                             FinishedStartAnimDelegate;                         // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             FinishedFinishAnimDelegate;                        // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector2D>                      CursorPointList;                                   // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ULList;                                            // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      URList;                                            // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      DLList;                                            // 0x0418(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      DRList;                                            // 0x0428(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              DirectingFinished;                                 // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              HeadingClearFinished;                              // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              IndexClearFinished;                                // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              IndexClearPlaySE;                                  // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PieceCorrectFinished;                              // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PieceIncorrectFinished;                            // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isSuccess)> PieceDetailApplyStartFinished;                     // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PageTurnIndexRFinished;                            // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PageTurnIndexLFinished;                            // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isSucess)> FinishedDetectiveInteractIconAnimDelegate;         // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              TimerLightingAFinishedDelegate;                    // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              MainLayoutStartFinishedDelegate;                   // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              MainLayoutFinishFinishedDelegate;                  // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PieceDetailUnlockFinishedDelegate;                 // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              MainLayutStartCandleDelegate;                      // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              MainLayoutStartTitleDelegate;                      // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	bool AddDamage(int32 AddDamage_0, int32* OutResultHP);
	void AddPieceList(const struct FRCNzFinalePieceObjectInfo& pieceInfo);
	void AlertStart();
	void ChangeSelectPieceEvent(const class FString& PieceTitle, class UTexture2D* PieceDetail, int32 isLock, bool isUsed, bool isUnlock);
	void ClosePieceList();
	void CreateIndex();
	void DirectingFinishedEvent();
	void FinishedFinishAnimation();
	void FinishedQuestionFinishAnimation(bool isSuccess);
	void FinishedStartAnimation();
	void FinishedTimerBurnLightingAAnimation();
	int32 GetCurrentSelectedPieceIdx();
	struct FRCNzFinalePieceObjectInfo GetCurrentSelectPiece();
	class URCNzUiFinaleIndexListParentWidget* GetIndexListParentWidget();
	class URCNzUiFinaleIndexListWidget* GetIndexListWidget();
	bool GetIsHoverdPieceList();
	int32 GetOneLinePieceItemNum();
	void GetPGLayoutLocationAndSize(struct FVector2D* Location, struct FVector2D* Size);
	class URCNzUiFinalePGLayoutWidget* GetPGLayoutWidget();
	TArray<class URCNzUiFinalePieceList_PieceBase*> GetPieceListItemLArray();
	float GetPieceListLAngle();
	struct FVector2D GetPieceListLScale();
	struct FVector2D GetPieceLListParentSize();
	void GetPieceSListParentLocAndSize(struct FVector2D* Loc, struct FVector2D* Size);
	void GetPieceSLocationAndSize(int32 idx, struct FVector2D* Loc, struct FVector2D* Size);
	class URCNzUiFinaleQuestionWidget* GetQuestionWidget();
	void HeadingClearEvent();
	void HeadingClearFinishedEvent();
	void IndexClearEvent();
	void IndexClearFinishedEvent();
	void IndexClearPlaySEEvent();
	void InitializeFinaleUI();
	void InitializeHPBar(float HpMax);
	void InitializeIndexList(const class FString& chNumStr);
	void InitializePieceList(const TArray<struct FRCNzFinalePieceObjectInfo>& pieceList);
	void InputDecideDetectiveMode();
	bool IsDebugDrawFlag();
	bool IsDetailPieceListMode();
	bool IsShowKomaDescriptionTextUI();
	bool IsShowQuestionTextUI();
	bool IsVisiblePieceList();
	void MoveDetectiveConstruct(const TArray<bool>& isCheckList);
	void MoveDetectiveScene();
	void MoveHeading();
	void MoveIndexScene();
	void OpenPieceList();
	void OpenPieceSelectWindow();
	void PieceCorrectEvent();
	void PieceCorrectFinishedEvent();
	void PieceDetailFinishApplyBlock_DoneEvent();
	void PieceDetailFinishApplyBlock_LockEvent();
	void PieceDetailFinishApplyFinishEvent();
	void PieceDetailFinishApplyStartEvent();
	void PieceDetailFinishUnLockEvent();
	void PieceGetEvent();
	void PieceIncorrectFinishedEvent();
	void PieceMoveLeft();
	void PieceMoveRight();
	void PlayApplyBlock_Done();
	void PlayApplyBlock_Lock();
	void PlayClearAnimTimeLimit();
	void PlayDoneAnimPieceDetail();
	void PlayFinishAnimation();
	void PlayGameOverAnimTimeLimit();
	void PlayIncorrectAnim();
	void PlayPageTurnIndexLAnim();
	void PlayPageTurnIndexRAnim();
	void PlayStartAnimation();
	void PlayStartGameAnimTimeLimit();
	void PlayStartLogoAnim();
	void SetDelayUnLockAnimTime(float Time);
	void SetIsHoverdPieceList(bool Val);
	void SetPageMoveDirIconVisiblity(EPageMoveVisibleDirection Visiblity);
	void SetQuestionRestNum(int32 Num);
	void SetSectionText(const class FString& sectionText1, const class FString& sectionText2);
	void SetTime(float Time);
	void SetTimeLimitAlertTimingScale(float Scale);
	void SetTimeScale(float TimeScale);
	void SetVisibleDetailPieeList();
	void SetVisibleHPBar(bool IsVisible_0);
	void SetVisibleIndexBtnGuide(bool IsVisible_0);
	void SetVisiblePieceList(bool isShow);
	void SetVisiblityDetectiveTitleUI(bool IsVisible_0);
	void ShowQuestionFinishAnimation(const struct FVector2D& Position, bool isSuccess);
	void StartCorrect();
	void StartInCorrect();
	bool UpdateCursorBtnGuide(ERCInputKeyType Key, bool IsVisible_0);
	void UpdateDetectiveTitle(const int32& Section, const class FString& Title);
	void UpdateHPBar(float Hp);
	bool UpdateIndexBtnGuide(ERCInputKeyType InKeyType, const class FString& str);
	bool UpdateLowSpeedBtnGuide(ERCInputKeyType kye, const class FString& str);
	bool UpdatePageGuideBtnGuide(ERCInputKeyType keyL, ERCInputKeyType keyR);
	void UpdatePieceList(const TArray<struct FRCNzFinalePieceObjectInfo>& pieceList, const TArray<struct FRCNzFinalePieceObjectInfo>& releasePieceList);
	bool UpdatePieceListBtnGuide(ERCInputKeyType Key);
	void UpdatePieceListUI();
	void UpdateQuestion(bool IsVisible_0, const class FString& QuestionText, const struct FVector2D& Position, const bool isLeft, const EFinaleInteractPointType Type, const bool isZoom);
	void UpdateSelectedPieceIdx(int32 idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleWidget">();
	}
	static class URCNzUiFinaleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleWidget");
static_assert(sizeof(URCNzUiFinaleWidget) == 0x000538, "Wrong size on URCNzUiFinaleWidget");
static_assert(offsetof(URCNzUiFinaleWidget, Timer) == 0x0002D8, "Member 'URCNzUiFinaleWidget::Timer' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, Alert) == 0x0002E0, "Member 'URCNzUiFinaleWidget::Alert' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceLayout) == 0x0002E8, "Member 'URCNzUiFinaleWidget::PieceLayout' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PageMoveLayout) == 0x0002F0, "Member 'URCNzUiFinaleWidget::PageMoveLayout' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceGet) == 0x0002F8, "Member 'URCNzUiFinaleWidget::PieceGet' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceCorrect) == 0x000300, "Member 'URCNzUiFinaleWidget::PieceCorrect' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, HeadingClear) == 0x000308, "Member 'URCNzUiFinaleWidget::HeadingClear' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexClear) == 0x000310, "Member 'URCNzUiFinaleWidget::IndexClear' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, QuestionRest) == 0x000318, "Member 'URCNzUiFinaleWidget::QuestionRest' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, QuestionLayout) == 0x000320, "Member 'URCNzUiFinaleWidget::QuestionLayout' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, HPBar) == 0x000328, "Member 'URCNzUiFinaleWidget::HPBar' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, QuestionWidget) == 0x000330, "Member 'URCNzUiFinaleWidget::QuestionWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexListWidget) == 0x000338, "Member 'URCNzUiFinaleWidget::IndexListWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexListParentWidget) == 0x000340, "Member 'URCNzUiFinaleWidget::IndexListParentWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, DetectiveTitleWidget) == 0x000348, "Member 'URCNzUiFinaleWidget::DetectiveTitleWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceQuestion) == 0x000350, "Member 'URCNzUiFinaleWidget::PieceQuestion' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, KomaDetailUI) == 0x000358, "Member 'URCNzUiFinaleWidget::KomaDetailUI' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceDetailWidget) == 0x000360, "Member 'URCNzUiFinaleWidget::PieceDetailWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PGLayoutWidget) == 0x000368, "Member 'URCNzUiFinaleWidget::PGLayoutWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexBtnGuide) == 0x000370, "Member 'URCNzUiFinaleWidget::IndexBtnGuide' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, LowSpeedBtnGuide) == 0x000378, "Member 'URCNzUiFinaleWidget::LowSpeedBtnGuide' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, InteractIconWidgetClass) == 0x000380, "Member 'URCNzUiFinaleWidget::InteractIconWidgetClass' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, FinaleIntteractIconWidgetPath) == 0x000388, "Member 'URCNzUiFinaleWidget::FinaleIntteractIconWidgetPath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, isIndex02) == 0x000398, "Member 'URCNzUiFinaleWidget::isIndex02' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, isPieceCorrectFlag) == 0x000399, "Member 'URCNzUiFinaleWidget::isPieceCorrectFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, AN_Incorrect) == 0x0003A0, "Member 'URCNzUiFinaleWidget::AN_Incorrect' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, AN_Start) == 0x0003A8, "Member 'URCNzUiFinaleWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, AN_Finish) == 0x0003B0, "Member 'URCNzUiFinaleWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, LockPieceNameStr) == 0x0003B8, "Member 'URCNzUiFinaleWidget::LockPieceNameStr' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, FinishedStartAnimDelegate) == 0x0003C8, "Member 'URCNzUiFinaleWidget::FinishedStartAnimDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, FinishedFinishAnimDelegate) == 0x0003D8, "Member 'URCNzUiFinaleWidget::FinishedFinishAnimDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, CursorPointList) == 0x0003E8, "Member 'URCNzUiFinaleWidget::CursorPointList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, ULList) == 0x0003F8, "Member 'URCNzUiFinaleWidget::ULList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, URList) == 0x000408, "Member 'URCNzUiFinaleWidget::URList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, DLList) == 0x000418, "Member 'URCNzUiFinaleWidget::DLList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, DRList) == 0x000428, "Member 'URCNzUiFinaleWidget::DRList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, DirectingFinished) == 0x000438, "Member 'URCNzUiFinaleWidget::DirectingFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, HeadingClearFinished) == 0x000448, "Member 'URCNzUiFinaleWidget::HeadingClearFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexClearFinished) == 0x000458, "Member 'URCNzUiFinaleWidget::IndexClearFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, IndexClearPlaySE) == 0x000468, "Member 'URCNzUiFinaleWidget::IndexClearPlaySE' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceCorrectFinished) == 0x000478, "Member 'URCNzUiFinaleWidget::PieceCorrectFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceIncorrectFinished) == 0x000488, "Member 'URCNzUiFinaleWidget::PieceIncorrectFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceDetailApplyStartFinished) == 0x000498, "Member 'URCNzUiFinaleWidget::PieceDetailApplyStartFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PageTurnIndexRFinished) == 0x0004A8, "Member 'URCNzUiFinaleWidget::PageTurnIndexRFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PageTurnIndexLFinished) == 0x0004B8, "Member 'URCNzUiFinaleWidget::PageTurnIndexLFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, FinishedDetectiveInteractIconAnimDelegate) == 0x0004C8, "Member 'URCNzUiFinaleWidget::FinishedDetectiveInteractIconAnimDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, TimerLightingAFinishedDelegate) == 0x0004D8, "Member 'URCNzUiFinaleWidget::TimerLightingAFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, MainLayoutStartFinishedDelegate) == 0x0004E8, "Member 'URCNzUiFinaleWidget::MainLayoutStartFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, MainLayoutFinishFinishedDelegate) == 0x0004F8, "Member 'URCNzUiFinaleWidget::MainLayoutFinishFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, PieceDetailUnlockFinishedDelegate) == 0x000508, "Member 'URCNzUiFinaleWidget::PieceDetailUnlockFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, MainLayutStartCandleDelegate) == 0x000518, "Member 'URCNzUiFinaleWidget::MainLayutStartCandleDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleWidget, MainLayoutStartTitleDelegate) == 0x000528, "Member 'URCNzUiFinaleWidget::MainLayoutStartTitleDelegate' has a wrong offset!");

// Class RC.RCUiOption
// 0x0180 (0x0458 - 0x02D8)
class URCUiOption final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x168];                                    // 0x02F0(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArrowButtonDownEvent();
	void TabOnMouseOver(class URCUiOptionTab* Tab);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOption">();
	}
	static class URCUiOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOption>();
	}
};
static_assert(alignof(URCUiOption) == 0x000008, "Wrong alignment on URCUiOption");
static_assert(sizeof(URCUiOption) == 0x000458, "Wrong size on URCUiOption");
static_assert(offsetof(URCUiOption, AN_Start) == 0x0002D8, "Member 'URCUiOption::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiOption, AN_Wait) == 0x0002E0, "Member 'URCUiOption::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiOption, AN_Finish) == 0x0002E8, "Member 'URCUiOption::AN_Finish' has a wrong offset!");

// Class RC.RCAnimNotify
// 0x0000 (0x0038 - 0x0038)
class URCAnimNotify : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotify">();
	}
	static class URCAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotify>();
	}
};
static_assert(alignof(URCAnimNotify) == 0x000008, "Wrong alignment on URCAnimNotify");
static_assert(sizeof(URCAnimNotify) == 0x000038, "Wrong size on URCAnimNotify");

// Class RC.RCNzMTB_PlayerActor
// 0x0008 (0x0228 - 0x0220)
class ARCNzMTB_PlayerActor final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzMTB_PlayerActor">();
	}
	static class ARCNzMTB_PlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzMTB_PlayerActor>();
	}
};
static_assert(alignof(ARCNzMTB_PlayerActor) == 0x000008, "Wrong alignment on ARCNzMTB_PlayerActor");
static_assert(sizeof(ARCNzMTB_PlayerActor) == 0x000228, "Wrong size on ARCNzMTB_PlayerActor");
static_assert(offsetof(ARCNzMTB_PlayerActor, Scene) == 0x000220, "Member 'ARCNzMTB_PlayerActor::Scene' has a wrong offset!");

// Class RC.RCAnimNotify_PlayNiagaraEffectEX
// 0x0078 (0x00B0 - 0x0038)
class alignas(0x10) URCAnimNotify_PlayNiagaraEffectEX final : public UAnimNotify
{
public:
	class UNiagaraSystem*                         NiagaraTemplate;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteScale;                                    // 0x006C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0070(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCPseudoAttachNiagaraComponent*        PseudoAttachNiagaraComponent;                      // 0x0088(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0090(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetSpawnedEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotify_PlayNiagaraEffectEX">();
	}
	static class URCAnimNotify_PlayNiagaraEffectEX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotify_PlayNiagaraEffectEX>();
	}
};
static_assert(alignof(URCAnimNotify_PlayNiagaraEffectEX) == 0x000010, "Wrong alignment on URCAnimNotify_PlayNiagaraEffectEX");
static_assert(sizeof(URCAnimNotify_PlayNiagaraEffectEX) == 0x0000B0, "Wrong size on URCAnimNotify_PlayNiagaraEffectEX");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, NiagaraTemplate) == 0x000038, "Member 'URCAnimNotify_PlayNiagaraEffectEX::NiagaraTemplate' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, RootSocketName) == 0x000040, "Member 'URCAnimNotify_PlayNiagaraEffectEX::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, SocketName) == 0x000048, "Member 'URCAnimNotify_PlayNiagaraEffectEX::SocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, bIgnoreSocketRotation) == 0x000050, "Member 'URCAnimNotify_PlayNiagaraEffectEX::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, LocationOffset) == 0x000054, "Member 'URCAnimNotify_PlayNiagaraEffectEX::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, RotationOffset) == 0x000060, "Member 'URCAnimNotify_PlayNiagaraEffectEX::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, bAbsoluteScale) == 0x00006C, "Member 'URCAnimNotify_PlayNiagaraEffectEX::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, Scale) == 0x000070, "Member 'URCAnimNotify_PlayNiagaraEffectEX::Scale' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, bKeepAttaching) == 0x00007C, "Member 'URCAnimNotify_PlayNiagaraEffectEX::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, KeepAttachingTime) == 0x000080, "Member 'URCAnimNotify_PlayNiagaraEffectEX::KeepAttachingTime' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, PseudoAttachNiagaraComponent) == 0x000088, "Member 'URCAnimNotify_PlayNiagaraEffectEX::PseudoAttachNiagaraComponent' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayNiagaraEffectEX, NiagaraComponent) == 0x000090, "Member 'URCAnimNotify_PlayNiagaraEffectEX::NiagaraComponent' has a wrong offset!");

// Class RC.RCUiMenuWorldMapNumber
// 0x0018 (0x0300 - 0x02E8)
class URCUiMenuWorldMapNumber final : public URCUiMenuCommonIcon
{
public:
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapNumber">();
	}
	static class URCUiMenuWorldMapNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapNumber>();
	}
};
static_assert(alignof(URCUiMenuWorldMapNumber) == 0x000008, "Wrong alignment on URCUiMenuWorldMapNumber");
static_assert(sizeof(URCUiMenuWorldMapNumber) == 0x000300, "Wrong size on URCUiMenuWorldMapNumber");

// Class RC.RCAnimNotify_PlayParticleEffectEX
// 0x0078 (0x00B0 - 0x0038)
class alignas(0x10) URCAnimNotify_PlayParticleEffectEX final : public UAnimNotify
{
public:
	class UParticleSystem*                        ParticleTemplate;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteScale;                                    // 0x006C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0070(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCPseudoAttachParticleComponent*       PseudoAttachParticleComponent;                     // 0x0088(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x0090(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotify_PlayParticleEffectEX">();
	}
	static class URCAnimNotify_PlayParticleEffectEX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotify_PlayParticleEffectEX>();
	}
};
static_assert(alignof(URCAnimNotify_PlayParticleEffectEX) == 0x000010, "Wrong alignment on URCAnimNotify_PlayParticleEffectEX");
static_assert(sizeof(URCAnimNotify_PlayParticleEffectEX) == 0x0000B0, "Wrong size on URCAnimNotify_PlayParticleEffectEX");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, ParticleTemplate) == 0x000038, "Member 'URCAnimNotify_PlayParticleEffectEX::ParticleTemplate' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, RootSocketName) == 0x000040, "Member 'URCAnimNotify_PlayParticleEffectEX::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, SocketName) == 0x000048, "Member 'URCAnimNotify_PlayParticleEffectEX::SocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, bIgnoreSocketRotation) == 0x000050, "Member 'URCAnimNotify_PlayParticleEffectEX::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, LocationOffset) == 0x000054, "Member 'URCAnimNotify_PlayParticleEffectEX::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, RotationOffset) == 0x000060, "Member 'URCAnimNotify_PlayParticleEffectEX::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, bAbsoluteScale) == 0x00006C, "Member 'URCAnimNotify_PlayParticleEffectEX::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, Scale) == 0x000070, "Member 'URCAnimNotify_PlayParticleEffectEX::Scale' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, bKeepAttaching) == 0x00007C, "Member 'URCAnimNotify_PlayParticleEffectEX::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, KeepAttachingTime) == 0x000080, "Member 'URCAnimNotify_PlayParticleEffectEX::KeepAttachingTime' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, PseudoAttachParticleComponent) == 0x000088, "Member 'URCAnimNotify_PlayParticleEffectEX::PseudoAttachParticleComponent' has a wrong offset!");
static_assert(offsetof(URCAnimNotify_PlayParticleEffectEX, ParticleComponent) == 0x000090, "Member 'URCAnimNotify_PlayParticleEffectEX::ParticleComponent' has a wrong offset!");

// Class RC.RCAnimNotifyBFL
// 0x0000 (0x0028 - 0x0028)
class URCAnimNotifyBFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotifyBFL">();
	}
	static class URCAnimNotifyBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotifyBFL>();
	}
};
static_assert(alignof(URCAnimNotifyBFL) == 0x000008, "Wrong alignment on URCAnimNotifyBFL");
static_assert(sizeof(URCAnimNotifyBFL) == 0x000028, "Wrong size on URCAnimNotifyBFL");

// Class RC.RCNzUiFinaleIndexListWidget
// 0x0070 (0x0348 - 0x02D8)
class URCNzUiFinaleIndexListWidget final : public URCUiWidgetBase
{
public:
	class UVerticalBox*                           sectionList1;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           sectionList2;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCNzUiFinaleHeadingTextWidget*> indexList;                                         // 0x02E8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         currentSelectIndex;                                // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IndexSizeY;                                        // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IndexSizeX;                                        // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IndexMaxNum;                                       // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OneLineIndexMaxNum;                                // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SectionUIPath;                                     // 0x0310(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isInitialize;                                      // 0x0320(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCNzFinaleManagerBase*                 FinaleManager;                                     // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isIndexList02;                                     // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     SectionNumberTexList;                              // 0x0338(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void DebugShowIndexSection(const struct FVector2D& UL, const struct FVector2D& ur, const struct FVector2D& dl, const struct FVector2D& dr, int32 idx);
	int32 GetCurentSelectSectionIndex();
	class FString GetCurrentSectionPieceUIPath();
	void GetCurrentSectionText(int32* SectionIdx, class FString* sectionTitle);
	class FString GetCurrentSelectSetionID();
	TArray<class URCNzUiFinaleHeadingTextWidget*> GetIndexList();
	struct FMargin GetIndexMargin(int32 idx);
	bool GetIsIndex02Flag();
	struct FVector2D GetListParentDesiredSize();
	struct FMargin GetListParentMargin();
	class FName GetTargetIndexSectionID(int32 idx);
	void InitializeFinaleIndexListWidget();
	bool IsCompleteInitialize();
	bool IsCurrentSection();
	bool IsExistNextSection();
	bool IsExistPrevSection();
	bool IsExistTargetSectionTextIDIndex(class FName TargetID, int32* lastIdx);
	bool IsExsitTargteIdxSection(int32 targetIdx);
	void MoveNextSection();
	void MovePrevSection();
	void ResetSelectIndexWidget();
	void SetVisibleSectionList(bool IsVisible_0);
	void UpdateIndexList(const struct FRCParamNzFinaleSectionTableRow& Section, int32 idx, class ARCNzFinaleManagerBase* FinaleManager_0);
	void UpdateSectionDetectivePointState(class ARCNzFinaleManagerBase* FinaleManager_0);
	void UpdateSelectIndexWidget(int32 targetIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleIndexListWidget">();
	}
	static class URCNzUiFinaleIndexListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleIndexListWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleIndexListWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleIndexListWidget");
static_assert(sizeof(URCNzUiFinaleIndexListWidget) == 0x000348, "Wrong size on URCNzUiFinaleIndexListWidget");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, sectionList1) == 0x0002D8, "Member 'URCNzUiFinaleIndexListWidget::sectionList1' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, sectionList2) == 0x0002E0, "Member 'URCNzUiFinaleIndexListWidget::sectionList2' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, indexList) == 0x0002E8, "Member 'URCNzUiFinaleIndexListWidget::indexList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, currentSelectIndex) == 0x0002F8, "Member 'URCNzUiFinaleIndexListWidget::currentSelectIndex' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, IndexSizeY) == 0x0002FC, "Member 'URCNzUiFinaleIndexListWidget::IndexSizeY' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, IndexSizeX) == 0x000300, "Member 'URCNzUiFinaleIndexListWidget::IndexSizeX' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, IndexMaxNum) == 0x000304, "Member 'URCNzUiFinaleIndexListWidget::IndexMaxNum' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, OneLineIndexMaxNum) == 0x000308, "Member 'URCNzUiFinaleIndexListWidget::OneLineIndexMaxNum' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, SectionUIPath) == 0x000310, "Member 'URCNzUiFinaleIndexListWidget::SectionUIPath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, isInitialize) == 0x000320, "Member 'URCNzUiFinaleIndexListWidget::isInitialize' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, FinaleManager) == 0x000328, "Member 'URCNzUiFinaleIndexListWidget::FinaleManager' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, isIndexList02) == 0x000330, "Member 'URCNzUiFinaleIndexListWidget::isIndexList02' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexListWidget, SectionNumberTexList) == 0x000338, "Member 'URCNzUiFinaleIndexListWidget::SectionNumberTexList' has a wrong offset!");

// Class RC.RCNazoLoopLevelScriptActor
// 0x0018 (0x0240 - 0x0228)
class ARCNazoLoopLevelScriptActor : public ALevelScriptActor
{
public:
	class ARCNazoLevelScriptActor*                NazoLSA;                                           // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInitialized;                                      // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoLoopLevelScriptActor">();
	}
	static class ARCNazoLoopLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoLoopLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoLoopLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoLoopLevelScriptActor");
static_assert(sizeof(ARCNazoLoopLevelScriptActor) == 0x000240, "Wrong size on ARCNazoLoopLevelScriptActor");
static_assert(offsetof(ARCNazoLoopLevelScriptActor, NazoLSA) == 0x000228, "Member 'ARCNazoLoopLevelScriptActor::NazoLSA' has a wrong offset!");
static_assert(offsetof(ARCNazoLoopLevelScriptActor, bInitialized) == 0x000238, "Member 'ARCNazoLoopLevelScriptActor::bInitialized' has a wrong offset!");

// Class RC.RCNazoMoveLoopLevelScriptActor
// 0x01C0 (0x0400 - 0x0240)
class ARCNazoMoveLoopLevelScriptActor final : public ARCNazoLoopLevelScriptActor
{
public:
	ERCNazoMoveLoopLSAState                       State;                                             // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DelayTimerHandle;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TalkDelayTimerHandle;                              // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SettingsDataTable;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCNazoMoveLoopLSALevelData            LevelData;                                         // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoMoveLoopLSAPlayerData           PlayerData;                                        // 0x0288(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoMoveLoopLSACameraData           CameraData;                                        // 0x0318(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoMoveLoopLSATalkData             TalkData;                                          // 0x0370(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoMoveLoopLSAFollowerData         FollowerData;                                      // 0x03C0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeBackCamera(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangeCamera(class ARCCineCameraActor* Camera, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangeCameraBase(class AActor* CameraBase, class ARCCineCameraActor* Camera, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangeCameraBaseFromTag(class FName CameraBaseTag, class FName CameraTag, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangeCameraFromTag(class FName CameraTag, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangePlayerSpeed(float Speed, float Time);
	void ChangeStateEvent(ERCNazoMoveLoopLSAState MoveLoopState);
	void ChangeTalkStateEvent(ERCNazoMoveLoopLSATalkState TalkState, class FName TalkID);
	void FinishMoveLoop();
	void TalkFinishedEvent(class FName TalkID);
	void TalkStartedEvent(class FName TalkID);
	void TalkStartTextEvent(int32 TextIndex, class FName TextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoMoveLoopLevelScriptActor">();
	}
	static class ARCNazoMoveLoopLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoMoveLoopLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoMoveLoopLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoMoveLoopLevelScriptActor");
static_assert(sizeof(ARCNazoMoveLoopLevelScriptActor) == 0x000400, "Wrong size on ARCNazoMoveLoopLevelScriptActor");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, State) == 0x000240, "Member 'ARCNazoMoveLoopLevelScriptActor::State' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, DelayTimerHandle) == 0x000248, "Member 'ARCNazoMoveLoopLevelScriptActor::DelayTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, TalkDelayTimerHandle) == 0x000250, "Member 'ARCNazoMoveLoopLevelScriptActor::TalkDelayTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, SettingsDataTable) == 0x000258, "Member 'ARCNazoMoveLoopLevelScriptActor::SettingsDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, LevelData) == 0x000260, "Member 'ARCNazoMoveLoopLevelScriptActor::LevelData' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, PlayerData) == 0x000288, "Member 'ARCNazoMoveLoopLevelScriptActor::PlayerData' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, CameraData) == 0x000318, "Member 'ARCNazoMoveLoopLevelScriptActor::CameraData' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, TalkData) == 0x000370, "Member 'ARCNazoMoveLoopLevelScriptActor::TalkData' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopLevelScriptActor, FollowerData) == 0x0003C0, "Member 'ARCNazoMoveLoopLevelScriptActor::FollowerData' has a wrong offset!");

// Class RC.RCAnimNotifyState_TimedNiagaraEffectEX
// 0x0050 (0x0080 - 0x0030)
class URCAnimNotifyState_TimedNiagaraEffectEX final : public UAnimNotifyState
{
public:
	class UNiagaraSystem*                         NiagaraTemplate;                                   // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x004C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestroyAtEnd;                                     // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x0065(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCPseudoAttachNiagaraComponent*        PseudoAttachNiagaraComponent;                      // 0x0070(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0078(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotifyState_TimedNiagaraEffectEX">();
	}
	static class URCAnimNotifyState_TimedNiagaraEffectEX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotifyState_TimedNiagaraEffectEX>();
	}
};
static_assert(alignof(URCAnimNotifyState_TimedNiagaraEffectEX) == 0x000008, "Wrong alignment on URCAnimNotifyState_TimedNiagaraEffectEX");
static_assert(sizeof(URCAnimNotifyState_TimedNiagaraEffectEX) == 0x000080, "Wrong size on URCAnimNotifyState_TimedNiagaraEffectEX");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, NiagaraTemplate) == 0x000030, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::NiagaraTemplate' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, RootSocketName) == 0x000038, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, SocketName) == 0x000040, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::SocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, bIgnoreSocketRotation) == 0x000048, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, LocationOffset) == 0x00004C, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, RotationOffset) == 0x000058, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, bDestroyAtEnd) == 0x000064, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, bKeepAttaching) == 0x000065, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, KeepAttachingTime) == 0x000068, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::KeepAttachingTime' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, PseudoAttachNiagaraComponent) == 0x000070, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::PseudoAttachNiagaraComponent' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedNiagaraEffectEX, NiagaraComponent) == 0x000078, "Member 'URCAnimNotifyState_TimedNiagaraEffectEX::NiagaraComponent' has a wrong offset!");

// Class RC.RCShinigamiAIRoute
// 0x0050 (0x0078 - 0x0028)
class URCShinigamiAIRoute final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCShinigamiAICommandTrigger*           AiCommandTrigger;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARCShinigamiAITargetPoint*>      TargetPointList;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMin;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMax;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStatusInit;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AiWaitTime;                                        // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NextTargetPointIndex;                              // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIRoute">();
	}
	static class URCShinigamiAIRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAIRoute>();
	}
};
static_assert(alignof(URCShinigamiAIRoute) == 0x000008, "Wrong alignment on URCShinigamiAIRoute");
static_assert(sizeof(URCShinigamiAIRoute) == 0x000078, "Wrong size on URCShinigamiAIRoute");
static_assert(offsetof(URCShinigamiAIRoute, ShinigamiActor) == 0x000038, "Member 'URCShinigamiAIRoute::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, Movement) == 0x000040, "Member 'URCShinigamiAIRoute::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, AiCommandTrigger) == 0x000048, "Member 'URCShinigamiAIRoute::AiCommandTrigger' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, TargetPointList) == 0x000050, "Member 'URCShinigamiAIRoute::TargetPointList' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, AiWaitTimeMin) == 0x000060, "Member 'URCShinigamiAIRoute::AiWaitTimeMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, AiWaitTimeMax) == 0x000064, "Member 'URCShinigamiAIRoute::AiWaitTimeMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, bStatusInit) == 0x000068, "Member 'URCShinigamiAIRoute::bStatusInit' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, AiWaitTime) == 0x00006C, "Member 'URCShinigamiAIRoute::AiWaitTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, NextTargetPointIndex) == 0x000070, "Member 'URCShinigamiAIRoute::NextTargetPointIndex' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIRoute, bDebugDraw) == 0x000074, "Member 'URCShinigamiAIRoute::bDebugDraw' has a wrong offset!");

// Class RC.RCAnimNotifyState_TimedParticleEffectEX
// 0x0050 (0x0080 - 0x0030)
class URCAnimNotifyState_TimedParticleEffectEX final : public UAnimNotifyState
{
public:
	class UParticleSystem*                        ParticleTemplate;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x004C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestroyAtEnd;                                     // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x0065(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCPseudoAttachParticleComponent*       PseudoAttachParticleComponent;                     // 0x0070(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               PSComponent;                                       // 0x0078(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimNotifyState_TimedParticleEffectEX">();
	}
	static class URCAnimNotifyState_TimedParticleEffectEX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimNotifyState_TimedParticleEffectEX>();
	}
};
static_assert(alignof(URCAnimNotifyState_TimedParticleEffectEX) == 0x000008, "Wrong alignment on URCAnimNotifyState_TimedParticleEffectEX");
static_assert(sizeof(URCAnimNotifyState_TimedParticleEffectEX) == 0x000080, "Wrong size on URCAnimNotifyState_TimedParticleEffectEX");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, ParticleTemplate) == 0x000030, "Member 'URCAnimNotifyState_TimedParticleEffectEX::ParticleTemplate' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, RootSocketName) == 0x000038, "Member 'URCAnimNotifyState_TimedParticleEffectEX::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, SocketName) == 0x000040, "Member 'URCAnimNotifyState_TimedParticleEffectEX::SocketName' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, bIgnoreSocketRotation) == 0x000048, "Member 'URCAnimNotifyState_TimedParticleEffectEX::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, LocationOffset) == 0x00004C, "Member 'URCAnimNotifyState_TimedParticleEffectEX::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, RotationOffset) == 0x000058, "Member 'URCAnimNotifyState_TimedParticleEffectEX::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, bDestroyAtEnd) == 0x000064, "Member 'URCAnimNotifyState_TimedParticleEffectEX::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, bKeepAttaching) == 0x000065, "Member 'URCAnimNotifyState_TimedParticleEffectEX::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, KeepAttachingTime) == 0x000068, "Member 'URCAnimNotifyState_TimedParticleEffectEX::KeepAttachingTime' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, PseudoAttachParticleComponent) == 0x000070, "Member 'URCAnimNotifyState_TimedParticleEffectEX::PseudoAttachParticleComponent' has a wrong offset!");
static_assert(offsetof(URCAnimNotifyState_TimedParticleEffectEX, PSComponent) == 0x000078, "Member 'URCAnimNotifyState_TimedParticleEffectEX::PSComponent' has a wrong offset!");

// Class RC.RCAnimSoundNotify
// 0x0018 (0x0050 - 0x0038)
class URCAnimSoundNotify final : public URCAnimNotify
{
public:
	ERCSoundType                                  SoundType;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SoundId;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAnimSoundNotify">();
	}
	static class URCAnimSoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAnimSoundNotify>();
	}
};
static_assert(alignof(URCAnimSoundNotify) == 0x000008, "Wrong alignment on URCAnimSoundNotify");
static_assert(sizeof(URCAnimSoundNotify) == 0x000050, "Wrong size on URCAnimSoundNotify");
static_assert(offsetof(URCAnimSoundNotify, SoundType) == 0x000038, "Member 'URCAnimSoundNotify::SoundType' has a wrong offset!");
static_assert(offsetof(URCAnimSoundNotify, SoundId) == 0x000040, "Member 'URCAnimSoundNotify::SoundId' has a wrong offset!");

// Class RC.RCSplineActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCSplineActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCSplineActor* GetSplineActor(class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSplineActorBFL">();
	}
	static class URCSplineActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSplineActorBFL>();
	}
};
static_assert(alignof(URCSplineActorBFL) == 0x000008, "Wrong alignment on URCSplineActorBFL");
static_assert(sizeof(URCSplineActorBFL) == 0x000028, "Wrong size on URCSplineActorBFL");

// Class RC.RCAsset
// 0x0028 (0x0050 - 0x0028)
class URCAsset final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                AssetObject;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecAssetLoadFinishChecker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAsset">();
	}
	static class URCAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAsset>();
	}
};
static_assert(alignof(URCAsset) == 0x000008, "Wrong alignment on URCAsset");
static_assert(sizeof(URCAsset) == 0x000050, "Wrong size on URCAsset");
static_assert(offsetof(URCAsset, AssetObject) == 0x000040, "Member 'URCAsset::AssetObject' has a wrong offset!");

// Class RC.RCAssetManager
// 0x0118 (0x0140 - 0x0028)
class URCAssetManager final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCAsset*>                       AssetList;                                         // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetInfo>                     BackupAssetInfo;                                   // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAssetManager">();
	}
	static class URCAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAssetManager>();
	}
};
static_assert(alignof(URCAssetManager) == 0x000008, "Wrong alignment on URCAssetManager");
static_assert(sizeof(URCAssetManager) == 0x000140, "Wrong size on URCAssetManager");
static_assert(offsetof(URCAssetManager, AssetList) == 0x000118, "Member 'URCAssetManager::AssetList' has a wrong offset!");
static_assert(offsetof(URCAssetManager, BackupAssetInfo) == 0x000130, "Member 'URCAssetManager::BackupAssetInfo' has a wrong offset!");

// Class RC.RCNzUiFinaleInteractIconWidget
// 0x00E8 (0x03C0 - 0x02D8)
class URCNzUiFinaleInteractIconWidget final : public URCUiWidgetBase
{
public:
	struct FRCNzFinaleGamePieceData               PieceData;                                         // 0x02D8(0x0070)(Protected, NativeAccessSpecifierProtected)
	class FName                                   PieceID;                                           // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          successFlag;                                       // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCorrected;                                       // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x2];                                      // 0x0352(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionScale;                                    // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPlayInOutAnimation;                              // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             PieceImg;                                          // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWidgetTransform                       QTransformSetting;                                 // 0x0368(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              QuetionTextFixedPosition;                          // 0x0384(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isUseFixedPosition;                                // 0x038C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isFinishStartAnim;                                 // 0x038D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38E[0x2];                                      // 0x038E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool isSuccess)> FinishedAnim;                                      // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              InteractStartFinishedDelegate;                     // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              InteractEndFinishedDelegate;                       // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	class FName GetAnswerID();
	class FString GetBackgroundImagePath(class ARCNzFinaleManagerBase* FinaleManager);
	float GetColScale();
	struct FVector2D GetInteractIconPosition(bool* isLeft);
	bool GetisCorrectFlag();
	bool GetIsFinishStartAnim();
	bool GetIsPlayInOutAnimationFlag();
	bool GetIsUseFixedPosition();
	struct FRCNzFinaleGamePieceData GetPieceData();
	bool GetPieceData_IsPick();
	class FString GetPieceDetailText();
	class FName GetPieceID();
	class UTexture2D* GetPieceImg();
	class FString GetPieceText();
	struct FVector2D GetQuestionTextFixedPosition();
	void InitializeInteractIconWidget(const struct FRCNzFinaleGamePieceData& Data);
	void PlayCorrectAnim();
	void PlayFailedAnim();
	void PlayFinishAnim();
	void PlayFinishQuestionAnim(bool isSuccess);
	void PlayHideAnim();
	void PlayQuestionAnim();
	void PlayStartAnim();
	void PlaySuccessAnim();
	void PlayWaitAnim();
	void SetCorrectedState();
	void SetIsCorrectFlag(bool Val);
	void SetPieceData_IsPick(bool isPick);
	void UpdateBackgroundImage(class UTexture2D* tex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleInteractIconWidget">();
	}
	static class URCNzUiFinaleInteractIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleInteractIconWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleInteractIconWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleInteractIconWidget");
static_assert(sizeof(URCNzUiFinaleInteractIconWidget) == 0x0003C0, "Wrong size on URCNzUiFinaleInteractIconWidget");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, PieceData) == 0x0002D8, "Member 'URCNzUiFinaleInteractIconWidget::PieceData' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, PieceID) == 0x000348, "Member 'URCNzUiFinaleInteractIconWidget::PieceID' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, successFlag) == 0x000350, "Member 'URCNzUiFinaleInteractIconWidget::successFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, isCorrected) == 0x000351, "Member 'URCNzUiFinaleInteractIconWidget::isCorrected' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, CollisionScale) == 0x000354, "Member 'URCNzUiFinaleInteractIconWidget::CollisionScale' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, isPlayInOutAnimation) == 0x000358, "Member 'URCNzUiFinaleInteractIconWidget::isPlayInOutAnimation' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, PieceImg) == 0x000360, "Member 'URCNzUiFinaleInteractIconWidget::PieceImg' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, QTransformSetting) == 0x000368, "Member 'URCNzUiFinaleInteractIconWidget::QTransformSetting' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, QuetionTextFixedPosition) == 0x000384, "Member 'URCNzUiFinaleInteractIconWidget::QuetionTextFixedPosition' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, isUseFixedPosition) == 0x00038C, "Member 'URCNzUiFinaleInteractIconWidget::isUseFixedPosition' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, isFinishStartAnim) == 0x00038D, "Member 'URCNzUiFinaleInteractIconWidget::isFinishStartAnim' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, FinishedAnim) == 0x000390, "Member 'URCNzUiFinaleInteractIconWidget::FinishedAnim' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, InteractStartFinishedDelegate) == 0x0003A0, "Member 'URCNzUiFinaleInteractIconWidget::InteractStartFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleInteractIconWidget, InteractEndFinishedDelegate) == 0x0003B0, "Member 'URCNzUiFinaleInteractIconWidget::InteractEndFinishedDelegate' has a wrong offset!");

// Class RC.RCSoundManager
// 0x03C8 (0x05E8 - 0x0220)
class ARCSoundManager final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          isFade;                                            // 0x0228(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFadeData>                      fadeInDataArray;                                   // 0x0230(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFadeData>                      fadeOutDataArray;                                  // 0x0240(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterProxy*>              lipSyncCharacterProxyArray;                        // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FManualMotionData>              manualMotionDataArray;                             // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoundData>                     bgmSoundDataArray;                                 // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     seSoundDataArray;                                  // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     envSoundDataArray;                                 // 0x0290(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     voiceSoundDataArray;                               // 0x02A0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     gameSeSoundDataArray;                              // 0x02B0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     backLogVoiceSoundDataArray;                        // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     mapEnvSoundDataArray;                              // 0x02D0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEnvMapData>                    mapEnvPlayingSoundStrArray;                        // 0x02E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     env3DSoundDataArray;                               // 0x02F0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     seJingleSoundDataArray;                            // 0x0300(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     amatanVoiceSoundDataArray;                         // 0x0310(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoundData>                     optionBGMSoundDataArray;                           // 0x0320(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLoadData>                      loadedSoundArray;                                  // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           bgmResidentSheetPathArray;                         // 0x0340(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           seResidentSheetPathArray;                          // 0x0350(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           envResidentSheetPathArray;                         // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           voiceResidentSheetPathArray;                       // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           bgmNonResidentSheetPathArray;                      // 0x0380(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           seNonResidentSheetPathArray;                       // 0x0390(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           envNonResidentSheetPathArray;                      // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           voiceNonResidentSheetPathArray;                    // 0x03B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<bool>                                  residentSoundLoadingFlagArray;                     // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<bool>                                  notResidentSoundLoadingFlagArray;                  // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueBGMResidentSheetArray;                     // 0x03E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueSEResidentSheetArray;                      // 0x03F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueENVResidentSheetArray;                     // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueVOICEResidentSheetArray;                   // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueBGMNonResidentSheetArray;                  // 0x0420(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueSENonResidentSheetArray;                   // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueENVNonResidentSheetArray;                  // 0x0440(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundAtomCueSheet*>             soundCueVOICENonResidentSheetArray;                // 0x0450(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class URCParamLipSyncForTextIDData*           paramLipSyncForTextIDData;                         // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   chapterLipSyncDataPath;                            // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isLoadChapterLipSyncParam;                         // 0x0470(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomStatics*                           AtomStatics;                                       // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetDefaultArray;                           // 0x0480(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetSadArray;                               // 0x0490(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetAngryArray;                             // 0x04A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetSurpriseArray;                          // 0x04B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetPlesureArray;                           // 0x04C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ERCCharacterMorphTarget>               morthTargetSpecialArray;                           // 0x04D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          isInitSheetLoad;                                   // 0x04E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCueSheetLoaded;                                  // 0x04E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isStartedCueSheetLoad;                             // 0x04E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isReloadVoiceSheet;                                // 0x04E3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundVolume                           SoundVolume;                                       // 0x04E4(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          IsMenuPause;                                       // 0x051C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51D[0x3];                                      // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         defaultLipSyncWidth;                               // 0x0520(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         adjustAiueoLipSyncRate;                            // 0x0524(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isLoadingFinish;                                   // 0x0528(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_529[0x7];                                      // 0x0529(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoundPlayerPosFade                    SoundPlayerPosFade;                                // 0x0530(0x0040)(NativeAccessSpecifierPrivate)
	class FName                                   currentVoiceFacial;                                // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLipSyncData>                   lipSyncDataArray;                                  // 0x0578(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          isLoadingLipSyncData;                              // 0x0588(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   useLipSyncMorphTargetName;                         // 0x058C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFacialCharaData>               voiceCharaArray;                                   // 0x0598(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           disableLipSyncCharaIDArray;                        // 0x05A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          isEnableLipSync;                                   // 0x05B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         beforeTopVowelIndex;                               // 0x05BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCheckSubTitle;                                   // 0x05C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isBackLog;                                         // 0x05C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isInitVolume;                                      // 0x05C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isEnableSkip;                                      // 0x05C3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isEnableSQCSkip;                                   // 0x05C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isRunningSQC;                                      // 0x05C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C6[0x2];                                      // 0x05C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SQCTime;                                           // 0x05C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDeathMatchBattle;                                // 0x05CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAtomComponent*>                 PauseAtomComponentList;                            // 0x05D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bDisableGameSound;                                 // 0x05E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x7];                                      // 0x05E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcVolume(ERCSoundType SoundType);
	void CheckSheetLoad();
	void CrossFade(ERCSoundType SoundType, const class FString& SoundId, float fadeInTime);
	void FadeIn(ERCSoundType SoundType, const class FString& SoundId, float fadeInTime, float StartTime, float finishVolume, bool isBaseOriginalVolume);
	void FadeInAll(ERCSoundType SoundType, float fadeInTime, float StartTime, float finishVolume);
	void FadeOut(ERCSoundType SoundType, const class FString& SoundId, float fadeOutTime, float finishVolume);
	void FadeOutAll(ERCSoundType SoundType, float fadeOutTime, float finishVolume);
	TArray<struct FSoundData> GetBgmSoundDataArray();
	TArray<class FName> GetCueSheetParamPathArray(ERCSoundType SoundType);
	TArray<struct FSoundData> GetEnviromentSoundDataArray();
	struct FRCParamLipSyncDataAdjustTableRow GetLipSyncParamDataAdjust(class FName voiceCharaID);
	float GetLipSyncVol(float voiceVol);
	struct FRCParamSoundNonResidentListTableRow GetNonResidentCueSheetParam(const class FString& SheetID);
	class FString GetPlayingBGMID();
	TArray<struct FSoundData> GetSeSoundDataArray();
	struct FLoadData GetSoundAtomCue(ERCSoundType SoundType);
	TArray<struct FSoundData> GetSoundDataArray(ERCSoundType SoundType);
	class FString GetSoundId(ERCSoundType SoundType, int32 soundIndex, const class FString& CharaID);
	struct FRCParamSoundFormatTableRow GetSoundParamData(ERCSoundType SoundType);
	TArray<struct FSoundData> GetVoiceSoundDataArray();
	void Initialize();
	bool isCurrentSoundID(ERCSoundType SoundType, const class FString& SoundId, const class FString& CharaID);
	bool IsLoadedNonResidentSheet();
	bool isSameVolume(float lVolume, float rVolume);
	void LoadNonResidentSheet(const class FString& SheetID);
	void LoopSetting(class USoundAtomCue* pSoundCue, bool IsLoop);
	void Pause();
	void PauseForSoundType(ERCSoundType SoundType, bool bAllPause);
	void PauseSingle(ERCSoundType SoundType, const class FString& SoundId, class AActor* Actor);
	void Play(ERCSoundType SoundType, bool IsLoop, float StartTime);
	void PlayLipSync();
	void ReloadVoiceSheet();
	void ResetNonResidentSheet();
	void Resume();
	void ResumeFieldSound();
	void ResumeForSoundType(ERCSoundType SoundType);
	void ResumeSingle(ERCSoundType SoundType, const class FString& SoundId, class AActor* Actor);
	void SetFadeSoundForPositionData(const struct FSoundPlayerPosFade& Data);
	void SetLipSyncCharaArray(const TArray<class ACharacter*>& charaArray);
	void SetPlaySound(ERCSoundType SoundType, const class FString& SoundId, bool IsLoop, const class FString& CharaID, bool isFadeIn, const class FString& ParamSoundID, ERCSoundType OptionType, float volumeRate);
	void StartSheetLoad();
	void Stop(ERCSoundType SoundType);
	void UpdateFade(float DeltaTime);
	void UpdateMasterVolume(float MasterVolume);
	void UpdateMenuPauseVolume();
	void UpdateOptionVolume(ERCSoundType SoundType, float Volume);
	void UpdateSingleSoundVolume(ERCSoundType SoundType, const class FString& SoundId, float volumeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSoundManager">();
	}
	static class ARCSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSoundManager>();
	}
};
static_assert(alignof(ARCSoundManager) == 0x000008, "Wrong alignment on ARCSoundManager");
static_assert(sizeof(ARCSoundManager) == 0x0005E8, "Wrong size on ARCSoundManager");
static_assert(offsetof(ARCSoundManager, isFade) == 0x000228, "Member 'ARCSoundManager::isFade' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, fadeInDataArray) == 0x000230, "Member 'ARCSoundManager::fadeInDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, fadeOutDataArray) == 0x000240, "Member 'ARCSoundManager::fadeOutDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, lipSyncCharacterProxyArray) == 0x000250, "Member 'ARCSoundManager::lipSyncCharacterProxyArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, manualMotionDataArray) == 0x000260, "Member 'ARCSoundManager::manualMotionDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, bgmSoundDataArray) == 0x000270, "Member 'ARCSoundManager::bgmSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, seSoundDataArray) == 0x000280, "Member 'ARCSoundManager::seSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, envSoundDataArray) == 0x000290, "Member 'ARCSoundManager::envSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, voiceSoundDataArray) == 0x0002A0, "Member 'ARCSoundManager::voiceSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, gameSeSoundDataArray) == 0x0002B0, "Member 'ARCSoundManager::gameSeSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, backLogVoiceSoundDataArray) == 0x0002C0, "Member 'ARCSoundManager::backLogVoiceSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, mapEnvSoundDataArray) == 0x0002D0, "Member 'ARCSoundManager::mapEnvSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, mapEnvPlayingSoundStrArray) == 0x0002E0, "Member 'ARCSoundManager::mapEnvPlayingSoundStrArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, env3DSoundDataArray) == 0x0002F0, "Member 'ARCSoundManager::env3DSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, seJingleSoundDataArray) == 0x000300, "Member 'ARCSoundManager::seJingleSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, amatanVoiceSoundDataArray) == 0x000310, "Member 'ARCSoundManager::amatanVoiceSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, optionBGMSoundDataArray) == 0x000320, "Member 'ARCSoundManager::optionBGMSoundDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, loadedSoundArray) == 0x000330, "Member 'ARCSoundManager::loadedSoundArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, bgmResidentSheetPathArray) == 0x000340, "Member 'ARCSoundManager::bgmResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, seResidentSheetPathArray) == 0x000350, "Member 'ARCSoundManager::seResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, envResidentSheetPathArray) == 0x000360, "Member 'ARCSoundManager::envResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, voiceResidentSheetPathArray) == 0x000370, "Member 'ARCSoundManager::voiceResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, bgmNonResidentSheetPathArray) == 0x000380, "Member 'ARCSoundManager::bgmNonResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, seNonResidentSheetPathArray) == 0x000390, "Member 'ARCSoundManager::seNonResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, envNonResidentSheetPathArray) == 0x0003A0, "Member 'ARCSoundManager::envNonResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, voiceNonResidentSheetPathArray) == 0x0003B0, "Member 'ARCSoundManager::voiceNonResidentSheetPathArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, residentSoundLoadingFlagArray) == 0x0003C0, "Member 'ARCSoundManager::residentSoundLoadingFlagArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, notResidentSoundLoadingFlagArray) == 0x0003D0, "Member 'ARCSoundManager::notResidentSoundLoadingFlagArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueBGMResidentSheetArray) == 0x0003E0, "Member 'ARCSoundManager::soundCueBGMResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueSEResidentSheetArray) == 0x0003F0, "Member 'ARCSoundManager::soundCueSEResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueENVResidentSheetArray) == 0x000400, "Member 'ARCSoundManager::soundCueENVResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueVOICEResidentSheetArray) == 0x000410, "Member 'ARCSoundManager::soundCueVOICEResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueBGMNonResidentSheetArray) == 0x000420, "Member 'ARCSoundManager::soundCueBGMNonResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueSENonResidentSheetArray) == 0x000430, "Member 'ARCSoundManager::soundCueSENonResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueENVNonResidentSheetArray) == 0x000440, "Member 'ARCSoundManager::soundCueENVNonResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, soundCueVOICENonResidentSheetArray) == 0x000450, "Member 'ARCSoundManager::soundCueVOICENonResidentSheetArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, paramLipSyncForTextIDData) == 0x000460, "Member 'ARCSoundManager::paramLipSyncForTextIDData' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, chapterLipSyncDataPath) == 0x000468, "Member 'ARCSoundManager::chapterLipSyncDataPath' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isLoadChapterLipSyncParam) == 0x000470, "Member 'ARCSoundManager::isLoadChapterLipSyncParam' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, AtomStatics) == 0x000478, "Member 'ARCSoundManager::AtomStatics' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetDefaultArray) == 0x000480, "Member 'ARCSoundManager::morthTargetDefaultArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetSadArray) == 0x000490, "Member 'ARCSoundManager::morthTargetSadArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetAngryArray) == 0x0004A0, "Member 'ARCSoundManager::morthTargetAngryArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetSurpriseArray) == 0x0004B0, "Member 'ARCSoundManager::morthTargetSurpriseArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetPlesureArray) == 0x0004C0, "Member 'ARCSoundManager::morthTargetPlesureArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, morthTargetSpecialArray) == 0x0004D0, "Member 'ARCSoundManager::morthTargetSpecialArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isInitSheetLoad) == 0x0004E0, "Member 'ARCSoundManager::isInitSheetLoad' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isCueSheetLoaded) == 0x0004E1, "Member 'ARCSoundManager::isCueSheetLoaded' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isStartedCueSheetLoad) == 0x0004E2, "Member 'ARCSoundManager::isStartedCueSheetLoad' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isReloadVoiceSheet) == 0x0004E3, "Member 'ARCSoundManager::isReloadVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, SoundVolume) == 0x0004E4, "Member 'ARCSoundManager::SoundVolume' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, IsMenuPause) == 0x00051C, "Member 'ARCSoundManager::IsMenuPause' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, defaultLipSyncWidth) == 0x000520, "Member 'ARCSoundManager::defaultLipSyncWidth' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, adjustAiueoLipSyncRate) == 0x000524, "Member 'ARCSoundManager::adjustAiueoLipSyncRate' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isLoadingFinish) == 0x000528, "Member 'ARCSoundManager::isLoadingFinish' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, SoundPlayerPosFade) == 0x000530, "Member 'ARCSoundManager::SoundPlayerPosFade' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, currentVoiceFacial) == 0x000570, "Member 'ARCSoundManager::currentVoiceFacial' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, lipSyncDataArray) == 0x000578, "Member 'ARCSoundManager::lipSyncDataArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isLoadingLipSyncData) == 0x000588, "Member 'ARCSoundManager::isLoadingLipSyncData' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, useLipSyncMorphTargetName) == 0x00058C, "Member 'ARCSoundManager::useLipSyncMorphTargetName' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, voiceCharaArray) == 0x000598, "Member 'ARCSoundManager::voiceCharaArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, disableLipSyncCharaIDArray) == 0x0005A8, "Member 'ARCSoundManager::disableLipSyncCharaIDArray' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isEnableLipSync) == 0x0005B8, "Member 'ARCSoundManager::isEnableLipSync' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, beforeTopVowelIndex) == 0x0005BC, "Member 'ARCSoundManager::beforeTopVowelIndex' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isCheckSubTitle) == 0x0005C0, "Member 'ARCSoundManager::isCheckSubTitle' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isBackLog) == 0x0005C1, "Member 'ARCSoundManager::isBackLog' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isInitVolume) == 0x0005C2, "Member 'ARCSoundManager::isInitVolume' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isEnableSkip) == 0x0005C3, "Member 'ARCSoundManager::isEnableSkip' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isEnableSQCSkip) == 0x0005C4, "Member 'ARCSoundManager::isEnableSQCSkip' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, isRunningSQC) == 0x0005C5, "Member 'ARCSoundManager::isRunningSQC' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, SQCTime) == 0x0005C8, "Member 'ARCSoundManager::SQCTime' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, IsDeathMatchBattle) == 0x0005CC, "Member 'ARCSoundManager::IsDeathMatchBattle' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, PauseAtomComponentList) == 0x0005D0, "Member 'ARCSoundManager::PauseAtomComponentList' has a wrong offset!");
static_assert(offsetof(ARCSoundManager, bDisableGameSound) == 0x0005E0, "Member 'ARCSoundManager::bDisableGameSound' has a wrong offset!");

// Class RC.RCAttachmentActor
// 0x0010 (0x0298 - 0x0288)
class ARCAttachmentActor final : public ARCActor
{
public:
	class FName                                   ColorPaletteId;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnLoad;                                           // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAttachmentActor">();
	}
	static class ARCAttachmentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCAttachmentActor>();
	}
};
static_assert(alignof(ARCAttachmentActor) == 0x000008, "Wrong alignment on ARCAttachmentActor");
static_assert(sizeof(ARCAttachmentActor) == 0x000298, "Wrong size on ARCAttachmentActor");
static_assert(offsetof(ARCAttachmentActor, ColorPaletteId) == 0x000288, "Member 'ARCAttachmentActor::ColorPaletteId' has a wrong offset!");
static_assert(offsetof(ARCAttachmentActor, bOnLoad) == 0x000290, "Member 'ARCAttachmentActor::bOnLoad' has a wrong offset!");

// Class RC.RCAttachmentAnimCtrl
// 0x0018 (0x00C8 - 0x00B0)
class URCAttachmentAnimCtrl final : public UActorComponent
{
public:
	ERCAttachAnimType                             AnimationType;                                     // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCAttachAnimType                             CurrentAnimationType;                              // 0x00B1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x16];                                      // 0x00B2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAttachmentAnimCtrl">();
	}
	static class URCAttachmentAnimCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAttachmentAnimCtrl>();
	}
};
static_assert(alignof(URCAttachmentAnimCtrl) == 0x000008, "Wrong alignment on URCAttachmentAnimCtrl");
static_assert(sizeof(URCAttachmentAnimCtrl) == 0x0000C8, "Wrong size on URCAttachmentAnimCtrl");
static_assert(offsetof(URCAttachmentAnimCtrl, AnimationType) == 0x0000B0, "Member 'URCAttachmentAnimCtrl::AnimationType' has a wrong offset!");
static_assert(offsetof(URCAttachmentAnimCtrl, CurrentAnimationType) == 0x0000B1, "Member 'URCAttachmentAnimCtrl::CurrentAnimationType' has a wrong offset!");

// Class RC.RCCameraActor
// 0x0010 (0x07C0 - 0x07B0)
class ARCCameraActor : public ACameraActor
{
public:
	uint8                                         Pad_7B0[0x10];                                     // 0x07B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCameraActor">();
	}
	static class ARCCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCameraActor>();
	}
};
static_assert(alignof(ARCCameraActor) == 0x000010, "Wrong alignment on ARCCameraActor");
static_assert(sizeof(ARCCameraActor) == 0x0007C0, "Wrong size on ARCCameraActor");

// Class RC.RCTPSCamera
// 0x0190 (0x0950 - 0x07C0)
class ARCTPSCamera : public ARCCameraActor
{
public:
	uint8                                         Pad_7C0[0x30];                                     // 0x07C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetX;                                           // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetY;                                           // 0x07F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetZ;                                           // 0x07F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLimitCheck;                                       // 0x07FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAngleCharacter;                                   // 0x07FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7FE[0x2];                                      // 0x07FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Angle;                                             // 0x0804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VerticalAngle;                                     // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Length;                                            // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthSpeed;                                       // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FOV;                                               // 0x0814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitVerticalAngleMin;                             // 0x0818(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitVerticalAngleMax;                             // 0x081C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitLengthMin;                                    // 0x0820(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitLengthMax;                                    // 0x0824(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                FakeLocation;                                      // 0x0828(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseFake;                                          // 0x0834(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockMove;                                         // 0x0835(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_836[0x2];                                      // 0x0836(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OFFsetRot;                                         // 0x0838(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSpeed;                                         // 0x0840(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLengthCameraAlphaEnable;                          // 0x0844(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_845[0x3];                                      // 0x0845(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthCameraAlphaMin;                              // 0x0848(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthCameraAlphaMax;                              // 0x084C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bUseCameraLagSubstepping : 1;                      // 0x0850(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_851[0x3];                                      // 0x0851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagMaxTimeStep;                              // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePawnControlRotation : 1;                       // 0x085C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritPitch : 1;                                 // 0x085C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritYaw : 1;                                   // 0x085C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritRoll : 1;                                  // 0x085C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85D[0x3];                                      // 0x085D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagMaxDistance;                              // 0x0860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagSpeed;                                    // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x0868(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ProbeChannel;                                      // 0x0874(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_875[0x3];                                      // 0x0875(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProbeSize;                                         // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x087C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableCameraLag : 1;                              // 0x0888(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCameraRotationLag : 1;                      // 0x0888(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoCollisionTest : 1;                              // 0x0888(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_889[0xC7];                                     // 0x0889(0x00C7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveFakeLocation();
	void ResetCamera();
	void SetFakeLocation(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTPSCamera">();
	}
	static class ARCTPSCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTPSCamera>();
	}
};
static_assert(alignof(ARCTPSCamera) == 0x000010, "Wrong alignment on ARCTPSCamera");
static_assert(sizeof(ARCTPSCamera) == 0x000950, "Wrong size on ARCTPSCamera");
static_assert(offsetof(ARCTPSCamera, OffsetX) == 0x0007F0, "Member 'ARCTPSCamera::OffsetX' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, OffsetY) == 0x0007F4, "Member 'ARCTPSCamera::OffsetY' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, OffsetZ) == 0x0007F8, "Member 'ARCTPSCamera::OffsetZ' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, bLimitCheck) == 0x0007FC, "Member 'ARCTPSCamera::bLimitCheck' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, bAngleCharacter) == 0x0007FD, "Member 'ARCTPSCamera::bAngleCharacter' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, Height) == 0x000800, "Member 'ARCTPSCamera::Height' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, Angle) == 0x000804, "Member 'ARCTPSCamera::Angle' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, VerticalAngle) == 0x000808, "Member 'ARCTPSCamera::VerticalAngle' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, Length) == 0x00080C, "Member 'ARCTPSCamera::Length' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LengthSpeed) == 0x000810, "Member 'ARCTPSCamera::LengthSpeed' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, FOV) == 0x000814, "Member 'ARCTPSCamera::FOV' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LimitVerticalAngleMin) == 0x000818, "Member 'ARCTPSCamera::LimitVerticalAngleMin' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LimitVerticalAngleMax) == 0x00081C, "Member 'ARCTPSCamera::LimitVerticalAngleMax' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LimitLengthMin) == 0x000820, "Member 'ARCTPSCamera::LimitLengthMin' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LimitLengthMax) == 0x000824, "Member 'ARCTPSCamera::LimitLengthMax' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, FakeLocation) == 0x000828, "Member 'ARCTPSCamera::FakeLocation' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, bUseFake) == 0x000834, "Member 'ARCTPSCamera::bUseFake' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, bLockMove) == 0x000835, "Member 'ARCTPSCamera::bLockMove' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, OFFsetRot) == 0x000838, "Member 'ARCTPSCamera::OFFsetRot' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, AutoSpeed) == 0x000840, "Member 'ARCTPSCamera::AutoSpeed' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, bLengthCameraAlphaEnable) == 0x000844, "Member 'ARCTPSCamera::bLengthCameraAlphaEnable' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LengthCameraAlphaMin) == 0x000848, "Member 'ARCTPSCamera::LengthCameraAlphaMin' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, LengthCameraAlphaMax) == 0x00084C, "Member 'ARCTPSCamera::LengthCameraAlphaMax' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, CameraLagMaxTimeStep) == 0x000854, "Member 'ARCTPSCamera::CameraLagMaxTimeStep' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, CameraRotationLagSpeed) == 0x000858, "Member 'ARCTPSCamera::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, CameraLagMaxDistance) == 0x000860, "Member 'ARCTPSCamera::CameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, CameraLagSpeed) == 0x000864, "Member 'ARCTPSCamera::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, SocketOffset) == 0x000868, "Member 'ARCTPSCamera::SocketOffset' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, ProbeChannel) == 0x000874, "Member 'ARCTPSCamera::ProbeChannel' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, ProbeSize) == 0x000878, "Member 'ARCTPSCamera::ProbeSize' has a wrong offset!");
static_assert(offsetof(ARCTPSCamera, TargetOffset) == 0x00087C, "Member 'ARCTPSCamera::TargetOffset' has a wrong offset!");

// Class RC.RCShinigamiAIMove
// 0x0080 (0x00A8 - 0x0028)
class URCShinigamiAIMove final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PlayerActor;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCShinigamiAICommandTrigger*           AiCommandTrigger;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCShinigamiAIMoveArea*                 AIMoveArea;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveHiSpeedLength;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PlayerCenterOffset;                                // 0x007C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerRadius;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMin;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMax;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerCollisionLength;                             // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveNearLength;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTime;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiAiMoveType                        AiMoveType;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIMove">();
	}
	static class URCShinigamiAIMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAIMove>();
	}
};
static_assert(alignof(URCShinigamiAIMove) == 0x000008, "Wrong alignment on URCShinigamiAIMove");
static_assert(sizeof(URCShinigamiAIMove) == 0x0000A8, "Wrong size on URCShinigamiAIMove");
static_assert(offsetof(URCShinigamiAIMove, ShinigamiActor) == 0x000050, "Member 'URCShinigamiAIMove::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, PlayerActor) == 0x000058, "Member 'URCShinigamiAIMove::PlayerActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, Movement) == 0x000060, "Member 'URCShinigamiAIMove::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AiCommandTrigger) == 0x000068, "Member 'URCShinigamiAIMove::AiCommandTrigger' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AIMoveArea) == 0x000070, "Member 'URCShinigamiAIMove::AIMoveArea' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, MoveHiSpeedLength) == 0x000078, "Member 'URCShinigamiAIMove::MoveHiSpeedLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, PlayerCenterOffset) == 0x00007C, "Member 'URCShinigamiAIMove::PlayerCenterOffset' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, PlayerRadius) == 0x000088, "Member 'URCShinigamiAIMove::PlayerRadius' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AiWaitTimeMin) == 0x00008C, "Member 'URCShinigamiAIMove::AiWaitTimeMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AiWaitTimeMax) == 0x000090, "Member 'URCShinigamiAIMove::AiWaitTimeMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, PlayerCollisionLength) == 0x000094, "Member 'URCShinigamiAIMove::PlayerCollisionLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, MoveNearLength) == 0x000098, "Member 'URCShinigamiAIMove::MoveNearLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AiWaitTime) == 0x00009C, "Member 'URCShinigamiAIMove::AiWaitTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, AiMoveType) == 0x0000A0, "Member 'URCShinigamiAIMove::AiMoveType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIMove, bDebugDraw) == 0x0000A1, "Member 'URCShinigamiAIMove::bDebugDraw' has a wrong offset!");

// Class RC.RCAttachmentAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class URCAttachmentAnimInstance final : public URCAnimInstance
{
public:
	struct FRCAttachmentMotionSlotData            SlotData;                                          // 0x02B8(0x0003)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAttachmentAnimInstance">();
	}
	static class URCAttachmentAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAttachmentAnimInstance>();
	}
};
static_assert(alignof(URCAttachmentAnimInstance) == 0x000010, "Wrong alignment on URCAttachmentAnimInstance");
static_assert(sizeof(URCAttachmentAnimInstance) == 0x0002C0, "Wrong size on URCAttachmentAnimInstance");
static_assert(offsetof(URCAttachmentAnimInstance, SlotData) == 0x0002B8, "Member 'URCAttachmentAnimInstance::SlotData' has a wrong offset!");

// Class RC.RCRealPlayerController
// 0x0218 (0x07B8 - 0x05A0)
class ARCRealPlayerController : public ARCPlayerController
{
public:
	uint8                                         Pad_5A0[0x18];                                     // 0x05A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterName;                                     // 0x05B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x20];                                     // 0x05C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRun;                                          // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedWalk;                                         // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedTrain;                                        // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedYoromeki;                                     // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTpsCameraEnable;                                  // 0x05F0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x7];                                      // 0x05F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     CharacterBase;                                     // 0x05F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCCharacterProxy*                      CharacterProxy;                                    // 0x0600(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCRealPlayerGameMode                         RealPlayerGameMode;                                // 0x0608(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCResearchVisionTimeMode                     ResearchVisionTimeMode;                            // 0x0609(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCRealPlayerControllerReturnType             ReturnType;                                        // 0x060A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60B[0x1];                                      // 0x060B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpotSelectQuestionTextID;                          // 0x060C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastSelectIndex;                                   // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastPlayerStartName;                               // 0x0618(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastPlayerStartPosition;                           // 0x0620(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInputMove;                                  // 0x062C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeCamera;                                     // 0x062D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserchExit;                                      // 0x062E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserchMinimap;                                   // 0x062F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserchVisionChange;                              // 0x0630(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHudDraw;                                          // 0x0631(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartMenuCollection;                              // 0x0632(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEventTrigger;                                   // 0x0633(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMove;                                             // 0x0634(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputYaw;                                          // 0x0638(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveYaw;                                           // 0x063C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastMoveScale;                                     // 0x0640(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed;                                          // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkSpeed;                                         // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedScale;                                     // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCPlayerMoveSpeedType                        MoveSpeedType;                                     // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWalk;                                             // 0x0651(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRun;                                              // 0x0652(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunPadPressed;                                    // 0x0653(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopTimeSec;                                       // 0x0654(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveButtonSkip;                                   // 0x0658(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_659[0x3];                                      // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayTimeSec;                                       // 0x065C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetSpeed;                                         // 0x0660(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_661[0x3];                                      // 0x0661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveInputTime;                                     // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveInputElapsedTime;                              // 0x0668(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurn;                                             // 0x066C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66D[0x3];                                      // 0x066D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TurnDirection;                                     // 0x0670(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSplash;                                        // 0x067C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67D[0x3];                                      // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterLigthActor*                 ToonDirectionalLight;                              // 0x0680(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToonDirectionalLightInit;                         // 0x0688(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToonDirectionalLightOverwrite;                    // 0x0689(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68A[0x6];                                      // 0x068A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ToonDirectionalLightEventFollowCameraActor;        // 0x0690(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ToonDirectionalLightEventRotatorOffset;            // 0x0698(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               ToonDirectionalLightSeqOffset;                     // 0x06A4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ToonDirectionalLightNextLocation;                  // 0x06B0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ToonDirectionalLightNextRotator;                   // 0x06BC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSwitchCameraToonDirectionalLight;                 // 0x06C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C9[0x7];                                      // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCRainMaker*                           RCRainMaker;                                       // 0x06D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveTickMax;                                       // 0x06D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveTick;                                          // 0x06DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovePositionLength;                                // 0x06E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E4[0x4];                                      // 0x06E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCPlayerMoveInfo>              MovePositionList;                                  // 0x06E8(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsButtonADVResearchExit;                          // 0x06F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsButtonADVHolding;                               // 0x06F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsButtonADVTalk;                                  // 0x06FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FB[0x5];                                      // 0x06FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCEventActorInfo                      AutoPlayTargetActor;                               // 0x0700(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCEventActorInfo                      AutoPlayAccessActor;                               // 0x0718(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                AutoPlayTargetPosition;                            // 0x0730(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AutoPlayOldPosition;                               // 0x073C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AutoPlayStackCount;                                // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoPlayStackWarp;                                // 0x074C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugScriptDraw;                                  // 0x074D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74E[0x2];                                      // 0x074E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccessLength;                                      // 0x0750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkCharacterName;                                 // 0x0754(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CheckActorName;                                    // 0x075C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BaloonCharacterNameList;                           // 0x0768(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           CheckNameActorNameList;                            // 0x0778(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class ARCBoatPawn*                            Boat;                                              // 0x0788(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoatSuspended;                                     // 0x0790(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_791[0x17];                                     // 0x0791(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugPositionDraw;                                // 0x07A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A9[0x3];                                      // 0x07A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugPositionLength;                               // 0x07AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugPositionHeight;                               // 0x07B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugPositionAngle;                                // 0x07B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ARCBoatPawn* GetBoat();
	class ARCCharacterRender* GetCharacter();
	class FName GetLastPlayerStartName();
	class ARCRainMaker* GetRainMaker();
	ERCRealPlayerGameMode GetRealPlayerGameMode();
	ERCResearchVisionTimeMode GetResearchVisionTimeMode();
	bool IsInputFlag();
	bool IsPlayerActor(class AActor* InActor);
	bool IsPlayerReady();
	bool IsReserchExitFlag();
	bool IsReserchMinimapFlag();
	bool IsReserchVisionChangeFlag();
	void Reset();
	void Respawn();
	void RestartPlay();
	void SetBoatEnabled(bool Enable, class ARCBoatPawn* BoatPawn);
	void SetCharacterName(class FName InCharacterName);
	void SetDebugScriptDraw(bool bDraw);
	void SetInputFlag(bool bFlag);
	void SetLastPlayerStartName(class FName InPlayerStartName);
	void SetMoveSpeedType(ERCPlayerMoveSpeedType InSpeedType);
	void SetNextToonDirectionalLightPosition(const struct FVector& InLocation, const struct FRotator& InRotator, bool bForce);
	void SetRainDraw(bool flag);
	void SetRealPlayerGameMode(ERCRealPlayerGameMode InGameMode);
	void SetResearchVisionTimeMode(ERCResearchVisionTimeMode InTimeMode);
	void SetReserchExitFlag(bool bFlag);
	void SetReserchMinimapFlag(bool bFlag);
	void SetReserchVisionChangeFlag(bool bFlag);
	void SetSpotSelectQuestionTextID(class FName InSpotSelectQuestionTextID);
	void SetStartMenuCollection(bool bInStartMenuCollection);
	void StartPlay(ERCRealPlayerGameMode InGameMode);

	bool GetBoatSuspended() const;
	class ARCCharacterLigthActor* GetToonDirectionalLightActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealPlayerController">();
	}
	static class ARCRealPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealPlayerController>();
	}
};
static_assert(alignof(ARCRealPlayerController) == 0x000008, "Wrong alignment on ARCRealPlayerController");
static_assert(sizeof(ARCRealPlayerController) == 0x0007B8, "Wrong size on ARCRealPlayerController");
static_assert(offsetof(ARCRealPlayerController, CharacterName) == 0x0005B8, "Member 'ARCRealPlayerController::CharacterName' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, SpeedRun) == 0x0005E0, "Member 'ARCRealPlayerController::SpeedRun' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, SpeedWalk) == 0x0005E4, "Member 'ARCRealPlayerController::SpeedWalk' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, SpeedTrain) == 0x0005E8, "Member 'ARCRealPlayerController::SpeedTrain' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, SpeedYoromeki) == 0x0005EC, "Member 'ARCRealPlayerController::SpeedYoromeki' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bTpsCameraEnable) == 0x0005F0, "Member 'ARCRealPlayerController::bTpsCameraEnable' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, CharacterBase) == 0x0005F8, "Member 'ARCRealPlayerController::CharacterBase' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, CharacterProxy) == 0x000600, "Member 'ARCRealPlayerController::CharacterProxy' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, RealPlayerGameMode) == 0x000608, "Member 'ARCRealPlayerController::RealPlayerGameMode' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ResearchVisionTimeMode) == 0x000609, "Member 'ARCRealPlayerController::ResearchVisionTimeMode' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ReturnType) == 0x00060A, "Member 'ARCRealPlayerController::ReturnType' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, SpotSelectQuestionTextID) == 0x00060C, "Member 'ARCRealPlayerController::SpotSelectQuestionTextID' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, LastSelectIndex) == 0x000614, "Member 'ARCRealPlayerController::LastSelectIndex' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, LastPlayerStartName) == 0x000618, "Member 'ARCRealPlayerController::LastPlayerStartName' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, LastPlayerStartPosition) == 0x000620, "Member 'ARCRealPlayerController::LastPlayerStartPosition' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bEnableInputMove) == 0x00062C, "Member 'ARCRealPlayerController::bEnableInputMove' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bChangeCamera) == 0x00062D, "Member 'ARCRealPlayerController::bChangeCamera' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bReserchExit) == 0x00062E, "Member 'ARCRealPlayerController::bReserchExit' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bReserchMinimap) == 0x00062F, "Member 'ARCRealPlayerController::bReserchMinimap' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bReserchVisionChange) == 0x000630, "Member 'ARCRealPlayerController::bReserchVisionChange' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bHudDraw) == 0x000631, "Member 'ARCRealPlayerController::bHudDraw' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bStartMenuCollection) == 0x000632, "Member 'ARCRealPlayerController::bStartMenuCollection' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bIsEventTrigger) == 0x000633, "Member 'ARCRealPlayerController::bIsEventTrigger' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bMove) == 0x000634, "Member 'ARCRealPlayerController::bMove' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, InputYaw) == 0x000638, "Member 'ARCRealPlayerController::InputYaw' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveYaw) == 0x00063C, "Member 'ARCRealPlayerController::MoveYaw' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, LastMoveScale) == 0x000640, "Member 'ARCRealPlayerController::LastMoveScale' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, RunSpeed) == 0x000644, "Member 'ARCRealPlayerController::RunSpeed' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, WalkSpeed) == 0x000648, "Member 'ARCRealPlayerController::WalkSpeed' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MaxSpeedScale) == 0x00064C, "Member 'ARCRealPlayerController::MaxSpeedScale' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveSpeedType) == 0x000650, "Member 'ARCRealPlayerController::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bWalk) == 0x000651, "Member 'ARCRealPlayerController::bWalk' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bRun) == 0x000652, "Member 'ARCRealPlayerController::bRun' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bRunPadPressed) == 0x000653, "Member 'ARCRealPlayerController::bRunPadPressed' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, StopTimeSec) == 0x000654, "Member 'ARCRealPlayerController::StopTimeSec' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bMoveButtonSkip) == 0x000658, "Member 'ARCRealPlayerController::bMoveButtonSkip' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, PlayTimeSec) == 0x00065C, "Member 'ARCRealPlayerController::PlayTimeSec' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bSetSpeed) == 0x000660, "Member 'ARCRealPlayerController::bSetSpeed' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveInputTime) == 0x000664, "Member 'ARCRealPlayerController::MoveInputTime' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveInputElapsedTime) == 0x000668, "Member 'ARCRealPlayerController::MoveInputElapsedTime' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bTurn) == 0x00066C, "Member 'ARCRealPlayerController::bTurn' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, TurnDirection) == 0x000670, "Member 'ARCRealPlayerController::TurnDirection' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bUseSplash) == 0x00067C, "Member 'ARCRealPlayerController::bUseSplash' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLight) == 0x000680, "Member 'ARCRealPlayerController::ToonDirectionalLight' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bToonDirectionalLightInit) == 0x000688, "Member 'ARCRealPlayerController::bToonDirectionalLightInit' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bToonDirectionalLightOverwrite) == 0x000689, "Member 'ARCRealPlayerController::bToonDirectionalLightOverwrite' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLightEventFollowCameraActor) == 0x000690, "Member 'ARCRealPlayerController::ToonDirectionalLightEventFollowCameraActor' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLightEventRotatorOffset) == 0x000698, "Member 'ARCRealPlayerController::ToonDirectionalLightEventRotatorOffset' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLightSeqOffset) == 0x0006A4, "Member 'ARCRealPlayerController::ToonDirectionalLightSeqOffset' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLightNextLocation) == 0x0006B0, "Member 'ARCRealPlayerController::ToonDirectionalLightNextLocation' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, ToonDirectionalLightNextRotator) == 0x0006BC, "Member 'ARCRealPlayerController::ToonDirectionalLightNextRotator' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bSwitchCameraToonDirectionalLight) == 0x0006C8, "Member 'ARCRealPlayerController::bSwitchCameraToonDirectionalLight' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, RCRainMaker) == 0x0006D0, "Member 'ARCRealPlayerController::RCRainMaker' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveTickMax) == 0x0006D8, "Member 'ARCRealPlayerController::MoveTickMax' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MoveTick) == 0x0006DC, "Member 'ARCRealPlayerController::MoveTick' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MovePositionLength) == 0x0006E0, "Member 'ARCRealPlayerController::MovePositionLength' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, MovePositionList) == 0x0006E8, "Member 'ARCRealPlayerController::MovePositionList' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bIsButtonADVResearchExit) == 0x0006F8, "Member 'ARCRealPlayerController::bIsButtonADVResearchExit' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bIsButtonADVHolding) == 0x0006F9, "Member 'ARCRealPlayerController::bIsButtonADVHolding' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bIsButtonADVTalk) == 0x0006FA, "Member 'ARCRealPlayerController::bIsButtonADVTalk' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AutoPlayTargetActor) == 0x000700, "Member 'ARCRealPlayerController::AutoPlayTargetActor' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AutoPlayAccessActor) == 0x000718, "Member 'ARCRealPlayerController::AutoPlayAccessActor' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AutoPlayTargetPosition) == 0x000730, "Member 'ARCRealPlayerController::AutoPlayTargetPosition' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AutoPlayOldPosition) == 0x00073C, "Member 'ARCRealPlayerController::AutoPlayOldPosition' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AutoPlayStackCount) == 0x000748, "Member 'ARCRealPlayerController::AutoPlayStackCount' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bAutoPlayStackWarp) == 0x00074C, "Member 'ARCRealPlayerController::bAutoPlayStackWarp' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bDebugScriptDraw) == 0x00074D, "Member 'ARCRealPlayerController::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, AccessLength) == 0x000750, "Member 'ARCRealPlayerController::AccessLength' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, TalkCharacterName) == 0x000754, "Member 'ARCRealPlayerController::TalkCharacterName' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, CheckActorName) == 0x00075C, "Member 'ARCRealPlayerController::CheckActorName' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, BaloonCharacterNameList) == 0x000768, "Member 'ARCRealPlayerController::BaloonCharacterNameList' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, CheckNameActorNameList) == 0x000778, "Member 'ARCRealPlayerController::CheckNameActorNameList' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, Boat) == 0x000788, "Member 'ARCRealPlayerController::Boat' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, BoatSuspended) == 0x000790, "Member 'ARCRealPlayerController::BoatSuspended' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, bDebugPositionDraw) == 0x0007A8, "Member 'ARCRealPlayerController::bDebugPositionDraw' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, DebugPositionLength) == 0x0007AC, "Member 'ARCRealPlayerController::DebugPositionLength' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, DebugPositionHeight) == 0x0007B0, "Member 'ARCRealPlayerController::DebugPositionHeight' has a wrong offset!");
static_assert(offsetof(ARCRealPlayerController, DebugPositionAngle) == 0x0007B4, "Member 'ARCRealPlayerController::DebugPositionAngle' has a wrong offset!");

// Class RC.RCAttachmentBFL
// 0x0000 (0x0028 - 0x0028)
class URCAttachmentBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeLightColor(class AActor* InActor, const struct FLinearColor& InAmbientColor, const struct FLinearColor& InDirectionalColor);
	static class AActor* GetAttachmentActor(const class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCAttachmentBFL">();
	}
	static class URCAttachmentBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCAttachmentBFL>();
	}
};
static_assert(alignof(URCAttachmentBFL) == 0x000008, "Wrong alignment on URCAttachmentBFL");
static_assert(sizeof(URCAttachmentBFL) == 0x000028, "Wrong size on URCAttachmentBFL");

// Class RC.RCStairwayVolumeSubLevelScriptActor
// 0x0050 (0x0278 - 0x0228)
class ARCStairwayVolumeSubLevelScriptActor final : public ALevelScriptActor
{
public:
	uint8                                         Pad_228[0x50];                                     // 0x0228(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCStairwayVolumeSubLevelScriptActor">();
	}
	static class ARCStairwayVolumeSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCStairwayVolumeSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCStairwayVolumeSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCStairwayVolumeSubLevelScriptActor");
static_assert(sizeof(ARCStairwayVolumeSubLevelScriptActor) == 0x000278, "Wrong size on ARCStairwayVolumeSubLevelScriptActor");

// Class RC.RCBgActor
// 0x0008 (0x0290 - 0x0288)
class ARCBgActor : public ARCActor
{
public:
	bool                                          bDebugDraw;                                        // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgActor">();
	}
	static class ARCBgActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCBgActor>();
	}
};
static_assert(alignof(ARCBgActor) == 0x000008, "Wrong alignment on ARCBgActor");
static_assert(sizeof(ARCBgActor) == 0x000290, "Wrong size on ARCBgActor");
static_assert(offsetof(ARCBgActor, bDebugDraw) == 0x000288, "Member 'ARCBgActor::bDebugDraw' has a wrong offset!");

// Class RC.RCBgActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCBgActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCBgActor* GetBgActor(class FName InBgActorName);
	static bool IsVisibility(class FName InBgActorName);
	static void SetVisibility(class FName InBgActorName, bool bVisibleFlag);
	static void SetVisibles(const class FString& InActorName, bool bInVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgActorBFL">();
	}
	static class URCBgActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBgActorBFL>();
	}
};
static_assert(alignof(URCBgActorBFL) == 0x000008, "Wrong alignment on URCBgActorBFL");
static_assert(sizeof(URCBgActorBFL) == 0x000028, "Wrong size on URCBgActorBFL");

// Class RC.RCMorphBlender
// 0x00E0 (0x0108 - 0x0028)
class URCMorphBlender : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FacialCharacterId;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  MorphTargetEnum;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERCCharacterMorphTarget, int32>          EnumMapper;                                        // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           Dict;                                              // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMorphBlender">();
	}
	static class URCMorphBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMorphBlender>();
	}
};
static_assert(alignof(URCMorphBlender) == 0x000008, "Wrong alignment on URCMorphBlender");
static_assert(sizeof(URCMorphBlender) == 0x000108, "Wrong size on URCMorphBlender");
static_assert(offsetof(URCMorphBlender, TargetMesh) == 0x000030, "Member 'URCMorphBlender::TargetMesh' has a wrong offset!");
static_assert(offsetof(URCMorphBlender, FacialCharacterId) == 0x000058, "Member 'URCMorphBlender::FacialCharacterId' has a wrong offset!");
static_assert(offsetof(URCMorphBlender, MorphTargetEnum) == 0x000080, "Member 'URCMorphBlender::MorphTargetEnum' has a wrong offset!");
static_assert(offsetof(URCMorphBlender, EnumMapper) == 0x000098, "Member 'URCMorphBlender::EnumMapper' has a wrong offset!");
static_assert(offsetof(URCMorphBlender, Dict) == 0x0000E8, "Member 'URCMorphBlender::Dict' has a wrong offset!");

// Class RC.RCShinigamiMorphBlender
// 0x0000 (0x0108 - 0x0108)
class URCShinigamiMorphBlender final : public URCMorphBlender
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiMorphBlender">();
	}
	static class URCShinigamiMorphBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiMorphBlender>();
	}
};
static_assert(alignof(URCShinigamiMorphBlender) == 0x000008, "Wrong alignment on URCShinigamiMorphBlender");
static_assert(sizeof(URCShinigamiMorphBlender) == 0x000108, "Wrong size on URCShinigamiMorphBlender");

// Class RC.RCBgActorManager
// 0x0010 (0x0038 - 0x0028)
class URCBgActorManager final : public UObject
{
public:
	TArray<class ARCBgActor*>                     BgActorList;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgActorManager">();
	}
	static class URCBgActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBgActorManager>();
	}
};
static_assert(alignof(URCBgActorManager) == 0x000008, "Wrong alignment on URCBgActorManager");
static_assert(sizeof(URCBgActorManager) == 0x000038, "Wrong size on URCBgActorManager");
static_assert(offsetof(URCBgActorManager, BgActorList) == 0x000028, "Member 'URCBgActorManager::BgActorList' has a wrong offset!");

// Class RC.RCNzCriminalQuestion
// 0x0028 (0x0300 - 0x02D8)
class URCNzCriminalQuestion final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      SpText_Question;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestionFontSize;                                  // 0x02F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalQuestion">();
	}
	static class URCNzCriminalQuestion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalQuestion>();
	}
};
static_assert(alignof(URCNzCriminalQuestion) == 0x000008, "Wrong alignment on URCNzCriminalQuestion");
static_assert(sizeof(URCNzCriminalQuestion) == 0x000300, "Wrong size on URCNzCriminalQuestion");
static_assert(offsetof(URCNzCriminalQuestion, SpText_Question) == 0x0002D8, "Member 'URCNzCriminalQuestion::SpText_Question' has a wrong offset!");
static_assert(offsetof(URCNzCriminalQuestion, QuestionFontSize) == 0x0002F8, "Member 'URCNzCriminalQuestion::QuestionFontSize' has a wrong offset!");

// Class RC.RCBgActorTickEnable
// 0x0000 (0x0290 - 0x0290)
class ARCBgActorTickEnable final : public ARCBgActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgActorTickEnable">();
	}
	static class ARCBgActorTickEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCBgActorTickEnable>();
	}
};
static_assert(alignof(ARCBgActorTickEnable) == 0x000008, "Wrong alignment on ARCBgActorTickEnable");
static_assert(sizeof(ARCBgActorTickEnable) == 0x000290, "Wrong size on ARCBgActorTickEnable");

// Class RC.RCMenuManager
// 0x0018 (0x02F8 - 0x02E0)
class URCMenuManager : public URCMenuWidget
{
public:
	class UWidget*                                LastFocusedWidget;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusIntervalTime;                                 // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetKeyboardFocusOnPossible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuManager">();
	}
	static class URCMenuManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuManager>();
	}
};
static_assert(alignof(URCMenuManager) == 0x000008, "Wrong alignment on URCMenuManager");
static_assert(sizeof(URCMenuManager) == 0x0002F8, "Wrong size on URCMenuManager");
static_assert(offsetof(URCMenuManager, LastFocusedWidget) == 0x0002E0, "Member 'URCMenuManager::LastFocusedWidget' has a wrong offset!");
static_assert(offsetof(URCMenuManager, FocusIntervalTime) == 0x0002F0, "Member 'URCMenuManager::FocusIntervalTime' has a wrong offset!");

// Class RC.RCTItleSubStoryList
// 0x0058 (0x0350 - 0x02F8)
class URCTItleSubStoryList : public URCMenuManager
{
public:
	TArray<class URCTitleSubStoryListItemSwitch*> switchArray;                                       // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URCTitleSubStoryListItemSwitch*> useSwitchArray;                                    // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<int32>                                 ChapterIDArray;                                    // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class USpUIScrollBox*                         ScrollBox;                                         // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           verticalListBox;                                   // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         dispTopIndex;                                      // 0x0338(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x033C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         scrollSize;                                        // 0x0344(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isChangeSelectIndex;                               // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         enableListMax;                                     // 0x034C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UWidget* SubStoryListSelectNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTItleSubStoryList">();
	}
	static class URCTItleSubStoryList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTItleSubStoryList>();
	}
};
static_assert(alignof(URCTItleSubStoryList) == 0x000008, "Wrong alignment on URCTItleSubStoryList");
static_assert(sizeof(URCTItleSubStoryList) == 0x000350, "Wrong size on URCTItleSubStoryList");
static_assert(offsetof(URCTItleSubStoryList, switchArray) == 0x0002F8, "Member 'URCTItleSubStoryList::switchArray' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, useSwitchArray) == 0x000308, "Member 'URCTItleSubStoryList::useSwitchArray' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, ChapterIDArray) == 0x000318, "Member 'URCTItleSubStoryList::ChapterIDArray' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, ScrollBox) == 0x000328, "Member 'URCTItleSubStoryList::ScrollBox' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, verticalListBox) == 0x000330, "Member 'URCTItleSubStoryList::verticalListBox' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, dispTopIndex) == 0x000338, "Member 'URCTItleSubStoryList::dispTopIndex' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, SelectIndex) == 0x00033C, "Member 'URCTItleSubStoryList::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, bListLoop) == 0x000340, "Member 'URCTItleSubStoryList::bListLoop' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, scrollSize) == 0x000344, "Member 'URCTItleSubStoryList::scrollSize' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, isChangeSelectIndex) == 0x000348, "Member 'URCTItleSubStoryList::isChangeSelectIndex' has a wrong offset!");
static_assert(offsetof(URCTItleSubStoryList, enableListMax) == 0x00034C, "Member 'URCTItleSubStoryList::enableListMax' has a wrong offset!");

// Class RC.RCBgBFL
// 0x0000 (0x0028 - 0x0028)
class URCBgBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsMapIDEquale(class FName InMapID1, class FName InMapID2);
	static bool IsSyncSubLevel();
	static bool LoadAllEventSetting(int32 InChapterNum, class FName InSceneNum, class FName InMapID);
	static bool StartUnLoadSubLevelList(bool bLoadingDraw, bool bPlayerMove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgBFL">();
	}
	static class URCBgBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBgBFL>();
	}
};
static_assert(alignof(URCBgBFL) == 0x000008, "Wrong alignment on URCBgBFL");
static_assert(sizeof(URCBgBFL) == 0x000028, "Wrong size on URCBgBFL");

// Class RC.RCTipsManager
// 0x0020 (0x0048 - 0x0028)
class URCTipsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTipsInfo>                      TipsDrawList;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTipsManager">();
	}
	static class URCTipsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTipsManager>();
	}
};
static_assert(alignof(URCTipsManager) == 0x000008, "Wrong alignment on URCTipsManager");
static_assert(sizeof(URCTipsManager) == 0x000048, "Wrong size on URCTipsManager");
static_assert(offsetof(URCTipsManager, TipsDrawList) == 0x000038, "Member 'URCTipsManager::TipsDrawList' has a wrong offset!");

// Class RC.RCLevelScriptActor
// 0x0058 (0x0280 - 0x0228)
class ARCLevelScriptActor : public ALevelScriptActor
{
public:
	TMap<class FName, TSubclassOf<class UObject>> LoadedAssets;                                      // 0x0228(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bParsistant;                                       // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadAssets(const TArray<TSoftClassPtr<class UClass>>& InAssets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLevelScriptActor">();
	}
	static class ARCLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCLevelScriptActor>();
	}
};
static_assert(alignof(ARCLevelScriptActor) == 0x000008, "Wrong alignment on ARCLevelScriptActor");
static_assert(sizeof(ARCLevelScriptActor) == 0x000280, "Wrong size on ARCLevelScriptActor");
static_assert(offsetof(ARCLevelScriptActor, LoadedAssets) == 0x000228, "Member 'ARCLevelScriptActor::LoadedAssets' has a wrong offset!");
static_assert(offsetof(ARCLevelScriptActor, bParsistant) == 0x000278, "Member 'ARCLevelScriptActor::bParsistant' has a wrong offset!");

// Class RC.RCEventTrigger
// 0x0078 (0x0300 - 0x0288)
class ARCEventTrigger : public ARCActor
{
public:
	bool                                          bDebugScriptDraw;                                  // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOtherPlayer;                                      // 0x0289(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OtherActorName;                                    // 0x028C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCollisionEnable;                                  // 0x0294(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisonPrisetName;                                // 0x0298(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCActorQuestType                             QuestType;                                         // 0x02A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestTitleName;                                    // 0x02A4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   VariableName;                                      // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VariableArrayNum;                                  // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VariableCheckNum;                                  // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JumpScriptLabelName;                               // 0x02BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CheckActorName;                                    // 0x02C4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInPlayer;                                         // 0x02CC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD[0x33];                                     // 0x02CD(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetOtherActorName();
	bool IsCollisionEnable();
	bool IsOtherPlayer();
	void OnActorBeginOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void SetCollisionEnable(bool bInEnable);
	void SetOtherActorName(class FName bName);
	void SetOtherPlayer(bool bInOtherPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTrigger">();
	}
	static class ARCEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEventTrigger>();
	}
};
static_assert(alignof(ARCEventTrigger) == 0x000008, "Wrong alignment on ARCEventTrigger");
static_assert(sizeof(ARCEventTrigger) == 0x000300, "Wrong size on ARCEventTrigger");
static_assert(offsetof(ARCEventTrigger, bDebugScriptDraw) == 0x000288, "Member 'ARCEventTrigger::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, bOtherPlayer) == 0x000289, "Member 'ARCEventTrigger::bOtherPlayer' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, OtherActorName) == 0x00028C, "Member 'ARCEventTrigger::OtherActorName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, bCollisionEnable) == 0x000294, "Member 'ARCEventTrigger::bCollisionEnable' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, CollisonPrisetName) == 0x000298, "Member 'ARCEventTrigger::CollisonPrisetName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, QuestType) == 0x0002A0, "Member 'ARCEventTrigger::QuestType' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, QuestTitleName) == 0x0002A4, "Member 'ARCEventTrigger::QuestTitleName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, VariableName) == 0x0002AC, "Member 'ARCEventTrigger::VariableName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, VariableArrayNum) == 0x0002B4, "Member 'ARCEventTrigger::VariableArrayNum' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, VariableCheckNum) == 0x0002B8, "Member 'ARCEventTrigger::VariableCheckNum' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, JumpScriptLabelName) == 0x0002BC, "Member 'ARCEventTrigger::JumpScriptLabelName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, CheckActorName) == 0x0002C4, "Member 'ARCEventTrigger::CheckActorName' has a wrong offset!");
static_assert(offsetof(ARCEventTrigger, bInPlayer) == 0x0002CC, "Member 'ARCEventTrigger::bInPlayer' has a wrong offset!");

// Class RC.RCEventTriggerCapsule
// 0x0018 (0x0318 - 0x0300)
class ARCEventTriggerCapsule final : public ARCEventTrigger
{
public:
	class USceneComponent*                        Scene;                                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0310(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x0314(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTriggerCapsule">();
	}
	static class ARCEventTriggerCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEventTriggerCapsule>();
	}
};
static_assert(alignof(ARCEventTriggerCapsule) == 0x000008, "Wrong alignment on ARCEventTriggerCapsule");
static_assert(sizeof(ARCEventTriggerCapsule) == 0x000318, "Wrong size on ARCEventTriggerCapsule");
static_assert(offsetof(ARCEventTriggerCapsule, Scene) == 0x000300, "Member 'ARCEventTriggerCapsule::Scene' has a wrong offset!");
static_assert(offsetof(ARCEventTriggerCapsule, CapsuleComp) == 0x000308, "Member 'ARCEventTriggerCapsule::CapsuleComp' has a wrong offset!");
static_assert(offsetof(ARCEventTriggerCapsule, HalfHeight) == 0x000310, "Member 'ARCEventTriggerCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(ARCEventTriggerCapsule, Radius) == 0x000314, "Member 'ARCEventTriggerCapsule::Radius' has a wrong offset!");

// Class RC.RCBgLevelScriptActor
// 0x0120 (0x03A0 - 0x0280)
class ARCBgLevelScriptActor : public ARCLevelScriptActor
{
public:
	class URCSubLevelLoad*                        SubLevelLoad;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCSubLevelLoad*                        AddSubLevelLoad;                                   // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCEventSubLevelList*                   EventSubLevelList;                                 // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCEventSubLevelList*                   EventCommonSubLevelList;                           // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCEventSubLevelList*                   EventSubQuestSubLevelList;                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCEventSubLevelList*                   EventCommonAddSubLevelList;                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventSubLevelListFilename;                         // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventCommonSubLevelListFilename;                   // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventSubQuestSubLevelListFilename;                 // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventCommonAddSubLevelListFilename;                // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapID;                                             // 0x02D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapIDLong;                                         // 0x02D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BgArea;                                            // 0x02E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BgMapNum;                                          // 0x02E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BgType;                                            // 0x02E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBgLoadReady;                                      // 0x02EC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x02ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleActor;                                     // 0x02EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bChangeSubLevel;                                   // 0x02EF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableChangeSubLevel;                            // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorHiddenList;                                   // 0x02F8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 MeshHiddenList;                                    // 0x0308(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                LightHiddenList;                                   // 0x0318(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x78];                                     // 0x0328(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableChangeSubLevel();
	int32 GetBgArea();
	class FName GetBgMapID();
	class FName GetBgMapIDLong();
	int32 GetBgMapNum();
	int32 GetBgType();
	bool GetCharacterSettingList(TArray<class FName>* OutCharacterSettingList, class FName InMapID, int32 InChapterNum, bool bCommonOnly);
	bool GetEventSettingList(TArray<class FName>* OutEventSettingList, TArray<class FName>* OutMapIDList, int32 InChapterNum, bool bCommonOnly);
	bool GetSubLevelList(TArray<class FName>* OutSubLevelList, class FName InMapID, bool bCommonOnly);
	bool IsEnableSubLevel();
	bool IsSyncSubLevel();
	bool IsVisibledSubLevel();
	bool LoadAllLevel(int32 InChapterNum, class FName InSceneNum, class FName InMapID, bool bCommonOnly);
	bool LoadEventSubLevelList(int32 InChapterNum, class FName InSceneNum, class FName InMapID, bool bCommonOnly);
	bool ReadyLoadBgListMapID(class FName InMapID);
	void ReleaseEventSubLevelList();
	void SetVisibility(bool bFlag, bool bIsActor);
	bool StartAddLoadSubLevelList(const TArray<class FName>& InSubLevelNameList, bool bLoadingDraw);
	bool StartLoadBgList(int32 Area, int32 MapNum, int32 Type, bool bLoadingDraw, bool bPlayerMove);
	bool StartLoadBgListMapID(class FName InMapID, bool bLoadingDraw, bool bPlayerMove);
	void StartLoadCommonSubLevel();
	bool StartLoadSubLevelList(const TArray<class FName>& InSubLevelNameList, bool bLoadingDraw, bool bPlayerMove);
	bool StartUnLoadSubLevelList(bool bLoadingDraw, bool bPlayerMove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBgLevelScriptActor">();
	}
	static class ARCBgLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCBgLevelScriptActor>();
	}
};
static_assert(alignof(ARCBgLevelScriptActor) == 0x000008, "Wrong alignment on ARCBgLevelScriptActor");
static_assert(sizeof(ARCBgLevelScriptActor) == 0x0003A0, "Wrong size on ARCBgLevelScriptActor");
static_assert(offsetof(ARCBgLevelScriptActor, SubLevelLoad) == 0x000280, "Member 'ARCBgLevelScriptActor::SubLevelLoad' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, AddSubLevelLoad) == 0x000288, "Member 'ARCBgLevelScriptActor::AddSubLevelLoad' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventSubLevelList) == 0x000290, "Member 'ARCBgLevelScriptActor::EventSubLevelList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventCommonSubLevelList) == 0x000298, "Member 'ARCBgLevelScriptActor::EventCommonSubLevelList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventSubQuestSubLevelList) == 0x0002A0, "Member 'ARCBgLevelScriptActor::EventSubQuestSubLevelList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventCommonAddSubLevelList) == 0x0002A8, "Member 'ARCBgLevelScriptActor::EventCommonAddSubLevelList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventSubLevelListFilename) == 0x0002B0, "Member 'ARCBgLevelScriptActor::EventSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventCommonSubLevelListFilename) == 0x0002B8, "Member 'ARCBgLevelScriptActor::EventCommonSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventSubQuestSubLevelListFilename) == 0x0002C0, "Member 'ARCBgLevelScriptActor::EventSubQuestSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, EventCommonAddSubLevelListFilename) == 0x0002C8, "Member 'ARCBgLevelScriptActor::EventCommonAddSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, MapID) == 0x0002D0, "Member 'ARCBgLevelScriptActor::MapID' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, MapIDLong) == 0x0002D8, "Member 'ARCBgLevelScriptActor::MapIDLong' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, BgArea) == 0x0002E0, "Member 'ARCBgLevelScriptActor::BgArea' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, BgMapNum) == 0x0002E4, "Member 'ARCBgLevelScriptActor::BgMapNum' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, BgType) == 0x0002E8, "Member 'ARCBgLevelScriptActor::BgType' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, bBgLoadReady) == 0x0002EC, "Member 'ARCBgLevelScriptActor::bBgLoadReady' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, bVisible) == 0x0002ED, "Member 'ARCBgLevelScriptActor::bVisible' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, bVisibleActor) == 0x0002EE, "Member 'ARCBgLevelScriptActor::bVisibleActor' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, bChangeSubLevel) == 0x0002EF, "Member 'ARCBgLevelScriptActor::bChangeSubLevel' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, bDisableChangeSubLevel) == 0x0002F0, "Member 'ARCBgLevelScriptActor::bDisableChangeSubLevel' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, ActorHiddenList) == 0x0002F8, "Member 'ARCBgLevelScriptActor::ActorHiddenList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, MeshHiddenList) == 0x000308, "Member 'ARCBgLevelScriptActor::MeshHiddenList' has a wrong offset!");
static_assert(offsetof(ARCBgLevelScriptActor, LightHiddenList) == 0x000318, "Member 'ARCBgLevelScriptActor::LightHiddenList' has a wrong offset!");

// Class RC.RCText3DMeshedComponent
// 0x0000 (0x0310 - 0x0310)
class URCText3DMeshedComponent final : public UText3DMeshedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCText3DMeshedComponent">();
	}
	static class URCText3DMeshedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCText3DMeshedComponent>();
	}
};
static_assert(alignof(URCText3DMeshedComponent) == 0x000010, "Wrong alignment on URCText3DMeshedComponent");
static_assert(sizeof(URCText3DMeshedComponent) == 0x000310, "Wrong size on URCText3DMeshedComponent");

// Class RC.RCBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
public:
	static void EndTipsScreen_Debug();
	static class FString GetSvnCommitDateRC();
	static class FString GetSvnCommitDateRCDev();
	static class FString GetSvnRevisionNumberRC();
	static class FString GetSvnRevisionNumberRCDev();
	static void InitLoadingScreen();
	static void InitRealLevelOpen();
	static bool IsAssetAllLoadComplete();
	static bool IsDevelopmentBuild();
	static bool IsDisableChangeSubLevel();
	static bool IsLoadComplete();
	static bool IsMapMoveNotRealPlChange();
	static bool IsOpenDebugMenu();
	static bool IsOpenSpUEDebugMenu();
	static bool IsPause();
	static bool IsPauseEnable();
	static bool IsRealSceneChangePLChange();
	static bool IsScreenFade();
	static bool IsScreenFadeOut();
	static bool IsScreenFadeTypeUi();
	static void SetLoadCompletePlayerWarp();
	static void SetLoadDisplayNum(int32 Num);
	static void SetPause(bool bInFlag);
	static void SetPauseEnable(bool bInFlag);
	static void SetPlayerPauseMoveTest(bool bInFlag);
	static bool StartLongLoadingScreen();
	static void StartNextSubLevel();
	static void StartSceneChange(ERCSceneChangeType Type);
	static void StartScreenFadeIn(float Duration);
	static void StartScreenFadeOut(float Duration, const struct FLinearColor& Color, ERCFadeType InType);
	static bool StartShortLoadingScreen();
	static void StartTipsScreen_Debug();
	static void StopLoadingScreen();
	static void ToggleDebugMenu();
	static void ToggleTipsScreenDebugPrintFlag_Debug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBlueprintFunctionLibrary">();
	}
	static class URCBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(URCBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on URCBlueprintFunctionLibrary");
static_assert(sizeof(URCBlueprintFunctionLibrary) == 0x000028, "Wrong size on URCBlueprintFunctionLibrary");

// Class RC.RCBoatBFL
// 0x0000 (0x0028 - 0x0028)
class URCBoatBFL final : public UBlueprintFunctionLibrary
{
public:
	static void Disemberk(bool OnlyFreeingControl);
	static class ARCCharacterScript* GetPassenger(class APawn* Boat, class FName Socket);
	static TArray<class ARCCharacterScript*> GetPassengers(class APawn* Boat);
	static void GoAboard(class APawn* Boat, class APawn* Driver);
	static bool GoAboard2(class APawn* Boat, class FName Socket, class ARCCharacterScript* Passenger, bool Player, bool Reset);
	static class APawn* Pause();
	static void Resume(class APawn* Boat);
	static bool TakePayload(class APawn* Boat, class FName Socket, class AActor* Passenger);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBoatBFL">();
	}
	static class URCBoatBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBoatBFL>();
	}
};
static_assert(alignof(URCBoatBFL) == 0x000008, "Wrong alignment on URCBoatBFL");
static_assert(sizeof(URCBoatBFL) == 0x000028, "Wrong size on URCBoatBFL");

// Class RC.RCManaComponent
// 0x0008 (0x02B0 - 0x02A8)
class URCManaComponent final : public UManaComponent
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCManaComponent">();
	}
	static class URCManaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCManaComponent>();
	}
};
static_assert(alignof(URCManaComponent) == 0x000008, "Wrong alignment on URCManaComponent");
static_assert(sizeof(URCManaComponent) == 0x0002B0, "Wrong size on URCManaComponent");

// Class RC.RCBoatPawn
// 0x0240 (0x0500 - 0x02C0)
class ARCBoatPawn final : public ARCPawn
{
public:
	uint8                                         Pad_2C0[0xD4];                                     // 0x02C0(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoseThreshold;                                     // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TailThreshold;                                     // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackSpeedCoeff;                                    // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedCoeff;                                    // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimpleTurnSpeedCoeff;                              // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Acceleration;                                      // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedStep1;                                        // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedStep2;                                        // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseSimulation;                                     // 0x03B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Heading;                                           // 0x03B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Velocity_;                                         // 0x03C4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Steering;                                          // 0x03D0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PreserveCamera;                                    // 0x03D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0xE];                                      // 0x03D2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PS_Shipwave;                                       // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PS_EngineSplash0;                                  // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PS_EngineSplash1;                                  // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PS_Splash;                                         // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANiagaraActor*                          NiagaraShipwave;                                   // 0x0400(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANiagaraActor*                          NiagaraSplash;                                     // 0x0408(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANiagaraActor*                          NiagaraEngineSplash0;                              // 0x0410(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANiagaraActor*                          NiagaraEngineSplash1;                              // 0x0418(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UAnimInstance>> CustomAnimBP_Binding;                              // 0x0420(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, class UAnimInstance*>       Prev_Binding;                                      // 0x0470(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x20];                                     // 0x04C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* Boat, int32 step)> SpeedstepDipatcher;                                // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Boat, ERCBoatAccelEventCode code, const struct FVector& Vec)> AccelDipatcher;                                    // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FVector GetNavigationHead();
	struct FVector GetNavigationVelocity();
	struct FVector GetNavigationVelocityNorm(float DeltaTime);
	float GetSimulationTick(float Tick);
	void OnCrash(bool DidSpawnEffect, const struct FVector& HitLoc, const struct FVector& head, const struct FVector& Velocity, float DeltaTime);
	void OnCrashed(class UPrimitiveComponent* Component, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& Normal, const struct FHitResult& HitResult);
	void OnNavigationUpdate(const struct FVector& head, const struct FVector& Velocity, float RotationDegrees, float DeltaTime);
	void OnReset(const struct FVector& head, const struct FVector& Velocity, float RotationDegrees);
	void OnThrottleDown(int32 step, const struct FVector& head, const struct FVector& Velocity, bool Forward, float DeltaTime);
	void OnThrottleUp(int32 step, const struct FVector& head, const struct FVector& Velocity, bool Forward, float DeltaTime);
	void SetSteering(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBoatPawn">();
	}
	static class ARCBoatPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCBoatPawn>();
	}
};
static_assert(alignof(ARCBoatPawn) == 0x000008, "Wrong alignment on ARCBoatPawn");
static_assert(sizeof(ARCBoatPawn) == 0x000500, "Wrong size on ARCBoatPawn");
static_assert(offsetof(ARCBoatPawn, NoseThreshold) == 0x000394, "Member 'ARCBoatPawn::NoseThreshold' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, TailThreshold) == 0x000398, "Member 'ARCBoatPawn::TailThreshold' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, BackSpeedCoeff) == 0x00039C, "Member 'ARCBoatPawn::BackSpeedCoeff' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, TurnSpeedCoeff) == 0x0003A0, "Member 'ARCBoatPawn::TurnSpeedCoeff' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, SimpleTurnSpeedCoeff) == 0x0003A4, "Member 'ARCBoatPawn::SimpleTurnSpeedCoeff' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, Acceleration) == 0x0003A8, "Member 'ARCBoatPawn::Acceleration' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, SpeedStep1) == 0x0003AC, "Member 'ARCBoatPawn::SpeedStep1' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, SpeedStep2) == 0x0003B0, "Member 'ARCBoatPawn::SpeedStep2' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, UseSimulation) == 0x0003B4, "Member 'ARCBoatPawn::UseSimulation' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, Heading) == 0x0003B8, "Member 'ARCBoatPawn::Heading' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, Velocity_) == 0x0003C4, "Member 'ARCBoatPawn::Velocity_' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, Steering) == 0x0003D0, "Member 'ARCBoatPawn::Steering' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, PreserveCamera) == 0x0003D1, "Member 'ARCBoatPawn::PreserveCamera' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, PS_Shipwave) == 0x0003E0, "Member 'ARCBoatPawn::PS_Shipwave' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, PS_EngineSplash0) == 0x0003E8, "Member 'ARCBoatPawn::PS_EngineSplash0' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, PS_EngineSplash1) == 0x0003F0, "Member 'ARCBoatPawn::PS_EngineSplash1' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, PS_Splash) == 0x0003F8, "Member 'ARCBoatPawn::PS_Splash' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, NiagaraShipwave) == 0x000400, "Member 'ARCBoatPawn::NiagaraShipwave' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, NiagaraSplash) == 0x000408, "Member 'ARCBoatPawn::NiagaraSplash' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, NiagaraEngineSplash0) == 0x000410, "Member 'ARCBoatPawn::NiagaraEngineSplash0' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, NiagaraEngineSplash1) == 0x000418, "Member 'ARCBoatPawn::NiagaraEngineSplash1' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, CustomAnimBP_Binding) == 0x000420, "Member 'ARCBoatPawn::CustomAnimBP_Binding' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, Prev_Binding) == 0x000470, "Member 'ARCBoatPawn::Prev_Binding' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, SpeedstepDipatcher) == 0x0004E0, "Member 'ARCBoatPawn::SpeedstepDipatcher' has a wrong offset!");
static_assert(offsetof(ARCBoatPawn, AccelDipatcher) == 0x0004F0, "Member 'ARCBoatPawn::AccelDipatcher' has a wrong offset!");

// Class RC.RCTriggerCapsule
// 0x0000 (0x0228 - 0x0228)
class ARCTriggerCapsule final : public ATriggerCapsule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTriggerCapsule">();
	}
	static class ARCTriggerCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTriggerCapsule>();
	}
};
static_assert(alignof(ARCTriggerCapsule) == 0x000008, "Wrong alignment on ARCTriggerCapsule");
static_assert(sizeof(ARCTriggerCapsule) == 0x000228, "Wrong size on ARCTriggerCapsule");

// Class RC.RCRealLevelScriptActor
// 0x00C8 (0x0468 - 0x03A0)
class ARCRealLevelScriptActor : public ARCBgLevelScriptActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCTPSCamera*                           TpsCameraActor;                                    // 0x03A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCLSADefautCameraStatus                      TpsCameraStatus;                                   // 0x03B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCRealEventSubLevelScriptActor*> EventSubLevelScriptActorList;                      // 0x03B8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventTalkSubLevelScriptActor*> EventTalkSubLevelScriptActorList;                  // 0x03C8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventCheckSubLevelScriptActor*> EventCheckSubLevelScriptActorList;                 // 0x03D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventShinigamiSubLevelScriptActor*> EventShinigamiSubLevelScriptActorList;             // 0x03E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventResearchExitSubLevelScriptActor*> EventResearchExitSubLevelScriptActorList;          // 0x03F8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventMapMoveSubLevelScriptActor*> EventMapMoveSubLevelScriptActorList;               // 0x0408(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventBusstopSubLevelScriptActor*> EventBusstopSubLevelScriptActorList;               // 0x0418(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCRealEventBusstopEventSubLevelScriptActor*> EventBusstopEventSubLevelScriptActorList;          // 0x0428(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	class FName                                   TalkCharacterName;                                 // 0x0438(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CheckActorName;                                    // 0x0440(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapMoveTriggerName;                                // 0x0448(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCGameMode                                   NextGameMode;                                      // 0x0450(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSubLevelLoadSync;                                 // 0x0451(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSubLevelLoadingWait;                              // 0x0452(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_453[0x5];                                      // 0x0453(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventNextLevel;                                  // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	ERCGameMode GetNextGameMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealLevelScriptActor">();
	}
	static class ARCRealLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealLevelScriptActor");
static_assert(sizeof(ARCRealLevelScriptActor) == 0x000468, "Wrong size on ARCRealLevelScriptActor");
static_assert(offsetof(ARCRealLevelScriptActor, TpsCameraActor) == 0x0003A8, "Member 'ARCRealLevelScriptActor::TpsCameraActor' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, TpsCameraStatus) == 0x0003B0, "Member 'ARCRealLevelScriptActor::TpsCameraStatus' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventSubLevelScriptActorList) == 0x0003B8, "Member 'ARCRealLevelScriptActor::EventSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventTalkSubLevelScriptActorList) == 0x0003C8, "Member 'ARCRealLevelScriptActor::EventTalkSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventCheckSubLevelScriptActorList) == 0x0003D8, "Member 'ARCRealLevelScriptActor::EventCheckSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventShinigamiSubLevelScriptActorList) == 0x0003E8, "Member 'ARCRealLevelScriptActor::EventShinigamiSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventResearchExitSubLevelScriptActorList) == 0x0003F8, "Member 'ARCRealLevelScriptActor::EventResearchExitSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventMapMoveSubLevelScriptActorList) == 0x000408, "Member 'ARCRealLevelScriptActor::EventMapMoveSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventBusstopSubLevelScriptActorList) == 0x000418, "Member 'ARCRealLevelScriptActor::EventBusstopSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, EventBusstopEventSubLevelScriptActorList) == 0x000428, "Member 'ARCRealLevelScriptActor::EventBusstopEventSubLevelScriptActorList' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, TalkCharacterName) == 0x000438, "Member 'ARCRealLevelScriptActor::TalkCharacterName' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, CheckActorName) == 0x000440, "Member 'ARCRealLevelScriptActor::CheckActorName' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, MapMoveTriggerName) == 0x000448, "Member 'ARCRealLevelScriptActor::MapMoveTriggerName' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, NextGameMode) == 0x000450, "Member 'ARCRealLevelScriptActor::NextGameMode' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, bSubLevelLoadSync) == 0x000451, "Member 'ARCRealLevelScriptActor::bSubLevelLoadSync' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, bSubLevelLoadingWait) == 0x000452, "Member 'ARCRealLevelScriptActor::bSubLevelLoadingWait' has a wrong offset!");
static_assert(offsetof(ARCRealLevelScriptActor, OnEventNextLevel) == 0x000458, "Member 'ARCRealLevelScriptActor::OnEventNextLevel' has a wrong offset!");

// Class RC.RCNazoLevelScriptActor
// 0x0250 (0x06B8 - 0x0468)
class ARCNazoLevelScriptActor : public ARCRealLevelScriptActor
{
public:
	uint8                                         Pad_468[0x2];                                      // 0x0468(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ERCNazoLSAState                               State;                                             // 0x046A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46B[0xD];                                      // 0x046B(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SceneSettingsDataTable;                            // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SceneSettingsDataTableBG;                          // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TileSettingsDataTableBG;                           // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        SceneSettingsDataTablePath;                        // 0x0490(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        SceneSettingsDataTableBGPath;                      // 0x04A8(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        SceneSettingsDataTableBGCommonPath;                // 0x04C0(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TileSettingsDataTableBGCommonPath;                 // 0x04D8(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MapListLevelPath;                                  // 0x04F0(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TileListLevelPath;                                 // 0x0508(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MapListCommonLevelPath;                            // 0x0520(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TileListCommonLevelPath;                           // 0x0538(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartSceneID;                                      // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartSceneIndex;                                   // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSceneTest;                                        // 0x055C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CheckPointSceneID;                                 // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           SceneIDArrayAfterCheckPoint;                       // 0x0568(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bFirstScene;                                       // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartByManualSaveData;                            // 0x0579(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartByAutoSaveData;                              // 0x057A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57B[0x1];                                      // 0x057B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentSceneID;                                    // 0x057C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSceneIndex;                                 // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentSceneVisibleCompleted;                     // 0x0588(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentSceneAssetLoadCompleted;                   // 0x0589(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58A[0x2];                                      // 0x058A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LoadEndEventSceneID;                               // 0x058C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PrevSceneID;                                       // 0x0594(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrevSceneIndex;                                    // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NextSceneID;                                       // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSceneIndex;                                    // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNextSceneAutoLoadStart;                           // 0x05AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AD[0x3];                                      // 0x05AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextSceneAutoLoadSceneIndex;                       // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextSceneAutoLoadDelay;                            // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextSceneAutoLoadElapsedTime;                      // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NextSceneAutoLoadSceneID;                          // 0x05BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSceneAutoLoadMomoryRate;                       // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSceneAutoLoadWarningMomoryRate;                // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChangeSceneReleaseCnt;                             // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeSceneRestart;                               // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCNazoSceneData>               SceneDataArray;                                    // 0x05D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      SceneDataMap;                                      // 0x05E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoadingSceneIDArray;                               // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoadedSceneIDArray;                                // 0x0648(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCNazoLevelManageData>         LevelManageDataArray;                              // 0x0658(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCNazoTileData>     TileDataMap;                                       // 0x0668(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	bool ChangeCheckPointScene(bool bRecoverPlayerHP);
	bool ChangeFirstScene();
	bool ChangeNextScene();
	bool ChangeScene(class FName SceneID);
	bool ChangeTitle();
	class FName GetCurrentSceneID();
	class ALevelScriptActor* GetCurrentSceneLevelScriptActor();
	class FName GetNextSceneID();
	bool IsCurrentSceneReady();
	bool IsCurrentSceneVisibleCompleted();
	bool IsInitialized();
	bool IsLoadSceneCompleted(class FName SceneID);
	bool IsReleaseSceneCompleted(class FName SceneID);
	bool IsSceneInvisible(class FName SceneID);
	void LoadAllNextScenes();
	void LoadLevelCompleted();
	void LoadNextScene();
	bool LoadScene(class FName SceneID);
	void ReleaseCurrentScene();
	void ReleaseScene(class FName SceneID);
	void SetCurrentSceneLevelScriptActor(class ALevelScriptActor* LevelScriptActor);
	void StartScene(class FName SceneID);
	void UnloadLevelCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoLevelScriptActor">();
	}
	static class ARCNazoLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoLevelScriptActor");
static_assert(sizeof(ARCNazoLevelScriptActor) == 0x0006B8, "Wrong size on ARCNazoLevelScriptActor");
static_assert(offsetof(ARCNazoLevelScriptActor, State) == 0x00046A, "Member 'ARCNazoLevelScriptActor::State' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneSettingsDataTable) == 0x000478, "Member 'ARCNazoLevelScriptActor::SceneSettingsDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneSettingsDataTableBG) == 0x000480, "Member 'ARCNazoLevelScriptActor::SceneSettingsDataTableBG' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, TileSettingsDataTableBG) == 0x000488, "Member 'ARCNazoLevelScriptActor::TileSettingsDataTableBG' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneSettingsDataTablePath) == 0x000490, "Member 'ARCNazoLevelScriptActor::SceneSettingsDataTablePath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneSettingsDataTableBGPath) == 0x0004A8, "Member 'ARCNazoLevelScriptActor::SceneSettingsDataTableBGPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneSettingsDataTableBGCommonPath) == 0x0004C0, "Member 'ARCNazoLevelScriptActor::SceneSettingsDataTableBGCommonPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, TileSettingsDataTableBGCommonPath) == 0x0004D8, "Member 'ARCNazoLevelScriptActor::TileSettingsDataTableBGCommonPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, MapListLevelPath) == 0x0004F0, "Member 'ARCNazoLevelScriptActor::MapListLevelPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, TileListLevelPath) == 0x000508, "Member 'ARCNazoLevelScriptActor::TileListLevelPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, MapListCommonLevelPath) == 0x000520, "Member 'ARCNazoLevelScriptActor::MapListCommonLevelPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, TileListCommonLevelPath) == 0x000538, "Member 'ARCNazoLevelScriptActor::TileListCommonLevelPath' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, StartSceneID) == 0x000550, "Member 'ARCNazoLevelScriptActor::StartSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, StartSceneIndex) == 0x000558, "Member 'ARCNazoLevelScriptActor::StartSceneIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bSceneTest) == 0x00055C, "Member 'ARCNazoLevelScriptActor::bSceneTest' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, CheckPointSceneID) == 0x000560, "Member 'ARCNazoLevelScriptActor::CheckPointSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneIDArrayAfterCheckPoint) == 0x000568, "Member 'ARCNazoLevelScriptActor::SceneIDArrayAfterCheckPoint' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bFirstScene) == 0x000578, "Member 'ARCNazoLevelScriptActor::bFirstScene' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bStartByManualSaveData) == 0x000579, "Member 'ARCNazoLevelScriptActor::bStartByManualSaveData' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bStartByAutoSaveData) == 0x00057A, "Member 'ARCNazoLevelScriptActor::bStartByAutoSaveData' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, CurrentSceneID) == 0x00057C, "Member 'ARCNazoLevelScriptActor::CurrentSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, CurrentSceneIndex) == 0x000584, "Member 'ARCNazoLevelScriptActor::CurrentSceneIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bCurrentSceneVisibleCompleted) == 0x000588, "Member 'ARCNazoLevelScriptActor::bCurrentSceneVisibleCompleted' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bCurrentSceneAssetLoadCompleted) == 0x000589, "Member 'ARCNazoLevelScriptActor::bCurrentSceneAssetLoadCompleted' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, LoadEndEventSceneID) == 0x00058C, "Member 'ARCNazoLevelScriptActor::LoadEndEventSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, PrevSceneID) == 0x000594, "Member 'ARCNazoLevelScriptActor::PrevSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, PrevSceneIndex) == 0x00059C, "Member 'ARCNazoLevelScriptActor::PrevSceneIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneID) == 0x0005A0, "Member 'ARCNazoLevelScriptActor::NextSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneIndex) == 0x0005A8, "Member 'ARCNazoLevelScriptActor::NextSceneIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bNextSceneAutoLoadStart) == 0x0005AC, "Member 'ARCNazoLevelScriptActor::bNextSceneAutoLoadStart' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadSceneIndex) == 0x0005B0, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadSceneIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadDelay) == 0x0005B4, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadDelay' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadElapsedTime) == 0x0005B8, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadElapsedTime' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadSceneID) == 0x0005BC, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadSceneID' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadMomoryRate) == 0x0005C4, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadMomoryRate' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, NextSceneAutoLoadWarningMomoryRate) == 0x0005C8, "Member 'ARCNazoLevelScriptActor::NextSceneAutoLoadWarningMomoryRate' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, ChangeSceneReleaseCnt) == 0x0005CC, "Member 'ARCNazoLevelScriptActor::ChangeSceneReleaseCnt' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, bChangeSceneRestart) == 0x0005D0, "Member 'ARCNazoLevelScriptActor::bChangeSceneRestart' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneDataArray) == 0x0005D8, "Member 'ARCNazoLevelScriptActor::SceneDataArray' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, SceneDataMap) == 0x0005E8, "Member 'ARCNazoLevelScriptActor::SceneDataMap' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, LoadingSceneIDArray) == 0x000638, "Member 'ARCNazoLevelScriptActor::LoadingSceneIDArray' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, LoadedSceneIDArray) == 0x000648, "Member 'ARCNazoLevelScriptActor::LoadedSceneIDArray' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, LevelManageDataArray) == 0x000658, "Member 'ARCNazoLevelScriptActor::LevelManageDataArray' has a wrong offset!");
static_assert(offsetof(ARCNazoLevelScriptActor, TileDataMap) == 0x000668, "Member 'ARCNazoLevelScriptActor::TileDataMap' has a wrong offset!");

// Class RC.RCNazoSceneTestLevelScriptActor
// 0x0000 (0x06B8 - 0x06B8)
class ARCNazoSceneTestLevelScriptActor : public ARCNazoLevelScriptActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoSceneTestLevelScriptActor">();
	}
	static class ARCNazoSceneTestLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoSceneTestLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoSceneTestLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoSceneTestLevelScriptActor");
static_assert(sizeof(ARCNazoSceneTestLevelScriptActor) == 0x0006B8, "Wrong size on ARCNazoSceneTestLevelScriptActor");

// Class RC.RCNazoMapViewerLevelScriptActor
// 0x0338 (0x09F0 - 0x06B8)
class ARCNazoMapViewerLevelScriptActor final : public ARCNazoSceneTestLevelScriptActor
{
public:
	uint8                                         Pad_6B8[0x338];                                    // 0x06B8(0x0338)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMenu();
	void OpenMenu();
	void ToggleMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoMapViewerLevelScriptActor">();
	}
	static class ARCNazoMapViewerLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoMapViewerLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoMapViewerLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoMapViewerLevelScriptActor");
static_assert(sizeof(ARCNazoMapViewerLevelScriptActor) == 0x0009F0, "Wrong size on ARCNazoMapViewerLevelScriptActor");

// Class RC.RCSaveGame
// 0x0010 (0x0038 - 0x0028)
class URCSaveGame : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              SaveTime;                                          // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveGame">();
	}
	static class URCSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveGame>();
	}
};
static_assert(alignof(URCSaveGame) == 0x000008, "Wrong alignment on URCSaveGame");
static_assert(sizeof(URCSaveGame) == 0x000038, "Wrong size on URCSaveGame");
static_assert(offsetof(URCSaveGame, Version) == 0x000028, "Member 'URCSaveGame::Version' has a wrong offset!");
static_assert(offsetof(URCSaveGame, SaveTime) == 0x000030, "Member 'URCSaveGame::SaveTime' has a wrong offset!");

// Class RC.RCSaveSystem
// 0x0198 (0x01D0 - 0x0038)
class URCSaveSystem final : public URCSaveGame
{
public:
	int32                                         LastAutoSaveNum;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOption                                Option;                                            // 0x003C(0x0068)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCVariableSystemSave                  VariableSystemSave;                                // 0x00A8(0x0100)(NativeAccessSpecifierPrivate)
	struct FRCKeyConfigInfo                       KeyConfig;                                         // 0x01A8(0x0020)(NativeAccessSpecifierPrivate)
	bool                                          bMargeDemoSavedata;                                // 0x01C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveSystem">();
	}
	static class URCSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveSystem>();
	}
};
static_assert(alignof(URCSaveSystem) == 0x000008, "Wrong alignment on URCSaveSystem");
static_assert(sizeof(URCSaveSystem) == 0x0001D0, "Wrong size on URCSaveSystem");
static_assert(offsetof(URCSaveSystem, LastAutoSaveNum) == 0x000038, "Member 'URCSaveSystem::LastAutoSaveNum' has a wrong offset!");
static_assert(offsetof(URCSaveSystem, Option) == 0x00003C, "Member 'URCSaveSystem::Option' has a wrong offset!");
static_assert(offsetof(URCSaveSystem, VariableSystemSave) == 0x0000A8, "Member 'URCSaveSystem::VariableSystemSave' has a wrong offset!");
static_assert(offsetof(URCSaveSystem, KeyConfig) == 0x0001A8, "Member 'URCSaveSystem::KeyConfig' has a wrong offset!");
static_assert(offsetof(URCSaveSystem, bMargeDemoSavedata) == 0x0001C8, "Member 'URCSaveSystem::bMargeDemoSavedata' has a wrong offset!");

// Class RC.RCForceFeedBackManager
// 0x0008 (0x0030 - 0x0028)
class URCForceFeedBackManager final : public UObject
{
public:
	ERCForceFeedBackLoadStatus                    LoadStatus;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputPlatform                              InputPlatform;                                     // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputPlatform                              NextInputPlatform;                                 // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputPlatform                              LoadedPlatform;                                    // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCForceFeedBackManager">();
	}
	static class URCForceFeedBackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCForceFeedBackManager>();
	}
};
static_assert(alignof(URCForceFeedBackManager) == 0x000008, "Wrong alignment on URCForceFeedBackManager");
static_assert(sizeof(URCForceFeedBackManager) == 0x000030, "Wrong size on URCForceFeedBackManager");
static_assert(offsetof(URCForceFeedBackManager, LoadStatus) == 0x000028, "Member 'URCForceFeedBackManager::LoadStatus' has a wrong offset!");
static_assert(offsetof(URCForceFeedBackManager, InputPlatform) == 0x000029, "Member 'URCForceFeedBackManager::InputPlatform' has a wrong offset!");
static_assert(offsetof(URCForceFeedBackManager, NextInputPlatform) == 0x00002A, "Member 'URCForceFeedBackManager::NextInputPlatform' has a wrong offset!");
static_assert(offsetof(URCForceFeedBackManager, LoadedPlatform) == 0x00002B, "Member 'URCForceFeedBackManager::LoadedPlatform' has a wrong offset!");

// Class RC.RCTitleChapterSelect
// 0x0058 (0x0330 - 0x02D8)
class URCTitleChapterSelect : public URCUiWidgetBase
{
public:
	class UImage*                                 chapterImage;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleChapterSelectList*              SelectList;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleChapterSelectCaption*           selectCaption;                                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuMainQuestImage*                questImage;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleHelp*                           titleHelp;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       Title_BTNGuide;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleChapterSelectWindow*            SelectWindow;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCTitleChapterSelectState                    State;                                             // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelWrap(ERCInputKeyType InKeyType);
	void DecideWrap(ERCInputKeyType InKeyType);
	void OnFinishedFinishAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelect">();
	}
	static class URCTitleChapterSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelect>();
	}
};
static_assert(alignof(URCTitleChapterSelect) == 0x000008, "Wrong alignment on URCTitleChapterSelect");
static_assert(sizeof(URCTitleChapterSelect) == 0x000330, "Wrong size on URCTitleChapterSelect");
static_assert(offsetof(URCTitleChapterSelect, chapterImage) == 0x0002D8, "Member 'URCTitleChapterSelect::chapterImage' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, SelectList) == 0x0002E0, "Member 'URCTitleChapterSelect::SelectList' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, selectCaption) == 0x0002E8, "Member 'URCTitleChapterSelect::selectCaption' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, questImage) == 0x0002F0, "Member 'URCTitleChapterSelect::questImage' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, titleHelp) == 0x0002F8, "Member 'URCTitleChapterSelect::titleHelp' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, Title_BTNGuide) == 0x000300, "Member 'URCTitleChapterSelect::Title_BTNGuide' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, SelectWindow) == 0x000308, "Member 'URCTitleChapterSelect::SelectWindow' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, AN_Start) == 0x000310, "Member 'URCTitleChapterSelect::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, AN_Wait) == 0x000318, "Member 'URCTitleChapterSelect::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, AN_Finish) == 0x000320, "Member 'URCTitleChapterSelect::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelect, State) == 0x000328, "Member 'URCTitleChapterSelect::State' has a wrong offset!");

// Class RC.RCBombReleaseAnswer
// 0x0048 (0x0368 - 0x0320)
class URCBombReleaseAnswer final : public URCMenuButton
{
public:
	class UImage*                                 Img_AnswerPanel;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Img_SelectCursor;                                  // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Img_SelectCursor_1;                                // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Img_SelectCursor_2;                                // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Img_SelectCursor_3;                                // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_InActive;                                       // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Active;                                         // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Done;                                           // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isCurrentSelect;                                   // 0x0360(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseAnswer">();
	}
	static class URCBombReleaseAnswer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseAnswer>();
	}
};
static_assert(alignof(URCBombReleaseAnswer) == 0x000008, "Wrong alignment on URCBombReleaseAnswer");
static_assert(sizeof(URCBombReleaseAnswer) == 0x000368, "Wrong size on URCBombReleaseAnswer");
static_assert(offsetof(URCBombReleaseAnswer, Img_AnswerPanel) == 0x000320, "Member 'URCBombReleaseAnswer::Img_AnswerPanel' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, Img_SelectCursor) == 0x000328, "Member 'URCBombReleaseAnswer::Img_SelectCursor' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, Img_SelectCursor_1) == 0x000330, "Member 'URCBombReleaseAnswer::Img_SelectCursor_1' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, Img_SelectCursor_2) == 0x000338, "Member 'URCBombReleaseAnswer::Img_SelectCursor_2' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, Img_SelectCursor_3) == 0x000340, "Member 'URCBombReleaseAnswer::Img_SelectCursor_3' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, AN_InActive) == 0x000348, "Member 'URCBombReleaseAnswer::AN_InActive' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, AN_Active) == 0x000350, "Member 'URCBombReleaseAnswer::AN_Active' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, AN_Done) == 0x000358, "Member 'URCBombReleaseAnswer::AN_Done' has a wrong offset!");
static_assert(offsetof(URCBombReleaseAnswer, isCurrentSelect) == 0x000360, "Member 'URCBombReleaseAnswer::isCurrentSelect' has a wrong offset!");

// Class RC.RCBombReleaseGame
// 0x0108 (0x0378 - 0x0270)
class URCBombReleaseGame final : public URCUserWidget
{
public:
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_0;                              // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_1;                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_2;                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_3;                              // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_4;                              // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseAnswer*                   WBP_MG_Bomb_Answer_5;                              // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URCBombReleaseAnswer*>           answerArray;                                       // 0x02A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UUserWidget*                            WBP_MG_Bomb_Timer;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            WBP_MG_Bomb_QuestionImage;                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseMistake*                  WBP_MG_Bomb_IsMisstake;                            // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseSuccess*                  WBP_MG_Bomb_IsSuccess;                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCBombReleaseTimeNum*                  timeNum1;                                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCBombReleaseTimeNum*                  timeNum2;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 questionImage;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 messageImage;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         questionTime;                                      // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         selectQuestion;                                    // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         selectVerticalMove;                                // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         selectWidthMove;                                   // 0x030C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCount;                                           // 0x0310(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCParamBombReleaseTableRow            bombReleaseParam;                                  // 0x0318(0x0060)(NativeAccessSpecifierPrivate)

public:
	void SetMistakeVisible(bool IsVisible_0);
	void SetSuccessVisible(bool IsVisible_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseGame">();
	}
	static class URCBombReleaseGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseGame>();
	}
};
static_assert(alignof(URCBombReleaseGame) == 0x000008, "Wrong alignment on URCBombReleaseGame");
static_assert(sizeof(URCBombReleaseGame) == 0x000378, "Wrong size on URCBombReleaseGame");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_0) == 0x000270, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_0' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_1) == 0x000278, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_1' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_2) == 0x000280, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_2' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_3) == 0x000288, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_3' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_4) == 0x000290, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_4' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Answer_5) == 0x000298, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Answer_5' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, answerArray) == 0x0002A0, "Member 'URCBombReleaseGame::answerArray' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_Timer) == 0x0002B0, "Member 'URCBombReleaseGame::WBP_MG_Bomb_Timer' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_QuestionImage) == 0x0002B8, "Member 'URCBombReleaseGame::WBP_MG_Bomb_QuestionImage' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_IsMisstake) == 0x0002C0, "Member 'URCBombReleaseGame::WBP_MG_Bomb_IsMisstake' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, WBP_MG_Bomb_IsSuccess) == 0x0002C8, "Member 'URCBombReleaseGame::WBP_MG_Bomb_IsSuccess' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, AN_Start) == 0x0002D0, "Member 'URCBombReleaseGame::AN_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, AN_Finish) == 0x0002D8, "Member 'URCBombReleaseGame::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, timeNum1) == 0x0002E0, "Member 'URCBombReleaseGame::timeNum1' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, timeNum2) == 0x0002E8, "Member 'URCBombReleaseGame::timeNum2' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, questionImage) == 0x0002F0, "Member 'URCBombReleaseGame::questionImage' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, messageImage) == 0x0002F8, "Member 'URCBombReleaseGame::messageImage' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, questionTime) == 0x000300, "Member 'URCBombReleaseGame::questionTime' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, selectQuestion) == 0x000304, "Member 'URCBombReleaseGame::selectQuestion' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, selectVerticalMove) == 0x000308, "Member 'URCBombReleaseGame::selectVerticalMove' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, selectWidthMove) == 0x00030C, "Member 'URCBombReleaseGame::selectWidthMove' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, isCount) == 0x000310, "Member 'URCBombReleaseGame::isCount' has a wrong offset!");
static_assert(offsetof(URCBombReleaseGame, bombReleaseParam) == 0x000318, "Member 'URCBombReleaseGame::bombReleaseParam' has a wrong offset!");

// Class RC.RCEventTriggerBFL
// 0x0000 (0x0028 - 0x0028)
class URCEventTriggerBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCEventTrigger* GetEventTrigger(class FName InName);
	static bool IsCollisionEnable(class FName InName);
	static void SetCollisionEnable(class FName InName, bool bInEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTriggerBFL">();
	}
	static class URCEventTriggerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEventTriggerBFL>();
	}
};
static_assert(alignof(URCEventTriggerBFL) == 0x000008, "Wrong alignment on URCEventTriggerBFL");
static_assert(sizeof(URCEventTriggerBFL) == 0x000028, "Wrong size on URCEventTriggerBFL");

// Class RC.RCTopMenu
// 0x0080 (0x0360 - 0x02E0)
class URCTopMenu final : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x70];                                     // 0x02E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CancelEnableTime;                                  // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void CloseMenuWrap(ERCInputKeyType InKeyTyoe);
	void CloseWorldMapWrap(ERCInputKeyType InKeyTyoe);
	void InitializeTopMenu();
	void Open(ERCGameMenuDirectAccessType bInAccessType, bool bInIsAreaMenuCancel);
	void OpenContentWrap(ERCInputKeyType InKeyTyoe);
	void OpenKagiSelect(const TArray<class FName>& InKaiKagiIDArray, bool bInNotPause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTopMenu">();
	}
	static class URCTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTopMenu>();
	}
};
static_assert(alignof(URCTopMenu) == 0x000008, "Wrong alignment on URCTopMenu");
static_assert(sizeof(URCTopMenu) == 0x000360, "Wrong size on URCTopMenu");
static_assert(offsetof(URCTopMenu, CancelEnableTime) == 0x000350, "Member 'URCTopMenu::CancelEnableTime' has a wrong offset!");

// Class RC.RCBombReleaseMistake
// 0x0020 (0x0290 - 0x0270)
class URCBombReleaseMistake final : public URCUserWidget
{
public:
	class UWidgetAnimation*                       AN_On_Start;                                       // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isStartAnimation;                                  // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFinishAnimation;                                 // 0x0289(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishAnimation();
	bool IsFinishedAnimation();
	void OffAnimation();
	void StartAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseMistake">();
	}
	static class URCBombReleaseMistake* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseMistake>();
	}
};
static_assert(alignof(URCBombReleaseMistake) == 0x000008, "Wrong alignment on URCBombReleaseMistake");
static_assert(sizeof(URCBombReleaseMistake) == 0x000290, "Wrong size on URCBombReleaseMistake");
static_assert(offsetof(URCBombReleaseMistake, AN_On_Start) == 0x000270, "Member 'URCBombReleaseMistake::AN_On_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseMistake, AN_Finish) == 0x000278, "Member 'URCBombReleaseMistake::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseMistake, AN_Off) == 0x000280, "Member 'URCBombReleaseMistake::AN_Off' has a wrong offset!");
static_assert(offsetof(URCBombReleaseMistake, isStartAnimation) == 0x000288, "Member 'URCBombReleaseMistake::isStartAnimation' has a wrong offset!");
static_assert(offsetof(URCBombReleaseMistake, isFinishAnimation) == 0x000289, "Member 'URCBombReleaseMistake::isFinishAnimation' has a wrong offset!");

// Class RC.RCFixedCameraActor
// 0x0010 (0x07D0 - 0x07C0)
class ARCFixedCameraActor final : public ARCCameraActor
{
public:
	uint8                                         Pad_7C0[0x4];                                      // 0x07C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLookAt;                                           // 0x07C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C5[0xB];                                      // 0x07C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AtouchRain(float lenght, bool Zfollow, float OffsetZ);
	void RemoveRain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCFixedCameraActor">();
	}
	static class ARCFixedCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCFixedCameraActor>();
	}
};
static_assert(alignof(ARCFixedCameraActor) == 0x000010, "Wrong alignment on ARCFixedCameraActor");
static_assert(sizeof(ARCFixedCameraActor) == 0x0007D0, "Wrong size on ARCFixedCameraActor");
static_assert(offsetof(ARCFixedCameraActor, bLookAt) == 0x0007C4, "Member 'ARCFixedCameraActor::bLookAt' has a wrong offset!");

// Class RC.RCBombReleaseStart
// 0x0020 (0x02F8 - 0x02D8)
class URCBombReleaseStart final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         State;                                             // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseStart">();
	}
	static class URCBombReleaseStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseStart>();
	}
};
static_assert(alignof(URCBombReleaseStart) == 0x000008, "Wrong alignment on URCBombReleaseStart");
static_assert(sizeof(URCBombReleaseStart) == 0x0002F8, "Wrong size on URCBombReleaseStart");
static_assert(offsetof(URCBombReleaseStart, AN_Start) == 0x0002D8, "Member 'URCBombReleaseStart::AN_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseStart, AN_Off) == 0x0002E0, "Member 'URCBombReleaseStart::AN_Off' has a wrong offset!");
static_assert(offsetof(URCBombReleaseStart, AN_Finish) == 0x0002E8, "Member 'URCBombReleaseStart::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseStart, State) == 0x0002F0, "Member 'URCBombReleaseStart::State' has a wrong offset!");

// Class RC.RCTimeManager
// 0x0020 (0x0048 - 0x0028)
class URCTimeManager final : public UObject
{
public:
	bool                                          bMenuPause;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMenuPauseExec;                                    // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SkipSpeed;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NowSpeed;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCTimer*>                       TimerList;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTimeManager">();
	}
	static class URCTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTimeManager>();
	}
};
static_assert(alignof(URCTimeManager) == 0x000008, "Wrong alignment on URCTimeManager");
static_assert(sizeof(URCTimeManager) == 0x000048, "Wrong size on URCTimeManager");
static_assert(offsetof(URCTimeManager, bMenuPause) == 0x000028, "Member 'URCTimeManager::bMenuPause' has a wrong offset!");
static_assert(offsetof(URCTimeManager, bMenuPauseExec) == 0x000029, "Member 'URCTimeManager::bMenuPauseExec' has a wrong offset!");
static_assert(offsetof(URCTimeManager, Speed) == 0x00002C, "Member 'URCTimeManager::Speed' has a wrong offset!");
static_assert(offsetof(URCTimeManager, SkipSpeed) == 0x000030, "Member 'URCTimeManager::SkipSpeed' has a wrong offset!");
static_assert(offsetof(URCTimeManager, NowSpeed) == 0x000034, "Member 'URCTimeManager::NowSpeed' has a wrong offset!");
static_assert(offsetof(URCTimeManager, TimerList) == 0x000038, "Member 'URCTimeManager::TimerList' has a wrong offset!");

// Class RC.RCBombReleaseSuccess
// 0x0020 (0x0290 - 0x0270)
class URCBombReleaseSuccess final : public URCUserWidget
{
public:
	class UWidgetAnimation*                       AN_On_Start;                                       // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isStartAnimation;                                  // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFinishAnimation;                                 // 0x0289(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishAnimation();
	bool IsFinishedAnimation();
	void OffAnimation();
	void StartAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseSuccess">();
	}
	static class URCBombReleaseSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseSuccess>();
	}
};
static_assert(alignof(URCBombReleaseSuccess) == 0x000008, "Wrong alignment on URCBombReleaseSuccess");
static_assert(sizeof(URCBombReleaseSuccess) == 0x000290, "Wrong size on URCBombReleaseSuccess");
static_assert(offsetof(URCBombReleaseSuccess, AN_On_Start) == 0x000270, "Member 'URCBombReleaseSuccess::AN_On_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseSuccess, AN_Finish) == 0x000278, "Member 'URCBombReleaseSuccess::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseSuccess, AN_Off) == 0x000280, "Member 'URCBombReleaseSuccess::AN_Off' has a wrong offset!");
static_assert(offsetof(URCBombReleaseSuccess, isStartAnimation) == 0x000288, "Member 'URCBombReleaseSuccess::isStartAnimation' has a wrong offset!");
static_assert(offsetof(URCBombReleaseSuccess, isFinishAnimation) == 0x000289, "Member 'URCBombReleaseSuccess::isFinishAnimation' has a wrong offset!");

// Class RC.RCBombReleaseTimeNum
// 0x0028 (0x0298 - 0x0270)
class URCBombReleaseTimeNum final : public URCUserWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher_1;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_0;                                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_1;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_2;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         numUVSize;                                         // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseTimeNum">();
	}
	static class URCBombReleaseTimeNum* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseTimeNum>();
	}
};
static_assert(alignof(URCBombReleaseTimeNum) == 0x000008, "Wrong alignment on URCBombReleaseTimeNum");
static_assert(sizeof(URCBombReleaseTimeNum) == 0x000298, "Wrong size on URCBombReleaseTimeNum");
static_assert(offsetof(URCBombReleaseTimeNum, WidgetSwitcher_1) == 0x000270, "Member 'URCBombReleaseTimeNum::WidgetSwitcher_1' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTimeNum, Image_0) == 0x000278, "Member 'URCBombReleaseTimeNum::Image_0' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTimeNum, Image_1) == 0x000280, "Member 'URCBombReleaseTimeNum::Image_1' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTimeNum, Image_2) == 0x000288, "Member 'URCBombReleaseTimeNum::Image_2' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTimeNum, numUVSize) == 0x000290, "Member 'URCBombReleaseTimeNum::numUVSize' has a wrong offset!");

// Class RC.RCKusariBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCKusariBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CorrectChain(class UNiagaraComponent* NiagaraTemplate);
	static bool CorrectChainAuto(bool On);
	static bool SetChainParam(const struct FVector& Gravity, float Drag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCKusariBlueprintFunctionLibrary">();
	}
	static class URCKusariBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCKusariBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(URCKusariBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on URCKusariBlueprintFunctionLibrary");
static_assert(sizeof(URCKusariBlueprintFunctionLibrary) == 0x000028, "Wrong size on URCKusariBlueprintFunctionLibrary");

// Class RC.RCBombReleaseTitle
// 0x0020 (0x0290 - 0x0270)
class URCBombReleaseTitle final : public URCUserWidget
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseTitle">();
	}
	static class URCBombReleaseTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseTitle>();
	}
};
static_assert(alignof(URCBombReleaseTitle) == 0x000008, "Wrong alignment on URCBombReleaseTitle");
static_assert(sizeof(URCBombReleaseTitle) == 0x000290, "Wrong size on URCBombReleaseTitle");
static_assert(offsetof(URCBombReleaseTitle, AN_Start) == 0x000270, "Member 'URCBombReleaseTitle::AN_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTitle, AN_Finish) == 0x000278, "Member 'URCBombReleaseTitle::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTitle, AN_Wait) == 0x000280, "Member 'URCBombReleaseTitle::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCBombReleaseTitle, AN_Push) == 0x000288, "Member 'URCBombReleaseTitle::AN_Push' has a wrong offset!");

// Class RC.RCNzUiFinaleHeadingTextWidget
// 0x0048 (0x0320 - 0x02D8)
class URCNzUiFinaleHeadingTextWidget final : public URCUiWidgetBase
{
public:
	class FName                                   SectionID;                                         // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextID;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCNzFinaleManagerBase*                 FinaleManager;                                     // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SectionIdx;                                        // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DetectiveUIPath;                                   // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              DetectiveBackgroudImgScale;                        // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      DebugDrawLinesPointList;                           // 0x0310(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class FString GetDetectiveUIPath();
	class FString GetHeadingText();
	int32 GetIndexText();
	class FName GetSectionID();
	int32 GetSectionIdx();
	class FName GetSectionTextID();
	void InitializeHeadingTextWidget(class FName SectionID_0, class FName TextID_0, class ARCNzFinaleManagerBase* FinaleManager_0, int32 idx, const class FString& uiPath);
	void UpdateDebugDrawLine(const TArray<struct FVector2D>& Points);
	void UpdateDetectiveRestStatus(const TArray<bool>& statusList);
	void UpdateHeadingText(const class FString& Text);
	void UpdateIndexTex(const class UTexture2D* tex);
	void UpdateIndexText(const class FString& Text);
	void UpdatePieceState(const TArray<bool>& isStateList);
	void UpdateSelectStatus(bool IsSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleHeadingTextWidget">();
	}
	static class URCNzUiFinaleHeadingTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleHeadingTextWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleHeadingTextWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleHeadingTextWidget");
static_assert(sizeof(URCNzUiFinaleHeadingTextWidget) == 0x000320, "Wrong size on URCNzUiFinaleHeadingTextWidget");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, SectionID) == 0x0002D8, "Member 'URCNzUiFinaleHeadingTextWidget::SectionID' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, TextID) == 0x0002E0, "Member 'URCNzUiFinaleHeadingTextWidget::TextID' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, FinaleManager) == 0x0002E8, "Member 'URCNzUiFinaleHeadingTextWidget::FinaleManager' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, SectionIdx) == 0x0002F0, "Member 'URCNzUiFinaleHeadingTextWidget::SectionIdx' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, DetectiveUIPath) == 0x0002F8, "Member 'URCNzUiFinaleHeadingTextWidget::DetectiveUIPath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, DetectiveBackgroudImgScale) == 0x000308, "Member 'URCNzUiFinaleHeadingTextWidget::DetectiveBackgroudImgScale' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingTextWidget, DebugDrawLinesPointList) == 0x000310, "Member 'URCNzUiFinaleHeadingTextWidget::DebugDrawLinesPointList' has a wrong offset!");

// Class RC.RCUiMenuStatusIcon
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuStatusIcon final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuStatusIcon">();
	}
	static class URCUiMenuStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuStatusIcon>();
	}
};
static_assert(alignof(URCUiMenuStatusIcon) == 0x000008, "Wrong alignment on URCUiMenuStatusIcon");
static_assert(sizeof(URCUiMenuStatusIcon) == 0x0002E8, "Wrong size on URCUiMenuStatusIcon");

// Class RC.RCBombReleaseWidget
// 0x00B8 (0x0328 - 0x0270)
class URCBombReleaseWidget final : public URCUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnSuccessEvent;                                    // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMistakeEvent;                                    // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCBombReleaseGame*                     WBP_MG_Bomb_Game;                                  // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCBombReleaseTitle*                    WBP_MG_Bomb_Title;                                 // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCBombReleaseStart*                    WBP_MG_Bomb_Start;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         State;                                             // 0x02B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCParamBombReleaseTableRow            bombParameter;                                     // 0x02C0(0x0060)(NativeAccessSpecifierPrivate)
	int32                                         questionCount;                                     // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isTitleAnimation;                                  // 0x0324(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFinishStatusSuccess;                             // 0x0325(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finish();
	void GameOver(float DeltaTime);
	void PlayScene(float DeltaTime);
	void PreFinish();
	void PreGameOver();
	void PrePlayScene();
	void PreStartScene();
	void PreSuccess();
	void PreTitleScene();
	void PreTutorialScene();
	void StartScene();
	void Success(float DeltaTime);
	void TitleScene();
	void TutorialScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBombReleaseWidget">();
	}
	static class URCBombReleaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBombReleaseWidget>();
	}
};
static_assert(alignof(URCBombReleaseWidget) == 0x000008, "Wrong alignment on URCBombReleaseWidget");
static_assert(sizeof(URCBombReleaseWidget) == 0x000328, "Wrong size on URCBombReleaseWidget");
static_assert(offsetof(URCBombReleaseWidget, OnSuccessEvent) == 0x000270, "Member 'URCBombReleaseWidget::OnSuccessEvent' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, OnMistakeEvent) == 0x000280, "Member 'URCBombReleaseWidget::OnMistakeEvent' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, AN_Start) == 0x000290, "Member 'URCBombReleaseWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, AN_Finish) == 0x000298, "Member 'URCBombReleaseWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, WBP_MG_Bomb_Game) == 0x0002A0, "Member 'URCBombReleaseWidget::WBP_MG_Bomb_Game' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, WBP_MG_Bomb_Title) == 0x0002A8, "Member 'URCBombReleaseWidget::WBP_MG_Bomb_Title' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, WBP_MG_Bomb_Start) == 0x0002B0, "Member 'URCBombReleaseWidget::WBP_MG_Bomb_Start' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, State) == 0x0002B8, "Member 'URCBombReleaseWidget::State' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, bombParameter) == 0x0002C0, "Member 'URCBombReleaseWidget::bombParameter' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, questionCount) == 0x000320, "Member 'URCBombReleaseWidget::questionCount' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, isTitleAnimation) == 0x000324, "Member 'URCBombReleaseWidget::isTitleAnimation' has a wrong offset!");
static_assert(offsetof(URCBombReleaseWidget, isFinishStatusSuccess) == 0x000325, "Member 'URCBombReleaseWidget::isFinishStatusSuccess' has a wrong offset!");

// Class RC.RCUiMenuSkillTreeIconEffect
// 0x0010 (0x02F8 - 0x02E8)
class URCUiMenuSkillTreeIconEffect final : public URCUiMenuCommonIcon
{
public:
	class UWidgetAnimation*                       AN_On_Loop;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       An_Open_Start;                                     // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTreeIconEffect">();
	}
	static class URCUiMenuSkillTreeIconEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTreeIconEffect>();
	}
};
static_assert(alignof(URCUiMenuSkillTreeIconEffect) == 0x000008, "Wrong alignment on URCUiMenuSkillTreeIconEffect");
static_assert(sizeof(URCUiMenuSkillTreeIconEffect) == 0x0002F8, "Wrong size on URCUiMenuSkillTreeIconEffect");
static_assert(offsetof(URCUiMenuSkillTreeIconEffect, AN_On_Loop) == 0x0002E8, "Member 'URCUiMenuSkillTreeIconEffect::AN_On_Loop' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTreeIconEffect, An_Open_Start) == 0x0002F0, "Member 'URCUiMenuSkillTreeIconEffect::An_Open_Start' has a wrong offset!");

// Class RC.RCTextData
// 0x0010 (0x0040 - 0x0030)
class URCTextData final : public URCCSVData
{
public:
	TArray<struct FRCTextDataTableRow>            Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTextData">();
	}
	static class URCTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTextData>();
	}
};
static_assert(alignof(URCTextData) == 0x000008, "Wrong alignment on URCTextData");
static_assert(sizeof(URCTextData) == 0x000040, "Wrong size on URCTextData");
static_assert(offsetof(URCTextData, Data) == 0x000030, "Member 'URCTextData::Data' has a wrong offset!");

// Class RC.RCCameraBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCCameraBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckAcvivationCamera(class FName Tag);
	static float GetCameraAngle();
	static float GetCameraVAngle();
	static class AActor* GetCurrentCamera();
	static class FName GetCurrentCameraTag();
	static bool IsLoadingCamra();
	static void ReActivationCamera(bool Blend);
	static void RemoveFakeLocation();
	static void ResetActivationCamera(class FName Tag);
	static void SetActivationCamera(class FName Tag, bool Blend, float Time);
	static void SetActivationCameraWithBlendParam(class FName Tag, const struct FViewTargetTransitionParams& Param);
	static void SetCameraAnglePlayerBack(float va);
	static void SetFakeLocation(const struct FVector& Location);
	static void SetFoceCameraAngle(float A, float va);
	static void SetPlayerCamera(class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCameraBlueprintFunctionLibrary">();
	}
	static class URCCameraBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCameraBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(URCCameraBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on URCCameraBlueprintFunctionLibrary");
static_assert(sizeof(URCCameraBlueprintFunctionLibrary) == 0x000028, "Wrong size on URCCameraBlueprintFunctionLibrary");

// Class RC.RCGetFrameBufferActor
// 0x0070 (0x02F8 - 0x0288)
class ARCGetFrameBufferActor final : public ARCActor
{
public:
	class UMaterialInstanceDynamic*               MaterialInstanceDynamic;                           // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 CaptureFrameData;                                  // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             CaptureFrameTexture;                               // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCapture;                                       // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3F];                                     // 0x02B9(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReSetOnlyColor();
	void ReSetTriming();
	void SetMaterialInstanceDynamic(class UMaterialInstanceDynamic* MI);
	void SetOnlyColor(const struct FColor& col);
	void SetTriming(const struct FVector& Min, const struct FVector& Max);
	bool StartFrameGrab();
	void StopFrameGrab();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGetFrameBufferActor">();
	}
	static class ARCGetFrameBufferActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGetFrameBufferActor>();
	}
};
static_assert(alignof(ARCGetFrameBufferActor) == 0x000008, "Wrong alignment on ARCGetFrameBufferActor");
static_assert(sizeof(ARCGetFrameBufferActor) == 0x0002F8, "Wrong size on ARCGetFrameBufferActor");
static_assert(offsetof(ARCGetFrameBufferActor, MaterialInstanceDynamic) == 0x000288, "Member 'ARCGetFrameBufferActor::MaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(ARCGetFrameBufferActor, CaptureFrameData) == 0x0002A0, "Member 'ARCGetFrameBufferActor::CaptureFrameData' has a wrong offset!");
static_assert(offsetof(ARCGetFrameBufferActor, CaptureFrameTexture) == 0x0002B0, "Member 'ARCGetFrameBufferActor::CaptureFrameTexture' has a wrong offset!");
static_assert(offsetof(ARCGetFrameBufferActor, AutoCapture) == 0x0002B8, "Member 'ARCGetFrameBufferActor::AutoCapture' has a wrong offset!");

// Class RC.RCCameraManager
// 0x00C0 (0x02E0 - 0x0220)
class alignas(0x10) ARCCameraManager final : public AActor
{
public:
	TArray<class ARCCameraActor*>                 AllCameras;                                        // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ARCCameraActor*                         CurrentCamera;                                     // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0xA8];                                     // 0x0238(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCameraManager">();
	}
	static class ARCCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCameraManager>();
	}
};
static_assert(alignof(ARCCameraManager) == 0x000010, "Wrong alignment on ARCCameraManager");
static_assert(sizeof(ARCCameraManager) == 0x0002E0, "Wrong size on ARCCameraManager");
static_assert(offsetof(ARCCameraManager, AllCameras) == 0x000220, "Member 'ARCCameraManager::AllCameras' has a wrong offset!");
static_assert(offsetof(ARCCameraManager, CurrentCamera) == 0x000230, "Member 'ARCCameraManager::CurrentCamera' has a wrong offset!");

// Class RC.RCCameraTriggerBox
// 0x0000 (0x0228 - 0x0228)
class ARCCameraTriggerBox final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCameraTriggerBox">();
	}
	static class ARCCameraTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCameraTriggerBox>();
	}
};
static_assert(alignof(ARCCameraTriggerBox) == 0x000008, "Wrong alignment on ARCCameraTriggerBox");
static_assert(sizeof(ARCCameraTriggerBox) == 0x000228, "Wrong size on ARCCameraTriggerBox");

// Class RC.RCNzUiFinalePageGuideWidget
// 0x0018 (0x02F0 - 0x02D8)
class URCNzUiFinalePageGuideWidget final : public URCUiWidgetBase
{
public:
	EPageGuideType                                pageType;                                          // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x17];                                     // 0x02D9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePageGuideState(const bool IsSelect);
	void InitializePageGuide(EPageGuideType Type);
	void PlayAnimDefaultL();
	void PlayAnimDefaultS();
	void PlayAnimQuestionL();
	void PlayAnimQuestionS();
	void UpdatePageGuide(EPageGuideType Type, bool isCurrentPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePageGuideWidget">();
	}
	static class URCNzUiFinalePageGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePageGuideWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePageGuideWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePageGuideWidget");
static_assert(sizeof(URCNzUiFinalePageGuideWidget) == 0x0002F0, "Wrong size on URCNzUiFinalePageGuideWidget");
static_assert(offsetof(URCNzUiFinalePageGuideWidget, pageType) == 0x0002D8, "Member 'URCNzUiFinalePageGuideWidget::pageType' has a wrong offset!");

// Class RC.RCHardwareXboxSX
// 0x0000 (0x0028 - 0x0028)
class URCHardwareXboxSX final : public UObject
{
public:
	static ERCXSXConsoleType GetXSXConsoleType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCHardwareXboxSX">();
	}
	static class URCHardwareXboxSX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCHardwareXboxSX>();
	}
};
static_assert(alignof(URCHardwareXboxSX) == 0x000008, "Wrong alignment on URCHardwareXboxSX");
static_assert(sizeof(URCHardwareXboxSX) == 0x000028, "Wrong size on URCHardwareXboxSX");

// Class RC.RCUiMenuTutorial
// 0x0030 (0x0308 - 0x02D8)
class URCUiMenuTutorial final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_In;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_Out;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectTutorialWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuTutorial">();
	}
	static class URCUiMenuTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuTutorial>();
	}
};
static_assert(alignof(URCUiMenuTutorial) == 0x000008, "Wrong alignment on URCUiMenuTutorial");
static_assert(sizeof(URCUiMenuTutorial) == 0x000308, "Wrong size on URCUiMenuTutorial");
static_assert(offsetof(URCUiMenuTutorial, AN_On) == 0x0002D8, "Member 'URCUiMenuTutorial::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorial, AN_Off) == 0x0002E0, "Member 'URCUiMenuTutorial::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorial, AN_Flame_In) == 0x0002E8, "Member 'URCUiMenuTutorial::AN_Flame_In' has a wrong offset!");
static_assert(offsetof(URCUiMenuTutorial, AN_Flame_Out) == 0x0002F0, "Member 'URCUiMenuTutorial::AN_Flame_Out' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectBar
// 0x0048 (0x0368 - 0x0320)
class URCNzUiBattleKaiKagiSelectBar : public URCMenuButton
{
public:
	class UTextBlock*                             Text_KaikagiName_01;                               // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Next;                                           // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Prev;                                           // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               AnimArray;                                         // 0x0350(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void Decide();
	void InitializeBattleKaiKagiSelectBar();
	void PlayAnim(ERCNzUiBattleKaiKagiSelectPartsAnimType InAnimType);
	void Select();
	void SetKaiKagiName(class FName InTextID);
	void SetVisible(bool bInVisibility);
	void Unselect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectBar">();
	}
	static class URCNzUiBattleKaiKagiSelectBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectBar>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectBar) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectBar");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectBar) == 0x000368, "Wrong size on URCNzUiBattleKaiKagiSelectBar");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, Text_KaikagiName_01) == 0x000320, "Member 'URCNzUiBattleKaiKagiSelectBar::Text_KaikagiName_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AN_Start) == 0x000328, "Member 'URCNzUiBattleKaiKagiSelectBar::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AN_Wait) == 0x000330, "Member 'URCNzUiBattleKaiKagiSelectBar::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AN_Finish) == 0x000338, "Member 'URCNzUiBattleKaiKagiSelectBar::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AN_Next) == 0x000340, "Member 'URCNzUiBattleKaiKagiSelectBar::AN_Next' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AN_Prev) == 0x000348, "Member 'URCNzUiBattleKaiKagiSelectBar::AN_Prev' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar, AnimArray) == 0x000350, "Member 'URCNzUiBattleKaiKagiSelectBar::AnimArray' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectedBar
// 0x0010 (0x0378 - 0x0368)
class URCNzUiBattleKaiKagiSelectedBar final : public URCNzUiBattleKaiKagiSelectBar
{
public:
	class UTextBlock*                             Text_KaikagiName_02;                               // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiName_03;                               // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectedBar">();
	}
	static class URCNzUiBattleKaiKagiSelectedBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectedBar>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectedBar) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectedBar");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectedBar) == 0x000378, "Wrong size on URCNzUiBattleKaiKagiSelectedBar");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectedBar, Text_KaikagiName_02) == 0x000368, "Member 'URCNzUiBattleKaiKagiSelectedBar::Text_KaikagiName_02' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectedBar, Text_KaikagiName_03) == 0x000370, "Member 'URCNzUiBattleKaiKagiSelectedBar::Text_KaikagiName_03' has a wrong offset!");

// Class RC.RCCharacterAnimCtrl
// 0x0140 (0x01F0 - 0x00B0)
class URCCharacterAnimCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSequencerPlay;                                    // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentAnimationName;                              // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentAnimation1Name;                             // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentUseSlotExAnimationName;                     // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AnimationName;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Animation1Name;                                    // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ExAnimationName;                                   // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentSlotAlpha0;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlotAlpha0;                                        // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentSlotAlpha1;                                 // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlotAlpha1;                                        // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentSlotAlphaEx;                                // 0x0110(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlotAlphaEx;                                       // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRateBasis0;                             // 0x0118(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRateBasis0;                                    // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRateBasis1;                             // 0x0120(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRateBasis1;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRateBasisEx;                            // 0x0128(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRateBasisEx;                                   // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRate0;                                  // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate0;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRate1;                                  // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate1;                                         // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPlayRateEx;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRateEx;                                        // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCurrentMotionLoop;                                // 0x0148(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMotionLoop;                                       // 0x0149(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOutMotion0;                                       // 0x014A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOutMotion1;                                       // 0x014B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOutMotionEx;                                      // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentLipsyncAnimationName;                       // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentLipsyncSlotAlpha;                           // 0x0158(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentLipsyncPlayRateBasis;                       // 0x015C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentLipsyncPlayRate;                            // 0x0160(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LipsyncBlendAlpha;                                 // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterMotionListDataAsset*        MotionList;                                        // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterAnimInstance*>       RCCharacterAnimBP;                                 // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         SkeletalMeshes;                                    // 0x0180(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   CharacterId;                                       // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CharacterName;                                     // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMotionSlotType                               CurrentUseSlotType;                                // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSpawnedFromFurumaiSequencer;                    // 0x01A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A2[0x2E];                                     // 0x01A2(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	class URCExtraMotionCtrl*                     ExtraMotionCtrl;                                   // 0x01D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x18];                                     // 0x01D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventFinished();
	void EventFinishedInMotion(const int32 InSlotNumber);
	void EventFinishedLoopMotion(const int32 InSlotNumber);
	void EventFinishedOutMotion(const int32 InSlotNumber, const float InBlendSec);
	void EventIdle();
	void EventReset();
	void EventSequenceFinished();
	int32 GetUseExtraIdleIndex();
	bool IsExistOutCurrentMotion();
	bool IsExtraIdleTransition();
	bool IsFinishedMotion();
	bool IsMotionBlend();
	bool IsStartedMotion();
	bool PlayLipsyncMotion(const class FName InMotionName, bool bLoop, const float InPlayRate);
	bool PlayMotion(const class FName InMotionName, bool bLoop, const float InPlayRate, EMotionSlotType InUseSlot, EMotionEventSlotSwitchType InSwitchType, const float InLoopMotionPlayStartPosRate, const float InSwitchDurationSec, bool bBlend);
	void SetDeathMatchFlag(bool bInDeathMatch);
	void SetExtraIdleTransition(bool bInbExtraIdleTransition);
	void SetNewAnimBP(class UClass* InNewAnimClass);
	void SetPlayLoop(bool bLoop);
	void SetPlayRate(const float InRate);
	void SetPlayRateBasis(const float InRate);
	void StopLipsyncMotion();
	void SwitchLipsyncIdle();
	void SwitchOutCurrentMotion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterAnimCtrl">();
	}
	static class URCCharacterAnimCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterAnimCtrl>();
	}
};
static_assert(alignof(URCCharacterAnimCtrl) == 0x000008, "Wrong alignment on URCCharacterAnimCtrl");
static_assert(sizeof(URCCharacterAnimCtrl) == 0x0001F0, "Wrong size on URCCharacterAnimCtrl");
static_assert(offsetof(URCCharacterAnimCtrl, bSequencerPlay) == 0x0000B4, "Member 'URCCharacterAnimCtrl::bSequencerPlay' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentAnimationName) == 0x0000B8, "Member 'URCCharacterAnimCtrl::CurrentAnimationName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentAnimation1Name) == 0x0000C0, "Member 'URCCharacterAnimCtrl::CurrentAnimation1Name' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentUseSlotExAnimationName) == 0x0000C8, "Member 'URCCharacterAnimCtrl::CurrentUseSlotExAnimationName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, AnimationName) == 0x0000D0, "Member 'URCCharacterAnimCtrl::AnimationName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, Animation1Name) == 0x0000E0, "Member 'URCCharacterAnimCtrl::Animation1Name' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, ExAnimationName) == 0x0000F0, "Member 'URCCharacterAnimCtrl::ExAnimationName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentSlotAlpha0) == 0x000100, "Member 'URCCharacterAnimCtrl::CurrentSlotAlpha0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, SlotAlpha0) == 0x000104, "Member 'URCCharacterAnimCtrl::SlotAlpha0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentSlotAlpha1) == 0x000108, "Member 'URCCharacterAnimCtrl::CurrentSlotAlpha1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, SlotAlpha1) == 0x00010C, "Member 'URCCharacterAnimCtrl::SlotAlpha1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentSlotAlphaEx) == 0x000110, "Member 'URCCharacterAnimCtrl::CurrentSlotAlphaEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, SlotAlphaEx) == 0x000114, "Member 'URCCharacterAnimCtrl::SlotAlphaEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRateBasis0) == 0x000118, "Member 'URCCharacterAnimCtrl::CurrentPlayRateBasis0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRateBasis0) == 0x00011C, "Member 'URCCharacterAnimCtrl::PlayRateBasis0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRateBasis1) == 0x000120, "Member 'URCCharacterAnimCtrl::CurrentPlayRateBasis1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRateBasis1) == 0x000124, "Member 'URCCharacterAnimCtrl::PlayRateBasis1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRateBasisEx) == 0x000128, "Member 'URCCharacterAnimCtrl::CurrentPlayRateBasisEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRateBasisEx) == 0x00012C, "Member 'URCCharacterAnimCtrl::PlayRateBasisEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRate0) == 0x000130, "Member 'URCCharacterAnimCtrl::CurrentPlayRate0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRate0) == 0x000134, "Member 'URCCharacterAnimCtrl::PlayRate0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRate1) == 0x000138, "Member 'URCCharacterAnimCtrl::CurrentPlayRate1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRate1) == 0x00013C, "Member 'URCCharacterAnimCtrl::PlayRate1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentPlayRateEx) == 0x000140, "Member 'URCCharacterAnimCtrl::CurrentPlayRateEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, PlayRateEx) == 0x000144, "Member 'URCCharacterAnimCtrl::PlayRateEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bCurrentMotionLoop) == 0x000148, "Member 'URCCharacterAnimCtrl::bCurrentMotionLoop' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bMotionLoop) == 0x000149, "Member 'URCCharacterAnimCtrl::bMotionLoop' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bOutMotion0) == 0x00014A, "Member 'URCCharacterAnimCtrl::bOutMotion0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bOutMotion1) == 0x00014B, "Member 'URCCharacterAnimCtrl::bOutMotion1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bOutMotionEx) == 0x00014C, "Member 'URCCharacterAnimCtrl::bOutMotionEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentLipsyncAnimationName) == 0x000150, "Member 'URCCharacterAnimCtrl::CurrentLipsyncAnimationName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentLipsyncSlotAlpha) == 0x000158, "Member 'URCCharacterAnimCtrl::CurrentLipsyncSlotAlpha' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentLipsyncPlayRateBasis) == 0x00015C, "Member 'URCCharacterAnimCtrl::CurrentLipsyncPlayRateBasis' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentLipsyncPlayRate) == 0x000160, "Member 'URCCharacterAnimCtrl::CurrentLipsyncPlayRate' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, LipsyncBlendAlpha) == 0x000164, "Member 'URCCharacterAnimCtrl::LipsyncBlendAlpha' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, MotionList) == 0x000168, "Member 'URCCharacterAnimCtrl::MotionList' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, RCCharacterAnimBP) == 0x000170, "Member 'URCCharacterAnimCtrl::RCCharacterAnimBP' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, SkeletalMeshes) == 0x000180, "Member 'URCCharacterAnimCtrl::SkeletalMeshes' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CharacterId) == 0x000190, "Member 'URCCharacterAnimCtrl::CharacterId' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CharacterName) == 0x000198, "Member 'URCCharacterAnimCtrl::CharacterName' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, CurrentUseSlotType) == 0x0001A0, "Member 'URCCharacterAnimCtrl::CurrentUseSlotType' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, bIsSpawnedFromFurumaiSequencer) == 0x0001A1, "Member 'URCCharacterAnimCtrl::bIsSpawnedFromFurumaiSequencer' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimCtrl, ExtraMotionCtrl) == 0x0001D0, "Member 'URCCharacterAnimCtrl::ExtraMotionCtrl' has a wrong offset!");

// Class RC.RCUiMenuSubQuest
// 0x0040 (0x0340 - 0x0300)
class URCUiMenuSubQuest final : public URCUiMenuQuest
{
public:
	uint8                                         Pad_300[0x40];                                     // 0x0300(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSubQuest">();
	}
	static class URCUiMenuSubQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSubQuest>();
	}
};
static_assert(alignof(URCUiMenuSubQuest) == 0x000008, "Wrong alignment on URCUiMenuSubQuest");
static_assert(sizeof(URCUiMenuSubQuest) == 0x000340, "Wrong size on URCUiMenuSubQuest");

// Class RC.RCCharacterAnimInstance
// 0x02B0 (0x0570 - 0x02C0)
class URCCharacterAnimInstance : public URCAnimInstance
{
public:
	class UAnimationAsset*                        RequestAnimationData;                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseAnimPoseAlphaRate;                             // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestAnimPoseAlphaRate;                          // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCCharacterMotionSlotData             SlotData0;                                         // 0x02D0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRCCharacterMotionSlotData             SlotData1;                                         // 0x0308(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRCCharacterMotionSlotData             SlotDataEx;                                        // 0x0340(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRCScriptActorAnimInstFootIKData       FootIKData;                                        // 0x0378(0x0044)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCAnimInstTurnSettings                TurnSettings;                                      // 0x03C0(0x0088)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRCAnimInstTurnData                    TurnData;                                          // 0x0448(0x00A8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRCScriptActorAnimInstHitReactionData  HitReactionData;                                   // 0x04F0(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHoldingHand;                                      // 0x0514(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_515[0xB];                                      // 0x0515(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HoldingHandPos;                                    // 0x0520(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFakeSpeed;                                     // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x3];                                      // 0x0551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FakeSpeed;                                         // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRCCharacterLipsyncMotionSlotData      LipsyncSlotData;                                   // 0x0558(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	struct FRCCharacterSequencePlayerInfo GetSequencePlayerInfo(class FName InStateMachineName, class FName InStateName, class FName InSequenceName);
	TArray<struct FRCCharacterSequencePlayerInfo> GetSequencePlayerInfos(class FName InAnimGraphName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterAnimInstance">();
	}
	static class URCCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterAnimInstance>();
	}
};
static_assert(alignof(URCCharacterAnimInstance) == 0x000010, "Wrong alignment on URCCharacterAnimInstance");
static_assert(sizeof(URCCharacterAnimInstance) == 0x000570, "Wrong size on URCCharacterAnimInstance");
static_assert(offsetof(URCCharacterAnimInstance, RequestAnimationData) == 0x0002B8, "Member 'URCCharacterAnimInstance::RequestAnimationData' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, bLoop) == 0x0002C0, "Member 'URCCharacterAnimInstance::bLoop' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, BaseAnimPoseAlphaRate) == 0x0002C4, "Member 'URCCharacterAnimInstance::BaseAnimPoseAlphaRate' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, RequestAnimPoseAlphaRate) == 0x0002C8, "Member 'URCCharacterAnimInstance::RequestAnimPoseAlphaRate' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, SlotData0) == 0x0002D0, "Member 'URCCharacterAnimInstance::SlotData0' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, SlotData1) == 0x000308, "Member 'URCCharacterAnimInstance::SlotData1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, SlotDataEx) == 0x000340, "Member 'URCCharacterAnimInstance::SlotDataEx' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, FootIKData) == 0x000378, "Member 'URCCharacterAnimInstance::FootIKData' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, TurnSettings) == 0x0003C0, "Member 'URCCharacterAnimInstance::TurnSettings' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, TurnData) == 0x000448, "Member 'URCCharacterAnimInstance::TurnData' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, HitReactionData) == 0x0004F0, "Member 'URCCharacterAnimInstance::HitReactionData' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, bHoldingHand) == 0x000514, "Member 'URCCharacterAnimInstance::bHoldingHand' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, HoldingHandPos) == 0x000520, "Member 'URCCharacterAnimInstance::HoldingHandPos' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, bUseFakeSpeed) == 0x000550, "Member 'URCCharacterAnimInstance::bUseFakeSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, FakeSpeed) == 0x000554, "Member 'URCCharacterAnimInstance::FakeSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimInstance, LipsyncSlotData) == 0x000558, "Member 'URCCharacterAnimInstance::LipsyncSlotData' has a wrong offset!");

// Class RC.RCTitleChapterSelectList
// 0x0058 (0x0350 - 0x02F8)
class URCTitleChapterSelectList : public URCMenuManager
{
public:
	TArray<class URCTitleChapterSelectListItem*>  widgetListItemArray;                               // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URCTitleChapterSelectListItem*>  useListItemArray;                                  // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class USpUIScrollBox*                         ScrollBox;                                         // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           verticalListBox;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         listDispMax;                                       // 0x0328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         dispTopIndex;                                      // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0330(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0334(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCParamChapterSelectDataTableRow> dataArray;                                         // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bUpdateCaption;                                    // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         scrollSize;                                        // 0x034C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UWidget* ChapterSelectListSelectNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectList">();
	}
	static class URCTitleChapterSelectList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectList>();
	}
};
static_assert(alignof(URCTitleChapterSelectList) == 0x000008, "Wrong alignment on URCTitleChapterSelectList");
static_assert(sizeof(URCTitleChapterSelectList) == 0x000350, "Wrong size on URCTitleChapterSelectList");
static_assert(offsetof(URCTitleChapterSelectList, widgetListItemArray) == 0x0002F8, "Member 'URCTitleChapterSelectList::widgetListItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, useListItemArray) == 0x000308, "Member 'URCTitleChapterSelectList::useListItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, ScrollBox) == 0x000318, "Member 'URCTitleChapterSelectList::ScrollBox' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, verticalListBox) == 0x000320, "Member 'URCTitleChapterSelectList::verticalListBox' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, listDispMax) == 0x000328, "Member 'URCTitleChapterSelectList::listDispMax' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, dispTopIndex) == 0x00032C, "Member 'URCTitleChapterSelectList::dispTopIndex' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, SelectIndex) == 0x000330, "Member 'URCTitleChapterSelectList::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, bListLoop) == 0x000334, "Member 'URCTitleChapterSelectList::bListLoop' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, dataArray) == 0x000338, "Member 'URCTitleChapterSelectList::dataArray' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, bUpdateCaption) == 0x000348, "Member 'URCTitleChapterSelectList::bUpdateCaption' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectList, scrollSize) == 0x00034C, "Member 'URCTitleChapterSelectList::scrollSize' has a wrong offset!");

// Class RC.RCCharacterAnimNotify
// 0x0030 (0x0068 - 0x0038)
class URCCharacterAnimNotify final : public URCAnimNotify
{
public:
	EAnimationNotifyType                          NotifyType;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StrValue1;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StrValue2;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloatValue1;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloatValue2;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetFloatValue1(float InValue) const;
	void SetFloatValue2(float InValue) const;
	void SetNotifyType(EAnimationNotifyType InType) const;
	void SetStrValue1(const class FString& InValue) const;
	void SetStrValue2(const class FString& InValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterAnimNotify">();
	}
	static class URCCharacterAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterAnimNotify>();
	}
};
static_assert(alignof(URCCharacterAnimNotify) == 0x000008, "Wrong alignment on URCCharacterAnimNotify");
static_assert(sizeof(URCCharacterAnimNotify) == 0x000068, "Wrong size on URCCharacterAnimNotify");
static_assert(offsetof(URCCharacterAnimNotify, NotifyType) == 0x000038, "Member 'URCCharacterAnimNotify::NotifyType' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimNotify, StrValue1) == 0x000040, "Member 'URCCharacterAnimNotify::StrValue1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimNotify, StrValue2) == 0x000050, "Member 'URCCharacterAnimNotify::StrValue2' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimNotify, FloatValue1) == 0x000060, "Member 'URCCharacterAnimNotify::FloatValue1' has a wrong offset!");
static_assert(offsetof(URCCharacterAnimNotify, FloatValue2) == 0x000064, "Member 'URCCharacterAnimNotify::FloatValue2' has a wrong offset!");

// Class RC.RCGrassSweep
// 0x0078 (0x0298 - 0x0220)
class ARCGrassSweep final : public AActor
{
public:
	float                                         Radius;                                            // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLimit;                                     // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BindingDuration;                                   // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleSpeed;                                       // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleInterval;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Waveform;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Attenuation;                                       // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedScale;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FormingDirection;                                  // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DeformCurve;                                       // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RippleRadius;                                      // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         RippleGenerateTimer;                               // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateInterval;                                    // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviouseTickLocation;                             // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCGrassSweepTransformer*>       GrassSweepTransformers;                            // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassSweep">();
	}
	static class ARCGrassSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassSweep>();
	}
};
static_assert(alignof(ARCGrassSweep) == 0x000008, "Wrong alignment on ARCGrassSweep");
static_assert(sizeof(ARCGrassSweep) == 0x000298, "Wrong size on ARCGrassSweep");
static_assert(offsetof(ARCGrassSweep, Radius) == 0x000220, "Member 'ARCGrassSweep::Radius' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, Thickness) == 0x000224, "Member 'ARCGrassSweep::Thickness' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, RotationLimit) == 0x000228, "Member 'ARCGrassSweep::RotationLimit' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, BindingDuration) == 0x00022C, "Member 'ARCGrassSweep::BindingDuration' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, RippleSpeed) == 0x000230, "Member 'ARCGrassSweep::RippleSpeed' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, RippleInterval) == 0x000234, "Member 'ARCGrassSweep::RippleInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, Waveform) == 0x000238, "Member 'ARCGrassSweep::Waveform' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, Attenuation) == 0x000240, "Member 'ARCGrassSweep::Attenuation' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, SpeedScale) == 0x000248, "Member 'ARCGrassSweep::SpeedScale' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, FormingDirection) == 0x000250, "Member 'ARCGrassSweep::FormingDirection' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, DeformCurve) == 0x000258, "Member 'ARCGrassSweep::DeformCurve' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, RippleRadius) == 0x000260, "Member 'ARCGrassSweep::RippleRadius' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, RippleGenerateTimer) == 0x000270, "Member 'ARCGrassSweep::RippleGenerateTimer' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, UpdateInterval) == 0x000274, "Member 'ARCGrassSweep::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, PreviouseTickLocation) == 0x000278, "Member 'ARCGrassSweep::PreviouseTickLocation' has a wrong offset!");
static_assert(offsetof(ARCGrassSweep, GrassSweepTransformers) == 0x000288, "Member 'ARCGrassSweep::GrassSweepTransformers' has a wrong offset!");

// Class RC.RCCharacterAttachmentCtrl
// 0x0110 (0x01C0 - 0x00B0)
class URCCharacterAttachmentCtrl final : public UActorComponent
{
public:
	EAttachState                                  State;                                             // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentAttachmentFormId;                           // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttachPlaceType, class ARCActor*>       AttachmentMap;                                     // 0x00C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  AttachPlaceEnum;                                   // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     CharacterBase;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          PawnBase;                                          // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MapAmbientLightColor;                              // 0x0178(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MapDirectionalLightColor;                          // 0x0188(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         MeshArray;                                         // 0x0198(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterialArray;                              // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x6];                                      // 0x01B8(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAssetPriority                              ReadPriorily;                                      // 0x01BE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BF[0x1];                                      // 0x01BF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterAttachmentCtrl">();
	}
	static class URCCharacterAttachmentCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterAttachmentCtrl>();
	}
};
static_assert(alignof(URCCharacterAttachmentCtrl) == 0x000008, "Wrong alignment on URCCharacterAttachmentCtrl");
static_assert(sizeof(URCCharacterAttachmentCtrl) == 0x0001C0, "Wrong size on URCCharacterAttachmentCtrl");
static_assert(offsetof(URCCharacterAttachmentCtrl, State) == 0x0000B0, "Member 'URCCharacterAttachmentCtrl::State' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, CurrentAttachmentFormId) == 0x0000B4, "Member 'URCCharacterAttachmentCtrl::CurrentAttachmentFormId' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, AttachmentMap) == 0x0000C0, "Member 'URCCharacterAttachmentCtrl::AttachmentMap' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, AttachPlaceEnum) == 0x000160, "Member 'URCCharacterAttachmentCtrl::AttachPlaceEnum' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, CharacterBase) == 0x000168, "Member 'URCCharacterAttachmentCtrl::CharacterBase' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, PawnBase) == 0x000170, "Member 'URCCharacterAttachmentCtrl::PawnBase' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, MapAmbientLightColor) == 0x000178, "Member 'URCCharacterAttachmentCtrl::MapAmbientLightColor' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, MapDirectionalLightColor) == 0x000188, "Member 'URCCharacterAttachmentCtrl::MapDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, MeshArray) == 0x000198, "Member 'URCCharacterAttachmentCtrl::MeshArray' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, DynamicMaterialArray) == 0x0001A8, "Member 'URCCharacterAttachmentCtrl::DynamicMaterialArray' has a wrong offset!");
static_assert(offsetof(URCCharacterAttachmentCtrl, ReadPriorily) == 0x0001BE, "Member 'URCCharacterAttachmentCtrl::ReadPriorily' has a wrong offset!");

// Class RC.RCScriptActorComponent
// 0x0128 (0x01D8 - 0x00B0)
class URCScriptActorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x1C];                                      // 0x00B0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMovementComponent;                              // 0x00CC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCollsion;                                       // 0x00CD(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTickExec;                                         // 0x00CE(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMoveVector3;                                      // 0x00CF(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RunSpeed;                                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeed;                                         // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRunSpeed;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultWalkSpeed;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeedSettingFirst;                                // 0x00E0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallLock;                                         // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x00E4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMove;                                             // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveFirstWarp;                                    // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveLoop;                                         // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3[0x1];                                       // 0x00F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovePositionNum;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRCScriptActorMoveInfo>         MovePositionList;                                  // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMoveEndChangeYaw;                                 // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveEndChangeYawPosition;                          // 0x010C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEndOffetYaw;                                   // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovePlayerCheck;                                  // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveSplineName;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSplineDistance;                                // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveSplineReverse;                                // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveOnSpline;                                     // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveWait;                                          // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovePause;                                        // 0x0134(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveYanwChange;                                   // 0x0135(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveFadeOut;                                      // 0x0136(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeYaw;                                        // 0x0137(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeYawSpeed;                                    // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeYawSpeedSclae;                               // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeYaw;                                         // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeYawTime;                                     // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStart;                                        // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStartUp;                                      // 0x0149(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeedScale;                                    // 0x014C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStopSpeedScale;                                // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStopTickMax;                                   // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStopTick;                                      // 0x0158(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdleMotionID;                                      // 0x015C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveBlock;                                        // 0x0164(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSplineSpeed;                                   // 0x0168(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreWalkSplineTimeRate;                             // 0x016C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BSMaxSpeed;                                        // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineSpeedAjustRate;                              // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSplineZOffset;                                 // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BackPosition;                                      // 0x017C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackYaw;                                           // 0x0188(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMove;                                         // 0x018C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMoveFirstWarp;                                // 0x018D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMoveLoop;                                     // 0x018E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F[0x1];                                      // 0x018F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BackMovePositionNum;                               // 0x0190(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCScriptActorMoveInfo>         BackMovePositionList;                              // 0x0198(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bBackMoveEndChangeYaw;                             // 0x01A8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BackMoveEndChangeYawPosition;                      // 0x01AC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackMoveEndOffetYaw;                               // 0x01B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackMoveWait;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMovePlayerCheck;                              // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BackMoveSplineName;                                // 0x01C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackMoveSplineDistance;                            // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMoveSplineReverse;                            // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackMoveOnSpline;                                 // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x6];                                      // 0x01D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCScriptActorComponent">();
	}
	static class URCScriptActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCScriptActorComponent>();
	}
};
static_assert(alignof(URCScriptActorComponent) == 0x000008, "Wrong alignment on URCScriptActorComponent");
static_assert(sizeof(URCScriptActorComponent) == 0x0001D8, "Wrong size on URCScriptActorComponent");
static_assert(offsetof(URCScriptActorComponent, bIsMovementComponent) == 0x0000CC, "Member 'URCScriptActorComponent::bIsMovementComponent' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bIsCollsion) == 0x0000CD, "Member 'URCScriptActorComponent::bIsCollsion' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bTickExec) == 0x0000CE, "Member 'URCScriptActorComponent::bTickExec' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveVector3) == 0x0000CF, "Member 'URCScriptActorComponent::bMoveVector3' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, RunSpeed) == 0x0000D0, "Member 'URCScriptActorComponent::RunSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, WalkSpeed) == 0x0000D4, "Member 'URCScriptActorComponent::WalkSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, DefaultRunSpeed) == 0x0000D8, "Member 'URCScriptActorComponent::DefaultRunSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, DefaultWalkSpeed) == 0x0000DC, "Member 'URCScriptActorComponent::DefaultWalkSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bSpeedSettingFirst) == 0x0000E0, "Member 'URCScriptActorComponent::bSpeedSettingFirst' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bFallLock) == 0x0000E1, "Member 'URCScriptActorComponent::bFallLock' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, Velocity) == 0x0000E4, "Member 'URCScriptActorComponent::Velocity' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMove) == 0x0000F0, "Member 'URCScriptActorComponent::bMove' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveFirstWarp) == 0x0000F1, "Member 'URCScriptActorComponent::bMoveFirstWarp' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveLoop) == 0x0000F2, "Member 'URCScriptActorComponent::bMoveLoop' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MovePositionNum) == 0x0000F4, "Member 'URCScriptActorComponent::MovePositionNum' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MovePositionList) == 0x0000F8, "Member 'URCScriptActorComponent::MovePositionList' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveEndChangeYaw) == 0x000108, "Member 'URCScriptActorComponent::bMoveEndChangeYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveEndChangeYawPosition) == 0x00010C, "Member 'URCScriptActorComponent::MoveEndChangeYawPosition' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveEndOffetYaw) == 0x000118, "Member 'URCScriptActorComponent::MoveEndOffetYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMovePlayerCheck) == 0x00011C, "Member 'URCScriptActorComponent::bMovePlayerCheck' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveSplineName) == 0x000120, "Member 'URCScriptActorComponent::MoveSplineName' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveSplineDistance) == 0x000128, "Member 'URCScriptActorComponent::MoveSplineDistance' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveSplineReverse) == 0x00012C, "Member 'URCScriptActorComponent::bMoveSplineReverse' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveOnSpline) == 0x00012D, "Member 'URCScriptActorComponent::bMoveOnSpline' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveWait) == 0x000130, "Member 'URCScriptActorComponent::MoveWait' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMovePause) == 0x000134, "Member 'URCScriptActorComponent::bMovePause' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveYanwChange) == 0x000135, "Member 'URCScriptActorComponent::bMoveYanwChange' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveFadeOut) == 0x000136, "Member 'URCScriptActorComponent::bMoveFadeOut' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bChangeYaw) == 0x000137, "Member 'URCScriptActorComponent::bChangeYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, ChangeYawSpeed) == 0x000138, "Member 'URCScriptActorComponent::ChangeYawSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, ChangeYawSpeedSclae) == 0x00013C, "Member 'URCScriptActorComponent::ChangeYawSpeedSclae' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, ChangeYaw) == 0x000140, "Member 'URCScriptActorComponent::ChangeYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, ChangeYawTime) == 0x000144, "Member 'URCScriptActorComponent::ChangeYawTime' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveStart) == 0x000148, "Member 'URCScriptActorComponent::bMoveStart' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveStartUp) == 0x000149, "Member 'URCScriptActorComponent::bMoveStartUp' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveSpeedScale) == 0x00014C, "Member 'URCScriptActorComponent::MoveSpeedScale' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveStopSpeedScale) == 0x000150, "Member 'URCScriptActorComponent::MoveStopSpeedScale' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveStopTickMax) == 0x000154, "Member 'URCScriptActorComponent::MoveStopTickMax' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, MoveStopTick) == 0x000158, "Member 'URCScriptActorComponent::MoveStopTick' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, IdleMotionID) == 0x00015C, "Member 'URCScriptActorComponent::IdleMotionID' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bMoveBlock) == 0x000164, "Member 'URCScriptActorComponent::bMoveBlock' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, WalkSplineSpeed) == 0x000168, "Member 'URCScriptActorComponent::WalkSplineSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, PreWalkSplineTimeRate) == 0x00016C, "Member 'URCScriptActorComponent::PreWalkSplineTimeRate' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BSMaxSpeed) == 0x000170, "Member 'URCScriptActorComponent::BSMaxSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, SplineSpeedAjustRate) == 0x000174, "Member 'URCScriptActorComponent::SplineSpeedAjustRate' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, WalkSplineZOffset) == 0x000178, "Member 'URCScriptActorComponent::WalkSplineZOffset' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackPosition) == 0x00017C, "Member 'URCScriptActorComponent::BackPosition' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackYaw) == 0x000188, "Member 'URCScriptActorComponent::BackYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMove) == 0x00018C, "Member 'URCScriptActorComponent::bBackMove' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMoveFirstWarp) == 0x00018D, "Member 'URCScriptActorComponent::bBackMoveFirstWarp' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMoveLoop) == 0x00018E, "Member 'URCScriptActorComponent::bBackMoveLoop' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMovePositionNum) == 0x000190, "Member 'URCScriptActorComponent::BackMovePositionNum' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMovePositionList) == 0x000198, "Member 'URCScriptActorComponent::BackMovePositionList' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMoveEndChangeYaw) == 0x0001A8, "Member 'URCScriptActorComponent::bBackMoveEndChangeYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMoveEndChangeYawPosition) == 0x0001AC, "Member 'URCScriptActorComponent::BackMoveEndChangeYawPosition' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMoveEndOffetYaw) == 0x0001B8, "Member 'URCScriptActorComponent::BackMoveEndOffetYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMoveWait) == 0x0001BC, "Member 'URCScriptActorComponent::BackMoveWait' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMovePlayerCheck) == 0x0001C0, "Member 'URCScriptActorComponent::bBackMovePlayerCheck' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMoveSplineName) == 0x0001C4, "Member 'URCScriptActorComponent::BackMoveSplineName' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, BackMoveSplineDistance) == 0x0001CC, "Member 'URCScriptActorComponent::BackMoveSplineDistance' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMoveSplineReverse) == 0x0001D0, "Member 'URCScriptActorComponent::bBackMoveSplineReverse' has a wrong offset!");
static_assert(offsetof(URCScriptActorComponent, bBackMoveOnSpline) == 0x0001D1, "Member 'URCScriptActorComponent::bBackMoveOnSpline' has a wrong offset!");

// Class RC.RCCharacterFacialCtrl
// 0x01B0 (0x0260 - 0x00B0)
class URCCharacterFacialCtrl : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentFacialName;                                 // 0x0100(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FacialName;                                        // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBlink;                                         // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkIntervalSec;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlinkDuration;                                     // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShortBlinkIntervalCount;                           // 0x0124(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipsyncBasedOnLinesIntervalSec;                    // 0x0128(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipsyncBasedOnLinesDuration;                       // 0x012C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERCCharacterMorphTarget>               LipsyncBasedOnLinesMorphArray;                     // 0x0138(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 LipsyncBasedOnLinesValueArray;                     // 0x0148(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialDuration;                                    // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialBlendRate;                                   // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMorphBlender*                        EyeMorphBlend;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMorphBlender*                        EyebrowMorphBlend;                                 // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMorphBlender*                        MouthMorphBlend;                                   // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterId;                                       // 0x0190(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BaseCharacterId;                                   // 0x0198(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentEyeLPatternName;                            // 0x01A0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentEyeRPatternName;                            // 0x01B0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentEffectLinePatternName;                      // 0x01C0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x2];                                      // 0x01D0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanFlowLiquid;                                    // 0x01D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D3[0x1];                                      // 0x01D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlowLiquidSec;                                     // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlowLiquidBackSec;                                 // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0xC];                                      // 0x01DC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentSSweatParam;                                // 0x01E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreSSweatParam;                                    // 0x01EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostSSweatParam;                                   // 0x01F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBSweatParam;                                // 0x01F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreBSweatParam;                                    // 0x01F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostBSweatParam;                                   // 0x01FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTearsParam;                                 // 0x0200(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreTearsParam;                                     // 0x0204(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostTearsParam;                                    // 0x0208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentColorChangePatternName;                     // 0x0210(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentColorChangePatternIntensity;                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreColorChangePatternIntensity;                    // 0x0224(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostColorChangePatternIntensity;                   // 0x0228(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0xC];                                      // 0x022C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColorChangePatternBackSec;                         // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorChangeColor;                                  // 0x0240(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LipSyncCullNum;                                    // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0xC];                                      // 0x0254(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blink();
	void ChangeFacial(const class FName InFacialName, bool bAllowFlowLiquid);
	void SetCanBlink(bool bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterFacialCtrl">();
	}
	static class URCCharacterFacialCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterFacialCtrl>();
	}
};
static_assert(alignof(URCCharacterFacialCtrl) == 0x000008, "Wrong alignment on URCCharacterFacialCtrl");
static_assert(sizeof(URCCharacterFacialCtrl) == 0x000260, "Wrong size on URCCharacterFacialCtrl");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentFacialName) == 0x000100, "Member 'URCCharacterFacialCtrl::CurrentFacialName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, FacialName) == 0x000108, "Member 'URCCharacterFacialCtrl::FacialName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, bCanBlink) == 0x000118, "Member 'URCCharacterFacialCtrl::bCanBlink' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, BlinkIntervalSec) == 0x00011C, "Member 'URCCharacterFacialCtrl::BlinkIntervalSec' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, BlinkDuration) == 0x000120, "Member 'URCCharacterFacialCtrl::BlinkDuration' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, ShortBlinkIntervalCount) == 0x000124, "Member 'URCCharacterFacialCtrl::ShortBlinkIntervalCount' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, LipsyncBasedOnLinesIntervalSec) == 0x000128, "Member 'URCCharacterFacialCtrl::LipsyncBasedOnLinesIntervalSec' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, LipsyncBasedOnLinesDuration) == 0x00012C, "Member 'URCCharacterFacialCtrl::LipsyncBasedOnLinesDuration' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, LipsyncBasedOnLinesMorphArray) == 0x000138, "Member 'URCCharacterFacialCtrl::LipsyncBasedOnLinesMorphArray' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, LipsyncBasedOnLinesValueArray) == 0x000148, "Member 'URCCharacterFacialCtrl::LipsyncBasedOnLinesValueArray' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, FacialDuration) == 0x000160, "Member 'URCCharacterFacialCtrl::FacialDuration' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, FacialBlendRate) == 0x000164, "Member 'URCCharacterFacialCtrl::FacialBlendRate' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, EyeMorphBlend) == 0x000168, "Member 'URCCharacterFacialCtrl::EyeMorphBlend' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, EyebrowMorphBlend) == 0x000170, "Member 'URCCharacterFacialCtrl::EyebrowMorphBlend' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, MouthMorphBlend) == 0x000178, "Member 'URCCharacterFacialCtrl::MouthMorphBlend' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CharacterId) == 0x000190, "Member 'URCCharacterFacialCtrl::CharacterId' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, BaseCharacterId) == 0x000198, "Member 'URCCharacterFacialCtrl::BaseCharacterId' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentEyeLPatternName) == 0x0001A0, "Member 'URCCharacterFacialCtrl::CurrentEyeLPatternName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentEyeRPatternName) == 0x0001B0, "Member 'URCCharacterFacialCtrl::CurrentEyeRPatternName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentEffectLinePatternName) == 0x0001C0, "Member 'URCCharacterFacialCtrl::CurrentEffectLinePatternName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, bCanFlowLiquid) == 0x0001D2, "Member 'URCCharacterFacialCtrl::bCanFlowLiquid' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, FlowLiquidSec) == 0x0001D4, "Member 'URCCharacterFacialCtrl::FlowLiquidSec' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, FlowLiquidBackSec) == 0x0001D8, "Member 'URCCharacterFacialCtrl::FlowLiquidBackSec' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentSSweatParam) == 0x0001E8, "Member 'URCCharacterFacialCtrl::CurrentSSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PreSSweatParam) == 0x0001EC, "Member 'URCCharacterFacialCtrl::PreSSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PostSSweatParam) == 0x0001F0, "Member 'URCCharacterFacialCtrl::PostSSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentBSweatParam) == 0x0001F4, "Member 'URCCharacterFacialCtrl::CurrentBSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PreBSweatParam) == 0x0001F8, "Member 'URCCharacterFacialCtrl::PreBSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PostBSweatParam) == 0x0001FC, "Member 'URCCharacterFacialCtrl::PostBSweatParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentTearsParam) == 0x000200, "Member 'URCCharacterFacialCtrl::CurrentTearsParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PreTearsParam) == 0x000204, "Member 'URCCharacterFacialCtrl::PreTearsParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PostTearsParam) == 0x000208, "Member 'URCCharacterFacialCtrl::PostTearsParam' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentColorChangePatternName) == 0x000210, "Member 'URCCharacterFacialCtrl::CurrentColorChangePatternName' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, CurrentColorChangePatternIntensity) == 0x000220, "Member 'URCCharacterFacialCtrl::CurrentColorChangePatternIntensity' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PreColorChangePatternIntensity) == 0x000224, "Member 'URCCharacterFacialCtrl::PreColorChangePatternIntensity' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, PostColorChangePatternIntensity) == 0x000228, "Member 'URCCharacterFacialCtrl::PostColorChangePatternIntensity' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, ColorChangePatternBackSec) == 0x000238, "Member 'URCCharacterFacialCtrl::ColorChangePatternBackSec' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, ColorChangeColor) == 0x000240, "Member 'URCCharacterFacialCtrl::ColorChangeColor' has a wrong offset!");
static_assert(offsetof(URCCharacterFacialCtrl, LipSyncCullNum) == 0x000250, "Member 'URCCharacterFacialCtrl::LipSyncCullNum' has a wrong offset!");

// Class RC.RCEventCharacter
// 0x00A0 (0x0A00 - 0x0960)
class ARCEventCharacter final : public ARCCharacterRender
{
public:
	class FName                                   FormStyle;                                         // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FRCEventCharacterFormStyleData> FormStyleDataMap;                                  // 0x0968(0x0050)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 EyeSkeletalMesh;                                   // 0x09B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoHairSpecular;                                 // 0x09C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C1[0x3];                                      // 0x09C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadInitRotator;                                   // 0x09C4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               HeadCurrentRotator;                                // 0x09D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               HeadDiffRotator;                                   // 0x09DC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         HairSpecularX;                                     // 0x09E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HairSpecularY;                                     // 0x09EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HairSpecularZ;                                     // 0x09F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F4[0xC];                                      // 0x09F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URCCharacterAnimCtrl* GetAnimCtrl();

	const class USkeletalMeshComponent* GetEyeSkeletalMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventCharacter">();
	}
	static class ARCEventCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEventCharacter>();
	}
};
static_assert(alignof(ARCEventCharacter) == 0x000010, "Wrong alignment on ARCEventCharacter");
static_assert(sizeof(ARCEventCharacter) == 0x000A00, "Wrong size on ARCEventCharacter");
static_assert(offsetof(ARCEventCharacter, FormStyle) == 0x000960, "Member 'ARCEventCharacter::FormStyle' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, FormStyleDataMap) == 0x000968, "Member 'ARCEventCharacter::FormStyleDataMap' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, EyeSkeletalMesh) == 0x0009B8, "Member 'ARCEventCharacter::EyeSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, bAutoHairSpecular) == 0x0009C0, "Member 'ARCEventCharacter::bAutoHairSpecular' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HeadInitRotator) == 0x0009C4, "Member 'ARCEventCharacter::HeadInitRotator' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HeadCurrentRotator) == 0x0009D0, "Member 'ARCEventCharacter::HeadCurrentRotator' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HeadDiffRotator) == 0x0009DC, "Member 'ARCEventCharacter::HeadDiffRotator' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HairSpecularX) == 0x0009E8, "Member 'ARCEventCharacter::HairSpecularX' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HairSpecularY) == 0x0009EC, "Member 'ARCEventCharacter::HairSpecularY' has a wrong offset!");
static_assert(offsetof(ARCEventCharacter, HairSpecularZ) == 0x0009F0, "Member 'ARCEventCharacter::HairSpecularZ' has a wrong offset!");

// Class RC.RCCharacterFacialDataAsset
// 0x0010 (0x0040 - 0x0030)
class URCCharacterFacialDataAsset final : public UDataAsset
{
public:
	TArray<class FString>                         Records;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Reimport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterFacialDataAsset">();
	}
	static class URCCharacterFacialDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterFacialDataAsset>();
	}
};
static_assert(alignof(URCCharacterFacialDataAsset) == 0x000008, "Wrong alignment on URCCharacterFacialDataAsset");
static_assert(sizeof(URCCharacterFacialDataAsset) == 0x000040, "Wrong size on URCCharacterFacialDataAsset");
static_assert(offsetof(URCCharacterFacialDataAsset, Records) == 0x000030, "Member 'URCCharacterFacialDataAsset::Records' has a wrong offset!");

// Class RC.RCInstanceTransformer
// 0x0008 (0x0288 - 0x0280)
class ARCInstanceTransformer final : public ARCGrassTransformer
{
public:
	float                                         CurrentAlpha;                                      // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateGrassTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInstanceTransformer">();
	}
	static class ARCInstanceTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCInstanceTransformer>();
	}
};
static_assert(alignof(ARCInstanceTransformer) == 0x000008, "Wrong alignment on ARCInstanceTransformer");
static_assert(sizeof(ARCInstanceTransformer) == 0x000288, "Wrong size on ARCInstanceTransformer");
static_assert(offsetof(ARCInstanceTransformer, CurrentAlpha) == 0x000280, "Member 'ARCInstanceTransformer::CurrentAlpha' has a wrong offset!");

// Class RC.RCCharacterFacialListDataAsset
// 0x0050 (0x0080 - 0x0030)
class URCCharacterFacialListDataAsset final : public UDataAsset
{
public:
	TMap<class FName, class FName>                Records;                                           // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void Reimport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterFacialListDataAsset">();
	}
	static class URCCharacterFacialListDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterFacialListDataAsset>();
	}
};
static_assert(alignof(URCCharacterFacialListDataAsset) == 0x000008, "Wrong alignment on URCCharacterFacialListDataAsset");
static_assert(sizeof(URCCharacterFacialListDataAsset) == 0x000080, "Wrong size on URCCharacterFacialListDataAsset");
static_assert(offsetof(URCCharacterFacialListDataAsset, Records) == 0x000030, "Member 'URCCharacterFacialListDataAsset::Records' has a wrong offset!");

// Class RC.RCNzUiCountdown
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiCountdown final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Blinking;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiCountdownNum*                    CountdownNum;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseCountdown();
	void InitCountdown(int32 Time, int32 blinkingStartTime);
	void SetFTime(float Time);
	void ShowCountdown();
	void StartCountdown();
	void StopCountdown();

	bool IsFinished() const;
	bool IsShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiCountdown">();
	}
	static class URCNzUiCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiCountdown>();
	}
};
static_assert(alignof(URCNzUiCountdown) == 0x000008, "Wrong alignment on URCNzUiCountdown");
static_assert(sizeof(URCNzUiCountdown) == 0x000310, "Wrong size on URCNzUiCountdown");
static_assert(offsetof(URCNzUiCountdown, AN_Start) == 0x0002D8, "Member 'URCNzUiCountdown::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdown, AN_Finish) == 0x0002E0, "Member 'URCNzUiCountdown::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdown, AN_Blinking) == 0x0002E8, "Member 'URCNzUiCountdown::AN_Blinking' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdown, CountdownNum) == 0x0002F0, "Member 'URCNzUiCountdown::CountdownNum' has a wrong offset!");

// Class RC.RCCharacterFootIKBFL
// 0x0000 (0x0028 - 0x0028)
class URCCharacterFootIKBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AnimInstSetCanFootIK(class URCCharacterAnimInstance* AnimInst, bool bCanFootIK);
	static void AnimInstTickFootIK(class URCCharacterAnimInstance* AnimInst);
	static void InitFootIK(class URCCharacterMovementComponent* MovementComp);
	static void SetFootIKEnable(class AActor* Actor, bool bFootIKEnable);
	static void TickFootIK(float DeltaTime, class URCCharacterMovementComponent* MovementComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterFootIKBFL">();
	}
	static class URCCharacterFootIKBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterFootIKBFL>();
	}
};
static_assert(alignof(URCCharacterFootIKBFL) == 0x000008, "Wrong alignment on URCCharacterFootIKBFL");
static_assert(sizeof(URCCharacterFootIKBFL) == 0x000028, "Wrong size on URCCharacterFootIKBFL");

// Class RC.RCCharacterFormCtrl
// 0x0128 (0x01D8 - 0x00B0)
class URCCharacterFormCtrl final : public UActorComponent
{
public:
	EFormState                                    State;                                             // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentSkinId;                                     // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentEyeId;                                      // 0x00BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentFormId;                                     // 0x00C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecalProcess;                                     // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUmbrellaShadowProcess;                            // 0x00CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCAssetPriority                              ReadPriorily;                                      // 0x00CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     CharacterBase;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          PawnBase;                                          // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerSkeletalMeshComponent;                        // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EFormPartType, class USkeletalMeshComponent*> FormMap;                                           // 0x00F8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x78];                                     // 0x0148(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  FormPartTypeEnum;                                  // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0xC];                                      // 0x01C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ERCOptionMobQuality                           MobQuality;                                        // 0x01D4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterFormCtrl">();
	}
	static class URCCharacterFormCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterFormCtrl>();
	}
};
static_assert(alignof(URCCharacterFormCtrl) == 0x000008, "Wrong alignment on URCCharacterFormCtrl");
static_assert(sizeof(URCCharacterFormCtrl) == 0x0001D8, "Wrong size on URCCharacterFormCtrl");
static_assert(offsetof(URCCharacterFormCtrl, State) == 0x0000B0, "Member 'URCCharacterFormCtrl::State' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, CurrentSkinId) == 0x0000B4, "Member 'URCCharacterFormCtrl::CurrentSkinId' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, CurrentEyeId) == 0x0000BC, "Member 'URCCharacterFormCtrl::CurrentEyeId' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, CurrentFormId) == 0x0000C4, "Member 'URCCharacterFormCtrl::CurrentFormId' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, bDecalProcess) == 0x0000CC, "Member 'URCCharacterFormCtrl::bDecalProcess' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, bUmbrellaShadowProcess) == 0x0000CD, "Member 'URCCharacterFormCtrl::bUmbrellaShadowProcess' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, ReadPriorily) == 0x0000CE, "Member 'URCCharacterFormCtrl::ReadPriorily' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, CharacterBase) == 0x0000D0, "Member 'URCCharacterFormCtrl::CharacterBase' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, PawnBase) == 0x0000D8, "Member 'URCCharacterFormCtrl::PawnBase' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, OwnerSkeletalMeshComponent) == 0x0000F0, "Member 'URCCharacterFormCtrl::OwnerSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, FormMap) == 0x0000F8, "Member 'URCCharacterFormCtrl::FormMap' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, FormPartTypeEnum) == 0x0001C0, "Member 'URCCharacterFormCtrl::FormPartTypeEnum' has a wrong offset!");
static_assert(offsetof(URCCharacterFormCtrl, MobQuality) == 0x0001D4, "Member 'URCCharacterFormCtrl::MobQuality' has a wrong offset!");

// Class RC.RCScreenshotBFL
// 0x0000 (0x0028 - 0x0028)
class URCScreenshotBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEnable();
	static void SetEnable(bool bFlag);
	static void SetEnableFromChapter(int32 InChapter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCScreenshotBFL">();
	}
	static class URCScreenshotBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCScreenshotBFL>();
	}
};
static_assert(alignof(URCScreenshotBFL) == 0x000008, "Wrong alignment on URCScreenshotBFL");
static_assert(sizeof(URCScreenshotBFL) == 0x000028, "Wrong size on URCScreenshotBFL");

// Class RC.RCCharacterHitReactionBFL
// 0x0000 (0x0028 - 0x0028)
class URCCharacterHitReactionBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AnimInstTickHitReaction(float DeltaTime, class URCCharacterAnimInstance* AnimInst);
	static void TickHitReaction(float DeltaTime, class URCCharacterMovementComponent* MovementComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterHitReactionBFL">();
	}
	static class URCCharacterHitReactionBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterHitReactionBFL>();
	}
};
static_assert(alignof(URCCharacterHitReactionBFL) == 0x000008, "Wrong alignment on URCCharacterHitReactionBFL");
static_assert(sizeof(URCCharacterHitReactionBFL) == 0x000028, "Wrong size on URCCharacterHitReactionBFL");

// Class RC.RCCharacterHoldingHandCtrl
// 0x0080 (0x0130 - 0x00B0)
class URCCharacterHoldingHandCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHoldingHand;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HoldingHandCharacter;                              // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HoldingHandPos;                                    // 0x00D0(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterAnimInstance*>       OwnerCharacterAnimBP;                              // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterAnimInstance*>       TargetCharacterAnimBP;                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     CharacterBase;                                     // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          PawnBase;                                          // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterHoldingHandCtrl">();
	}
	static class URCCharacterHoldingHandCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterHoldingHandCtrl>();
	}
};
static_assert(alignof(URCCharacterHoldingHandCtrl) == 0x000010, "Wrong alignment on URCCharacterHoldingHandCtrl");
static_assert(sizeof(URCCharacterHoldingHandCtrl) == 0x000130, "Wrong size on URCCharacterHoldingHandCtrl");
static_assert(offsetof(URCCharacterHoldingHandCtrl, bHoldingHand) == 0x0000B8, "Member 'URCCharacterHoldingHandCtrl::bHoldingHand' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, HoldingHandCharacter) == 0x0000C0, "Member 'URCCharacterHoldingHandCtrl::HoldingHandCharacter' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, HoldingHandPos) == 0x0000D0, "Member 'URCCharacterHoldingHandCtrl::HoldingHandPos' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, OwnerCharacterAnimBP) == 0x000100, "Member 'URCCharacterHoldingHandCtrl::OwnerCharacterAnimBP' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, TargetCharacterAnimBP) == 0x000110, "Member 'URCCharacterHoldingHandCtrl::TargetCharacterAnimBP' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, CharacterBase) == 0x000120, "Member 'URCCharacterHoldingHandCtrl::CharacterBase' has a wrong offset!");
static_assert(offsetof(URCCharacterHoldingHandCtrl, PawnBase) == 0x000128, "Member 'URCCharacterHoldingHandCtrl::PawnBase' has a wrong offset!");

// Class RC.RCSequenceFollowTarget
// 0x0080 (0x02A0 - 0x0220)
class alignas(0x10) ARCSequenceFollowTarget final : public AActor
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 FollowActor;                                       // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x70];                                     // 0x0230(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSequenceFollowTarget">();
	}
	static class ARCSequenceFollowTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSequenceFollowTarget>();
	}
};
static_assert(alignof(ARCSequenceFollowTarget) == 0x000010, "Wrong alignment on ARCSequenceFollowTarget");
static_assert(sizeof(ARCSequenceFollowTarget) == 0x0002A0, "Wrong size on ARCSequenceFollowTarget");
static_assert(offsetof(ARCSequenceFollowTarget, DefaultSceneRoot) == 0x000220, "Member 'ARCSequenceFollowTarget::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARCSequenceFollowTarget, FollowActor) == 0x000228, "Member 'ARCSequenceFollowTarget::FollowActor' has a wrong offset!");

// Class RC.RCCharacterLigthActor
// 0x0040 (0x02C8 - 0x0288)
class ARCCharacterLigthActor final : public ARCActor
{
public:
	uint8                                         Pad_288[0xC];                                      // 0x0288(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOffset;                                    // 0x0294(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               SeqRotatorOffset;                                  // 0x02A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               CurrentCameraRotation;                             // 0x02AC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               RotationOffsetInitValue;                           // 0x02B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterLigthActor">();
	}
	static class ARCCharacterLigthActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterLigthActor>();
	}
};
static_assert(alignof(ARCCharacterLigthActor) == 0x000008, "Wrong alignment on ARCCharacterLigthActor");
static_assert(sizeof(ARCCharacterLigthActor) == 0x0002C8, "Wrong size on ARCCharacterLigthActor");
static_assert(offsetof(ARCCharacterLigthActor, RotationOffset) == 0x000294, "Member 'ARCCharacterLigthActor::RotationOffset' has a wrong offset!");
static_assert(offsetof(ARCCharacterLigthActor, SeqRotatorOffset) == 0x0002A0, "Member 'ARCCharacterLigthActor::SeqRotatorOffset' has a wrong offset!");
static_assert(offsetof(ARCCharacterLigthActor, CurrentCameraRotation) == 0x0002AC, "Member 'ARCCharacterLigthActor::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(ARCCharacterLigthActor, RotationOffsetInitValue) == 0x0002B8, "Member 'ARCCharacterLigthActor::RotationOffsetInitValue' has a wrong offset!");

// Class RC.RCCharacterLookCtrl
// 0x02E0 (0x0390 - 0x00B0)
class URCCharacterLookCtrl final : public UActorComponent
{
public:
	ELookTargetProcess                            LookTargetProcess;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLookTarget;                                       // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CanViewDistance;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CanViewAngle;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookTargetPos;                                     // 0x00C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookTargetPosNext;                                 // 0x00CC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InitLookTargetPos;                                 // 0x00D8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LookTargetDelay;                                   // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LookTargetActorName;                               // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentLookTargetActorName;                        // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterLookTargetActor*            LookTargetActor;                                   // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LookTargetCharacterName0;                          // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentLookTargetCharacterName0;                   // 0x0120(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkinnedMeshComponent*                  LookTargetCharacterSkinnedMeshComponent0;          // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LookTargetCharacterSocketName0;                    // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookTargetCharacterPos0;                           // 0x0148(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LookTargetCharacterName1;                          // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentLookTargetCharacterName1;                   // 0x0168(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkinnedMeshComponent*                  LookTargetCharacterSkinnedMeshComponent1;          // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LookTargetCharacterSocketName1;                    // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookTargetCharacterPos1;                           // 0x0190(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LookTargetCharacterAlpha;                          // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EyeballLTranslation;                               // 0x01A0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               EyeballLRotator;                                   // 0x01AC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                EyeballRTranslation;                               // 0x01B8(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               EyeballRRotator;                                   // 0x01C4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Spine1Rotator;                                     // 0x01D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Spine2Rotator;                                     // 0x01DC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Spine3Rotator;                                     // 0x01E8(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               NeckRotator;                                       // 0x01F4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               HeadRotator;                                       // 0x0200(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               CurrentNeckRotator;                                // 0x020C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               CurrentHeadRotator;                                // 0x0218(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               CurrentCharacterRotator;                           // 0x0224(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x90];                                     // 0x0230(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeTranslateNearMax;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeTranslateFarMax;                                // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeTranslateUpMax;                                 // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeTranslateDownMax;                               // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeViewAngleLR;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeViewAngleUp;                                    // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeViewAngleDown;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeLookSpeed;                                      // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeMoveSec;                                        // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x8];                                      // 0x02E4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultEyeMoveSec;                                 // 0x02EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultEyeTranslateNearMax;                        // 0x02F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultEyeTranslateFarMax;                         // 0x02F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultEyeTranslateUpMax;                          // 0x02F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultEyeTranslateDownMax;                        // 0x02FC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckWeightSpine1;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckWeightSpine2;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckWeightSpine3;                                  // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckWeightNeck;                                    // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckWeightHead;                                    // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckLimitAngleLR;                                  // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckLimitAngleUp;                                  // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckLimitAngleDown;                                // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckLookSpeed;                                     // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeckMoveSec;                                       // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x14];                                     // 0x0328(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultNeckWeightSpine1;                           // 0x033C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultNeckWeightSpine2;                           // 0x0340(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultNeckWeightSpine3;                           // 0x0344(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultNeckWeightNeck;                             // 0x0348(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultNeckWeightHead;                             // 0x034C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Owner;                                             // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     CharacterBase;                                     // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          PawnBase;                                          // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterFacialCtrl*                 FacialCtrl;                                        // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LookAtTargetActor;                                 // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LookAtTargetBoneName;                              // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkinnedMeshComponent*                  LookAtTargetSkinnedMeshComponent;                  // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExistEyeBone;                                     // 0x0388(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNoDelayLookProcess;                               // 0x0389(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookAt(const class AActor* InActor, const class FName InLookAtBoneName);
	void SetLookTarget(const struct FVector& InTargetPos);
	void SetViewParam(float InCanViewDistance, float InCanViewAngle);
	void StopLookAt(float InDurationSec);

	class AActor* GetCurrentLookAtTargetActor() const;
	class FName GetCurrentLookAtTargetBoneName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterLookCtrl">();
	}
	static class URCCharacterLookCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterLookCtrl>();
	}
};
static_assert(alignof(URCCharacterLookCtrl) == 0x000008, "Wrong alignment on URCCharacterLookCtrl");
static_assert(sizeof(URCCharacterLookCtrl) == 0x000390, "Wrong size on URCCharacterLookCtrl");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetProcess) == 0x0000B0, "Member 'URCCharacterLookCtrl::LookTargetProcess' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, bLookTarget) == 0x0000B4, "Member 'URCCharacterLookCtrl::bLookTarget' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CanViewDistance) == 0x0000B8, "Member 'URCCharacterLookCtrl::CanViewDistance' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CanViewAngle) == 0x0000BC, "Member 'URCCharacterLookCtrl::CanViewAngle' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetPos) == 0x0000C0, "Member 'URCCharacterLookCtrl::LookTargetPos' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetPosNext) == 0x0000CC, "Member 'URCCharacterLookCtrl::LookTargetPosNext' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, InitLookTargetPos) == 0x0000D8, "Member 'URCCharacterLookCtrl::InitLookTargetPos' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetDelay) == 0x0000E4, "Member 'URCCharacterLookCtrl::LookTargetDelay' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetActorName) == 0x0000E8, "Member 'URCCharacterLookCtrl::LookTargetActorName' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentLookTargetActorName) == 0x0000F8, "Member 'URCCharacterLookCtrl::CurrentLookTargetActorName' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetActor) == 0x000108, "Member 'URCCharacterLookCtrl::LookTargetActor' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterName0) == 0x000110, "Member 'URCCharacterLookCtrl::LookTargetCharacterName0' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentLookTargetCharacterName0) == 0x000120, "Member 'URCCharacterLookCtrl::CurrentLookTargetCharacterName0' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterSkinnedMeshComponent0) == 0x000130, "Member 'URCCharacterLookCtrl::LookTargetCharacterSkinnedMeshComponent0' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterSocketName0) == 0x000138, "Member 'URCCharacterLookCtrl::LookTargetCharacterSocketName0' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterPos0) == 0x000148, "Member 'URCCharacterLookCtrl::LookTargetCharacterPos0' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterName1) == 0x000158, "Member 'URCCharacterLookCtrl::LookTargetCharacterName1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentLookTargetCharacterName1) == 0x000168, "Member 'URCCharacterLookCtrl::CurrentLookTargetCharacterName1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterSkinnedMeshComponent1) == 0x000178, "Member 'URCCharacterLookCtrl::LookTargetCharacterSkinnedMeshComponent1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterSocketName1) == 0x000180, "Member 'URCCharacterLookCtrl::LookTargetCharacterSocketName1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterPos1) == 0x000190, "Member 'URCCharacterLookCtrl::LookTargetCharacterPos1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookTargetCharacterAlpha) == 0x00019C, "Member 'URCCharacterLookCtrl::LookTargetCharacterAlpha' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeballLTranslation) == 0x0001A0, "Member 'URCCharacterLookCtrl::EyeballLTranslation' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeballLRotator) == 0x0001AC, "Member 'URCCharacterLookCtrl::EyeballLRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeballRTranslation) == 0x0001B8, "Member 'URCCharacterLookCtrl::EyeballRTranslation' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeballRRotator) == 0x0001C4, "Member 'URCCharacterLookCtrl::EyeballRRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, Spine1Rotator) == 0x0001D0, "Member 'URCCharacterLookCtrl::Spine1Rotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, Spine2Rotator) == 0x0001DC, "Member 'URCCharacterLookCtrl::Spine2Rotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, Spine3Rotator) == 0x0001E8, "Member 'URCCharacterLookCtrl::Spine3Rotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckRotator) == 0x0001F4, "Member 'URCCharacterLookCtrl::NeckRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, HeadRotator) == 0x000200, "Member 'URCCharacterLookCtrl::HeadRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentNeckRotator) == 0x00020C, "Member 'URCCharacterLookCtrl::CurrentNeckRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentHeadRotator) == 0x000218, "Member 'URCCharacterLookCtrl::CurrentHeadRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CurrentCharacterRotator) == 0x000224, "Member 'URCCharacterLookCtrl::CurrentCharacterRotator' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeTranslateNearMax) == 0x0002C0, "Member 'URCCharacterLookCtrl::EyeTranslateNearMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeTranslateFarMax) == 0x0002C4, "Member 'URCCharacterLookCtrl::EyeTranslateFarMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeTranslateUpMax) == 0x0002C8, "Member 'URCCharacterLookCtrl::EyeTranslateUpMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeTranslateDownMax) == 0x0002CC, "Member 'URCCharacterLookCtrl::EyeTranslateDownMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeViewAngleLR) == 0x0002D0, "Member 'URCCharacterLookCtrl::EyeViewAngleLR' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeViewAngleUp) == 0x0002D4, "Member 'URCCharacterLookCtrl::EyeViewAngleUp' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeViewAngleDown) == 0x0002D8, "Member 'URCCharacterLookCtrl::EyeViewAngleDown' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeLookSpeed) == 0x0002DC, "Member 'URCCharacterLookCtrl::EyeLookSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, EyeMoveSec) == 0x0002E0, "Member 'URCCharacterLookCtrl::EyeMoveSec' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultEyeMoveSec) == 0x0002EC, "Member 'URCCharacterLookCtrl::DefaultEyeMoveSec' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultEyeTranslateNearMax) == 0x0002F0, "Member 'URCCharacterLookCtrl::DefaultEyeTranslateNearMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultEyeTranslateFarMax) == 0x0002F4, "Member 'URCCharacterLookCtrl::DefaultEyeTranslateFarMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultEyeTranslateUpMax) == 0x0002F8, "Member 'URCCharacterLookCtrl::DefaultEyeTranslateUpMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultEyeTranslateDownMax) == 0x0002FC, "Member 'URCCharacterLookCtrl::DefaultEyeTranslateDownMax' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckWeightSpine1) == 0x000300, "Member 'URCCharacterLookCtrl::NeckWeightSpine1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckWeightSpine2) == 0x000304, "Member 'URCCharacterLookCtrl::NeckWeightSpine2' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckWeightSpine3) == 0x000308, "Member 'URCCharacterLookCtrl::NeckWeightSpine3' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckWeightNeck) == 0x00030C, "Member 'URCCharacterLookCtrl::NeckWeightNeck' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckWeightHead) == 0x000310, "Member 'URCCharacterLookCtrl::NeckWeightHead' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckLimitAngleLR) == 0x000314, "Member 'URCCharacterLookCtrl::NeckLimitAngleLR' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckLimitAngleUp) == 0x000318, "Member 'URCCharacterLookCtrl::NeckLimitAngleUp' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckLimitAngleDown) == 0x00031C, "Member 'URCCharacterLookCtrl::NeckLimitAngleDown' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckLookSpeed) == 0x000320, "Member 'URCCharacterLookCtrl::NeckLookSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, NeckMoveSec) == 0x000324, "Member 'URCCharacterLookCtrl::NeckMoveSec' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultNeckWeightSpine1) == 0x00033C, "Member 'URCCharacterLookCtrl::DefaultNeckWeightSpine1' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultNeckWeightSpine2) == 0x000340, "Member 'URCCharacterLookCtrl::DefaultNeckWeightSpine2' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultNeckWeightSpine3) == 0x000344, "Member 'URCCharacterLookCtrl::DefaultNeckWeightSpine3' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultNeckWeightNeck) == 0x000348, "Member 'URCCharacterLookCtrl::DefaultNeckWeightNeck' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, DefaultNeckWeightHead) == 0x00034C, "Member 'URCCharacterLookCtrl::DefaultNeckWeightHead' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, Owner) == 0x000350, "Member 'URCCharacterLookCtrl::Owner' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, CharacterBase) == 0x000358, "Member 'URCCharacterLookCtrl::CharacterBase' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, PawnBase) == 0x000360, "Member 'URCCharacterLookCtrl::PawnBase' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, FacialCtrl) == 0x000368, "Member 'URCCharacterLookCtrl::FacialCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookAtTargetActor) == 0x000370, "Member 'URCCharacterLookCtrl::LookAtTargetActor' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookAtTargetBoneName) == 0x000378, "Member 'URCCharacterLookCtrl::LookAtTargetBoneName' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, LookAtTargetSkinnedMeshComponent) == 0x000380, "Member 'URCCharacterLookCtrl::LookAtTargetSkinnedMeshComponent' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, bExistEyeBone) == 0x000388, "Member 'URCCharacterLookCtrl::bExistEyeBone' has a wrong offset!");
static_assert(offsetof(URCCharacterLookCtrl, bNoDelayLookProcess) == 0x000389, "Member 'URCCharacterLookCtrl::bNoDelayLookProcess' has a wrong offset!");

// Class RC.RCEventTriggerSequencerComponent
// 0x0020 (0x00D0 - 0x00B0)
class URCEventTriggerSequencerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ParentActor;                                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class FName InEventTriggerName);
	bool ResetSequencer();
	bool StartSequencer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTriggerSequencerComponent">();
	}
	static class URCEventTriggerSequencerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEventTriggerSequencerComponent>();
	}
};
static_assert(alignof(URCEventTriggerSequencerComponent) == 0x000008, "Wrong alignment on URCEventTriggerSequencerComponent");
static_assert(sizeof(URCEventTriggerSequencerComponent) == 0x0000D0, "Wrong size on URCEventTriggerSequencerComponent");
static_assert(offsetof(URCEventTriggerSequencerComponent, SequenceActor) == 0x0000C0, "Member 'URCEventTriggerSequencerComponent::SequenceActor' has a wrong offset!");
static_assert(offsetof(URCEventTriggerSequencerComponent, ParentActor) == 0x0000C8, "Member 'URCEventTriggerSequencerComponent::ParentActor' has a wrong offset!");

// Class RC.RCShinigamiTargetPoint
// 0x0010 (0x0230 - 0x0220)
class ARCShinigamiTargetPoint final : public ATargetPoint
{
public:
	float                                         lengs;                                             // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0xC];                                      // 0x0224(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetShinigami(class ARCOptionCharaShinigami* Shinigami);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiTargetPoint">();
	}
	static class ARCShinigamiTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCShinigamiTargetPoint>();
	}
};
static_assert(alignof(ARCShinigamiTargetPoint) == 0x000008, "Wrong alignment on ARCShinigamiTargetPoint");
static_assert(sizeof(ARCShinigamiTargetPoint) == 0x000230, "Wrong size on ARCShinigamiTargetPoint");
static_assert(offsetof(ARCShinigamiTargetPoint, lengs) == 0x000220, "Member 'ARCShinigamiTargetPoint::lengs' has a wrong offset!");

// Class RC.RCCharacterLookTargetActor
// 0x0000 (0x0288 - 0x0288)
class ARCCharacterLookTargetActor final : public ARCActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterLookTargetActor">();
	}
	static class ARCCharacterLookTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterLookTargetActor>();
	}
};
static_assert(alignof(ARCCharacterLookTargetActor) == 0x000008, "Wrong alignment on ARCCharacterLookTargetActor");
static_assert(sizeof(ARCCharacterLookTargetActor) == 0x000288, "Wrong size on ARCCharacterLookTargetActor");

// Class RC.RCKeyInfo
// 0x0040 (0x0068 - 0x0028)
class URCKeyInfo final : public UObject
{
public:
	uint8                                         Pad_28[0xC];                                       // 0x0028(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCKeyType>                     KeyList;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          AnyKeys;                                           // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPressed;                                          // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReleased;                                         // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDown;                                             // 0x004B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRepeat;                                           // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepeatWait;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMove;                                             // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OldValue;                                          // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PointerValue;                                      // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputButtonType                            InputButtonType;                                   // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputHardwareType                          InputHardwareType;                                 // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugPressed;                                     // 0x0066(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCKeyInfo">();
	}
	static class URCKeyInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCKeyInfo>();
	}
};
static_assert(alignof(URCKeyInfo) == 0x000008, "Wrong alignment on URCKeyInfo");
static_assert(sizeof(URCKeyInfo) == 0x000068, "Wrong size on URCKeyInfo");
static_assert(offsetof(URCKeyInfo, Index_0) == 0x000034, "Member 'URCKeyInfo::Index_0' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, KeyList) == 0x000038, "Member 'URCKeyInfo::KeyList' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, AnyKeys) == 0x000048, "Member 'URCKeyInfo::AnyKeys' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bPressed) == 0x000049, "Member 'URCKeyInfo::bPressed' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bReleased) == 0x00004A, "Member 'URCKeyInfo::bReleased' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bDown) == 0x00004B, "Member 'URCKeyInfo::bDown' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bRepeat) == 0x00004C, "Member 'URCKeyInfo::bRepeat' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, RepeatWait) == 0x000050, "Member 'URCKeyInfo::RepeatWait' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bMove) == 0x000054, "Member 'URCKeyInfo::bMove' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, Value) == 0x000058, "Member 'URCKeyInfo::Value' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, OldValue) == 0x00005C, "Member 'URCKeyInfo::OldValue' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, PointerValue) == 0x000060, "Member 'URCKeyInfo::PointerValue' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, InputButtonType) == 0x000064, "Member 'URCKeyInfo::InputButtonType' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, InputHardwareType) == 0x000065, "Member 'URCKeyInfo::InputHardwareType' has a wrong offset!");
static_assert(offsetof(URCKeyInfo, bDebugPressed) == 0x000066, "Member 'URCKeyInfo::bDebugPressed' has a wrong offset!");

// Class RC.RCCharacterMotionDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class URCCharacterMotionDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FRCCharacterMotionData> CharacterRecords;                                  // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRCMobCharacterMotionData> MobCharacterRecords;                               // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void Reimport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterMotionDataAsset">();
	}
	static class URCCharacterMotionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterMotionDataAsset>();
	}
};
static_assert(alignof(URCCharacterMotionDataAsset) == 0x000008, "Wrong alignment on URCCharacterMotionDataAsset");
static_assert(sizeof(URCCharacterMotionDataAsset) == 0x0000D0, "Wrong size on URCCharacterMotionDataAsset");
static_assert(offsetof(URCCharacterMotionDataAsset, CharacterRecords) == 0x000030, "Member 'URCCharacterMotionDataAsset::CharacterRecords' has a wrong offset!");
static_assert(offsetof(URCCharacterMotionDataAsset, MobCharacterRecords) == 0x000080, "Member 'URCCharacterMotionDataAsset::MobCharacterRecords' has a wrong offset!");

// Class RC.RCNzUiFinaleDetectiveTitleWidget
// 0x0000 (0x02D8 - 0x02D8)
class URCNzUiFinaleDetectiveTitleWidget final : public URCUiWidgetBase
{
public:
	void SetSectionText(const class FString& sectionText1, const class FString& sectionText2);
	void UpdateTitle(const int32& SectionName, const class FString& Title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleDetectiveTitleWidget">();
	}
	static class URCNzUiFinaleDetectiveTitleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleDetectiveTitleWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleDetectiveTitleWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleDetectiveTitleWidget");
static_assert(sizeof(URCNzUiFinaleDetectiveTitleWidget) == 0x0002D8, "Wrong size on URCNzUiFinaleDetectiveTitleWidget");

// Class RC.RCCharacterMotionDataTable
// 0x0010 (0x0040 - 0x0030)
class URCCharacterMotionDataTable final : public URCCSVData
{
public:
	TArray<struct FRCCharacterMotionDataTableRecord> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterMotionDataTable">();
	}
	static class URCCharacterMotionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterMotionDataTable>();
	}
};
static_assert(alignof(URCCharacterMotionDataTable) == 0x000008, "Wrong alignment on URCCharacterMotionDataTable");
static_assert(sizeof(URCCharacterMotionDataTable) == 0x000040, "Wrong size on URCCharacterMotionDataTable");
static_assert(offsetof(URCCharacterMotionDataTable, Data) == 0x000030, "Member 'URCCharacterMotionDataTable::Data' has a wrong offset!");

// Class RC.RCCharacterMotionListDataAsset
// 0x00F0 (0x0120 - 0x0030)
class URCCharacterMotionListDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FRCCharacterMasterBasicContentMotionName> MasterBasicRecords;                                // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRCCharacterMotionContent> Records;                                           // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRCCharacterMotionUniqueContentScene> UniqueRecords;                                     // 0x00D0(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void Reimport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterMotionListDataAsset">();
	}
	static class URCCharacterMotionListDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterMotionListDataAsset>();
	}
};
static_assert(alignof(URCCharacterMotionListDataAsset) == 0x000008, "Wrong alignment on URCCharacterMotionListDataAsset");
static_assert(sizeof(URCCharacterMotionListDataAsset) == 0x000120, "Wrong size on URCCharacterMotionListDataAsset");
static_assert(offsetof(URCCharacterMotionListDataAsset, MasterBasicRecords) == 0x000030, "Member 'URCCharacterMotionListDataAsset::MasterBasicRecords' has a wrong offset!");
static_assert(offsetof(URCCharacterMotionListDataAsset, Records) == 0x000080, "Member 'URCCharacterMotionListDataAsset::Records' has a wrong offset!");
static_assert(offsetof(URCCharacterMotionListDataAsset, UniqueRecords) == 0x0000D0, "Member 'URCCharacterMotionListDataAsset::UniqueRecords' has a wrong offset!");

// Class RC.RCInstallManager
// 0x0020 (0x0048 - 0x0028)
class URCInstallManager final : public UObject
{
public:
	class URCInstallInterface*                    Install;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugInstallNotComplete;                          // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInstallManager">();
	}
	static class URCInstallManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInstallManager>();
	}
};
static_assert(alignof(URCInstallManager) == 0x000008, "Wrong alignment on URCInstallManager");
static_assert(sizeof(URCInstallManager) == 0x000048, "Wrong size on URCInstallManager");
static_assert(offsetof(URCInstallManager, Install) == 0x000028, "Member 'URCInstallManager::Install' has a wrong offset!");
static_assert(offsetof(URCInstallManager, bDebugInstallNotComplete) == 0x000040, "Member 'URCInstallManager::bDebugInstallNotComplete' has a wrong offset!");

// Class RC.RCSelectText3DActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCSelectText3DActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCSelectText3DActor* GetSelectText3DActor(class FName InActorName);
	static void SetTextColor(class FName InActorName, const struct FLinearColor& InTextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSelectText3DActorBFL">();
	}
	static class URCSelectText3DActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSelectText3DActorBFL>();
	}
};
static_assert(alignof(URCSelectText3DActorBFL) == 0x000008, "Wrong alignment on URCSelectText3DActorBFL");
static_assert(sizeof(URCSelectText3DActorBFL) == 0x000028, "Wrong size on URCSelectText3DActorBFL");

// Class RC.RCCharacterMovementComponent
// 0x0130 (0x0C20 - 0x0AF0)
class URCCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_AF0[0x30];                                     // 0x0AF0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MaxVelocity;                                       // 0x0B20(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityInterpolateSpeedRate;                      // 0x0B2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRCScriptActorFootIKSettings           FootIKSettings;                                    // 0x0B30(0x0050)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCScriptActorFootIKData               FootIKData;                                        // 0x0B80(0x0064)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE4[0x4];                                      // 0x0BE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 StairwayUnderneath;                                // 0x0BE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFootSteps;                                        // 0x0BF0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompanion;                                        // 0x0BF1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpirit;                                           // 0x0BF2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF3[0x1];                                      // 0x0BF3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RightFootSteppingFloorType;                        // 0x0BF4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootSteppingFloorName;                        // 0x0BFC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootSteppingFloorType;                         // 0x0C04(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootSteppingFloorName;                         // 0x0C0C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugFloorTypeDraw;                               // 0x0C14(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C15[0xB];                                      // 0x0C15(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterMovementComponent">();
	}
	static class URCCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterMovementComponent>();
	}
};
static_assert(alignof(URCCharacterMovementComponent) == 0x000010, "Wrong alignment on URCCharacterMovementComponent");
static_assert(sizeof(URCCharacterMovementComponent) == 0x000C20, "Wrong size on URCCharacterMovementComponent");
static_assert(offsetof(URCCharacterMovementComponent, MaxVelocity) == 0x000B20, "Member 'URCCharacterMovementComponent::MaxVelocity' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, VelocityInterpolateSpeedRate) == 0x000B2C, "Member 'URCCharacterMovementComponent::VelocityInterpolateSpeedRate' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, FootIKSettings) == 0x000B30, "Member 'URCCharacterMovementComponent::FootIKSettings' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, FootIKData) == 0x000B80, "Member 'URCCharacterMovementComponent::FootIKData' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, StairwayUnderneath) == 0x000BE8, "Member 'URCCharacterMovementComponent::StairwayUnderneath' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, bFootSteps) == 0x000BF0, "Member 'URCCharacterMovementComponent::bFootSteps' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, bCompanion) == 0x000BF1, "Member 'URCCharacterMovementComponent::bCompanion' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, bSpirit) == 0x000BF2, "Member 'URCCharacterMovementComponent::bSpirit' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, RightFootSteppingFloorType) == 0x000BF4, "Member 'URCCharacterMovementComponent::RightFootSteppingFloorType' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, RightFootSteppingFloorName) == 0x000BFC, "Member 'URCCharacterMovementComponent::RightFootSteppingFloorName' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, LeftFootSteppingFloorType) == 0x000C04, "Member 'URCCharacterMovementComponent::LeftFootSteppingFloorType' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, LeftFootSteppingFloorName) == 0x000C0C, "Member 'URCCharacterMovementComponent::LeftFootSteppingFloorName' has a wrong offset!");
static_assert(offsetof(URCCharacterMovementComponent, bDebugFloorTypeDraw) == 0x000C14, "Member 'URCCharacterMovementComponent::bDebugFloorTypeDraw' has a wrong offset!");

// Class RC.RCCharacterProxy
// 0x01D8 (0x0200 - 0x0028)
class URCCharacterProxy final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     CharacterRender;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          PawnRender;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCKakiwariRender*                      KakiwariRender;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCAnimalRender*                        AnimalRender;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterAttachmentCtrl*             AttachmentCtrl;                                    // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterAnimCtrl*                   MotionCtrl;                                        // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterFormCtrl*                   FormCtrl;                                          // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterFacialCtrl*                 FacialCtrl;                                        // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterLookCtrl*                   LookCtrl;                                          // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterToonOutlineCtrl*            OutlineCtrl;                                       // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterHoldingHandCtrl*            HoldingHandCtrl;                                   // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x70];                                      // 0x00C8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  MotionClassificationEnum;                          // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCCharacterMotionListDataAsset*        MotionListDataAsset;                               // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x48];                                     // 0x0150(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class URCScriptActorStatus*                   CharacterStatus;                                   // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x60];                                     // 0x01A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterProxy">();
	}
	static class URCCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterProxy>();
	}
};
static_assert(alignof(URCCharacterProxy) == 0x000008, "Wrong alignment on URCCharacterProxy");
static_assert(sizeof(URCCharacterProxy) == 0x000200, "Wrong size on URCCharacterProxy");
static_assert(offsetof(URCCharacterProxy, CharacterRender) == 0x000070, "Member 'URCCharacterProxy::CharacterRender' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, PawnRender) == 0x000078, "Member 'URCCharacterProxy::PawnRender' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, KakiwariRender) == 0x000080, "Member 'URCCharacterProxy::KakiwariRender' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, AnimalRender) == 0x000088, "Member 'URCCharacterProxy::AnimalRender' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, AttachmentCtrl) == 0x000090, "Member 'URCCharacterProxy::AttachmentCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, MotionCtrl) == 0x000098, "Member 'URCCharacterProxy::MotionCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, FormCtrl) == 0x0000A0, "Member 'URCCharacterProxy::FormCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, FacialCtrl) == 0x0000A8, "Member 'URCCharacterProxy::FacialCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, LookCtrl) == 0x0000B0, "Member 'URCCharacterProxy::LookCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, OutlineCtrl) == 0x0000B8, "Member 'URCCharacterProxy::OutlineCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, HoldingHandCtrl) == 0x0000C0, "Member 'URCCharacterProxy::HoldingHandCtrl' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, MotionClassificationEnum) == 0x000138, "Member 'URCCharacterProxy::MotionClassificationEnum' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, MotionListDataAsset) == 0x000148, "Member 'URCCharacterProxy::MotionListDataAsset' has a wrong offset!");
static_assert(offsetof(URCCharacterProxy, CharacterStatus) == 0x000198, "Member 'URCCharacterProxy::CharacterStatus' has a wrong offset!");

// Class RC.RCParamFaceEffectAnimListData
// 0x0010 (0x0040 - 0x0030)
class URCParamFaceEffectAnimListData final : public URCCSVData
{
public:
	TArray<struct FRCParamFaceEffectAnimListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFaceEffectAnimListData">();
	}
	static class URCParamFaceEffectAnimListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFaceEffectAnimListData>();
	}
};
static_assert(alignof(URCParamFaceEffectAnimListData) == 0x000008, "Wrong alignment on URCParamFaceEffectAnimListData");
static_assert(sizeof(URCParamFaceEffectAnimListData) == 0x000040, "Wrong size on URCParamFaceEffectAnimListData");
static_assert(offsetof(URCParamFaceEffectAnimListData, Data) == 0x000030, "Member 'URCParamFaceEffectAnimListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleCutin
// 0x0048 (0x0320 - 0x02D8)
class URCNzUiBattleCutin final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Hajiki;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Assist;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Ronpa;                                          // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Assist_Face;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x1];                                      // 0x0300(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadingImage;                                     // 0x0301(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssistImagePath;                                   // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ERCNzUiBattleCutinStatus GetBattleCutinStatus();
	void InitializeBattleCutin(const struct FSoftObjectPath& InAssistImagePath);
	void Open(ERCNzUiBattleCutinType InType);
	void UninitializeBattleCutin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleCutin">();
	}
	static class URCNzUiBattleCutin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleCutin>();
	}
};
static_assert(alignof(URCNzUiBattleCutin) == 0x000008, "Wrong alignment on URCNzUiBattleCutin");
static_assert(sizeof(URCNzUiBattleCutin) == 0x000320, "Wrong size on URCNzUiBattleCutin");
static_assert(offsetof(URCNzUiBattleCutin, AN_Hajiki) == 0x0002E0, "Member 'URCNzUiBattleCutin::AN_Hajiki' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleCutin, AN_Assist) == 0x0002E8, "Member 'URCNzUiBattleCutin::AN_Assist' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleCutin, AN_Ronpa) == 0x0002F0, "Member 'URCNzUiBattleCutin::AN_Ronpa' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleCutin, Img_Assist_Face) == 0x0002F8, "Member 'URCNzUiBattleCutin::Img_Assist_Face' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleCutin, bLoadingImage) == 0x000301, "Member 'URCNzUiBattleCutin::bLoadingImage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleCutin, AssistImagePath) == 0x000308, "Member 'URCNzUiBattleCutin::AssistImagePath' has a wrong offset!");

// Class RC.RCTitleManager
// 0x0008 (0x0030 - 0x0028)
class URCTitleManager final : public UObject
{
public:
	ERCTitleState                                 State;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCTitleState                                 beforeState;                                       // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEnableSaveData;                                  // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isTitleButtonGuideAnimation;                       // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInstallingDialog;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleManager">();
	}
	static class URCTitleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleManager>();
	}
};
static_assert(alignof(URCTitleManager) == 0x000008, "Wrong alignment on URCTitleManager");
static_assert(sizeof(URCTitleManager) == 0x000030, "Wrong size on URCTitleManager");
static_assert(offsetof(URCTitleManager, State) == 0x000028, "Member 'URCTitleManager::State' has a wrong offset!");
static_assert(offsetof(URCTitleManager, beforeState) == 0x000029, "Member 'URCTitleManager::beforeState' has a wrong offset!");
static_assert(offsetof(URCTitleManager, IsEnableSaveData) == 0x00002A, "Member 'URCTitleManager::IsEnableSaveData' has a wrong offset!");
static_assert(offsetof(URCTitleManager, isTitleButtonGuideAnimation) == 0x00002B, "Member 'URCTitleManager::isTitleButtonGuideAnimation' has a wrong offset!");
static_assert(offsetof(URCTitleManager, bIsInstallingDialog) == 0x00002C, "Member 'URCTitleManager::bIsInstallingDialog' has a wrong offset!");

// Class RC.RCCharacterProxyBFL
// 0x0000 (0x0028 - 0x0028)
class URCCharacterProxyBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyCharacterMaterial(const class FName InMaterialId);
	static void ApplyColorPalette(class AActor* InActor, const class FName InColorPaletteId, const class FName InFaceColorPaletteId, const class FName InSoliderNumberId, const class FName InEyeId, const class FName InSkinId);
	static void ApplyEventEmissive(const class FName InCharacterName, const float InEventEmissiveValue);
	static void ApplyEventHairSpecular(const class FName InCharacterName, const float InEventHairSpecularX, const float InEventHairSpecularY, const float InEventHairSpecularZ);
	static void AttachActorToEye(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToHead(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToLeftHand(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToMouth(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToOverhead(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToPelvis(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToRightHand(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToSpine(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToUlity01(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToUlity02(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToUlity03(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToUlity04(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void AttachActorToUlity05(class AActor* InActor, class AActor* InAttachment, const class FName InColorParretId, const struct FVector& InOffset);
	static void BackupMovePosition(class AActor* InActor);
	static void BackupMovePositionByCharacterName(class FName InName);
	static void Blink(class AActor* InActor);
	static void ChangeAttachmentAnimation(class AActor* InActor, const EAttachPlaceType InPlaceType, const ERCAttachAnimType InAnimationType);
	static void ChangeColorPatternOnEvent(const class FName InCharacterName, const class FName InEventFacialColorName, float InFadeTime);
	static void ChangeColorPatternOnEventForActor(class AActor* InActor, const class FName InEventFacialColorName, float InFadeTime);
	static void ChangeDecalParentSocket(class AActor* InActor, const class FName InSocketName);
	static void ChangeFacial(class AActor* InActor, const class FName InFacialName, bool bAllowFlowLiquid);
	static void ChangeRimLight(class AActor* InActor, const struct FLinearColor& InOutlineColor, const float InOutlineCoverageValue, const float InOutlineSmoothValue, const float InRimLightDurationSec);
	static void DetachAttachment(class AActor* InActor, const EAttachPlaceType InPlaceType, const struct FVector& InPutPos);
	static void EventFinishedOutMotion(class AActor* InActor, const float InBlendSec);
	static void ExecuteHoldingHand(class AActor* InActor, const class AActor* InTaegetActor);
	static class AActor* GetActor(class FName InName);
	static class AActor* GetActorContainKakiwari(class FName InName);
	static class FName GetCharacterAttatchmentFormId(class FName InName);
	static bool GetFacial2DMotionNameList(const class FName InFacial2DId, TArray<class FName>* OutMotionNameList);
	static bool GetFinishChangeRimLight(class AActor* InActor);
	static class AActor* GetShinigamiActor();
	static void InitShinigamiPosition(float InLength, float InHeight, float InAngle);
	static bool IsAllLoadComplete();
	static bool IsAllMoveEnd();
	static bool IsExistOutCurrentMotion(class AActor* InActor);
	static bool IsFinishedMotion(class AActor* InActor);
	static bool IsLoadActorComplete(const TArray<class FName>& InCheckCharacterNameArray);
	static bool IsLoadComplete(class FName InName);
	static bool IsMotionBlend(class AActor* InActor);
	static bool IsMoveEnd(class AActor* InActor);
	static bool IsMoveMobDraw();
	static void PlayLipsyncBasedOnLines(class AActor* InActor, float InLineCharacters, const float InLineDisplaySec, const float InLineIntervalAjust);
	static void PlayLipsyncMotion(class AActor* InActor, const class FName InMotionName, bool bLoop, const float InPlayRate);
	static void Release(class FName InName);
	static void ReserveAppearance(const class FName InName, class FName InBodyColorPaletteId, class FName InFaceColorPaletteId, class FName InSoliderNumberId, class FName InEyeId, class FName InSkinId);
	static void ReservePlayMotion(const class FName InName, const class FName InMotionName, bool bStartLoopMotion);
	static void ResetCameraAlphaLength();
	static void ResetEventMotion(class AActor* InActor);
	static void ResetMove(class AActor* InActor);
	static void ResetMoveByCharacterName(class FName InName);
	static void RestoreMoveList(class AActor* InActor);
	static void RestoreMoveListByCharacterName(class FName InName);
	static void RestoreMovePosition(class AActor* InActor, float SpeedScale);
	static void RestoreMovePositionByCharacterName(class FName InName, float SpeedScale);
	static void RestoreRotationYaw(class AActor* InActor, float SpeedScale, bool bDirect);
	static void RestoreRotationYawByCharacterName(class FName InName, float SpeedScale, bool bDirect);
	static void SetAllNoDelayLookProcessFlag(bool bState);
	static void SetAllPause(bool bPauseFlag);
	static void SetAllVisibility(bool bVisibleFlag);
	static void SetAutoOutlineWidth(class AActor* InActor, bool bAuto);
	static void SetCameraAlphaLengh(int32 InLengthMin, int32 InLengthMax);
	static void SetCameraFadeEnable(class AActor* InActor, bool bFlag);
	static void SetCanBlink(class AActor* InActor, bool bState);
	static void SetCenterActorType(ERCCharacterProxyCenterActorType InType);
	static void SetCharacterAttatchmentFormId(class FName InName, class FName InCharacterAttatchmentFormId);
	static void SetDefaultLookSetting(class AActor* InActor);
	static void SetExtraIdle(class AActor* InActor, bool bState);
	static void SetLookAtActor(class AActor* InActor, const class AActor* InLookAtTargetActor, const class FName InLookAtTargetBoneName);
	static void SetLookAtCharacterFace(class AActor* InActor, const class AActor* InLookAtTargetActor);
	static void SetLookAtPosition(class AActor* InActor, const struct FVector& InLookAtTargetPos);
	static void SetMoveMobDraw(bool bInDraw);
	static void SetMovePause(class AActor* InActor, bool bInMovePause);
	static void SetMovNearPlayerHide(bool bInFlag);
	static void SetNewAnimBP(class AActor* InActor, class UClass* InNewAnimClass);
	static void SetNoDelayLookProcessFlag(class AActor* InActor, bool bState);
	static void SetOrientRotationtoMovementFlag(class AActor* InActor, bool bFlag);
	static void SetOutlineWidth(class AActor* InActor, const float InWidth);
	static void SetPause(class AActor* InActor, bool bPauseFlag);
	static void SetPauseByCharacterName(class FName InName, bool bPauseFlag);
	static void SetPositionYaw(class AActor* InActor, const struct FVector& InPosition, float InYaw);
	static void SetPositionYawByCharacterName(class FName InName, const struct FVector& InPosition, float InYaw);
	static void SetSpecialSelectLookSetting(class AActor* InActor, const float InEyeMoveSpeed, const float InEyeTranslateNearMax, const float InEyeTranslateFarMax, const float InEyeTranslateUpMax, const float InEyeTranslateDownMax);
	static void SetTalkInfo(class AActor* InActor, bool bInTalk, int32 InBalloonFrameType, int32 InBalloonType, class FName InSelifTextId);
	static void SetTalkInfoByCharacterName(class FName InName, bool bInTalk, int32 InBalloonFrameType, int32 InBalloonType, class FName InSelifTextId);
	static void SetTalkSetting(class AActor* InActor, float InTalkLength, float InSelifLength, float InBalloonLength, float InBalloonHeightOffset, float InBalloonAngleOffset, float InBalloonLengthOffset);
	static void SetTalkSettingByCharacterName(class FName InName, float InTalkLength, float InSelifLength, float InBalloonLength, float InBalloonHeightOffset, float InBalloonAngleOffset, float InBalloonLengthOffset);
	static void SetTransformPlayerStartName(class AActor* InActor, class FName InPlayerStartTagName, const struct FVector& InOffsetPos, float InOffsetYaw);
	static void SetTransformPlayerStartNameByCharacterName(class FName InName, class FName InPlayerStartTagName, const struct FVector& InOffsetPos, float InOffsetYaw);
	static void SetTransformTargetPointName(class AActor* InActor, class FName InPointName, const struct FVector& InOffsetPos, float InOffsetYaw);
	static void SetTransformTargetPointNameByCharacterName(class FName InName, class FName InPointName, const struct FVector& InOffsetPos, float InOffsetYaw);
	static void SetupAllBgCharacterMaterial();
	static void SetViewParam(class AActor* InActor, const float InCanViewDistance, const float InCanViewAngle);
	static void SetVisibility(class AActor* InActor, bool bVisibleFlag, bool bIsCollision);
	static void SetVisibilityByCharacterName(class FName InName, bool bVisibleFlag);
	static void SetVisibilityContainKakiwari(class AActor* InActor, bool bVisibleFlag, bool bIsCollision);
	static bool StartCharcterSettingLoad(class FName InSettingFilename);
	static bool StartLoad(class FName InName, class FName InFilename, bool bVisibleFlag, bool bScriptLoad);
	static bool StartLoadAutoName(class FName* OutName, class FName InFilename, bool bVisibleFlag, bool bScriptLoad);
	static bool StartLoadModelList(class FName InName, ESCCharacterModel CharacterModel, class FName InPlayerStartName, class FName InMotionName, bool bVisibleFlag, bool bScriptLoad);
	static bool StartLoadModelListAutoName(class FName* OutName, ESCCharacterModel CharacterModel, class FName InPlayerStartName, class FName InMotionName, bool bVisibleFlag, bool bScriptLoad);
	static void StartMotion(class FName InName, class FName InMotionName, bool bLoop);
	static void StartMotionActor(class AActor* InActor, class FName InMotionName, const float InPlayRate, bool bLoop, float InSwitchDurationSec, bool bStartLoopMotion);
	static void StartMoveFromPlayer(class AActor* InActor, float InLength, float InAngle, float InHeight, float SpeedScale, bool bEndPlayerYaw, float TurnSpeedScale);
	static void StartMoveFromPlayerByCharacterName(class FName InName, float InLength, float InAngle, float InHeight, float SpeedScale, bool bEndPlayerYaw);
	static void StartMoveFromPosition(class AActor* InActor, const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bEndChangeYaw, const struct FVector& EndChangeYawPosition, bool bPlayerCheck, float TurnSpeedScale);
	static void StartMoveFromPositionByCharacterName(class FName InName, const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bEndChangeYaw, const struct FVector& EndChangeYawPosition, bool bPlayerCheck);
	static void StartMoveFromPositionList(class AActor* InActor, const TArray<struct FRCScriptActorMoveInfo>& InMoveInfoList, int32 StartMoveInfoNum, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	static void StartMoveFromPositionListByCharacterName(class FName InName, TArray<struct FRCScriptActorMoveInfo>* InMoveInfoList, int32 StartMoveInfoNum, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	static void StartMoveFromSplineName(class AActor* InActor, class FName InSplineName, float StartDistanceRange, bool bReverse, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	static void StartMoveFromSplineNameByCharacterName(class FName InName, class FName InSplineName, float StartDistanceRange, bool bReverse, bool bEndChangeYaw, float InOffsetYaw, bool bFirstWarp, bool bLoop, bool bPlayerCheck);
	static void StartMoveFromTargetPointName(class AActor* InActor, class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, bool bEndChangeYaw, float InOffsetYaw, float InChangeYawSpeed, bool bPlayerCheck, float TurnSpeedScale);
	static void StartMoveFromTargetPointNameByCharacterName(class FName InName, class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, bool bEndChangeYaw, float InOffsetYaw, bool bPlayerCheck);
	static void StartRotationFromActor(class AActor* InActor, class AActor* InTargetActor, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationFromCharacter(class AActor* InActor, class AActor* InTargetActor, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationFromCharacterByCharacterName(class FName InName, class FName InTargetCharacterName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationFromPlayer(class AActor* InActor, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationFromPosition(class AActor* InActor, const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bDirect);
	static void StartRotationFromPositionByCharacterName(class FName InName, const struct FVector& InPosition, float SpeedScale, float InOffsetYaw, bool bDirect);
	static void StartRotationFromTargetPointName(class AActor* InActor, class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationFromTargetPointNameByCharacterName(class FName InName, class FName InPointName, float SpeedScale, const struct FVector& InOffsetPos, float InOffsetYaw, bool bDirect);
	static void StartRotationYaw(class AActor* InActor, float Yaw, float SpeedScale, bool bDirect);
	static void StartRotationYawByCharacterName(class FName InName, float Yaw, float SpeedScale, bool bDirect);
	static void StopHoldingHand(class AActor* InActor, const class AActor* InTaegetActor);
	static void StopLookAt(class AActor* InActor);
	static void StopMove(class AActor* InActor);
	static void StopMoveByCharacterName(class FName InName);
	static void StopWalkSpline(class AActor* InActor);
	static void SwitchOutCurrentEventMotion(class AActor* InActor);
	static void UndoRimLight(class AActor* InActor, const float InRimLightDurationSec);
	static void WalkSpline(class AActor* InActor, class AActor* InSplineActor, const float InTimeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterProxyBFL">();
	}
	static class URCCharacterProxyBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterProxyBFL>();
	}
};
static_assert(alignof(URCCharacterProxyBFL) == 0x000008, "Wrong alignment on URCCharacterProxyBFL");
static_assert(sizeof(URCCharacterProxyBFL) == 0x000028, "Wrong size on URCCharacterProxyBFL");

// Class RC.RCCharacterProxyManager
// 0x0128 (0x0150 - 0x0028)
class URCCharacterProxyManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCCharacterProxy*>              CharacterProxyList;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterProxy*>              AddCharacterProxyList;                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URCCharacterProxy*>              ReleaseCharacterProxyList;                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class URCCharacterSettingManager*             CharacterSettingManager;                           // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AutoCharacterNum;                                  // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AutoSpawnNum;                                      // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MobSpawnMemoryThreshold;                           // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverPlayerLength;                                  // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StopPlayerLength;                                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMovNearPlayerHide;                                // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthActorMin;                                    // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthActorMax;                                    // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthKakiwariMin;                                 // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthKakiwariMax;                                 // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CharacterDrawMax;                                  // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PawnDrawMax;                                       // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KakiwariDrawMax;                                   // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstanceCharacterDraw;                             // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstancePawnDraw;                                  // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowCharacterDraw;                                  // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowPawnDraw;                                       // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowKakiwariDraw;                                   // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMoveMobDraw;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMoveMobDrawChange;                              // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterFadeInSecond;                             // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterFadeOutSecond;                            // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KakiwariFadeInSecond;                              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KakiwariFadeOutSecond;                             // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MobRunSpeed;                                       // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MobWalkSpeed;                                      // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwari;                                         // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwariArea;                                     // 0x00CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraCenterPosition;                              // 0x00D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKakiwariLoad;                                     // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthCameraAlphaMin;                              // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LengthCameraAlphaMax;                              // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CameraPosition;                                    // 0x00E8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraFOV;                                         // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           DrawLayerNameList;                                 // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bDrawLayerNameChange;                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCCharacterProxy*>              DrawLayerProxy;                                    // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bReleaseToGC;                                      // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRelease;                                          // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCCharacterProxyCenterActorType              CenterActorType;                                   // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCCharacterProxySortInfo>      SortList;                                          // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterProxyManager">();
	}
	static class URCCharacterProxyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterProxyManager>();
	}
};
static_assert(alignof(URCCharacterProxyManager) == 0x000008, "Wrong alignment on URCCharacterProxyManager");
static_assert(sizeof(URCCharacterProxyManager) == 0x000150, "Wrong size on URCCharacterProxyManager");
static_assert(offsetof(URCCharacterProxyManager, CharacterProxyList) == 0x000030, "Member 'URCCharacterProxyManager::CharacterProxyList' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, AddCharacterProxyList) == 0x000040, "Member 'URCCharacterProxyManager::AddCharacterProxyList' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, ReleaseCharacterProxyList) == 0x000050, "Member 'URCCharacterProxyManager::ReleaseCharacterProxyList' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CharacterSettingManager) == 0x000060, "Member 'URCCharacterProxyManager::CharacterSettingManager' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, AutoCharacterNum) == 0x000068, "Member 'URCCharacterProxyManager::AutoCharacterNum' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, AutoSpawnNum) == 0x00006C, "Member 'URCCharacterProxyManager::AutoSpawnNum' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, MobSpawnMemoryThreshold) == 0x000070, "Member 'URCCharacterProxyManager::MobSpawnMemoryThreshold' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, OverPlayerLength) == 0x000074, "Member 'URCCharacterProxyManager::OverPlayerLength' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, StopPlayerLength) == 0x000078, "Member 'URCCharacterProxyManager::StopPlayerLength' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bMovNearPlayerHide) == 0x00007C, "Member 'URCCharacterProxyManager::bMovNearPlayerHide' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthActorMin) == 0x000080, "Member 'URCCharacterProxyManager::LengthActorMin' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthActorMax) == 0x000084, "Member 'URCCharacterProxyManager::LengthActorMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthKakiwariMin) == 0x000088, "Member 'URCCharacterProxyManager::LengthKakiwariMin' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthKakiwariMax) == 0x00008C, "Member 'URCCharacterProxyManager::LengthKakiwariMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CharacterDrawMax) == 0x000090, "Member 'URCCharacterProxyManager::CharacterDrawMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, PawnDrawMax) == 0x000094, "Member 'URCCharacterProxyManager::PawnDrawMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, KakiwariDrawMax) == 0x000098, "Member 'URCCharacterProxyManager::KakiwariDrawMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, InstanceCharacterDraw) == 0x00009C, "Member 'URCCharacterProxyManager::InstanceCharacterDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, InstancePawnDraw) == 0x0000A0, "Member 'URCCharacterProxyManager::InstancePawnDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, NowCharacterDraw) == 0x0000A4, "Member 'URCCharacterProxyManager::NowCharacterDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, NowPawnDraw) == 0x0000A8, "Member 'URCCharacterProxyManager::NowPawnDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, NowKakiwariDraw) == 0x0000AC, "Member 'URCCharacterProxyManager::NowKakiwariDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bIsMoveMobDraw) == 0x0000B0, "Member 'URCCharacterProxyManager::bIsMoveMobDraw' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bIsMoveMobDrawChange) == 0x0000B1, "Member 'URCCharacterProxyManager::bIsMoveMobDrawChange' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CharacterFadeInSecond) == 0x0000B4, "Member 'URCCharacterProxyManager::CharacterFadeInSecond' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CharacterFadeOutSecond) == 0x0000B8, "Member 'URCCharacterProxyManager::CharacterFadeOutSecond' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, KakiwariFadeInSecond) == 0x0000BC, "Member 'URCCharacterProxyManager::KakiwariFadeInSecond' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, KakiwariFadeOutSecond) == 0x0000C0, "Member 'URCCharacterProxyManager::KakiwariFadeOutSecond' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, MobRunSpeed) == 0x0000C4, "Member 'URCCharacterProxyManager::MobRunSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, MobWalkSpeed) == 0x0000C8, "Member 'URCCharacterProxyManager::MobWalkSpeed' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bKakiwari) == 0x0000CC, "Member 'URCCharacterProxyManager::bKakiwari' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bKakiwariArea) == 0x0000CD, "Member 'URCCharacterProxyManager::bKakiwariArea' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CameraCenterPosition) == 0x0000D0, "Member 'URCCharacterProxyManager::CameraCenterPosition' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bKakiwariLoad) == 0x0000DC, "Member 'URCCharacterProxyManager::bKakiwariLoad' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthCameraAlphaMin) == 0x0000E0, "Member 'URCCharacterProxyManager::LengthCameraAlphaMin' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, LengthCameraAlphaMax) == 0x0000E4, "Member 'URCCharacterProxyManager::LengthCameraAlphaMax' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CameraPosition) == 0x0000E8, "Member 'URCCharacterProxyManager::CameraPosition' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CameraFOV) == 0x0000F4, "Member 'URCCharacterProxyManager::CameraFOV' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, DrawLayerNameList) == 0x0000F8, "Member 'URCCharacterProxyManager::DrawLayerNameList' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bDrawLayerNameChange) == 0x000108, "Member 'URCCharacterProxyManager::bDrawLayerNameChange' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, DrawLayerProxy) == 0x000110, "Member 'URCCharacterProxyManager::DrawLayerProxy' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bReleaseToGC) == 0x000120, "Member 'URCCharacterProxyManager::bReleaseToGC' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, bRelease) == 0x000121, "Member 'URCCharacterProxyManager::bRelease' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, CenterActorType) == 0x000122, "Member 'URCCharacterProxyManager::CenterActorType' has a wrong offset!");
static_assert(offsetof(URCCharacterProxyManager, SortList) == 0x000128, "Member 'URCCharacterProxyManager::SortList' has a wrong offset!");

// Class RC.RCMenuGameModeBase
// 0x0000 (0x02D0 - 0x02D0)
class ARCMenuGameModeBase : public ARCGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuGameModeBase">();
	}
	static class ARCMenuGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMenuGameModeBase>();
	}
};
static_assert(alignof(ARCMenuGameModeBase) == 0x000008, "Wrong alignment on ARCMenuGameModeBase");
static_assert(sizeof(ARCMenuGameModeBase) == 0x0002D0, "Wrong size on ARCMenuGameModeBase");

// Class RC.RCTitleSubStoryListItemBase
// 0x0030 (0x0308 - 0x02D8)
class URCTitleSubStoryListItemBase : public URCUiWidgetBase
{
public:
	class UTextBlock*                             text00;                                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             text01;                                            // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Def;                                            // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryListItemBase">();
	}
	static class URCTitleSubStoryListItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryListItemBase>();
	}
};
static_assert(alignof(URCTitleSubStoryListItemBase) == 0x000008, "Wrong alignment on URCTitleSubStoryListItemBase");
static_assert(sizeof(URCTitleSubStoryListItemBase) == 0x000308, "Wrong size on URCTitleSubStoryListItemBase");
static_assert(offsetof(URCTitleSubStoryListItemBase, text00) == 0x0002D8, "Member 'URCTitleSubStoryListItemBase::text00' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemBase, text01) == 0x0002E0, "Member 'URCTitleSubStoryListItemBase::text01' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemBase, AN_Def) == 0x0002E8, "Member 'URCTitleSubStoryListItemBase::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemBase, AN_Off) == 0x0002F0, "Member 'URCTitleSubStoryListItemBase::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemBase, AN_Cursor_On) == 0x0002F8, "Member 'URCTitleSubStoryListItemBase::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemBase, AN_Cursor_Out) == 0x000300, "Member 'URCTitleSubStoryListItemBase::AN_Cursor_Out' has a wrong offset!");

// Class RC.RCTitleSubStoryListItemFinish
// 0x0008 (0x0310 - 0x0308)
class URCTitleSubStoryListItemFinish : public URCTitleSubStoryListItemBase
{
public:
	class UImage*                                 dlIcon;                                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryListItemFinish">();
	}
	static class URCTitleSubStoryListItemFinish* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryListItemFinish>();
	}
};
static_assert(alignof(URCTitleSubStoryListItemFinish) == 0x000008, "Wrong alignment on URCTitleSubStoryListItemFinish");
static_assert(sizeof(URCTitleSubStoryListItemFinish) == 0x000310, "Wrong size on URCTitleSubStoryListItemFinish");
static_assert(offsetof(URCTitleSubStoryListItemFinish, dlIcon) == 0x000308, "Member 'URCTitleSubStoryListItemFinish::dlIcon' has a wrong offset!");

// Class RC.RCNzCriminalCharacterName
// 0x0020 (0x02F8 - 0x02D8)
class URCNzCriminalCharacterName final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      SpText_CharacterName;                              // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalCharacterName">();
	}
	static class URCNzCriminalCharacterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalCharacterName>();
	}
};
static_assert(alignof(URCNzCriminalCharacterName) == 0x000008, "Wrong alignment on URCNzCriminalCharacterName");
static_assert(sizeof(URCNzCriminalCharacterName) == 0x0002F8, "Wrong size on URCNzCriminalCharacterName");
static_assert(offsetof(URCNzCriminalCharacterName, SpText_CharacterName) == 0x0002D8, "Member 'URCNzCriminalCharacterName::SpText_CharacterName' has a wrong offset!");

// Class RC.RCTitleSaveCheckConnectWindowTxt
// 0x0038 (0x0358 - 0x0320)
class URCTitleSaveCheckConnectWindowTxt : public URCMenuButton
{
public:
	class UTextBlock*                             textLine;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Def;                                            // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentMouseSelect;                              // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSaveCheckConnectWindowTxt">();
	}
	static class URCTitleSaveCheckConnectWindowTxt* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSaveCheckConnectWindowTxt>();
	}
};
static_assert(alignof(URCTitleSaveCheckConnectWindowTxt) == 0x000008, "Wrong alignment on URCTitleSaveCheckConnectWindowTxt");
static_assert(sizeof(URCTitleSaveCheckConnectWindowTxt) == 0x000358, "Wrong size on URCTitleSaveCheckConnectWindowTxt");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, textLine) == 0x000320, "Member 'URCTitleSaveCheckConnectWindowTxt::textLine' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, AN_Def) == 0x000328, "Member 'URCTitleSaveCheckConnectWindowTxt::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, AN_Off) == 0x000330, "Member 'URCTitleSaveCheckConnectWindowTxt::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, AN_Cursor_On) == 0x000338, "Member 'URCTitleSaveCheckConnectWindowTxt::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, AN_Cursor_Out) == 0x000340, "Member 'URCTitleSaveCheckConnectWindowTxt::AN_Cursor_Out' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, AN_Push) == 0x000348, "Member 'URCTitleSaveCheckConnectWindowTxt::AN_Push' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindowTxt, isCurrentMouseSelect) == 0x000350, "Member 'URCTitleSaveCheckConnectWindowTxt::isCurrentMouseSelect' has a wrong offset!");

// Class RC.RCCharacterSettingManager
// 0x0020 (0x0048 - 0x0028)
class URCCharacterSettingManager final : public UObject
{
public:
	TArray<class URCParamCharacterSettingDataAsset*> SettingList;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FilenameList;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterSettingManager">();
	}
	static class URCCharacterSettingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterSettingManager>();
	}
};
static_assert(alignof(URCCharacterSettingManager) == 0x000008, "Wrong alignment on URCCharacterSettingManager");
static_assert(sizeof(URCCharacterSettingManager) == 0x000048, "Wrong size on URCCharacterSettingManager");
static_assert(offsetof(URCCharacterSettingManager, SettingList) == 0x000028, "Member 'URCCharacterSettingManager::SettingList' has a wrong offset!");
static_assert(offsetof(URCCharacterSettingManager, FilenameList) == 0x000038, "Member 'URCCharacterSettingManager::FilenameList' has a wrong offset!");

// Class RC.RCCharacterSoldier
// 0x0060 (0x09C0 - 0x0960)
class ARCCharacterSoldier final : public ARCCharacterRender
{
public:
	class FName                                   FormStyle;                                         // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FRCCharacterFormStyleData> FormStyleDataMap;                                  // 0x0968(0x0050)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9B8[0x8];                                      // 0x09B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterSoldier">();
	}
	static class ARCCharacterSoldier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterSoldier>();
	}
};
static_assert(alignof(ARCCharacterSoldier) == 0x000010, "Wrong alignment on ARCCharacterSoldier");
static_assert(sizeof(ARCCharacterSoldier) == 0x0009C0, "Wrong size on ARCCharacterSoldier");
static_assert(offsetof(ARCCharacterSoldier, FormStyle) == 0x000960, "Member 'ARCCharacterSoldier::FormStyle' has a wrong offset!");
static_assert(offsetof(ARCCharacterSoldier, FormStyleDataMap) == 0x000968, "Member 'ARCCharacterSoldier::FormStyleDataMap' has a wrong offset!");

// Class RC.RCNazoMoveLoopParentActor
// 0x0058 (0x0278 - 0x0220)
class ARCNazoMoveLoopParentActor final : public AActor
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ChildActorArray;                                   // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         ReentryActorClassArray;                            // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnWarp;                                            // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWarpToLast;                                      // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWarpEnd;                                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ReentryActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoMoveLoopParentActor">();
	}
	static class ARCNazoMoveLoopParentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoMoveLoopParentActor>();
	}
};
static_assert(alignof(ARCNazoMoveLoopParentActor) == 0x000008, "Wrong alignment on ARCNazoMoveLoopParentActor");
static_assert(sizeof(ARCNazoMoveLoopParentActor) == 0x000278, "Wrong size on ARCNazoMoveLoopParentActor");
static_assert(offsetof(ARCNazoMoveLoopParentActor, DefaultSceneRoot) == 0x000220, "Member 'ARCNazoMoveLoopParentActor::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopParentActor, ChildActorArray) == 0x000228, "Member 'ARCNazoMoveLoopParentActor::ChildActorArray' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopParentActor, ReentryActorClassArray) == 0x000238, "Member 'ARCNazoMoveLoopParentActor::ReentryActorClassArray' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopParentActor, OnWarp) == 0x000248, "Member 'ARCNazoMoveLoopParentActor::OnWarp' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopParentActor, OnWarpToLast) == 0x000258, "Member 'ARCNazoMoveLoopParentActor::OnWarpToLast' has a wrong offset!");
static_assert(offsetof(ARCNazoMoveLoopParentActor, OnWarpEnd) == 0x000268, "Member 'ARCNazoMoveLoopParentActor::OnWarpEnd' has a wrong offset!");

// Class RC.RCTitleLogo
// 0x0068 (0x0340 - 0x02D8)
class URCTitleLogo : public URCUiWidgetBase
{
public:
	class URCTitleLogoPressButton*                Button;                                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CopyLight;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_UserID;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_VersionNum;                                   // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TitleLogoImage;                                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCheckPushKey;                                    // 0x0318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TitleLogoImagePath;                                // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoadingImage;                                   // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedGenericWindow_ToTerminateGame(bool res);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleLogo">();
	}
	static class URCTitleLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleLogo>();
	}
};
static_assert(alignof(URCTitleLogo) == 0x000008, "Wrong alignment on URCTitleLogo");
static_assert(sizeof(URCTitleLogo) == 0x000340, "Wrong size on URCTitleLogo");
static_assert(offsetof(URCTitleLogo, Button) == 0x0002D8, "Member 'URCTitleLogo::Button' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, Text_CopyLight) == 0x0002E0, "Member 'URCTitleLogo::Text_CopyLight' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, Text_UserID) == 0x0002E8, "Member 'URCTitleLogo::Text_UserID' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, Text_VersionNum) == 0x0002F0, "Member 'URCTitleLogo::Text_VersionNum' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, TitleLogoImage) == 0x0002F8, "Member 'URCTitleLogo::TitleLogoImage' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, AN_Start) == 0x000300, "Member 'URCTitleLogo::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, AN_Wait) == 0x000308, "Member 'URCTitleLogo::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, AN_Finish) == 0x000310, "Member 'URCTitleLogo::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, isCheckPushKey) == 0x000318, "Member 'URCTitleLogo::isCheckPushKey' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, TitleLogoImagePath) == 0x000320, "Member 'URCTitleLogo::TitleLogoImagePath' has a wrong offset!");
static_assert(offsetof(URCTitleLogo, bIsLoadingImage) == 0x000338, "Member 'URCTitleLogo::bIsLoadingImage' has a wrong offset!");

// Class RC.RCCharacterToonOutlineCtrl
// 0x0050 (0x0100 - 0x00B0)
class URCCharacterToonOutlineCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x1C];                                      // 0x00B0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoOutlineWidth;                                 // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutlineWidth;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentOutlineWidth;                               // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OutlineWidthMax;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OutlineWidthMin;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OutlineWidthMaxCameraDistance;                     // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OutlineWidthMinCameraDistance;                     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FoVCoefficient;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     OwnerCharacter;                                    // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCPawnRender*                          OwnerPawn;                                         // 0x00F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterToonOutlineCtrl">();
	}
	static class URCCharacterToonOutlineCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterToonOutlineCtrl>();
	}
};
static_assert(alignof(URCCharacterToonOutlineCtrl) == 0x000008, "Wrong alignment on URCCharacterToonOutlineCtrl");
static_assert(sizeof(URCCharacterToonOutlineCtrl) == 0x000100, "Wrong size on URCCharacterToonOutlineCtrl");
static_assert(offsetof(URCCharacterToonOutlineCtrl, bAutoOutlineWidth) == 0x0000CC, "Member 'URCCharacterToonOutlineCtrl::bAutoOutlineWidth' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OutlineWidth) == 0x0000D0, "Member 'URCCharacterToonOutlineCtrl::OutlineWidth' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, CurrentOutlineWidth) == 0x0000D4, "Member 'URCCharacterToonOutlineCtrl::CurrentOutlineWidth' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OutlineWidthMax) == 0x0000D8, "Member 'URCCharacterToonOutlineCtrl::OutlineWidthMax' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OutlineWidthMin) == 0x0000DC, "Member 'URCCharacterToonOutlineCtrl::OutlineWidthMin' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OutlineWidthMaxCameraDistance) == 0x0000E0, "Member 'URCCharacterToonOutlineCtrl::OutlineWidthMaxCameraDistance' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OutlineWidthMinCameraDistance) == 0x0000E4, "Member 'URCCharacterToonOutlineCtrl::OutlineWidthMinCameraDistance' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, FoVCoefficient) == 0x0000E8, "Member 'URCCharacterToonOutlineCtrl::FoVCoefficient' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OwnerCharacter) == 0x0000F0, "Member 'URCCharacterToonOutlineCtrl::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(URCCharacterToonOutlineCtrl, OwnerPawn) == 0x0000F8, "Member 'URCCharacterToonOutlineCtrl::OwnerPawn' has a wrong offset!");

// Class RC.RCParamEventSubLevelData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventSubLevelData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventSubLevelTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventSubLevelData">();
	}
	static class URCParamEventSubLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventSubLevelData>();
	}
};
static_assert(alignof(URCParamEventSubLevelData) == 0x000008, "Wrong alignment on URCParamEventSubLevelData");
static_assert(sizeof(URCParamEventSubLevelData) == 0x000040, "Wrong size on URCParamEventSubLevelData");
static_assert(offsetof(URCParamEventSubLevelData, Data) == 0x000030, "Member 'URCParamEventSubLevelData::Data' has a wrong offset!");

// Class RC.RCCharacterTurnBFL
// 0x0000 (0x0028 - 0x0028)
class URCCharacterTurnBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AnimInstInitializeTurn(class URCCharacterAnimInstance* AnimInst);
	static void AnimInstTickTurn(float DeltaTime, class URCCharacterAnimInstance* AnimInst);
	static void CheckLeaveTurn(bool* bLeaveTurn, const struct FRCAnimInstTurnData& TurnData);
	static bool CheckTurning(class AActor* Actor);
	static void EndTurn(class URCCharacterAnimInstance* AnimInst);
	static void InitializeTurn(class ARCCharacterScript* Character);
	static void SetTurnable(class URCCharacterAnimInstance* AnimInst, bool bTurnable);
	static void StartTurnState(class URCCharacterAnimInstance* AnimInst);
	static void StopTurn(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterTurnBFL">();
	}
	static class URCCharacterTurnBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterTurnBFL>();
	}
};
static_assert(alignof(URCCharacterTurnBFL) == 0x000008, "Wrong alignment on URCCharacterTurnBFL");
static_assert(sizeof(URCCharacterTurnBFL) == 0x000028, "Wrong size on URCCharacterTurnBFL");

// Class RC.RCParamFormListData
// 0x0010 (0x0040 - 0x0030)
class URCParamFormListData final : public URCCSVData
{
public:
	TArray<struct FRCParamFormListTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFormListData">();
	}
	static class URCParamFormListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFormListData>();
	}
};
static_assert(alignof(URCParamFormListData) == 0x000008, "Wrong alignment on URCParamFormListData");
static_assert(sizeof(URCParamFormListData) == 0x000040, "Wrong size on URCParamFormListData");
static_assert(offsetof(URCParamFormListData, Data) == 0x000030, "Member 'URCParamFormListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagi
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiBattleKaiKagi final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_KaikagiChange;                                  // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagiName*               kaikagiName;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagiSelectButton*       KaiKagiSelectButton;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeKaiKagi(class FName InTextID);
	void Close();
	ERCNzUiBattleKaiKagiStatus GetBattleKaiKagiStatus();
	void InitializeBattleKaiKagi();
	void Open();
	void SetKaiKagiName(class FName InTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagi">();
	}
	static class URCNzUiBattleKaiKagi* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagi>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagi) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagi");
static_assert(sizeof(URCNzUiBattleKaiKagi) == 0x000310, "Wrong size on URCNzUiBattleKaiKagi");
static_assert(offsetof(URCNzUiBattleKaiKagi, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleKaiKagi::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagi, AN_Wait) == 0x0002E8, "Member 'URCNzUiBattleKaiKagi::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagi, AN_Finish) == 0x0002F0, "Member 'URCNzUiBattleKaiKagi::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagi, AN_KaikagiChange) == 0x0002F8, "Member 'URCNzUiBattleKaiKagi::AN_KaikagiChange' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagi, kaikagiName) == 0x000300, "Member 'URCNzUiBattleKaiKagi::kaikagiName' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagi, KaiKagiSelectButton) == 0x000308, "Member 'URCNzUiBattleKaiKagi::KaiKagiSelectButton' has a wrong offset!");

// Class RC.RCMenuPlayerController
// 0x0000 (0x05A0 - 0x05A0)
class ARCMenuPlayerController : public ARCPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuPlayerController">();
	}
	static class ARCMenuPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMenuPlayerController>();
	}
};
static_assert(alignof(ARCMenuPlayerController) == 0x000008, "Wrong alignment on ARCMenuPlayerController");
static_assert(sizeof(ARCMenuPlayerController) == 0x0005A0, "Wrong size on ARCMenuPlayerController");

// Class RC.RCTitleProtPlayerController
// 0x0008 (0x05A8 - 0x05A0)
class ARCTitleProtPlayerController final : public ARCMenuPlayerController
{
public:
	class URCTitleProtManager*                    TitleProtManager;                                  // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleProtPlayerController">();
	}
	static class ARCTitleProtPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitleProtPlayerController>();
	}
};
static_assert(alignof(ARCTitleProtPlayerController) == 0x000008, "Wrong alignment on ARCTitleProtPlayerController");
static_assert(sizeof(ARCTitleProtPlayerController) == 0x0005A8, "Wrong size on ARCTitleProtPlayerController");
static_assert(offsetof(ARCTitleProtPlayerController, TitleProtManager) == 0x0005A0, "Member 'ARCTitleProtPlayerController::TitleProtManager' has a wrong offset!");

// Class RC.RCCharacterViewerActor
// 0x0000 (0x0220 - 0x0220)
class ARCCharacterViewerActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerActor">();
	}
	static class ARCCharacterViewerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterViewerActor>();
	}
};
static_assert(alignof(ARCCharacterViewerActor) == 0x000008, "Wrong alignment on ARCCharacterViewerActor");
static_assert(sizeof(ARCCharacterViewerActor) == 0x000220, "Wrong size on ARCCharacterViewerActor");

// Class RC.RCCharacterViewerAnimCtrl
// 0x0060 (0x0110 - 0x00B0)
class URCCharacterViewerAnimCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x60];                                      // 0x00B0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerAnimCtrl">();
	}
	static class URCCharacterViewerAnimCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerAnimCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerAnimCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerAnimCtrl");
static_assert(sizeof(URCCharacterViewerAnimCtrl) == 0x000110, "Wrong size on URCCharacterViewerAnimCtrl");

// Class RC.RCMojimichiManagerActor
// 0x0188 (0x0410 - 0x0288)
class alignas(0x10) ARCMojimichiManagerActor final : public ARCActor
{
public:
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     FractureBP;                                        // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ConstructBP;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             targetTexture;                                     // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DandDStart;                                        // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OrthogonalMetrics;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DensityScale;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParticleMetrics;                                   // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                Widget;                                            // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x38];                                     // 0x02C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetSize;                                        // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetPos;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           m_CameraActor;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x58];                                     // 0x0318(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NiagaraText;                                       // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         NiagaraMeshes;                                     // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               ParticleCapture;                                   // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ParticleRT;                                        // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TempBuffer;                                        // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TxtMat;                                            // 0x03B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 EffectPlane;                                       // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DebugTexture;                                      // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InternalResolution;                                // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InternalResolutionMetrics;                         // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RTMetrics;                                         // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DisolveCurve;                                      // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Divisor;                                           // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RTSingleChannel;                                   // 0x03F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F5[0x1B];                                     // 0x03F5(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DisolveText(float DisolveTime);
	bool ShowText();
	bool SpawnConstructor(class UWorld* World, class AActor* Actor, class UMeshComponent* Component);
	bool StartConstruction(class UWorld* World);
	bool StartConstructionWithActorTag(class UWorld* World, class FName ActorTag);
	bool StartFracture();
	void StopFracture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMojimichiManagerActor">();
	}
	static class ARCMojimichiManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMojimichiManagerActor>();
	}
};
static_assert(alignof(ARCMojimichiManagerActor) == 0x000010, "Wrong alignment on ARCMojimichiManagerActor");
static_assert(sizeof(ARCMojimichiManagerActor) == 0x000410, "Wrong size on ARCMojimichiManagerActor");
static_assert(offsetof(ARCMojimichiManagerActor, FractureBP) == 0x000290, "Member 'ARCMojimichiManagerActor::FractureBP' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, ConstructBP) == 0x000298, "Member 'ARCMojimichiManagerActor::ConstructBP' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, targetTexture) == 0x0002A0, "Member 'ARCMojimichiManagerActor::targetTexture' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, DandDStart) == 0x0002A8, "Member 'ARCMojimichiManagerActor::DandDStart' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, OrthogonalMetrics) == 0x0002AC, "Member 'ARCMojimichiManagerActor::OrthogonalMetrics' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, DensityScale) == 0x0002B0, "Member 'ARCMojimichiManagerActor::DensityScale' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, ParticleMetrics) == 0x0002B4, "Member 'ARCMojimichiManagerActor::ParticleMetrics' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, Widget) == 0x0002C0, "Member 'ARCMojimichiManagerActor::Widget' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, WidgetSize) == 0x000300, "Member 'ARCMojimichiManagerActor::WidgetSize' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, WidgetPos) == 0x000308, "Member 'ARCMojimichiManagerActor::WidgetPos' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, m_CameraActor) == 0x000310, "Member 'ARCMojimichiManagerActor::m_CameraActor' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, NiagaraText) == 0x000370, "Member 'ARCMojimichiManagerActor::NiagaraText' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, NiagaraMeshes) == 0x000378, "Member 'ARCMojimichiManagerActor::NiagaraMeshes' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, RenderTarget) == 0x000388, "Member 'ARCMojimichiManagerActor::RenderTarget' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, ParticleCapture) == 0x000390, "Member 'ARCMojimichiManagerActor::ParticleCapture' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, ParticleRT) == 0x000398, "Member 'ARCMojimichiManagerActor::ParticleRT' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, TempBuffer) == 0x0003A0, "Member 'ARCMojimichiManagerActor::TempBuffer' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, SceneComponent) == 0x0003A8, "Member 'ARCMojimichiManagerActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, TxtMat) == 0x0003B0, "Member 'ARCMojimichiManagerActor::TxtMat' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, EffectPlane) == 0x0003B8, "Member 'ARCMojimichiManagerActor::EffectPlane' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, DebugTexture) == 0x0003C0, "Member 'ARCMojimichiManagerActor::DebugTexture' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, InternalResolution) == 0x0003C8, "Member 'ARCMojimichiManagerActor::InternalResolution' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, InternalResolutionMetrics) == 0x0003D0, "Member 'ARCMojimichiManagerActor::InternalResolutionMetrics' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, RTMetrics) == 0x0003D4, "Member 'ARCMojimichiManagerActor::RTMetrics' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, DisolveCurve) == 0x0003E8, "Member 'ARCMojimichiManagerActor::DisolveCurve' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, Divisor) == 0x0003F0, "Member 'ARCMojimichiManagerActor::Divisor' has a wrong offset!");
static_assert(offsetof(ARCMojimichiManagerActor, RTSingleChannel) == 0x0003F4, "Member 'ARCMojimichiManagerActor::RTSingleChannel' has a wrong offset!");

// Class RC.RCTriggerSphere
// 0x0000 (0x0228 - 0x0228)
class ARCTriggerSphere final : public ATriggerSphere
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTriggerSphere">();
	}
	static class ARCTriggerSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTriggerSphere>();
	}
};
static_assert(alignof(ARCTriggerSphere) == 0x000008, "Wrong alignment on ARCTriggerSphere");
static_assert(sizeof(ARCTriggerSphere) == 0x000228, "Wrong size on ARCTriggerSphere");

// Class RC.RCCharacterViewerAttachmentCtrl
// 0x02A8 (0x0358 - 0x00B0)
class URCCharacterViewerAttachmentCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x2A8];                                     // 0x00B0(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerAttachmentCtrl">();
	}
	static class URCCharacterViewerAttachmentCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerAttachmentCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerAttachmentCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerAttachmentCtrl");
static_assert(sizeof(URCCharacterViewerAttachmentCtrl) == 0x000358, "Wrong size on URCCharacterViewerAttachmentCtrl");

// Class RC.RCMemoryManager
// 0x0000 (0x0028 - 0x0028)
class URCMemoryManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMemoryManager">();
	}
	static class URCMemoryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMemoryManager>();
	}
};
static_assert(alignof(URCMemoryManager) == 0x000008, "Wrong alignment on URCMemoryManager");
static_assert(sizeof(URCMemoryManager) == 0x000028, "Wrong size on URCMemoryManager");

// Class RC.RCCharacterViewerBlackboard
// 0x0010 (0x00C0 - 0x00B0)
class URCCharacterViewerBlackboard final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerBlackboard">();
	}
	static class URCCharacterViewerBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerBlackboard>();
	}
};
static_assert(alignof(URCCharacterViewerBlackboard) == 0x000008, "Wrong alignment on URCCharacterViewerBlackboard");
static_assert(sizeof(URCCharacterViewerBlackboard) == 0x0000C0, "Wrong size on URCCharacterViewerBlackboard");

// Class RC.RCTitleSubStoryListItemUnFinish
// 0x0008 (0x0310 - 0x0308)
class URCTitleSubStoryListItemUnFinish : public URCTitleSubStoryListItemBase
{
public:
	class UImage*                                 dlIcon;                                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryListItemUnFinish">();
	}
	static class URCTitleSubStoryListItemUnFinish* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryListItemUnFinish>();
	}
};
static_assert(alignof(URCTitleSubStoryListItemUnFinish) == 0x000008, "Wrong alignment on URCTitleSubStoryListItemUnFinish");
static_assert(sizeof(URCTitleSubStoryListItemUnFinish) == 0x000310, "Wrong size on URCTitleSubStoryListItemUnFinish");
static_assert(offsetof(URCTitleSubStoryListItemUnFinish, dlIcon) == 0x000308, "Member 'URCTitleSubStoryListItemUnFinish::dlIcon' has a wrong offset!");

// Class RC.RCCharacterViewerCameraPawn
// 0x00C8 (0x0348 - 0x0280)
class ARCCharacterViewerCameraPawn final : public APawn
{
public:
	class USpringArmComponent*                    OurCameraSpringArm;                                // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimTargetActor;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AimTargetSocketName;                               // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0xA8];                                     // 0x02A0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerCameraPawn">();
	}
	static class ARCCharacterViewerCameraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCharacterViewerCameraPawn>();
	}
};
static_assert(alignof(ARCCharacterViewerCameraPawn) == 0x000008, "Wrong alignment on ARCCharacterViewerCameraPawn");
static_assert(sizeof(ARCCharacterViewerCameraPawn) == 0x000348, "Wrong size on ARCCharacterViewerCameraPawn");
static_assert(offsetof(ARCCharacterViewerCameraPawn, OurCameraSpringArm) == 0x000280, "Member 'ARCCharacterViewerCameraPawn::OurCameraSpringArm' has a wrong offset!");
static_assert(offsetof(ARCCharacterViewerCameraPawn, AimTargetActor) == 0x000290, "Member 'ARCCharacterViewerCameraPawn::AimTargetActor' has a wrong offset!");
static_assert(offsetof(ARCCharacterViewerCameraPawn, AimTargetSocketName) == 0x000298, "Member 'ARCCharacterViewerCameraPawn::AimTargetSocketName' has a wrong offset!");

// Class RC.RCCharacterViewerCheckCtrl
// 0x0030 (0x00E0 - 0x00B0)
class URCCharacterViewerCheckCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerCheckCtrl">();
	}
	static class URCCharacterViewerCheckCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerCheckCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerCheckCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerCheckCtrl");
static_assert(sizeof(URCCharacterViewerCheckCtrl) == 0x0000E0, "Wrong size on URCCharacterViewerCheckCtrl");

// Class RC.RCNzCriminalButtonGuide
// 0x0010 (0x02E8 - 0x02D8)
class URCNzCriminalButtonGuide final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERCInputKeyType                               KeyType;                                           // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalButtonGuide">();
	}
	static class URCNzCriminalButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalButtonGuide>();
	}
};
static_assert(alignof(URCNzCriminalButtonGuide) == 0x000008, "Wrong alignment on URCNzCriminalButtonGuide");
static_assert(sizeof(URCNzCriminalButtonGuide) == 0x0002E8, "Wrong size on URCNzCriminalButtonGuide");
static_assert(offsetof(URCNzCriminalButtonGuide, KeyType) == 0x0002E0, "Member 'URCNzCriminalButtonGuide::KeyType' has a wrong offset!");

// Class RC.RCTitleProtGameModeBase
// 0x0000 (0x02D0 - 0x02D0)
class ARCTitleProtGameModeBase final : public ARCMenuGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleProtGameModeBase">();
	}
	static class ARCTitleProtGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitleProtGameModeBase>();
	}
};
static_assert(alignof(ARCTitleProtGameModeBase) == 0x000008, "Wrong alignment on ARCTitleProtGameModeBase");
static_assert(sizeof(ARCTitleProtGameModeBase) == 0x0002D0, "Wrong size on ARCTitleProtGameModeBase");

// Class RC.RCCharacterViewerDressUp
// 0x0020 (0x00D0 - 0x00B0)
class URCCharacterViewerDressUp final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerDressUp">();
	}
	static class URCCharacterViewerDressUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerDressUp>();
	}
};
static_assert(alignof(URCCharacterViewerDressUp) == 0x000008, "Wrong alignment on URCCharacterViewerDressUp");
static_assert(sizeof(URCCharacterViewerDressUp) == 0x0000D0, "Wrong size on URCCharacterViewerDressUp");

// Class RC.RCParamForceFeedBackEffectData
// 0x0010 (0x0040 - 0x0030)
class URCParamForceFeedBackEffectData final : public URCCSVData
{
public:
	TArray<struct FRCParamForceFeedBackEffectTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamForceFeedBackEffectData">();
	}
	static class URCParamForceFeedBackEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamForceFeedBackEffectData>();
	}
};
static_assert(alignof(URCParamForceFeedBackEffectData) == 0x000008, "Wrong alignment on URCParamForceFeedBackEffectData");
static_assert(sizeof(URCParamForceFeedBackEffectData) == 0x000040, "Wrong size on URCParamForceFeedBackEffectData");
static_assert(offsetof(URCParamForceFeedBackEffectData, Data) == 0x000030, "Member 'URCParamForceFeedBackEffectData::Data' has a wrong offset!");

// Class RC.RCCharacterViewerFacialCtrl
// 0x0100 (0x01B0 - 0x00B0)
class URCCharacterViewerFacialCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x100];                                     // 0x00B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerFacialCtrl">();
	}
	static class URCCharacterViewerFacialCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerFacialCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerFacialCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerFacialCtrl");
static_assert(sizeof(URCCharacterViewerFacialCtrl) == 0x0001B0, "Wrong size on URCCharacterViewerFacialCtrl");

// Class RC.RCParamKaikagiListData
// 0x0010 (0x0040 - 0x0030)
class URCParamKaikagiListData final : public URCCSVData
{
public:
	TArray<struct FRCParamKaikagiListTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamKaikagiListData">();
	}
	static class URCParamKaikagiListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamKaikagiListData>();
	}
};
static_assert(alignof(URCParamKaikagiListData) == 0x000008, "Wrong alignment on URCParamKaikagiListData");
static_assert(sizeof(URCParamKaikagiListData) == 0x000040, "Wrong size on URCParamKaikagiListData");
static_assert(offsetof(URCParamKaikagiListData, Data) == 0x000030, "Member 'URCParamKaikagiListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectButton
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiBattleKaiKagiSelectButton final : public URCUiWidgetBase
{
public:
	class URichTextBlock*                         Text_KaikagiName;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeBattleKaiKagiSelectButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectButton">();
	}
	static class URCNzUiBattleKaiKagiSelectButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectButton>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectButton) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectButton");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectButton) == 0x0002E0, "Wrong size on URCNzUiBattleKaiKagiSelectButton");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectButton, Text_KaikagiName) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiSelectButton::Text_KaikagiName' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewerModel
// 0x00C0 (0x0398 - 0x02D8)
class URCUiMenuCharacterViewerModel final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_In;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Slide_Wait;                                     // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Slide_L;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Slide_R;                                        // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Out;                                            // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCUiMenuCharacterViewerModelSlideType        CurrentSlideType;                                  // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x57];                                     // 0x0301(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterModel0TexPath;                            // 0x0358(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterModel1TexPath;                            // 0x0368(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterModel2TexPath;                            // 0x0378(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerModel">();
	}
	static class URCUiMenuCharacterViewerModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerModel>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerModel) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerModel");
static_assert(sizeof(URCUiMenuCharacterViewerModel) == 0x000398, "Wrong size on URCUiMenuCharacterViewerModel");
static_assert(offsetof(URCUiMenuCharacterViewerModel, AN_In) == 0x0002D8, "Member 'URCUiMenuCharacterViewerModel::AN_In' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, AN_Slide_Wait) == 0x0002E0, "Member 'URCUiMenuCharacterViewerModel::AN_Slide_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, AN_Slide_L) == 0x0002E8, "Member 'URCUiMenuCharacterViewerModel::AN_Slide_L' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, AN_Slide_R) == 0x0002F0, "Member 'URCUiMenuCharacterViewerModel::AN_Slide_R' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, AN_Out) == 0x0002F8, "Member 'URCUiMenuCharacterViewerModel::AN_Out' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, CurrentSlideType) == 0x000300, "Member 'URCUiMenuCharacterViewerModel::CurrentSlideType' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, CharacterModel0TexPath) == 0x000358, "Member 'URCUiMenuCharacterViewerModel::CharacterModel0TexPath' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, CharacterModel1TexPath) == 0x000368, "Member 'URCUiMenuCharacterViewerModel::CharacterModel1TexPath' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModel, CharacterModel2TexPath) == 0x000378, "Member 'URCUiMenuCharacterViewerModel::CharacterModel2TexPath' has a wrong offset!");

// Class RC.RCCharacterViewerFormCtrl
// 0x0380 (0x0430 - 0x00B0)
class URCCharacterViewerFormCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x380];                                     // 0x00B0(0x0380)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerFormCtrl">();
	}
	static class URCCharacterViewerFormCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerFormCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerFormCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerFormCtrl");
static_assert(sizeof(URCCharacterViewerFormCtrl) == 0x000430, "Wrong size on URCCharacterViewerFormCtrl");

// Class RC.RCParamEventSceneMapConnectInfoData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventSceneMapConnectInfoData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventSceneMapConnectInfoTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventSceneMapConnectInfoData">();
	}
	static class URCParamEventSceneMapConnectInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventSceneMapConnectInfoData>();
	}
};
static_assert(alignof(URCParamEventSceneMapConnectInfoData) == 0x000008, "Wrong alignment on URCParamEventSceneMapConnectInfoData");
static_assert(sizeof(URCParamEventSceneMapConnectInfoData) == 0x000040, "Wrong size on URCParamEventSceneMapConnectInfoData");
static_assert(offsetof(URCParamEventSceneMapConnectInfoData, Data) == 0x000030, "Member 'URCParamEventSceneMapConnectInfoData::Data' has a wrong offset!");

// Class RC.RCCharacterViewerMenu
// 0x0000 (0x0028 - 0x0028)
class URCCharacterViewerMenu final : public UBlueprintFunctionLibrary
{
public:
	static void CloseDebugMenu();
	static void CreateDebugMenu();
	static void DeleteDebugMenu();
	static void OpenDebugMenu(const class UObject* InContext);
	static void ToggleDebugMenu(const class UObject* InContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerMenu">();
	}
	static class URCCharacterViewerMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerMenu>();
	}
};
static_assert(alignof(URCCharacterViewerMenu) == 0x000008, "Wrong alignment on URCCharacterViewerMenu");
static_assert(sizeof(URCCharacterViewerMenu) == 0x000028, "Wrong size on URCCharacterViewerMenu");

// Class RC.RCNzPuzzleQuestionBase
// 0x0000 (0x02D8 - 0x02D8)
class URCNzPuzzleQuestionBase final : public URCUiWidgetBase
{
public:
	void InitializePuzzleQuestion();
	void SetQuestion(const class FText& wordText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleQuestionBase">();
	}
	static class URCNzPuzzleQuestionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleQuestionBase>();
	}
};
static_assert(alignof(URCNzPuzzleQuestionBase) == 0x000008, "Wrong alignment on URCNzPuzzleQuestionBase");
static_assert(sizeof(URCNzPuzzleQuestionBase) == 0x0002D8, "Wrong size on URCNzPuzzleQuestionBase");

// Class RC.RCUiCutInAnim
// 0x0078 (0x0350 - 0x02D8)
class URCUiCutInAnim final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Anim1;                                          // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait1;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Anim2;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait2;                                          // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Anim3;                                          // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait3;                                          // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Anim4;                                          // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait4;                                          // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeWidgetAnim();
	void Close();
	void InitializeCutIn();
	bool IsFinishContAnim();
	void Open();
	void SetAnimSpeedRate(float InAnimSpeedRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiCutInAnim">();
	}
	static class URCUiCutInAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiCutInAnim>();
	}
};
static_assert(alignof(URCUiCutInAnim) == 0x000008, "Wrong alignment on URCUiCutInAnim");
static_assert(sizeof(URCUiCutInAnim) == 0x000350, "Wrong size on URCUiCutInAnim");
static_assert(offsetof(URCUiCutInAnim, AN_Start) == 0x0002D8, "Member 'URCUiCutInAnim::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Wait) == 0x0002E0, "Member 'URCUiCutInAnim::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Finish) == 0x0002E8, "Member 'URCUiCutInAnim::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Anim1) == 0x0002F0, "Member 'URCUiCutInAnim::AN_Anim1' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Wait1) == 0x0002F8, "Member 'URCUiCutInAnim::AN_Wait1' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Anim2) == 0x000300, "Member 'URCUiCutInAnim::AN_Anim2' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Wait2) == 0x000308, "Member 'URCUiCutInAnim::AN_Wait2' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Anim3) == 0x000310, "Member 'URCUiCutInAnim::AN_Anim3' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Wait3) == 0x000318, "Member 'URCUiCutInAnim::AN_Wait3' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Anim4) == 0x000320, "Member 'URCUiCutInAnim::AN_Anim4' has a wrong offset!");
static_assert(offsetof(URCUiCutInAnim, AN_Wait4) == 0x000328, "Member 'URCUiCutInAnim::AN_Wait4' has a wrong offset!");

// Class RC.RCCharacterViewerSpawnCtrl
// 0x0000 (0x0158 - 0x0158)
class URCCharacterViewerSpawnCtrl final : public USpDebugModelViewerSpawnCtrlComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCharacterViewerSpawnCtrl">();
	}
	static class URCCharacterViewerSpawnCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCharacterViewerSpawnCtrl>();
	}
};
static_assert(alignof(URCCharacterViewerSpawnCtrl) == 0x000008, "Wrong alignment on URCCharacterViewerSpawnCtrl");
static_assert(sizeof(URCCharacterViewerSpawnCtrl) == 0x000158, "Wrong size on URCCharacterViewerSpawnCtrl");

// Class RC.RCMenuCollectionFace
// 0x0008 (0x0278 - 0x0270)
class URCMenuCollectionFace : public URCUserWidget
{
public:
	class UImage*                                 Face_Dummy_000;                                    // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionFace">();
	}
	static class URCMenuCollectionFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionFace>();
	}
};
static_assert(alignof(URCMenuCollectionFace) == 0x000008, "Wrong alignment on URCMenuCollectionFace");
static_assert(sizeof(URCMenuCollectionFace) == 0x000278, "Wrong size on URCMenuCollectionFace");
static_assert(offsetof(URCMenuCollectionFace, Face_Dummy_000) == 0x000270, "Member 'URCMenuCollectionFace::Face_Dummy_000' has a wrong offset!");

// Class RC.RCCheckActor
// 0x0080 (0x0308 - 0x0288)
class ARCCheckActor : public ARCActor
{
public:
	bool                                          bDebugScriptDraw;                                  // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCRealCheckActorType                         UIType;                                            // 0x0289(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheck;                                            // 0x028A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28B[0x1];                                      // 0x028B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CheckNameTextId;                                   // 0x028C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CheckLabelName;                                    // 0x0294(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckIcon;                                        // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerLookEnable;                                 // 0x029D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAreaMoveStop;                                     // 0x029E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29F[0x1];                                      // 0x029F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NextMapID;                                         // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NextPlayerStartName;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCRealCheckActorResearchVisionTimeType       ResearchVisionType;                                // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FigurePersonID;                                    // 0x02B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FigureNum;                                         // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckNameLength;                                   // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckIconLength;                                   // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckNameCenter;                                  // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckNameHeightOffset;                             // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IconScale;                                         // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   VariableName;                                      // 0x02D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VariableArrayNum;                                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VariableCheckNum;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckFinish;                                      // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckNameDraw;                                    // 0x02E5(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckIconDraw;                                    // 0x02E6(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckEnable;                                      // 0x02E7(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerLength;                                      // 0x02E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCActorQuestType                             QuestType;                                         // 0x02EC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestTitleName;                                    // 0x02F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnCheckChangeEvent;                                // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FName GetCheckNameTextId();
	int32 GetFigureNum();
	class FName GetFigurePersonID();
	class FName GetNextMapID();
	class FName GetNextPlayerStartName();
	ERCRealCheckActorResearchVisionTimeType GetResearchVisionType();
	bool IsAreaMoveStop();
	bool IsCheckFinish();
	bool IsCheckIconSetting();
	bool IsCheckSetting();
	void SetAreaMoveStop(bool bInAreaMoveStop);
	void SetCheckFinish(bool bInCheck);
	void SetCheckIconSetting(bool bInCheckIcon);
	void SetCheckNameTextId(class FName InTextID);
	void SetCheckSetting(bool bInCheck);
	void SetFigureNum(int32 InFigureNum);
	void SetFigurePersonID(class FName InFigurePersonID);
	void SetNextMapID(class FName InMapID);
	void SetNextPlayerStartName(class FName InPlayerStartName);
	void SetResearchVisionType(ERCRealCheckActorResearchVisionTimeType InResearchVisionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActor">();
	}
	static class ARCCheckActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCheckActor>();
	}
};
static_assert(alignof(ARCCheckActor) == 0x000008, "Wrong alignment on ARCCheckActor");
static_assert(sizeof(ARCCheckActor) == 0x000308, "Wrong size on ARCCheckActor");
static_assert(offsetof(ARCCheckActor, bDebugScriptDraw) == 0x000288, "Member 'ARCCheckActor::bDebugScriptDraw' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, UIType) == 0x000289, "Member 'ARCCheckActor::UIType' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheck) == 0x00028A, "Member 'ARCCheckActor::bCheck' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, CheckNameTextId) == 0x00028C, "Member 'ARCCheckActor::CheckNameTextId' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, CheckLabelName) == 0x000294, "Member 'ARCCheckActor::CheckLabelName' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckIcon) == 0x00029C, "Member 'ARCCheckActor::bCheckIcon' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bPlayerLookEnable) == 0x00029D, "Member 'ARCCheckActor::bPlayerLookEnable' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bAreaMoveStop) == 0x00029E, "Member 'ARCCheckActor::bAreaMoveStop' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, NextMapID) == 0x0002A0, "Member 'ARCCheckActor::NextMapID' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, NextPlayerStartName) == 0x0002A8, "Member 'ARCCheckActor::NextPlayerStartName' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, ResearchVisionType) == 0x0002B0, "Member 'ARCCheckActor::ResearchVisionType' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, FigurePersonID) == 0x0002B4, "Member 'ARCCheckActor::FigurePersonID' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, FigureNum) == 0x0002BC, "Member 'ARCCheckActor::FigureNum' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, CheckNameLength) == 0x0002C0, "Member 'ARCCheckActor::CheckNameLength' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, CheckIconLength) == 0x0002C4, "Member 'ARCCheckActor::CheckIconLength' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckNameCenter) == 0x0002C8, "Member 'ARCCheckActor::bCheckNameCenter' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, CheckNameHeightOffset) == 0x0002CC, "Member 'ARCCheckActor::CheckNameHeightOffset' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, IconScale) == 0x0002D0, "Member 'ARCCheckActor::IconScale' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, VariableName) == 0x0002D4, "Member 'ARCCheckActor::VariableName' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, VariableArrayNum) == 0x0002DC, "Member 'ARCCheckActor::VariableArrayNum' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, VariableCheckNum) == 0x0002E0, "Member 'ARCCheckActor::VariableCheckNum' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckFinish) == 0x0002E4, "Member 'ARCCheckActor::bCheckFinish' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckNameDraw) == 0x0002E5, "Member 'ARCCheckActor::bCheckNameDraw' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckIconDraw) == 0x0002E6, "Member 'ARCCheckActor::bCheckIconDraw' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, bCheckEnable) == 0x0002E7, "Member 'ARCCheckActor::bCheckEnable' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, PlayerLength) == 0x0002E8, "Member 'ARCCheckActor::PlayerLength' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, QuestType) == 0x0002EC, "Member 'ARCCheckActor::QuestType' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, QuestTitleName) == 0x0002F0, "Member 'ARCCheckActor::QuestTitleName' has a wrong offset!");
static_assert(offsetof(ARCCheckActor, OnCheckChangeEvent) == 0x0002F8, "Member 'ARCCheckActor::OnCheckChangeEvent' has a wrong offset!");

// Class RC.RCTriggerVolume
// 0x0000 (0x0258 - 0x0258)
class ARCTriggerVolume final : public ATriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTriggerVolume">();
	}
	static class ARCTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTriggerVolume>();
	}
};
static_assert(alignof(ARCTriggerVolume) == 0x000008, "Wrong alignment on ARCTriggerVolume");
static_assert(sizeof(ARCTriggerVolume) == 0x000258, "Wrong size on ARCTriggerVolume");

// Class RC.RCCheckActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCCheckActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCCheckActor* GetCheckActor(class FName InName);
	static bool IsAreaMoveStop(class FName InName);
	static bool IsCheckFinish(class FName InName);
	static bool IsCheckSetting(class FName InName);
	static void SetAllAreaMoveMainQuestFlag();
	static void SetAreaMoveStop(class FName InName, bool bInAreaMoveStop);
	static void SetCheckFinish(class FName InName, bool bInCheck);
	static void SetCheckSetting(class FName InName, bool bInCheck);
	static void SetCheckSettings(const class FString& InActorName, bool bInCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorBFL">();
	}
	static class URCCheckActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCheckActorBFL>();
	}
};
static_assert(alignof(URCCheckActorBFL) == 0x000008, "Wrong alignment on URCCheckActorBFL");
static_assert(sizeof(URCCheckActorBFL) == 0x000028, "Wrong size on URCCheckActorBFL");

// Class RC.RCCheckActorBox
// 0x0028 (0x0330 - 0x0308)
class ARCCheckActorBox : public ARCCheckActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComp;                                           // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerHit;                                        // 0x0318(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtent;                                         // 0x031C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfHeight;                                        // 0x0328(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x032C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActorBeginOverlapPlayerEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapPlayerEntry(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorBox">();
	}
	static class ARCCheckActorBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCheckActorBox>();
	}
};
static_assert(alignof(ARCCheckActorBox) == 0x000008, "Wrong alignment on ARCCheckActorBox");
static_assert(sizeof(ARCCheckActorBox) == 0x000330, "Wrong size on ARCCheckActorBox");
static_assert(offsetof(ARCCheckActorBox, Scene) == 0x000308, "Member 'ARCCheckActorBox::Scene' has a wrong offset!");
static_assert(offsetof(ARCCheckActorBox, BoxComp) == 0x000310, "Member 'ARCCheckActorBox::BoxComp' has a wrong offset!");
static_assert(offsetof(ARCCheckActorBox, bPlayerHit) == 0x000318, "Member 'ARCCheckActorBox::bPlayerHit' has a wrong offset!");
static_assert(offsetof(ARCCheckActorBox, BoxExtent) == 0x00031C, "Member 'ARCCheckActorBox::BoxExtent' has a wrong offset!");
static_assert(offsetof(ARCCheckActorBox, HalfHeight) == 0x000328, "Member 'ARCCheckActorBox::HalfHeight' has a wrong offset!");
static_assert(offsetof(ARCCheckActorBox, Radius) == 0x00032C, "Member 'ARCCheckActorBox::Radius' has a wrong offset!");

// Class RC.RCNzCriminalSelectGuide
// 0x0018 (0x02F0 - 0x02D8)
class URCNzCriminalSelectGuide final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_VisibleLR;                                      // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_VisibleL;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_VisibleR;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalSelectGuide">();
	}
	static class URCNzCriminalSelectGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalSelectGuide>();
	}
};
static_assert(alignof(URCNzCriminalSelectGuide) == 0x000008, "Wrong alignment on URCNzCriminalSelectGuide");
static_assert(sizeof(URCNzCriminalSelectGuide) == 0x0002F0, "Wrong size on URCNzCriminalSelectGuide");
static_assert(offsetof(URCNzCriminalSelectGuide, AN_VisibleLR) == 0x0002D8, "Member 'URCNzCriminalSelectGuide::AN_VisibleLR' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSelectGuide, AN_VisibleL) == 0x0002E0, "Member 'URCNzCriminalSelectGuide::AN_VisibleL' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSelectGuide, AN_VisibleR) == 0x0002E8, "Member 'URCNzCriminalSelectGuide::AN_VisibleR' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewer
// 0x0090 (0x0368 - 0x02D8)
class URCUiMenuCharacterViewer final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentCharacterId;                                // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentCharacterPhase;                             // 0x0338(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bButtonGuideVisible;                               // 0x033C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33D[0xB];                                      // 0x033D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReleaseTexPathList;                                // 0x0348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonGuideClickEvent(ERCInputKeyType KeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewer">();
	}
	static class URCUiMenuCharacterViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewer>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewer) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewer");
static_assert(sizeof(URCUiMenuCharacterViewer) == 0x000368, "Wrong size on URCUiMenuCharacterViewer");
static_assert(offsetof(URCUiMenuCharacterViewer, AN_Start) == 0x0002D8, "Member 'URCUiMenuCharacterViewer::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, AN_Wait) == 0x0002E0, "Member 'URCUiMenuCharacterViewer::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, AN_Finish) == 0x0002E8, "Member 'URCUiMenuCharacterViewer::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, CurrentCharacterId) == 0x000330, "Member 'URCUiMenuCharacterViewer::CurrentCharacterId' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, CurrentCharacterPhase) == 0x000338, "Member 'URCUiMenuCharacterViewer::CurrentCharacterPhase' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, bButtonGuideVisible) == 0x00033C, "Member 'URCUiMenuCharacterViewer::bButtonGuideVisible' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewer, ReleaseTexPathList) == 0x000348, "Member 'URCUiMenuCharacterViewer::ReleaseTexPathList' has a wrong offset!");

// Class RC.RCCheckActorCapsule
// 0x0018 (0x0320 - 0x0308)
class ARCCheckActorCapsule : public ARCCheckActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0318(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x031C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorCapsule">();
	}
	static class ARCCheckActorCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCheckActorCapsule>();
	}
};
static_assert(alignof(ARCCheckActorCapsule) == 0x000008, "Wrong alignment on ARCCheckActorCapsule");
static_assert(sizeof(ARCCheckActorCapsule) == 0x000320, "Wrong size on ARCCheckActorCapsule");
static_assert(offsetof(ARCCheckActorCapsule, Scene) == 0x000308, "Member 'ARCCheckActorCapsule::Scene' has a wrong offset!");
static_assert(offsetof(ARCCheckActorCapsule, CapsuleComp) == 0x000310, "Member 'ARCCheckActorCapsule::CapsuleComp' has a wrong offset!");
static_assert(offsetof(ARCCheckActorCapsule, HalfHeight) == 0x000318, "Member 'ARCCheckActorCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(ARCCheckActorCapsule, Radius) == 0x00031C, "Member 'ARCCheckActorCapsule::Radius' has a wrong offset!");

// Class RC.RCParamInputKeyConfigData
// 0x0010 (0x0040 - 0x0030)
class URCParamInputKeyConfigData final : public URCCSVData
{
public:
	TArray<struct FRCParamInputKeyConfigTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamInputKeyConfigData">();
	}
	static class URCParamInputKeyConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamInputKeyConfigData>();
	}
};
static_assert(alignof(URCParamInputKeyConfigData) == 0x000008, "Wrong alignment on URCParamInputKeyConfigData");
static_assert(sizeof(URCParamInputKeyConfigData) == 0x000040, "Wrong size on URCParamInputKeyConfigData");
static_assert(offsetof(URCParamInputKeyConfigData, Data) == 0x000030, "Member 'URCParamInputKeyConfigData::Data' has a wrong offset!");

// Class RC.RCCheckActorKaiKagiSelectBox
// 0x0008 (0x0338 - 0x0330)
class ARCCheckActorKaiKagiSelectBox final : public ARCCheckActorBox
{
public:
	class URCCheckActorKaiKagiSelectComponent*    KaiKagiSelectComp;                                 // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorKaiKagiSelectBox">();
	}
	static class ARCCheckActorKaiKagiSelectBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCheckActorKaiKagiSelectBox>();
	}
};
static_assert(alignof(ARCCheckActorKaiKagiSelectBox) == 0x000008, "Wrong alignment on ARCCheckActorKaiKagiSelectBox");
static_assert(sizeof(ARCCheckActorKaiKagiSelectBox) == 0x000338, "Wrong size on ARCCheckActorKaiKagiSelectBox");
static_assert(offsetof(ARCCheckActorKaiKagiSelectBox, KaiKagiSelectComp) == 0x000330, "Member 'ARCCheckActorKaiKagiSelectBox::KaiKagiSelectComp' has a wrong offset!");

// Class RC.RCParamMenuStatusData
// 0x0010 (0x0040 - 0x0030)
class URCParamMenuStatusData final : public URCCSVData
{
public:
	TArray<struct FRCParamMenuStatusTableRow>     Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMenuStatusData">();
	}
	static class URCParamMenuStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMenuStatusData>();
	}
};
static_assert(alignof(URCParamMenuStatusData) == 0x000008, "Wrong alignment on URCParamMenuStatusData");
static_assert(sizeof(URCParamMenuStatusData) == 0x000040, "Wrong size on URCParamMenuStatusData");
static_assert(offsetof(URCParamMenuStatusData, Data) == 0x000030, "Member 'URCParamMenuStatusData::Data' has a wrong offset!");

// Class RC.RCNzFinaleDetectiveBackGround
// 0x0008 (0x0228 - 0x0220)
class ARCNzFinaleDetectiveBackGround final : public AActor
{
public:
	class ARCNzFinaleManagerBase*                 FinaleManager;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeBackgroundImg(const class UTexture* Texture);
	void SetVisiblityBackground(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleDetectiveBackGround">();
	}
	static class ARCNzFinaleDetectiveBackGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleDetectiveBackGround>();
	}
};
static_assert(alignof(ARCNzFinaleDetectiveBackGround) == 0x000008, "Wrong alignment on ARCNzFinaleDetectiveBackGround");
static_assert(sizeof(ARCNzFinaleDetectiveBackGround) == 0x000228, "Wrong size on ARCNzFinaleDetectiveBackGround");
static_assert(offsetof(ARCNzFinaleDetectiveBackGround, FinaleManager) == 0x000220, "Member 'ARCNzFinaleDetectiveBackGround::FinaleManager' has a wrong offset!");

// Class RC.RCParamEventMapInfoData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventMapInfoData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventMapInfoTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventMapInfoData">();
	}
	static class URCParamEventMapInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventMapInfoData>();
	}
};
static_assert(alignof(URCParamEventMapInfoData) == 0x000008, "Wrong alignment on URCParamEventMapInfoData");
static_assert(sizeof(URCParamEventMapInfoData) == 0x000040, "Wrong size on URCParamEventMapInfoData");
static_assert(offsetof(URCParamEventMapInfoData, Data) == 0x000030, "Member 'URCParamEventMapInfoData::Data' has a wrong offset!");

// Class RC.RCUiMenuCommonWindowInfo
// 0x0028 (0x0310 - 0x02E8)
class URCUiMenuCommonWindowInfo : public URCUiMenuCommonIcon
{
public:
	class UTextLayoutWidget*                      Text_Information;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Info;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCommonWindowInfo">();
	}
	static class URCUiMenuCommonWindowInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCommonWindowInfo>();
	}
};
static_assert(alignof(URCUiMenuCommonWindowInfo) == 0x000008, "Wrong alignment on URCUiMenuCommonWindowInfo");
static_assert(sizeof(URCUiMenuCommonWindowInfo) == 0x000310, "Wrong size on URCUiMenuCommonWindowInfo");
static_assert(offsetof(URCUiMenuCommonWindowInfo, Text_Information) == 0x0002E8, "Member 'URCUiMenuCommonWindowInfo::Text_Information' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonWindowInfo, Text_Info) == 0x0002F0, "Member 'URCUiMenuCommonWindowInfo::Text_Info' has a wrong offset!");

// Class RC.RCCheckActorKaiKagiSelectCapsule
// 0x0008 (0x0328 - 0x0320)
class ARCCheckActorKaiKagiSelectCapsule final : public ARCCheckActorCapsule
{
public:
	class URCCheckActorKaiKagiSelectComponent*    KaiKagiSelectComp;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorKaiKagiSelectCapsule">();
	}
	static class ARCCheckActorKaiKagiSelectCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCheckActorKaiKagiSelectCapsule>();
	}
};
static_assert(alignof(ARCCheckActorKaiKagiSelectCapsule) == 0x000008, "Wrong alignment on ARCCheckActorKaiKagiSelectCapsule");
static_assert(sizeof(ARCCheckActorKaiKagiSelectCapsule) == 0x000328, "Wrong size on ARCCheckActorKaiKagiSelectCapsule");
static_assert(offsetof(ARCCheckActorKaiKagiSelectCapsule, KaiKagiSelectComp) == 0x000320, "Member 'ARCCheckActorKaiKagiSelectCapsule::KaiKagiSelectComp' has a wrong offset!");

// Class RC.RCParamFogData
// 0x0010 (0x0040 - 0x0030)
class URCParamFogData final : public URCCSVData
{
public:
	TArray<struct FRCParamFogTableRow>            Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFogData">();
	}
	static class URCParamFogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFogData>();
	}
};
static_assert(alignof(URCParamFogData) == 0x000008, "Wrong alignment on URCParamFogData");
static_assert(sizeof(URCParamFogData) == 0x000040, "Wrong size on URCParamFogData");
static_assert(offsetof(URCParamFogData, Data) == 0x000030, "Member 'URCParamFogData::Data' has a wrong offset!");

// Class RC.RCCheckActorKaiKagiSelectComponent
// 0x0090 (0x0640 - 0x05B0)
class URCCheckActorKaiKagiSelectComponent final : public UWidgetComponent
{
public:
	class URCNzUiKagiChoiceQuestion*              ChoiceQuestionWidget;                              // 0x05B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   QuestionTextID;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           KaiKagiIDArray;                                    // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllFailureFlag;                                   // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CorrectKaiKagiID;                                  // 0x05DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DeleteKaiKagiIDArray;                              // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         LimitTime;                                         // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopGameTime;                                     // 0x05FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotPause;                                         // 0x05FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelDisable;                                    // 0x05FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FF[0x29];                                     // 0x05FF(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CheckActorName;                                    // 0x0628(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCCheckActorKaiKagiSelectResult              Result;                                            // 0x0630(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x3];                                      // 0x0631(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectIndex;                                       // 0x0634(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCheckActorKaiKagiSelectComponent">();
	}
	static class URCCheckActorKaiKagiSelectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCheckActorKaiKagiSelectComponent>();
	}
};
static_assert(alignof(URCCheckActorKaiKagiSelectComponent) == 0x000010, "Wrong alignment on URCCheckActorKaiKagiSelectComponent");
static_assert(sizeof(URCCheckActorKaiKagiSelectComponent) == 0x000640, "Wrong size on URCCheckActorKaiKagiSelectComponent");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, ChoiceQuestionWidget) == 0x0005B0, "Member 'URCCheckActorKaiKagiSelectComponent::ChoiceQuestionWidget' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, QuestionTextID) == 0x0005B8, "Member 'URCCheckActorKaiKagiSelectComponent::QuestionTextID' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, KaiKagiIDArray) == 0x0005C8, "Member 'URCCheckActorKaiKagiSelectComponent::KaiKagiIDArray' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, bAllFailureFlag) == 0x0005D8, "Member 'URCCheckActorKaiKagiSelectComponent::bAllFailureFlag' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, CorrectKaiKagiID) == 0x0005DC, "Member 'URCCheckActorKaiKagiSelectComponent::CorrectKaiKagiID' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, DeleteKaiKagiIDArray) == 0x0005E8, "Member 'URCCheckActorKaiKagiSelectComponent::DeleteKaiKagiIDArray' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, LimitTime) == 0x0005F8, "Member 'URCCheckActorKaiKagiSelectComponent::LimitTime' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, bStopGameTime) == 0x0005FC, "Member 'URCCheckActorKaiKagiSelectComponent::bStopGameTime' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, bNotPause) == 0x0005FD, "Member 'URCCheckActorKaiKagiSelectComponent::bNotPause' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, bCancelDisable) == 0x0005FE, "Member 'URCCheckActorKaiKagiSelectComponent::bCancelDisable' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, CheckActorName) == 0x000628, "Member 'URCCheckActorKaiKagiSelectComponent::CheckActorName' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, Result) == 0x000630, "Member 'URCCheckActorKaiKagiSelectComponent::Result' has a wrong offset!");
static_assert(offsetof(URCCheckActorKaiKagiSelectComponent, SelectIndex) == 0x000634, "Member 'URCCheckActorKaiKagiSelectComponent::SelectIndex' has a wrong offset!");

// Class RC.RCNzUiAssistCutin
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiAssistCutin final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_NzAssistCutIn_Face;                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadingImage;                                     // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssistImagePath;                                   // 0x02F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ERCNzUiAssistCutinStatus GetAssistCutinStatus();
	void InitializeAssistCutin(const struct FSoftObjectPath& InAssistImagePath);
	void Open();
	void UninitializeAssistCutin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiAssistCutin">();
	}
	static class URCNzUiAssistCutin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiAssistCutin>();
	}
};
static_assert(alignof(URCNzUiAssistCutin) == 0x000008, "Wrong alignment on URCNzUiAssistCutin");
static_assert(sizeof(URCNzUiAssistCutin) == 0x000310, "Wrong size on URCNzUiAssistCutin");
static_assert(offsetof(URCNzUiAssistCutin, AN_Start) == 0x0002E0, "Member 'URCNzUiAssistCutin::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiAssistCutin, Img_NzAssistCutIn_Face) == 0x0002E8, "Member 'URCNzUiAssistCutin::Img_NzAssistCutIn_Face' has a wrong offset!");
static_assert(offsetof(URCNzUiAssistCutin, bLoadingImage) == 0x0002F0, "Member 'URCNzUiAssistCutin::bLoadingImage' has a wrong offset!");
static_assert(offsetof(URCNzUiAssistCutin, AssistImagePath) == 0x0002F8, "Member 'URCNzUiAssistCutin::AssistImagePath' has a wrong offset!");

// Class RC.RCUiDetPoint
// 0x00C0 (0x0398 - 0x02D8)
class URCUiDetPoint final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_RankUp_Start;                                   // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_RankUp_Wait;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_RankUp_Finish;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_TNPoint;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_RankNum;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Caption1;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Point1;                                       // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Caption2;                                     // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Point2;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Text1;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Text2;                               // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Rankup_Grp;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpUIGauge*                             SpGauge_TNPoint;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x40];                                     // 0x0358(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeDetPoint();
	void Open();
	void SetDetPoint(int32 InPoint);
	void SetDetRank(int32 InPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiDetPoint">();
	}
	static class URCUiDetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiDetPoint>();
	}
};
static_assert(alignof(URCUiDetPoint) == 0x000008, "Wrong alignment on URCUiDetPoint");
static_assert(sizeof(URCUiDetPoint) == 0x000398, "Wrong size on URCUiDetPoint");
static_assert(offsetof(URCUiDetPoint, AN_Start) == 0x0002D8, "Member 'URCUiDetPoint::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, AN_Wait) == 0x0002E0, "Member 'URCUiDetPoint::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, AN_Finish) == 0x0002E8, "Member 'URCUiDetPoint::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, AN_RankUp_Start) == 0x0002F0, "Member 'URCUiDetPoint::AN_RankUp_Start' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, AN_RankUp_Wait) == 0x0002F8, "Member 'URCUiDetPoint::AN_RankUp_Wait' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, AN_RankUp_Finish) == 0x000300, "Member 'URCUiDetPoint::AN_RankUp_Finish' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_TNPoint) == 0x000308, "Member 'URCUiDetPoint::Text_TNPoint' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_RankNum) == 0x000310, "Member 'URCUiDetPoint::Text_RankNum' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_Caption1) == 0x000318, "Member 'URCUiDetPoint::Text_Caption1' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_Point1) == 0x000320, "Member 'URCUiDetPoint::Text_Point1' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_Caption2) == 0x000328, "Member 'URCUiDetPoint::Text_Caption2' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Text_Point2) == 0x000330, "Member 'URCUiDetPoint::Text_Point2' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, HorizontalBox_Text1) == 0x000338, "Member 'URCUiDetPoint::HorizontalBox_Text1' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, HorizontalBox_Text2) == 0x000340, "Member 'URCUiDetPoint::HorizontalBox_Text2' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, Rankup_Grp) == 0x000348, "Member 'URCUiDetPoint::Rankup_Grp' has a wrong offset!");
static_assert(offsetof(URCUiDetPoint, SpGauge_TNPoint) == 0x000350, "Member 'URCUiDetPoint::SpGauge_TNPoint' has a wrong offset!");

// Class RC.RCCineCameraActor
// 0x0010 (0x0820 - 0x0810)
class ARCCineCameraActor final : public ACineCameraActor
{
public:
	float                                         rainDistanceOffset;                                // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         rainHeightOffset;                                  // 0x0814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useOffsetFlag;                                     // 0x0818(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AtouchRain(float lenght, bool Zfollow, float OffsetZ);
	void RemoveRain();
	void SetRainDistanceOffset(float disntaceOffset);
	void SetRainHeightOffset(float heightOffset);
	void SetUseOffsetFlag(bool bUseOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCineCameraActor">();
	}
	static class ARCCineCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCineCameraActor>();
	}
};
static_assert(alignof(ARCCineCameraActor) == 0x000010, "Wrong alignment on ARCCineCameraActor");
static_assert(sizeof(ARCCineCameraActor) == 0x000820, "Wrong size on ARCCineCameraActor");
static_assert(offsetof(ARCCineCameraActor, rainDistanceOffset) == 0x000810, "Member 'ARCCineCameraActor::rainDistanceOffset' has a wrong offset!");
static_assert(offsetof(ARCCineCameraActor, rainHeightOffset) == 0x000814, "Member 'ARCCineCameraActor::rainHeightOffset' has a wrong offset!");
static_assert(offsetof(ARCCineCameraActor, useOffsetFlag) == 0x000818, "Member 'ARCCineCameraActor::useOffsetFlag' has a wrong offset!");

// Class RC.RCCMNEventBFL
// 0x0000 (0x0028 - 0x0028)
class URCCMNEventBFL final : public UBlueprintFunctionLibrary
{
public:
	static void CamSwitch(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex);
	static void CamSwitchBlend(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InBlendTime, EViewTargetBlendFunction InBlendFunc, const float InBlendExp);
	static void CamSwitchBufReset(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex);
	static void InitCharacter(class AActor* InActor, const class FName InTargetPointName);
	static void ResetCharacter(class AActor* InActor);
	static void SetCamDistance(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InDistance);
	static void SetCamFocalLength(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InFocalLength);
	static void SetCamFocusOffset(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InFocusOffset);
	static void SetCamMoveX(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InX);
	static void SetCamMoveY(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InY);
	static void SetCamMoveZ(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InZ);
	static void SetCamPitch(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InPitch);
	static void SetCamRoll(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InRoll);
	static void SetCamVpY(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InY);
	static void SetCamVpZ(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InZ);
	static void SetCamYaw(const TArray<class ARCCineCameraActor*>& InCamList, const int32 InCamIndex, const float InYaw);
	static void WalkSpline(class AActor* InActor, class AActor* InSplineActor, float InTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCMNEventBFL">();
	}
	static class URCCMNEventBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCMNEventBFL>();
	}
};
static_assert(alignof(URCCMNEventBFL) == 0x000008, "Wrong alignment on URCCMNEventBFL");
static_assert(sizeof(URCCMNEventBFL) == 0x000028, "Wrong size on URCCMNEventBFL");

// Class RC.RCMenuCollectionCheckIcon
// 0x0028 (0x0298 - 0x0270)
class URCMenuCollectionCheckIcon : public URCUserWidget
{
public:
	class UImage*                                 Icon_Kidoku_Check;                                 // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Flame;                                          // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Check_Start;                                    // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Check_Wait;                                     // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionCheckIcon">();
	}
	static class URCMenuCollectionCheckIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionCheckIcon>();
	}
};
static_assert(alignof(URCMenuCollectionCheckIcon) == 0x000008, "Wrong alignment on URCMenuCollectionCheckIcon");
static_assert(sizeof(URCMenuCollectionCheckIcon) == 0x000298, "Wrong size on URCMenuCollectionCheckIcon");
static_assert(offsetof(URCMenuCollectionCheckIcon, Icon_Kidoku_Check) == 0x000270, "Member 'URCMenuCollectionCheckIcon::Icon_Kidoku_Check' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionCheckIcon, AN_Flame) == 0x000278, "Member 'URCMenuCollectionCheckIcon::AN_Flame' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionCheckIcon, AN_Check_Start) == 0x000280, "Member 'URCMenuCollectionCheckIcon::AN_Check_Start' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionCheckIcon, AN_Check_Wait) == 0x000288, "Member 'URCMenuCollectionCheckIcon::AN_Check_Wait' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionCheckIcon, AN_Off) == 0x000290, "Member 'URCMenuCollectionCheckIcon::AN_Off' has a wrong offset!");

// Class RC.RCUiMenuCommonTab
// 0x0028 (0x0300 - 0x02D8)
class URCUiMenuCommonTab : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInputFromButtonGuide(ERCInputKeyType InType);
	void SetTabIconActive(int32 InActiveIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCommonTab">();
	}
	static class URCUiMenuCommonTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCommonTab>();
	}
};
static_assert(alignof(URCUiMenuCommonTab) == 0x000008, "Wrong alignment on URCUiMenuCommonTab");
static_assert(sizeof(URCUiMenuCommonTab) == 0x000300, "Wrong size on URCUiMenuCommonTab");

// Class RC.RCCollisionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCCollisionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool SphereOverlapBlockingSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Position, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCollisionLibrary">();
	}
	static class URCCollisionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCollisionLibrary>();
	}
};
static_assert(alignof(URCCollisionLibrary) == 0x000008, "Wrong alignment on URCCollisionLibrary");
static_assert(sizeof(URCCollisionLibrary) == 0x000028, "Wrong size on URCCollisionLibrary");

// Class RC.RCParamMenuContentsListData
// 0x0010 (0x0040 - 0x0030)
class URCParamMenuContentsListData final : public URCCSVData
{
public:
	TArray<struct FRCParamMenuContentsListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMenuContentsListData">();
	}
	static class URCParamMenuContentsListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMenuContentsListData>();
	}
};
static_assert(alignof(URCParamMenuContentsListData) == 0x000008, "Wrong alignment on URCParamMenuContentsListData");
static_assert(sizeof(URCParamMenuContentsListData) == 0x000040, "Wrong size on URCParamMenuContentsListData");
static_assert(offsetof(URCParamMenuContentsListData, Data) == 0x000030, "Member 'URCParamMenuContentsListData::Data' has a wrong offset!");

// Class RC.RCMenuCollectionList
// 0x0038 (0x0330 - 0x02F8)
class URCMenuCollectionList : public URCMenuManager
{
public:
	class URCMenuCollectionListBar*               Collect_ListBar_00;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionListBar*               Collect_ListBar_01;                                // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionListBar*               Collect_ListBar_02;                                // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionListBar*               Collect_ListBar_03;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionListBar*               Collect_ListBar_04;                                // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCMenuCollectionListBar*>       listBarArray;                                      // 0x0320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionList">();
	}
	static class URCMenuCollectionList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionList>();
	}
};
static_assert(alignof(URCMenuCollectionList) == 0x000008, "Wrong alignment on URCMenuCollectionList");
static_assert(sizeof(URCMenuCollectionList) == 0x000330, "Wrong size on URCMenuCollectionList");
static_assert(offsetof(URCMenuCollectionList, Collect_ListBar_00) == 0x0002F8, "Member 'URCMenuCollectionList::Collect_ListBar_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionList, Collect_ListBar_01) == 0x000300, "Member 'URCMenuCollectionList::Collect_ListBar_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionList, Collect_ListBar_02) == 0x000308, "Member 'URCMenuCollectionList::Collect_ListBar_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionList, Collect_ListBar_03) == 0x000310, "Member 'URCMenuCollectionList::Collect_ListBar_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionList, Collect_ListBar_04) == 0x000318, "Member 'URCMenuCollectionList::Collect_ListBar_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionList, listBarArray) == 0x000320, "Member 'URCMenuCollectionList::listBarArray' has a wrong offset!");

// Class RC.RCCompanionAIComponent
// 0x0020 (0x00D0 - 0x00B0)
class URCCompanionAIComponent final : public UActorComponent
{
public:
	bool                                          bEnable;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontMove;                                        // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialize;                                       // 0x00B2(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class URCCompanionAIMove*                     AIMove;                                            // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SpeedBackup;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunSpeed;                                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkSpeed;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCompanionAIComponent">();
	}
	static class URCCompanionAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCompanionAIComponent>();
	}
};
static_assert(alignof(URCCompanionAIComponent) == 0x000008, "Wrong alignment on URCCompanionAIComponent");
static_assert(sizeof(URCCompanionAIComponent) == 0x0000D0, "Wrong size on URCCompanionAIComponent");
static_assert(offsetof(URCCompanionAIComponent, bEnable) == 0x0000B0, "Member 'URCCompanionAIComponent::bEnable' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, bFrontMove) == 0x0000B1, "Member 'URCCompanionAIComponent::bFrontMove' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, bInitialize) == 0x0000B2, "Member 'URCCompanionAIComponent::bInitialize' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, AIMove) == 0x0000B8, "Member 'URCCompanionAIComponent::AIMove' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, SpeedBackup) == 0x0000C0, "Member 'URCCompanionAIComponent::SpeedBackup' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, RunSpeed) == 0x0000C4, "Member 'URCCompanionAIComponent::RunSpeed' has a wrong offset!");
static_assert(offsetof(URCCompanionAIComponent, WalkSpeed) == 0x0000C8, "Member 'URCCompanionAIComponent::WalkSpeed' has a wrong offset!");

// Class RC.RCUiButtonGuideParts
// 0x00C0 (0x03A0 - 0x02E0)
class alignas(0x10) URCUiButtonGuideParts : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      buttonGuide;                                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Def;                                            // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Big;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Light;                                 // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x90];                                     // 0x0310(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiButtonGuideParts">();
	}
	static class URCUiButtonGuideParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiButtonGuideParts>();
	}
};
static_assert(alignof(URCUiButtonGuideParts) == 0x000010, "Wrong alignment on URCUiButtonGuideParts");
static_assert(sizeof(URCUiButtonGuideParts) == 0x0003A0, "Wrong size on URCUiButtonGuideParts");
static_assert(offsetof(URCUiButtonGuideParts, buttonGuide) == 0x0002F0, "Member 'URCUiButtonGuideParts::buttonGuide' has a wrong offset!");
static_assert(offsetof(URCUiButtonGuideParts, AN_Def) == 0x0002F8, "Member 'URCUiButtonGuideParts::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiButtonGuideParts, AN_OnCursor_Big) == 0x000300, "Member 'URCUiButtonGuideParts::AN_OnCursor_Big' has a wrong offset!");
static_assert(offsetof(URCUiButtonGuideParts, AN_OnCursor_Light) == 0x000308, "Member 'URCUiButtonGuideParts::AN_OnCursor_Light' has a wrong offset!");

// Class RC.RCCompanionAIMove
// 0x02F8 (0x0320 - 0x0028)
class URCCompanionAIMove final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class URCCharacterProxy*                      MyCharacterProxy;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     MyActor;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     PlayerActor;                                       // 0x0068(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCCompanionAiMoveType                        AiMoveType;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAiMoveTypeInit;                                   // 0x0071(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontMove;                                        // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_73[0x1];                                       // 0x0073(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovePlayerLength;                                  // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthFront;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthRun;                               // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthRunMax;                            // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthRunFront;                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthRunMaxFront;                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerLengthWarp;                              // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerHeightWarp;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveNearLength;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveWaitSecMax;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerOffsetLength;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovePlayerOffsetAngle;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NextPosition;                                      // 0x00A4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ActorsToIgnoreList;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	float                                         MoveOffsetLength;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveOffsetAngle;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveAngle;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveWaitSec;                                       // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickDeltaTime;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickDeltaTimePower;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PlayerStopPosition;                                // 0x00D8(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NowSpeed;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExecSpeed;                                         // 0x00E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerSpeed;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AngleIndex;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMoveLengthUpdate;                                 // 0x00F4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F5[0x223];                                     // 0x00F5(0x0223)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDraw;                                        // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCompanionAIMove">();
	}
	static class URCCompanionAIMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCompanionAIMove>();
	}
};
static_assert(alignof(URCCompanionAIMove) == 0x000008, "Wrong alignment on URCCompanionAIMove");
static_assert(sizeof(URCCompanionAIMove) == 0x000320, "Wrong size on URCCompanionAIMove");
static_assert(offsetof(URCCompanionAIMove, MyCharacterProxy) == 0x000058, "Member 'URCCompanionAIMove::MyCharacterProxy' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MyActor) == 0x000060, "Member 'URCCompanionAIMove::MyActor' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, PlayerActor) == 0x000068, "Member 'URCCompanionAIMove::PlayerActor' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, AiMoveType) == 0x000070, "Member 'URCCompanionAIMove::AiMoveType' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, bAiMoveTypeInit) == 0x000071, "Member 'URCCompanionAIMove::bAiMoveTypeInit' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, bFrontMove) == 0x000072, "Member 'URCCompanionAIMove::bFrontMove' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLength) == 0x000074, "Member 'URCCompanionAIMove::MovePlayerLength' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthFront) == 0x000078, "Member 'URCCompanionAIMove::MovePlayerLengthFront' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthRun) == 0x00007C, "Member 'URCCompanionAIMove::MovePlayerLengthRun' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthRunMax) == 0x000080, "Member 'URCCompanionAIMove::MovePlayerLengthRunMax' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthRunFront) == 0x000084, "Member 'URCCompanionAIMove::MovePlayerLengthRunFront' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthRunMaxFront) == 0x000088, "Member 'URCCompanionAIMove::MovePlayerLengthRunMaxFront' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerLengthWarp) == 0x00008C, "Member 'URCCompanionAIMove::MovePlayerLengthWarp' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerHeightWarp) == 0x000090, "Member 'URCCompanionAIMove::MovePlayerHeightWarp' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveNearLength) == 0x000094, "Member 'URCCompanionAIMove::MoveNearLength' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveWaitSecMax) == 0x000098, "Member 'URCCompanionAIMove::MoveWaitSecMax' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerOffsetLength) == 0x00009C, "Member 'URCCompanionAIMove::MovePlayerOffsetLength' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MovePlayerOffsetAngle) == 0x0000A0, "Member 'URCCompanionAIMove::MovePlayerOffsetAngle' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, NextPosition) == 0x0000A4, "Member 'URCCompanionAIMove::NextPosition' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, ActorsToIgnoreList) == 0x0000B0, "Member 'URCCompanionAIMove::ActorsToIgnoreList' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveOffsetLength) == 0x0000C0, "Member 'URCCompanionAIMove::MoveOffsetLength' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveOffsetAngle) == 0x0000C4, "Member 'URCCompanionAIMove::MoveOffsetAngle' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveAngle) == 0x0000C8, "Member 'URCCompanionAIMove::MoveAngle' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, MoveWaitSec) == 0x0000CC, "Member 'URCCompanionAIMove::MoveWaitSec' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, TickDeltaTime) == 0x0000D0, "Member 'URCCompanionAIMove::TickDeltaTime' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, TickDeltaTimePower) == 0x0000D4, "Member 'URCCompanionAIMove::TickDeltaTimePower' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, PlayerStopPosition) == 0x0000D8, "Member 'URCCompanionAIMove::PlayerStopPosition' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, NowSpeed) == 0x0000E4, "Member 'URCCompanionAIMove::NowSpeed' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, ExecSpeed) == 0x0000E8, "Member 'URCCompanionAIMove::ExecSpeed' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, PlayerSpeed) == 0x0000EC, "Member 'URCCompanionAIMove::PlayerSpeed' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, AngleIndex) == 0x0000F0, "Member 'URCCompanionAIMove::AngleIndex' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, bMoveLengthUpdate) == 0x0000F4, "Member 'URCCompanionAIMove::bMoveLengthUpdate' has a wrong offset!");
static_assert(offsetof(URCCompanionAIMove, bDebugDraw) == 0x000318, "Member 'URCCompanionAIMove::bDebugDraw' has a wrong offset!");

// Class RC.RCCompanionBFL
// 0x0000 (0x0028 - 0x0028)
class URCCompanionBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AddCharacter(class AActor* InCharacter);
	static class ARCCharacterRender* GetCharacterActor(int32 InCompanionIndex);
	static void RemoveCharacter(class AActor* InCharacter);
	static void SetCharacterVisible(bool bInVisible);
	static void SetPlayerWarp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCompanionBFL">();
	}
	static class URCCompanionBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCompanionBFL>();
	}
};
static_assert(alignof(URCCompanionBFL) == 0x000008, "Wrong alignment on URCCompanionBFL");
static_assert(sizeof(URCCompanionBFL) == 0x000028, "Wrong size on URCCompanionBFL");

// Class RC.RCPlayerCharacter
// 0x0020 (0x0980 - 0x0960)
class ARCPlayerCharacter : public ARCCharacterRender
{
public:
	uint8                                         Pad_960[0x10];                                     // 0x0960(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         lru_stairway_hold_;                                // 0x0970(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class URCCharacterAnimCtrl* GetAnimCtrl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlayerCharacter">();
	}
	static class ARCPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPlayerCharacter>();
	}
};
static_assert(alignof(ARCPlayerCharacter) == 0x000010, "Wrong alignment on ARCPlayerCharacter");
static_assert(sizeof(ARCPlayerCharacter) == 0x000980, "Wrong size on ARCPlayerCharacter");
static_assert(offsetof(ARCPlayerCharacter, lru_stairway_hold_) == 0x000970, "Member 'ARCPlayerCharacter::lru_stairway_hold_' has a wrong offset!");

// Class RC.RCScriptBFL
// 0x0000 (0x0028 - 0x0028)
class URCScriptBFL final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetValiable(class FName InVariable, int32 InArrayIndex);
	static bool JampLabel(class FName StartLabelName);
	static void SetNextLabel(class FName InLabelName);
	static void SetScriptPath(class FName InPathName);
	static void SetValiable(int32 InValue, class FName InVariable, int32 InArrayIndex);
	static bool StartScript(class FName InScriptName, class FName InLabelName);
	static bool StartScriptLineNo(class FName InScriptName, int32 InLineNo);
	static bool StartScriptWork();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCScriptBFL">();
	}
	static class URCScriptBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCScriptBFL>();
	}
};
static_assert(alignof(URCScriptBFL) == 0x000008, "Wrong alignment on URCScriptBFL");
static_assert(sizeof(URCScriptBFL) == 0x000028, "Wrong size on URCScriptBFL");

// Class RC.RCCompanionTrigger
// 0x0008 (0x0290 - 0x0288)
class ARCCompanionTrigger final : public ARCActor
{
public:
	bool                                          bVisibleCompanion;                                 // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCompanionTrigger">();
	}
	static class ARCCompanionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCompanionTrigger>();
	}
};
static_assert(alignof(ARCCompanionTrigger) == 0x000008, "Wrong alignment on ARCCompanionTrigger");
static_assert(sizeof(ARCCompanionTrigger) == 0x000290, "Wrong size on ARCCompanionTrigger");
static_assert(offsetof(ARCCompanionTrigger, bVisibleCompanion) == 0x000288, "Member 'ARCCompanionTrigger::bVisibleCompanion' has a wrong offset!");

// Class RC.RCGrassDeformer
// 0x0010 (0x0290 - 0x0280)
class ARCGrassDeformer final : public ARCGrassTransformer
{
public:
	class UCurveFloat*                            DeformCurve;                                       // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTimer;                                      // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateGrassTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassDeformer">();
	}
	static class ARCGrassDeformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassDeformer>();
	}
};
static_assert(alignof(ARCGrassDeformer) == 0x000008, "Wrong alignment on ARCGrassDeformer");
static_assert(sizeof(ARCGrassDeformer) == 0x000290, "Wrong size on ARCGrassDeformer");
static_assert(offsetof(ARCGrassDeformer, DeformCurve) == 0x000280, "Member 'ARCGrassDeformer::DeformCurve' has a wrong offset!");
static_assert(offsetof(ARCGrassDeformer, CurrentTimer) == 0x000288, "Member 'ARCGrassDeformer::CurrentTimer' has a wrong offset!");

// Class RC.RCCrescendoCameraActor
// 0x0000 (0x07C0 - 0x07C0)
class ARCCrescendoCameraActor final : public ARCCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCrescendoCameraActor">();
	}
	static class ARCCrescendoCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCrescendoCameraActor>();
	}
};
static_assert(alignof(ARCCrescendoCameraActor) == 0x000010, "Wrong alignment on ARCCrescendoCameraActor");
static_assert(sizeof(ARCCrescendoCameraActor) == 0x0007C0, "Wrong size on ARCCrescendoCameraActor");

// Class RC.SCCommandDataAsset
// 0x0010 (0x0040 - 0x0030)
class USCCommandDataAsset final : public URCCSVData
{
public:
	TArray<struct FSCScriptCommand>               Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCCommandDataAsset">();
	}
	static class USCCommandDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCCommandDataAsset>();
	}
};
static_assert(alignof(USCCommandDataAsset) == 0x000008, "Wrong alignment on USCCommandDataAsset");
static_assert(sizeof(USCCommandDataAsset) == 0x000040, "Wrong size on USCCommandDataAsset");
static_assert(offsetof(USCCommandDataAsset, Data) == 0x000030, "Member 'USCCommandDataAsset::Data' has a wrong offset!");

// Class RC.RCCrossWalkController
// 0x0058 (0x0278 - 0x0220)
class ARCCrossWalkController final : public AActor
{
public:
	float                                         Length;                                            // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         throughLength;                                     // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   crossWalkTag;                                      // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   crossWalkSwitchTag;                                // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   playerActorTag;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   signalBoxTag;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         crossWalkArray;                                    // 0x0248(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         crossWalkSwitchArray;                              // 0x0258(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         signalBoxArray;                                    // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	float GetCheckLength();
	class AActor* GetCrossWalkActor(int32 crossWalkIndex);
	float GetThroughLength();
	void Initialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCrossWalkController">();
	}
	static class ARCCrossWalkController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCrossWalkController>();
	}
};
static_assert(alignof(ARCCrossWalkController) == 0x000008, "Wrong alignment on ARCCrossWalkController");
static_assert(sizeof(ARCCrossWalkController) == 0x000278, "Wrong size on ARCCrossWalkController");
static_assert(offsetof(ARCCrossWalkController, Length) == 0x000220, "Member 'ARCCrossWalkController::Length' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, throughLength) == 0x000224, "Member 'ARCCrossWalkController::throughLength' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, crossWalkTag) == 0x000228, "Member 'ARCCrossWalkController::crossWalkTag' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, crossWalkSwitchTag) == 0x000230, "Member 'ARCCrossWalkController::crossWalkSwitchTag' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, playerActorTag) == 0x000238, "Member 'ARCCrossWalkController::playerActorTag' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, signalBoxTag) == 0x000240, "Member 'ARCCrossWalkController::signalBoxTag' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, crossWalkArray) == 0x000248, "Member 'ARCCrossWalkController::crossWalkArray' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, crossWalkSwitchArray) == 0x000258, "Member 'ARCCrossWalkController::crossWalkSwitchArray' has a wrong offset!");
static_assert(offsetof(ARCCrossWalkController, signalBoxArray) == 0x000268, "Member 'ARCCrossWalkController::signalBoxArray' has a wrong offset!");

// Class RC.RCCustomEventActor
// 0x0018 (0x02A8 - 0x0290)
class ARCCustomEventActor : public ARCBgActor
{
public:
	class FName                                   EventName;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnEvent;                                           // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FName GetEventName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCustomEventActor">();
	}
	static class ARCCustomEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCCustomEventActor>();
	}
};
static_assert(alignof(ARCCustomEventActor) == 0x000008, "Wrong alignment on ARCCustomEventActor");
static_assert(sizeof(ARCCustomEventActor) == 0x0002A8, "Wrong size on ARCCustomEventActor");
static_assert(offsetof(ARCCustomEventActor, EventName) == 0x000290, "Member 'ARCCustomEventActor::EventName' has a wrong offset!");
static_assert(offsetof(ARCCustomEventActor, OnEvent) == 0x000298, "Member 'ARCCustomEventActor::OnEvent' has a wrong offset!");

// Class RC.RCFloorTypeComponent
// 0x0010 (0x04F0 - 0x04E0)
class URCFloorTypeComponent final : public UStaticMeshComponent
{
public:
	int32                                         FloorTypeNumber;                                   // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E4[0xC];                                      // 0x04E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCFloorTypeComponent">();
	}
	static class URCFloorTypeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCFloorTypeComponent>();
	}
};
static_assert(alignof(URCFloorTypeComponent) == 0x000010, "Wrong alignment on URCFloorTypeComponent");
static_assert(sizeof(URCFloorTypeComponent) == 0x0004F0, "Wrong size on URCFloorTypeComponent");
static_assert(offsetof(URCFloorTypeComponent, FloorTypeNumber) == 0x0004E0, "Member 'URCFloorTypeComponent::FloorTypeNumber' has a wrong offset!");

// Class RC.RCUiBackLogItem
// 0x0098 (0x0370 - 0x02D8)
class URCUiBackLogItem final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x60];                                     // 0x02D8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OffCursor;                                      // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiBackLogItem">();
	}
	static class URCUiBackLogItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiBackLogItem>();
	}
};
static_assert(alignof(URCUiBackLogItem) == 0x000008, "Wrong alignment on URCUiBackLogItem");
static_assert(sizeof(URCUiBackLogItem) == 0x000370, "Wrong size on URCUiBackLogItem");
static_assert(offsetof(URCUiBackLogItem, AN_OnCursor) == 0x000338, "Member 'URCUiBackLogItem::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiBackLogItem, AN_OffCursor) == 0x000340, "Member 'URCUiBackLogItem::AN_OffCursor' has a wrong offset!");
static_assert(offsetof(URCUiBackLogItem, AN_Push) == 0x000348, "Member 'URCUiBackLogItem::AN_Push' has a wrong offset!");

// Class RC.RCCustomEventBFL
// 0x0000 (0x0028 - 0x0028)
class URCCustomEventBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool OnEventStart(class FName InActorName, class FName InEventName);
	static void OnEventStarts(const class FString& InActorName, class FName InEventName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCCustomEventBFL">();
	}
	static class URCCustomEventBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCCustomEventBFL>();
	}
};
static_assert(alignof(URCCustomEventBFL) == 0x000008, "Wrong alignment on URCCustomEventBFL");
static_assert(sizeof(URCCustomEventBFL) == 0x000028, "Wrong size on URCCustomEventBFL");

// Class RC.RCDataConversionBP
// 0x0000 (0x00B0 - 0x00B0)
class URCDataConversionBP final : public UActorComponent
{
public:
	class FString GetUTF8(const class FString& in_ansi_string);
	class FName TestPrint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDataConversionBP">();
	}
	static class URCDataConversionBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDataConversionBP>();
	}
};
static_assert(alignof(URCDataConversionBP) == 0x000008, "Wrong alignment on URCDataConversionBP");
static_assert(sizeof(URCDataConversionBP) == 0x0000B0, "Wrong size on URCDataConversionBP");

// Class RC.RCUiGenericWindow
// 0x00B0 (0x0388 - 0x02D8)
class URCUiGenericWindow : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Center_00;                                    // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Center_01;                                    // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Center_02;                                    // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Center_03;                                    // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Guide;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x58];                                     // 0x0318(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bResult)>  OnFinishEvent;                                     // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeGenericWindow();
	bool IsFinishGenericWindow();
	bool IsGetButtonResult();
	void Open(bool bInIsShowButton, bool bInIsFocusTrue, bool bInIsAcceptCancel, bool bInIsUseDefaultTextID);
	void OpenSingleButton();
	void SetButtonTextID(class FName InCancelTextID, class FName InDecideTextID);
	void SetWindowStrings(const TArray<class FString>& InStringArray);
	void SetWindowTextID(class FName InTextID);
	void SetWindowTextIDs(const TArray<class FName>& InTextIDArray);
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiGenericWindow">();
	}
	static class URCUiGenericWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiGenericWindow>();
	}
};
static_assert(alignof(URCUiGenericWindow) == 0x000008, "Wrong alignment on URCUiGenericWindow");
static_assert(sizeof(URCUiGenericWindow) == 0x000388, "Wrong size on URCUiGenericWindow");
static_assert(offsetof(URCUiGenericWindow, AN_Start) == 0x0002D8, "Member 'URCUiGenericWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, AN_Wait) == 0x0002E0, "Member 'URCUiGenericWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, AN_Finish) == 0x0002E8, "Member 'URCUiGenericWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, Text_Center_00) == 0x0002F0, "Member 'URCUiGenericWindow::Text_Center_00' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, Text_Center_01) == 0x0002F8, "Member 'URCUiGenericWindow::Text_Center_01' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, Text_Center_02) == 0x000300, "Member 'URCUiGenericWindow::Text_Center_02' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, Text_Center_03) == 0x000308, "Member 'URCUiGenericWindow::Text_Center_03' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, Text_Guide) == 0x000310, "Member 'URCUiGenericWindow::Text_Guide' has a wrong offset!");
static_assert(offsetof(URCUiGenericWindow, OnFinishEvent) == 0x000370, "Member 'URCUiGenericWindow::OnFinishEvent' has a wrong offset!");

// Class RC.RCDebugAutoMoveBFL
// 0x0000 (0x0028 - 0x0028)
class URCDebugAutoMoveBFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoMoveBFL">();
	}
	static class URCDebugAutoMoveBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoMoveBFL>();
	}
};
static_assert(alignof(URCDebugAutoMoveBFL) == 0x000008, "Wrong alignment on URCDebugAutoMoveBFL");
static_assert(sizeof(URCDebugAutoMoveBFL) == 0x000028, "Wrong size on URCDebugAutoMoveBFL");

// Class RC.RCDebugAutoMoveCell
// 0x0020 (0x0048 - 0x0028)
class URCDebugAutoMoveCell final : public UObject
{
public:
	struct FVector                                Position;                                          // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MoveCount;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCEventActorInfo>              ActorList;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoMoveCell">();
	}
	static class URCDebugAutoMoveCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoMoveCell>();
	}
};
static_assert(alignof(URCDebugAutoMoveCell) == 0x000008, "Wrong alignment on URCDebugAutoMoveCell");
static_assert(sizeof(URCDebugAutoMoveCell) == 0x000048, "Wrong size on URCDebugAutoMoveCell");
static_assert(offsetof(URCDebugAutoMoveCell, Position) == 0x000028, "Member 'URCDebugAutoMoveCell::Position' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveCell, MoveCount) == 0x000034, "Member 'URCDebugAutoMoveCell::MoveCount' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveCell, ActorList) == 0x000038, "Member 'URCDebugAutoMoveCell::ActorList' has a wrong offset!");

// Class RC.RCNzCriminalMain
// 0x0058 (0x0330 - 0x02D8)
class URCNzCriminalMain final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x38];                                     // 0x02F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSubtitles;                                        // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalMain">();
	}
	static class URCNzCriminalMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalMain>();
	}
};
static_assert(alignof(URCNzCriminalMain) == 0x000008, "Wrong alignment on URCNzCriminalMain");
static_assert(sizeof(URCNzCriminalMain) == 0x000330, "Wrong size on URCNzCriminalMain");
static_assert(offsetof(URCNzCriminalMain, AN_Start) == 0x0002D8, "Member 'URCNzCriminalMain::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzCriminalMain, AN_Wait) == 0x0002E0, "Member 'URCNzCriminalMain::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzCriminalMain, AN_Finish) == 0x0002E8, "Member 'URCNzCriminalMain::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzCriminalMain, bSubtitles) == 0x000328, "Member 'URCNzCriminalMain::bSubtitles' has a wrong offset!");

// Class RC.RCShinigamiAIAction
// 0x0090 (0x00B8 - 0x0028)
class URCShinigamiAIAction final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIComponent*                ParentComponent;                                   // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIFollow*                   AIFollow;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCShinigamiAICommandTrigger*           AiCommandTrigger;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCTargetPoint*                         TargetPoint;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetMoveSpeedMagnification;                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiWarpType                          TargetMoveWarpType;                                // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCLevelSequenceActor*                  LevelSequenceActor;                                // 0x0070(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlaySequencerLoopNum;                              // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayFollow;                                       // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TalkDataTable;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartTalkID;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTalkDelayAtEnd;                               // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTalkDelayToNext;                              // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayTalkID;                                        // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayTalkDelayAtEnd;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayTalkDelayToNext;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStatusInit;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStatusTalkInit;                                   // 0x00A9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayTime;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIAction">();
	}
	static class URCShinigamiAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAIAction>();
	}
};
static_assert(alignof(URCShinigamiAIAction) == 0x000008, "Wrong alignment on URCShinigamiAIAction");
static_assert(sizeof(URCShinigamiAIAction) == 0x0000B8, "Wrong size on URCShinigamiAIAction");
static_assert(offsetof(URCShinigamiAIAction, ShinigamiActor) == 0x000038, "Member 'URCShinigamiAIAction::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, ParentComponent) == 0x000040, "Member 'URCShinigamiAIAction::ParentComponent' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, Movement) == 0x000048, "Member 'URCShinigamiAIAction::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, AIFollow) == 0x000050, "Member 'URCShinigamiAIAction::AIFollow' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, AiCommandTrigger) == 0x000058, "Member 'URCShinigamiAIAction::AiCommandTrigger' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, TargetPoint) == 0x000060, "Member 'URCShinigamiAIAction::TargetPoint' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, TargetMoveSpeedMagnification) == 0x000068, "Member 'URCShinigamiAIAction::TargetMoveSpeedMagnification' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, TargetMoveWarpType) == 0x00006C, "Member 'URCShinigamiAIAction::TargetMoveWarpType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, LevelSequenceActor) == 0x000070, "Member 'URCShinigamiAIAction::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, PlaySequencerLoopNum) == 0x000078, "Member 'URCShinigamiAIAction::PlaySequencerLoopNum' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, bPlayFollow) == 0x00007C, "Member 'URCShinigamiAIAction::bPlayFollow' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, TalkDataTable) == 0x000080, "Member 'URCShinigamiAIAction::TalkDataTable' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, StartTalkID) == 0x000088, "Member 'URCShinigamiAIAction::StartTalkID' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, StartTalkDelayAtEnd) == 0x000090, "Member 'URCShinigamiAIAction::StartTalkDelayAtEnd' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, StartTalkDelayToNext) == 0x000094, "Member 'URCShinigamiAIAction::StartTalkDelayToNext' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, PlayTalkID) == 0x000098, "Member 'URCShinigamiAIAction::PlayTalkID' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, PlayTalkDelayAtEnd) == 0x0000A0, "Member 'URCShinigamiAIAction::PlayTalkDelayAtEnd' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, PlayTalkDelayToNext) == 0x0000A4, "Member 'URCShinigamiAIAction::PlayTalkDelayToNext' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, bStatusInit) == 0x0000A8, "Member 'URCShinigamiAIAction::bStatusInit' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, bStatusTalkInit) == 0x0000A9, "Member 'URCShinigamiAIAction::bStatusTalkInit' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, PlayTime) == 0x0000AC, "Member 'URCShinigamiAIAction::PlayTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIAction, bDebugDraw) == 0x0000B0, "Member 'URCShinigamiAIAction::bDebugDraw' has a wrong offset!");

// Class RC.RCDebugAutoMoveManager
// 0x0020 (0x0048 - 0x0028)
class URCDebugAutoMoveManager final : public UObject
{
public:
	TArray<class URCDebugAutoMoveMap*>            AutoMoveMapList;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class URCDebugAutoMoveMap*                    NowMapInfo;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMoveEnable;                                       // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoMoveManager">();
	}
	static class URCDebugAutoMoveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoMoveManager>();
	}
};
static_assert(alignof(URCDebugAutoMoveManager) == 0x000008, "Wrong alignment on URCDebugAutoMoveManager");
static_assert(sizeof(URCDebugAutoMoveManager) == 0x000048, "Wrong size on URCDebugAutoMoveManager");
static_assert(offsetof(URCDebugAutoMoveManager, AutoMoveMapList) == 0x000028, "Member 'URCDebugAutoMoveManager::AutoMoveMapList' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveManager, NowMapInfo) == 0x000038, "Member 'URCDebugAutoMoveManager::NowMapInfo' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveManager, bMoveEnable) == 0x000040, "Member 'URCDebugAutoMoveManager::bMoveEnable' has a wrong offset!");

// Class RC.RCNazoBattleLevelScriptActor
// 0x1228 (0x1450 - 0x0228)
class ARCNazoBattleLevelScriptActor final : public ALevelScriptActor
{
public:
	bool                                          bInitialized;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ERCNazoBattleLSAState                         State;                                             // 0x022C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCNazoLevelScriptActor*                NazoLSA;                                           // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimerHandle>                   DelayTimerHandleArray;                             // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SlowAndCameraShakeTimerHandle;                     // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CameraShakeSClass;                                 // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 CameraShakeMClass;                                 // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 CameraShakeLClass;                                 // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BattleSettingsDataTable;                           // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BattleSettingsKey;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RebuttalGroupSettingsDataTable;                    // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RebuttalLetterDataTable;                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DisturbLetterDataTable;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AssistParameterDataTable;                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoadRequestPathArray;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoadingPathArray;                                  // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoadedPathArray;                                   // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleSettings                  BattleSettings;                                    // 0x02E8(0x0318)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	ERCNazoBattleLSAPhases                        Phase;                                             // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayingVoiceID;                                    // 0x0604(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleSkipSpeedRate;                               // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputEnable;                                      // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNazoBattleLSAPlayerData             PlayerData;                                        // 0x0618(0x0210)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerAttackCollisionAtacchedSword;               // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_831[0x3];                                      // 0x0831(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerSwordCollisionSize;                          // 0x0834(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PlayerSwordCollisionOffset;                        // 0x0840(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNazoBattleLSAPlayerAttackCollisionSettings PlayerRebuttalSlashCollisionSettings;              // 0x0850(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAPlayerAttackCollisionSettings PlayerRepelCollisionSettings;                      // 0x0890(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCNazoBattleLSAPlayerAttackCollisionSettings> PlayerDisturbSlashCollisionSettingsArray;          // 0x08D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAPlayerAttackCollisionSettings PlayerAvoidanceSlashLCollisionSettings;            // 0x08E0(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAPlayerAttackCollisionSettings PlayerAvoidanceSlashRCollisionSettings;            // 0x0920(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCNazoBattleLSAPlayerAttackCollisionSettings> PlayerJumpSlashCollisionSettingsArray;             // 0x0960(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCNazoBattleLSAPlayerAttackCollisionSettings> PlayerCrouchSlashCollisionSettingsArray;           // 0x0970(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSlashPlayRate;                         // 0x0980(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSlashInputDisableTime;                 // 0x0984(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSlashCollisionEnableDelayTime;         // 0x0988(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackHitDelayTime;                          // 0x098C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessSlashRaedyPlayRate;             // 0x0990(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessCutinDelayTime;                 // 0x0994(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_998[0x8];                                      // 0x0998(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerAttackSuccessCutinTime;                      // 0x09A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessCancelKaijinMoveDelayTime;      // 0x09A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessSlowGameSpeed;                  // 0x09A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessSlowTime;                       // 0x09AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessReturnGameSpeedTime;            // 0x09B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B4[0x8];                                      // 0x09B4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerAttackSuccessChangeCameraDelayTime;          // 0x09BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessKaijinDamageDelayTime;          // 0x09C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackSuccessClearDelayTime;                 // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureRepelDelayTime;                 // 0x09C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureRepelPlayRate;                  // 0x09CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureSlowDelayTime;                  // 0x09D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureSlowSpeed;                      // 0x09D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureSlowTime;                       // 0x09D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackFailureEventDelayTime;                 // 0x09DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackRepelPlayRate;                         // 0x09E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackRepelInputDisableTime;                 // 0x09E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAttackRepelCollisionEnableDelayTime;         // 0x09E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRepelSuccessLetterSpeed;                     // 0x09EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRepelSuccessHitstopDelayTime;                // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRepelSuccessGameSpeed;                       // 0x09F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRepelSuccessCutinDelayTime;                  // 0x09F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9FC[0x8];                                      // 0x09FC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerRepelSuccessCutinTime;                       // 0x0A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRepelSuccessHitKaijinSEVolumeRate_FinalBattle; // 0x0A08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDisturbSlashPlayRate;                        // 0x0A0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDisturbSlashInputDisableTime;                // 0x0A10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDisturbSlashCollisionEnableDelayTime;        // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerDisturbSlashContinuousCountMax;              // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDisturbSlashContinuousAttackEnableDelayTime; // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDisturbSlashContinuousAttackEnableTime;      // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveLTime;                                   // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveRTime;                                   // 0x0A28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveLInputDisableTime;                       // 0x0A2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveRInputDisableTime;                       // 0x0A30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayerMoveLCurvePath;                              // 0x0A34(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayerMoveRCurvePath;                              // 0x0A3C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAvoidanceAttackEnableDelayTime;              // 0x0A44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAvoidanceAttackEnableTime;                   // 0x0A48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAvoidanceAttackTime;                         // 0x0A4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAvoidanceAttackInputDisableTime;             // 0x0A50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJumpRiseTime;                                // 0x0A54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJumpDistance;                                // 0x0A58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJumpContinuousAttackEnableDelayTime;         // 0x0A5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJumpContinuousAttackEnableTime;              // 0x0A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveUInputDisableTime;                       // 0x0A64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayerJumpCurvePath;                               // 0x0A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerCrouchContinuousAttackEnableDelayTime;       // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerCrouchContinuousAttackEnableDelayTime_StartLoop; // 0x0A74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerCrouchContinuousAttackEnableTime;            // 0x0A78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMoveDInputDisableTime;                       // 0x0A7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerJustAvoidCollisionFixedSizeFlag;            // 0x0A80(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A81[0x3];                                      // 0x0A81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerJustAvoidCollisionFixedSize;                 // 0x0A84(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJustAvoidCollisionSizeRate;                  // 0x0A90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJustAvoidUnrivalTimeU;                       // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJustAvoidUnrivalTimeD;                       // 0x0A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJustAvoidUnrivalTimeL;                       // 0x0A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerJustAvoidUnrivalTimeR;                       // 0x0AA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerUnrivalEffectColorLerpFlag;                 // 0x0AA4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA5[0x3];                                      // 0x0AA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerUnrivalEffectColorA;                         // 0x0AA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerUnrivalEffectColorB;                         // 0x0AAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerUnrivalEffectColorC;                         // 0x0AB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerUnrivalEffectRestTimeToColorB;               // 0x0AB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerUnrivalEffectRestTimeToColorC;               // 0x0AB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerUnrivalShortenJingleTime;                    // 0x0ABC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDamageInputDisableTime;                      // 0x0AC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC4[0x4];                                      // 0x0AC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PlayerDamageReductionRateArrayByContinueCount;     // 0x0AC8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD8[0x110];                                    // 0x0AD8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerSkillRebLetSpeedDownApplyAcc;               // 0x0BE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerSkillRebLetSpeedDownApplyIntervalTime;      // 0x0BE9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerSkillRebLetSpeedDownApplyDisturbLetter;     // 0x0BEA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BEB[0x25];                                     // 0x0BEB(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           PlayerDamageAirTimerHandle;                        // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAShinigamiData          ShinigamiData;                                     // 0x0C18(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAAssistData             AssistData;                                        // 0x0C38(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoBattleLSAKaijinGroupData        KaijinGroupData;                                   // 0x0CC0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D28[0xC];                                      // 0x0D28(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KaijinAttackMotionInLengthDefault;                 // 0x0D34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaijinWaitTimeAfterVoiceAndMotionEnd;              // 0x0D38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D3C[0x3C];                                     // 0x0D3C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNazoBattleLSACameraData             CameraData;                                        // 0x0D78(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bRebuttalCameraUseFocusLocationOffset;             // 0x0E78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E79[0x7];                                      // 0x0E79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCNazoBattleRebuttalGroupSettings> RebuttalGroupSettingsArray;                        // 0x0E80(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E90[0x50];                                     // 0x0E90(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RebuttalGroupCurrentIndex;                         // 0x0EE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalGroupCurrentNo;                            // 0x0EE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalGroupCurrentFirstChallenge;               // 0x0EE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE9[0xF];                                      // 0x0EE9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RebuttalCurrentIndex;                              // 0x0EF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalCurrentNo;                                 // 0x0EFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RebuttalCurrentKaiKagiID;                          // 0x0F00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RebuttalSelectableKaiKagiIDArray;                  // 0x0F08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           RebuttalDeleteKaiKagiIDArray;                      // 0x0F18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	ERCNazoBattleRebuttalLetterPosition           LastRebuttalLetterPosition;                        // 0x0F28(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastRebuttalLetterLeft;                           // 0x0F29(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2A[0x6];                                      // 0x0F2A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCNazoBattleLSARebuttalData>   RebuttalDataArray;                                 // 0x0F30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 RebuttalDataStartIndexArray;                       // 0x0F40(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 RebuttalDataEndIndexArray;                         // 0x0F50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         RebuttalDataCurrentStartIndex;                     // 0x0F60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalDataCurrentEndIndex;                       // 0x0F64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalDataCurrentNum;                            // 0x0F68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalPaused;                                   // 0x0F6C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalInputEnable;                              // 0x0F6D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F6E[0x2];                                      // 0x0F6E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RebuttalInputDisableTimerHandle;                   // 0x0F70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 RebuttalGroupJustAvoidCountArray;                  // 0x0F78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentRebuttalGroupJustAvoidCount;                // 0x0F88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8C[0x4];                                      // 0x0F8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RebuttalGroupDisturbSlashPointArray;               // 0x0F90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentRebuttalGroupDisturbSlashPoint;             // 0x0FA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalIndexAtAttack;                             // 0x0FA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RebuttalNoAtAttack;                                // 0x0FA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalKaijinCutin;                              // 0x0FAC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalGroupCleared;                             // 0x0FAD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalGroupFailed;                              // 0x0FAE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCNazoBattleLSARebuttalAttackFailureType     RebuttalAttackFailureType;                         // 0x0FAF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RebuttalAttackTalkID;                              // 0x0FB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalCloseContestSuccess;                      // 0x0FB8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB9[0x3];                                      // 0x0FB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RebuttalNoAtGameOver;                              // 0x0FBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RebuttalGameOverHintText;                          // 0x0FC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalGroupFinished;                            // 0x0FC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC9[0x3];                                      // 0x0FC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RebuttalIndexAtRebuttalFinished;                   // 0x0FCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD0[0x11];                                     // 0x0FD0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanAttackRebuttalLetterIfDisturbLetterExist;      // 0x0FE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE2[0x82];                                     // 0x0FE2(0x0082)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RebuttalLetterAttackLineEffectLifeTime;            // 0x1064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1068[0xB8];                                    // 0x1068(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNazoBattleRebuttalLetterAssets      RebuttalLetterAssets;                              // 0x1120(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNazoBattleRebuttalLetter*>    RebuttalLetterArray;                               // 0x11C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterDistanceToPlayer;                    // 0x11D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterOutDistance;                         // 0x11D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RebuttalLetterShadowColor;                         // 0x11D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeW;                         // 0x11E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeW_ZH;                      // 0x11EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeMax;                       // 0x11F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeMin;                       // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeMax_ZH;                    // 0x11F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RebuttalLetterAutoResizeMin_ZH;                    // 0x11FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalLetterHitCollisionVisibility;             // 0x1200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalLetterJustAvoidCollisionVisibility;       // 0x1201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1202[0x6];                                     // 0x1202(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCNazoBattleRebuttalLetter*>    UnusedRebuttalLetterArray;                         // 0x1208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x1];                                     // 0x1218(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanAttackDisturbLettersAtOnce;                    // 0x1219(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121A[0x8E];                                    // 0x121A(0x008E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNazoBattleDisturbLetterAssets       DisturbLetterAssets;                               // 0x12A8(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNazoBattleDisturbLetter*>     DisturbLetterArray;                                // 0x1358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         RebuttalIndexAtAttackDisturbLetter;                // 0x1368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisturbIndexAtAttackDisturbLetter;                 // 0x136C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisturbLetterVoiceVolumeRate;                      // 0x1370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1374[0x4];                                     // 0x1374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCNazoBattleDisturbLetter*>     UnusedDisturbLetterArray;                          // 0x1378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              DisplaceVolume;                                    // 0x1388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1390[0x10];                                    // 0x1390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleStart*                     BattleStartWidget;                                 // 0x13A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A8[0x10];                                    // 0x13A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleUi*                        BattleUIWidget;                                    // 0x13B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C0[0x20];                                    // 0x13C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleKaiKagiList*               KaiKagiListWidget;                                 // 0x13E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E8[0x10];                                    // 0x13E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleKaiKagiSelect*             KaiKagiSelectWidget;                               // 0x13F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1400[0x10];                                    // 0x1400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiAssistCutin*                     AssistCutinWidget;                                 // 0x1410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1418[0x38];                                    // 0x1418(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssistCutin_Start();
	void AssistPlayAnim(class FName InMotionName, float InPlayRate, bool bInLoop, float InBlendTime);
	void AttackFailure_Start(int32 RebuttalGroupNo, int32 RebuttalNo, ERCNazoBattleLSARebuttalAttackFailureType FailureType, class FName TalkID);
	void AttackSuccess_Start(int32 RebuttalGroupNo, int32 RebuttalNo, class FName TalkID);
	void BattleAllRebuttalLetterForceFinish();
	void BattleRebuttalResetPosition();
	bool BattleStartUI_IsFinished();
	bool BattleStartUI_Start();
	void BattleSubTitleSwitch();
	void BattleUI_ChangeKaiKagi(class FName InKaiKagiID);
	void BattleUI_Finish();
	void BattleUI_SetKaiKagiID(class FName InKaiKagiID);
	void BattleUI_Start(bool bInOpenKaiKagi, bool bInOpenPlayerHP);
	void ChangeCamera(class ACameraActor* Camera, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangeCameraFromTag(class FName CameraTag, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void ChangePhaseEvent(ERCNazoBattleLSAPhases BattlePhase);
	void ChangeStateEvent(ERCNazoBattleLSAState BattleState);
	void ClearEvent_Start(class FName TalkID, const TArray<class FName>& TalkIDArray);
	void CloseContest_End(bool bSuccess);
	void CloseContest_Start(int32 RebuttalGroupNo, int32 RebuttalNo, float InputTime, int32 InputCount, int32 FailureDamage);
	void Confrontation_Start(int32 RebuttalGroupNo, bool bFirstChallenge, class FName TalkID);
	void DebugSetDrawHUD(bool bInDraw);
	void DisturbLetterOnAttackDisable(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnAttackEnable(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnDamage(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnFinished(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnHit(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnOut(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnRepelled(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void DisturbLetterOnSlashed(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData);
	void EndPhase();
	void GameOver_Start(int32 RebuttalGroupNo, int32 RebuttalNo, class FName TalkID, class FName HintTextId);
	TArray<struct FRCNazoBattleLSARebuttalData> GetActiveRebuttalDataArray();
	ERCNazoBattleLSARebuttalAttackFailureType GetRebuttalAttackFailureType();
	class FName GetRebuttalAttackTalkID();
	class FName GetRebuttalClearEventTalkID();
	TArray<class FName> GetRebuttalClearEventTalkIDArray();
	int32 GetRebuttalCloseContestFailureDamage();
	int32 GetRebuttalCloseContestInputCount();
	float GetRebuttalCloseContestInputTime();
	class FName GetRebuttalConfrontationTalkID();
	class FName GetRebuttalGameOverHintTextID();
	class FName GetRebuttalGameOverTalkID();
	bool GetRebuttalGroupCurrentFirstChallenge();
	int32 GetRebuttalGroupCurrentNo();
	class FName GetRebuttalIntervalTalkID();
	class FName GetRebuttalNextRebuttalEventTalkID();
	int32 GetRebuttalNoAtAttack();
	int32 GetRebuttalNoAtGameOver();
	class FName GetRebuttalPreEventTalkID();
	bool GetUseSpawnLetter();
	void Interval_Start(int32 RebuttalGroupNo, class FName TalkID);
	bool IsInitialized();
	void KaijinPlayAnim(class FName InKaijinTag, class FName InMotionName, float InPlayRate, bool bInLoop, float InBlendTime);
	void KaijinPlayLoopAnim(class FName InKaijinTag, class FName InMotionName, float InPlayRate, float InBlendTime);
	void KaijinPlayOneShotAnim(class FName InKaijinTag, class FName InMotionName, float InPlayRate, float InBlendTime);
	void KaiKagiList_Finished();
	bool KaiKagiList_Start();
	void KaiKagiSelect_Decide(int32 SelectIndex);
	void KaiKagiSelect_Finished(int32 SelectIndex);
	bool KaiKagiSelect_Start();
	void KaiKagiSwitch_Next();
	void KaiKagiSwitch_Prev();
	void NextRebuttalEvent_Start(int32 RebuttalGroupNo, class FName TalkID);
	bool PlayerDamage(int32 InDamage, class FName InMotionName);
	void PlayerOnDamage(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void PlayerPlayAnim(class FName InMotionName, float InPlayRate, bool bInLoop, float InBlendTime, bool bInStartLoopMotion);
	void PlayerPlayLoopAnim(class FName InMotionName, float InPlayRate, float InBlendTime, bool bInStartLoopMotion);
	void PlayerPlayOneShotAnim(class FName InMotionName, float InPlayRate, float InBlendTime);
	void PreEvent_Start(class FName TalkID);
	void RebuttalKaijinCutin_Finish();
	void RebuttalKaijinCutin_Start(int32 RebuttalGroupNo, int32 RebuttalNo);
	void RebuttalKaikagiList_Finished(int32 RebuttalGroupNo);
	void RebuttalLetterOnAttackDisable(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnAttackEnable(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnFinished(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnHit(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnJustAvoidDisable(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnJustAvoidEnable(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnOut(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnRepelled(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnRepelledHitKaijin(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnRepelledPreventedByKaijin(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnSlashed(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void RebuttalLetterOnSlashStopped(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData);
	void SetBattleInputEnable(bool bInInputEnable);
	void SetRebuttalLetterCollisionVisibility(bool bInHitCollisionVisibility, bool bInJustAvoidCollisionVisibility);
	void SetUseSpawnLetter(bool bInUseSpawnLetter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoBattleLevelScriptActor">();
	}
	static class ARCNazoBattleLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoBattleLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoBattleLevelScriptActor) == 0x000010, "Wrong alignment on ARCNazoBattleLevelScriptActor");
static_assert(sizeof(ARCNazoBattleLevelScriptActor) == 0x001450, "Wrong size on ARCNazoBattleLevelScriptActor");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bInitialized) == 0x000228, "Member 'ARCNazoBattleLevelScriptActor::bInitialized' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, State) == 0x00022C, "Member 'ARCNazoBattleLevelScriptActor::State' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, NazoLSA) == 0x000230, "Member 'ARCNazoBattleLevelScriptActor::NazoLSA' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DelayTimerHandleArray) == 0x000240, "Member 'ARCNazoBattleLevelScriptActor::DelayTimerHandleArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, SlowAndCameraShakeTimerHandle) == 0x000250, "Member 'ARCNazoBattleLevelScriptActor::SlowAndCameraShakeTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CameraShakeSClass) == 0x000270, "Member 'ARCNazoBattleLevelScriptActor::CameraShakeSClass' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CameraShakeMClass) == 0x000278, "Member 'ARCNazoBattleLevelScriptActor::CameraShakeMClass' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CameraShakeLClass) == 0x000280, "Member 'ARCNazoBattleLevelScriptActor::CameraShakeLClass' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleSettingsDataTable) == 0x000288, "Member 'ARCNazoBattleLevelScriptActor::BattleSettingsDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleSettingsKey) == 0x000290, "Member 'ARCNazoBattleLevelScriptActor::BattleSettingsKey' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupSettingsDataTable) == 0x000298, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupSettingsDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterDataTable) == 0x0002A0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisturbLetterDataTable) == 0x0002A8, "Member 'ARCNazoBattleLevelScriptActor::DisturbLetterDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, AssistParameterDataTable) == 0x0002B0, "Member 'ARCNazoBattleLevelScriptActor::AssistParameterDataTable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, LoadRequestPathArray) == 0x0002B8, "Member 'ARCNazoBattleLevelScriptActor::LoadRequestPathArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, LoadingPathArray) == 0x0002C8, "Member 'ARCNazoBattleLevelScriptActor::LoadingPathArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, LoadedPathArray) == 0x0002D8, "Member 'ARCNazoBattleLevelScriptActor::LoadedPathArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleSettings) == 0x0002E8, "Member 'ARCNazoBattleLevelScriptActor::BattleSettings' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, Phase) == 0x000600, "Member 'ARCNazoBattleLevelScriptActor::Phase' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayingVoiceID) == 0x000604, "Member 'ARCNazoBattleLevelScriptActor::PlayingVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleSkipSpeedRate) == 0x00060C, "Member 'ARCNazoBattleLevelScriptActor::BattleSkipSpeedRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bInputEnable) == 0x000610, "Member 'ARCNazoBattleLevelScriptActor::bInputEnable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerData) == 0x000618, "Member 'ARCNazoBattleLevelScriptActor::PlayerData' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerAttackCollisionAtacchedSword) == 0x000830, "Member 'ARCNazoBattleLevelScriptActor::bPlayerAttackCollisionAtacchedSword' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerSwordCollisionSize) == 0x000834, "Member 'ARCNazoBattleLevelScriptActor::PlayerSwordCollisionSize' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerSwordCollisionOffset) == 0x000840, "Member 'ARCNazoBattleLevelScriptActor::PlayerSwordCollisionOffset' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRebuttalSlashCollisionSettings) == 0x000850, "Member 'ARCNazoBattleLevelScriptActor::PlayerRebuttalSlashCollisionSettings' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelCollisionSettings) == 0x000890, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelCollisionSettings' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashCollisionSettingsArray) == 0x0008D0, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashCollisionSettingsArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceSlashLCollisionSettings) == 0x0008E0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceSlashLCollisionSettings' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceSlashRCollisionSettings) == 0x000920, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceSlashRCollisionSettings' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpSlashCollisionSettingsArray) == 0x000960, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpSlashCollisionSettingsArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerCrouchSlashCollisionSettingsArray) == 0x000970, "Member 'ARCNazoBattleLevelScriptActor::PlayerCrouchSlashCollisionSettingsArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSlashPlayRate) == 0x000980, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSlashPlayRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSlashInputDisableTime) == 0x000984, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSlashInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSlashCollisionEnableDelayTime) == 0x000988, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSlashCollisionEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackHitDelayTime) == 0x00098C, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackHitDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessSlashRaedyPlayRate) == 0x000990, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessSlashRaedyPlayRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessCutinDelayTime) == 0x000994, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessCutinDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessCutinTime) == 0x0009A0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessCutinTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessCancelKaijinMoveDelayTime) == 0x0009A4, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessCancelKaijinMoveDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessSlowGameSpeed) == 0x0009A8, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessSlowGameSpeed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessSlowTime) == 0x0009AC, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessSlowTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessReturnGameSpeedTime) == 0x0009B0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessReturnGameSpeedTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessChangeCameraDelayTime) == 0x0009BC, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessChangeCameraDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessKaijinDamageDelayTime) == 0x0009C0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessKaijinDamageDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackSuccessClearDelayTime) == 0x0009C4, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackSuccessClearDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureRepelDelayTime) == 0x0009C8, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureRepelDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureRepelPlayRate) == 0x0009CC, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureRepelPlayRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureSlowDelayTime) == 0x0009D0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureSlowDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureSlowSpeed) == 0x0009D4, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureSlowSpeed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureSlowTime) == 0x0009D8, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureSlowTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackFailureEventDelayTime) == 0x0009DC, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackFailureEventDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackRepelPlayRate) == 0x0009E0, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackRepelPlayRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackRepelInputDisableTime) == 0x0009E4, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackRepelInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAttackRepelCollisionEnableDelayTime) == 0x0009E8, "Member 'ARCNazoBattleLevelScriptActor::PlayerAttackRepelCollisionEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessLetterSpeed) == 0x0009EC, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessLetterSpeed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessHitstopDelayTime) == 0x0009F0, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessHitstopDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessGameSpeed) == 0x0009F4, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessGameSpeed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessCutinDelayTime) == 0x0009F8, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessCutinDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessCutinTime) == 0x000A04, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessCutinTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerRepelSuccessHitKaijinSEVolumeRate_FinalBattle) == 0x000A08, "Member 'ARCNazoBattleLevelScriptActor::PlayerRepelSuccessHitKaijinSEVolumeRate_FinalBattle' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashPlayRate) == 0x000A0C, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashPlayRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashInputDisableTime) == 0x000A10, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashCollisionEnableDelayTime) == 0x000A14, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashCollisionEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashContinuousCountMax) == 0x000A18, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashContinuousCountMax' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashContinuousAttackEnableDelayTime) == 0x000A1C, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashContinuousAttackEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDisturbSlashContinuousAttackEnableTime) == 0x000A20, "Member 'ARCNazoBattleLevelScriptActor::PlayerDisturbSlashContinuousAttackEnableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveLTime) == 0x000A24, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveLTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveRTime) == 0x000A28, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveRTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveLInputDisableTime) == 0x000A2C, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveLInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveRInputDisableTime) == 0x000A30, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveRInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveLCurvePath) == 0x000A34, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveLCurvePath' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveRCurvePath) == 0x000A3C, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveRCurvePath' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceAttackEnableDelayTime) == 0x000A44, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceAttackEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceAttackEnableTime) == 0x000A48, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceAttackEnableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceAttackTime) == 0x000A4C, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceAttackTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerAvoidanceAttackInputDisableTime) == 0x000A50, "Member 'ARCNazoBattleLevelScriptActor::PlayerAvoidanceAttackInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpRiseTime) == 0x000A54, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpRiseTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpDistance) == 0x000A58, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpDistance' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpContinuousAttackEnableDelayTime) == 0x000A5C, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpContinuousAttackEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpContinuousAttackEnableTime) == 0x000A60, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpContinuousAttackEnableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveUInputDisableTime) == 0x000A64, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveUInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJumpCurvePath) == 0x000A68, "Member 'ARCNazoBattleLevelScriptActor::PlayerJumpCurvePath' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerCrouchContinuousAttackEnableDelayTime) == 0x000A70, "Member 'ARCNazoBattleLevelScriptActor::PlayerCrouchContinuousAttackEnableDelayTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerCrouchContinuousAttackEnableDelayTime_StartLoop) == 0x000A74, "Member 'ARCNazoBattleLevelScriptActor::PlayerCrouchContinuousAttackEnableDelayTime_StartLoop' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerCrouchContinuousAttackEnableTime) == 0x000A78, "Member 'ARCNazoBattleLevelScriptActor::PlayerCrouchContinuousAttackEnableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerMoveDInputDisableTime) == 0x000A7C, "Member 'ARCNazoBattleLevelScriptActor::PlayerMoveDInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerJustAvoidCollisionFixedSizeFlag) == 0x000A80, "Member 'ARCNazoBattleLevelScriptActor::bPlayerJustAvoidCollisionFixedSizeFlag' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidCollisionFixedSize) == 0x000A84, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidCollisionFixedSize' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidCollisionSizeRate) == 0x000A90, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidCollisionSizeRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidUnrivalTimeU) == 0x000A94, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidUnrivalTimeU' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidUnrivalTimeD) == 0x000A98, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidUnrivalTimeD' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidUnrivalTimeL) == 0x000A9C, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidUnrivalTimeL' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerJustAvoidUnrivalTimeR) == 0x000AA0, "Member 'ARCNazoBattleLevelScriptActor::PlayerJustAvoidUnrivalTimeR' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerUnrivalEffectColorLerpFlag) == 0x000AA4, "Member 'ARCNazoBattleLevelScriptActor::bPlayerUnrivalEffectColorLerpFlag' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalEffectColorA) == 0x000AA8, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalEffectColorA' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalEffectColorB) == 0x000AAC, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalEffectColorB' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalEffectColorC) == 0x000AB0, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalEffectColorC' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalEffectRestTimeToColorB) == 0x000AB4, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalEffectRestTimeToColorB' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalEffectRestTimeToColorC) == 0x000AB8, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalEffectRestTimeToColorC' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerUnrivalShortenJingleTime) == 0x000ABC, "Member 'ARCNazoBattleLevelScriptActor::PlayerUnrivalShortenJingleTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDamageInputDisableTime) == 0x000AC0, "Member 'ARCNazoBattleLevelScriptActor::PlayerDamageInputDisableTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDamageReductionRateArrayByContinueCount) == 0x000AC8, "Member 'ARCNazoBattleLevelScriptActor::PlayerDamageReductionRateArrayByContinueCount' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerSkillRebLetSpeedDownApplyAcc) == 0x000BE8, "Member 'ARCNazoBattleLevelScriptActor::bPlayerSkillRebLetSpeedDownApplyAcc' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerSkillRebLetSpeedDownApplyIntervalTime) == 0x000BE9, "Member 'ARCNazoBattleLevelScriptActor::bPlayerSkillRebLetSpeedDownApplyIntervalTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bPlayerSkillRebLetSpeedDownApplyDisturbLetter) == 0x000BEA, "Member 'ARCNazoBattleLevelScriptActor::bPlayerSkillRebLetSpeedDownApplyDisturbLetter' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, PlayerDamageAirTimerHandle) == 0x000C10, "Member 'ARCNazoBattleLevelScriptActor::PlayerDamageAirTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, ShinigamiData) == 0x000C18, "Member 'ARCNazoBattleLevelScriptActor::ShinigamiData' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, AssistData) == 0x000C38, "Member 'ARCNazoBattleLevelScriptActor::AssistData' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, KaijinGroupData) == 0x000CC0, "Member 'ARCNazoBattleLevelScriptActor::KaijinGroupData' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, KaijinAttackMotionInLengthDefault) == 0x000D34, "Member 'ARCNazoBattleLevelScriptActor::KaijinAttackMotionInLengthDefault' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, KaijinWaitTimeAfterVoiceAndMotionEnd) == 0x000D38, "Member 'ARCNazoBattleLevelScriptActor::KaijinWaitTimeAfterVoiceAndMotionEnd' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CameraData) == 0x000D78, "Member 'ARCNazoBattleLevelScriptActor::CameraData' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalCameraUseFocusLocationOffset) == 0x000E78, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalCameraUseFocusLocationOffset' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupSettingsArray) == 0x000E80, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupSettingsArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupCurrentIndex) == 0x000EE0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupCurrentIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupCurrentNo) == 0x000EE4, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupCurrentNo' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalGroupCurrentFirstChallenge) == 0x000EE8, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalGroupCurrentFirstChallenge' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalCurrentIndex) == 0x000EF8, "Member 'ARCNazoBattleLevelScriptActor::RebuttalCurrentIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalCurrentNo) == 0x000EFC, "Member 'ARCNazoBattleLevelScriptActor::RebuttalCurrentNo' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalCurrentKaiKagiID) == 0x000F00, "Member 'ARCNazoBattleLevelScriptActor::RebuttalCurrentKaiKagiID' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalSelectableKaiKagiIDArray) == 0x000F08, "Member 'ARCNazoBattleLevelScriptActor::RebuttalSelectableKaiKagiIDArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDeleteKaiKagiIDArray) == 0x000F18, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDeleteKaiKagiIDArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, LastRebuttalLetterPosition) == 0x000F28, "Member 'ARCNazoBattleLevelScriptActor::LastRebuttalLetterPosition' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bLastRebuttalLetterLeft) == 0x000F29, "Member 'ARCNazoBattleLevelScriptActor::bLastRebuttalLetterLeft' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataArray) == 0x000F30, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataStartIndexArray) == 0x000F40, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataStartIndexArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataEndIndexArray) == 0x000F50, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataEndIndexArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataCurrentStartIndex) == 0x000F60, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataCurrentStartIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataCurrentEndIndex) == 0x000F64, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataCurrentEndIndex' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalDataCurrentNum) == 0x000F68, "Member 'ARCNazoBattleLevelScriptActor::RebuttalDataCurrentNum' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalPaused) == 0x000F6C, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalPaused' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalInputEnable) == 0x000F6D, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalInputEnable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalInputDisableTimerHandle) == 0x000F70, "Member 'ARCNazoBattleLevelScriptActor::RebuttalInputDisableTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupJustAvoidCountArray) == 0x000F78, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupJustAvoidCountArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CurrentRebuttalGroupJustAvoidCount) == 0x000F88, "Member 'ARCNazoBattleLevelScriptActor::CurrentRebuttalGroupJustAvoidCount' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGroupDisturbSlashPointArray) == 0x000F90, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGroupDisturbSlashPointArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, CurrentRebuttalGroupDisturbSlashPoint) == 0x000FA0, "Member 'ARCNazoBattleLevelScriptActor::CurrentRebuttalGroupDisturbSlashPoint' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalIndexAtAttack) == 0x000FA4, "Member 'ARCNazoBattleLevelScriptActor::RebuttalIndexAtAttack' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalNoAtAttack) == 0x000FA8, "Member 'ARCNazoBattleLevelScriptActor::RebuttalNoAtAttack' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalKaijinCutin) == 0x000FAC, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalKaijinCutin' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalGroupCleared) == 0x000FAD, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalGroupCleared' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalGroupFailed) == 0x000FAE, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalGroupFailed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalAttackFailureType) == 0x000FAF, "Member 'ARCNazoBattleLevelScriptActor::RebuttalAttackFailureType' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalAttackTalkID) == 0x000FB0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalAttackTalkID' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalCloseContestSuccess) == 0x000FB8, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalCloseContestSuccess' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalNoAtGameOver) == 0x000FBC, "Member 'ARCNazoBattleLevelScriptActor::RebuttalNoAtGameOver' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalGameOverHintText) == 0x000FC0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalGameOverHintText' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalGroupFinished) == 0x000FC8, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalGroupFinished' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalIndexAtRebuttalFinished) == 0x000FCC, "Member 'ARCNazoBattleLevelScriptActor::RebuttalIndexAtRebuttalFinished' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bCanAttackRebuttalLetterIfDisturbLetterExist) == 0x000FE1, "Member 'ARCNazoBattleLevelScriptActor::bCanAttackRebuttalLetterIfDisturbLetterExist' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAttackLineEffectLifeTime) == 0x001064, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAttackLineEffectLifeTime' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAssets) == 0x001120, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAssets' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterArray) == 0x0011C0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterDistanceToPlayer) == 0x0011D0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterOutDistance) == 0x0011D4, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterOutDistance' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterShadowColor) == 0x0011D8, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterShadowColor' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeW) == 0x0011E8, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeW' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeW_ZH) == 0x0011EC, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeW_ZH' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeMax) == 0x0011F0, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeMax' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeMin) == 0x0011F4, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeMin' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeMax_ZH) == 0x0011F8, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeMax_ZH' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalLetterAutoResizeMin_ZH) == 0x0011FC, "Member 'ARCNazoBattleLevelScriptActor::RebuttalLetterAutoResizeMin_ZH' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalLetterHitCollisionVisibility) == 0x001200, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalLetterHitCollisionVisibility' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bRebuttalLetterJustAvoidCollisionVisibility) == 0x001201, "Member 'ARCNazoBattleLevelScriptActor::bRebuttalLetterJustAvoidCollisionVisibility' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, UnusedRebuttalLetterArray) == 0x001208, "Member 'ARCNazoBattleLevelScriptActor::UnusedRebuttalLetterArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, bCanAttackDisturbLettersAtOnce) == 0x001219, "Member 'ARCNazoBattleLevelScriptActor::bCanAttackDisturbLettersAtOnce' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisturbLetterAssets) == 0x0012A8, "Member 'ARCNazoBattleLevelScriptActor::DisturbLetterAssets' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisturbLetterArray) == 0x001358, "Member 'ARCNazoBattleLevelScriptActor::DisturbLetterArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, RebuttalIndexAtAttackDisturbLetter) == 0x001368, "Member 'ARCNazoBattleLevelScriptActor::RebuttalIndexAtAttackDisturbLetter' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisturbIndexAtAttackDisturbLetter) == 0x00136C, "Member 'ARCNazoBattleLevelScriptActor::DisturbIndexAtAttackDisturbLetter' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisturbLetterVoiceVolumeRate) == 0x001370, "Member 'ARCNazoBattleLevelScriptActor::DisturbLetterVoiceVolumeRate' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, UnusedDisturbLetterArray) == 0x001378, "Member 'ARCNazoBattleLevelScriptActor::UnusedDisturbLetterArray' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, DisplaceVolume) == 0x001388, "Member 'ARCNazoBattleLevelScriptActor::DisplaceVolume' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleStartWidget) == 0x0013A0, "Member 'ARCNazoBattleLevelScriptActor::BattleStartWidget' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, BattleUIWidget) == 0x0013B8, "Member 'ARCNazoBattleLevelScriptActor::BattleUIWidget' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, KaiKagiListWidget) == 0x0013E0, "Member 'ARCNazoBattleLevelScriptActor::KaiKagiListWidget' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, KaiKagiSelectWidget) == 0x0013F8, "Member 'ARCNazoBattleLevelScriptActor::KaiKagiSelectWidget' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleLevelScriptActor, AssistCutinWidget) == 0x001410, "Member 'ARCNazoBattleLevelScriptActor::AssistCutinWidget' has a wrong offset!");

// Class RC.RCDebugAutoMoveMap
// 0x0050 (0x0078 - 0x0028)
class URCDebugAutoMoveMap final : public UObject
{
public:
	class FName                                   MapID;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCDebugAutoMoveCell*>           CellList;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class URCDebugAutoMoveCell*                   NowCellInfo;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCDebugAutoMoveCell*                   OldCellInfo;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                StartPosition;                                     // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetPosition;                                    // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NextPosition;                                      // 0x0068(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoMoveMap">();
	}
	static class URCDebugAutoMoveMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoMoveMap>();
	}
};
static_assert(alignof(URCDebugAutoMoveMap) == 0x000008, "Wrong alignment on URCDebugAutoMoveMap");
static_assert(sizeof(URCDebugAutoMoveMap) == 0x000078, "Wrong size on URCDebugAutoMoveMap");
static_assert(offsetof(URCDebugAutoMoveMap, MapID) == 0x000028, "Member 'URCDebugAutoMoveMap::MapID' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, CellList) == 0x000030, "Member 'URCDebugAutoMoveMap::CellList' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, NowCellInfo) == 0x000040, "Member 'URCDebugAutoMoveMap::NowCellInfo' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, OldCellInfo) == 0x000048, "Member 'URCDebugAutoMoveMap::OldCellInfo' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, StartPosition) == 0x000050, "Member 'URCDebugAutoMoveMap::StartPosition' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, TargetPosition) == 0x00005C, "Member 'URCDebugAutoMoveMap::TargetPosition' has a wrong offset!");
static_assert(offsetof(URCDebugAutoMoveMap, NextPosition) == 0x000068, "Member 'URCDebugAutoMoveMap::NextPosition' has a wrong offset!");

// Class RC.RCSelectEventTrigger
// 0x0040 (0x0340 - 0x0300)
class ARCSelectEventTrigger final : public ARCEventTrigger
{
public:
	class FName                                   SelectText3DActorName;                             // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectBgActorName;                                 // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectCameraTagName;                               // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraSpeed;                                       // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExitNotBackCamera;                                // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NonSelectText3DActorNameList;                      // 0x0320(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   EndCameraTagName;                                  // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayerOverlapCount;                                // 0x0338(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsOverlapPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSelectEventTrigger">();
	}
	static class ARCSelectEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSelectEventTrigger>();
	}
};
static_assert(alignof(ARCSelectEventTrigger) == 0x000008, "Wrong alignment on ARCSelectEventTrigger");
static_assert(sizeof(ARCSelectEventTrigger) == 0x000340, "Wrong size on ARCSelectEventTrigger");
static_assert(offsetof(ARCSelectEventTrigger, SelectText3DActorName) == 0x000300, "Member 'ARCSelectEventTrigger::SelectText3DActorName' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, SelectBgActorName) == 0x000308, "Member 'ARCSelectEventTrigger::SelectBgActorName' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, SelectCameraTagName) == 0x000310, "Member 'ARCSelectEventTrigger::SelectCameraTagName' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, CameraSpeed) == 0x000318, "Member 'ARCSelectEventTrigger::CameraSpeed' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, bExitNotBackCamera) == 0x00031C, "Member 'ARCSelectEventTrigger::bExitNotBackCamera' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, NonSelectText3DActorNameList) == 0x000320, "Member 'ARCSelectEventTrigger::NonSelectText3DActorNameList' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, EndCameraTagName) == 0x000330, "Member 'ARCSelectEventTrigger::EndCameraTagName' has a wrong offset!");
static_assert(offsetof(ARCSelectEventTrigger, PlayerOverlapCount) == 0x000338, "Member 'ARCSelectEventTrigger::PlayerOverlapCount' has a wrong offset!");

// Class RC.RCDebugAutoPlayBFL
// 0x0000 (0x0028 - 0x0028)
class URCDebugAutoPlayBFL final : public UBlueprintFunctionLibrary
{
public:
	static ERCDebugAutoPlayType GetType();
	static bool IsAutoSceneChange();
	static bool IsEnable();
	static bool IsSceneLoop();
	static bool IsSkip();
	static void SetEnable(bool bInEnable);
	static void SetSceneLoop(bool bInSceneLoop);
	static void SetSkip(bool bInSkip);
	static void SetType(ERCDebugAutoPlayType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoPlayBFL">();
	}
	static class URCDebugAutoPlayBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoPlayBFL>();
	}
};
static_assert(alignof(URCDebugAutoPlayBFL) == 0x000008, "Wrong alignment on URCDebugAutoPlayBFL");
static_assert(sizeof(URCDebugAutoPlayBFL) == 0x000028, "Wrong size on URCDebugAutoPlayBFL");

// Class RC.RCDebugAutoPlayManager
// 0x0030 (0x0058 - 0x0028)
class URCDebugAutoPlayManager final : public UObject
{
public:
	bool                                          bEnable;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkip;                                             // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSceneLoop;                                        // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoSceneChange;                                  // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCDebugAutoPlayType                          Type;                                              // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCAutoPlayCheckLogInfo>        CheckLogList;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugAutoPlayManager">();
	}
	static class URCDebugAutoPlayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDebugAutoPlayManager>();
	}
};
static_assert(alignof(URCDebugAutoPlayManager) == 0x000008, "Wrong alignment on URCDebugAutoPlayManager");
static_assert(sizeof(URCDebugAutoPlayManager) == 0x000058, "Wrong size on URCDebugAutoPlayManager");
static_assert(offsetof(URCDebugAutoPlayManager, bEnable) == 0x000028, "Member 'URCDebugAutoPlayManager::bEnable' has a wrong offset!");
static_assert(offsetof(URCDebugAutoPlayManager, bSkip) == 0x000029, "Member 'URCDebugAutoPlayManager::bSkip' has a wrong offset!");
static_assert(offsetof(URCDebugAutoPlayManager, bSceneLoop) == 0x00002A, "Member 'URCDebugAutoPlayManager::bSceneLoop' has a wrong offset!");
static_assert(offsetof(URCDebugAutoPlayManager, bAutoSceneChange) == 0x00002B, "Member 'URCDebugAutoPlayManager::bAutoSceneChange' has a wrong offset!");
static_assert(offsetof(URCDebugAutoPlayManager, Type) == 0x00002C, "Member 'URCDebugAutoPlayManager::Type' has a wrong offset!");
static_assert(offsetof(URCDebugAutoPlayManager, CheckLogList) == 0x000030, "Member 'URCDebugAutoPlayManager::CheckLogList' has a wrong offset!");

// Class RC.RCWanderingSpiritActor
// 0x0148 (0x03D0 - 0x0288)
class ARCWanderingSpiritActor : public ARCActor
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      PassEffectComp;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PassEffect;                                        // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        PassEffectPath;                                    // 0x02A8(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMove;                                             // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGoReturnMove;                                     // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCWanderingSpiritMotionType                  MotionType;                                        // 0x02C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCWanderingSpiritSpeedType                   SpeedType;                                         // 0x02C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCWanderingSpiritMovingDirectionType         MovingDirectionType;                               // 0x02C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5[0x1];                                      // 0x02C5(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ERCWanderingSpiritMovingInterpType            MovingInterpType;                                  // 0x02C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C7[0x1];                                      // 0x02C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightMax;                                         // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightMin;                                         // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitHeightDistanceRate;                            // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Speed;                                             // 0x02D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightDistance;                                    // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitHeight;                                        // 0x02DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitHeight;                                       // 0x02E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DestinationHeight;                                 // 0x02E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x4];                                      // 0x02E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentZPos;                                       // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreZPos;                                           // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PostZPos;                                          // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x1C];                                     // 0x02F8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineTraceLength;                                   // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CenterLocalLocation;                               // 0x0318(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x19];                                     // 0x0324(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEffectSpawnable;                                  // 0x033D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33E[0xA];                                      // 0x033E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              EffectList_0;                                      // 0x0348(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              EffectList_1;                                      // 0x0358(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectSpawnMarginTime;                             // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_374[0x50];                                     // 0x0374(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveLength;                                        // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapPlayer(class AActor* SelfActor, class AActor* OtherActor);
	void OnActorHitPlayer(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCWanderingSpiritActor">();
	}
	static class ARCWanderingSpiritActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCWanderingSpiritActor>();
	}
};
static_assert(alignof(ARCWanderingSpiritActor) == 0x000008, "Wrong alignment on ARCWanderingSpiritActor");
static_assert(sizeof(ARCWanderingSpiritActor) == 0x0003D0, "Wrong size on ARCWanderingSpiritActor");
static_assert(offsetof(ARCWanderingSpiritActor, AnimInstance) == 0x000288, "Member 'ARCWanderingSpiritActor::AnimInstance' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, PassEffectComp) == 0x000298, "Member 'ARCWanderingSpiritActor::PassEffectComp' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, PassEffect) == 0x0002A0, "Member 'ARCWanderingSpiritActor::PassEffect' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, PassEffectPath) == 0x0002A8, "Member 'ARCWanderingSpiritActor::PassEffectPath' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, bMove) == 0x0002C0, "Member 'ARCWanderingSpiritActor::bMove' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, bGoReturnMove) == 0x0002C1, "Member 'ARCWanderingSpiritActor::bGoReturnMove' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, MotionType) == 0x0002C2, "Member 'ARCWanderingSpiritActor::MotionType' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, SpeedType) == 0x0002C3, "Member 'ARCWanderingSpiritActor::SpeedType' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, MovingDirectionType) == 0x0002C4, "Member 'ARCWanderingSpiritActor::MovingDirectionType' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, MovingInterpType) == 0x0002C6, "Member 'ARCWanderingSpiritActor::MovingInterpType' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, HeightMax) == 0x0002C8, "Member 'ARCWanderingSpiritActor::HeightMax' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, HeightMin) == 0x0002CC, "Member 'ARCWanderingSpiritActor::HeightMin' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, InitHeightDistanceRate) == 0x0002D0, "Member 'ARCWanderingSpiritActor::InitHeightDistanceRate' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, Speed) == 0x0002D4, "Member 'ARCWanderingSpiritActor::Speed' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, HeightDistance) == 0x0002D8, "Member 'ARCWanderingSpiritActor::HeightDistance' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, InitHeight) == 0x0002DC, "Member 'ARCWanderingSpiritActor::InitHeight' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, LimitHeight) == 0x0002E0, "Member 'ARCWanderingSpiritActor::LimitHeight' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, DestinationHeight) == 0x0002E4, "Member 'ARCWanderingSpiritActor::DestinationHeight' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, CurrentZPos) == 0x0002EC, "Member 'ARCWanderingSpiritActor::CurrentZPos' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, PreZPos) == 0x0002F0, "Member 'ARCWanderingSpiritActor::PreZPos' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, PostZPos) == 0x0002F4, "Member 'ARCWanderingSpiritActor::PostZPos' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, LineTraceLength) == 0x000314, "Member 'ARCWanderingSpiritActor::LineTraceLength' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, CenterLocalLocation) == 0x000318, "Member 'ARCWanderingSpiritActor::CenterLocalLocation' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, bEffectSpawnable) == 0x00033D, "Member 'ARCWanderingSpiritActor::bEffectSpawnable' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, EffectList_0) == 0x000348, "Member 'ARCWanderingSpiritActor::EffectList_0' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, EffectList_1) == 0x000358, "Member 'ARCWanderingSpiritActor::EffectList_1' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, EffectSpawnMarginTime) == 0x000370, "Member 'ARCWanderingSpiritActor::EffectSpawnMarginTime' has a wrong offset!");
static_assert(offsetof(ARCWanderingSpiritActor, MoveLength) == 0x0003C4, "Member 'ARCWanderingSpiritActor::MoveLength' has a wrong offset!");

// Class RC.RCGiantWanderingSpiritActor
// 0x0000 (0x03D0 - 0x03D0)
class ARCGiantWanderingSpiritActor final : public ARCWanderingSpiritActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGiantWanderingSpiritActor">();
	}
	static class ARCGiantWanderingSpiritActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGiantWanderingSpiritActor>();
	}
};
static_assert(alignof(ARCGiantWanderingSpiritActor) == 0x000008, "Wrong alignment on ARCGiantWanderingSpiritActor");
static_assert(sizeof(ARCGiantWanderingSpiritActor) == 0x0003D0, "Wrong size on ARCGiantWanderingSpiritActor");

// Class RC.RCUiGenericButton
// 0x0030 (0x0328 - 0x02F8)
class URCUiGenericButton : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x30];                                     // 0x02F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeGenericButton();
	void NativeTick(const struct FGeometry& MyGeometry, float InDeltaTime);
	void Open(bool bInIsFocusedTrue, bool bInIsAcceptCancel, int32 InValidButtonNum, bool bInIsUseDefaultTextID);
	void SetButtonTextID(class FName InCancelTextID, class FName InDecideTextID);
	void StartPush();
	class UWidget* WindowNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiGenericButton">();
	}
	static class URCUiGenericButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiGenericButton>();
	}
};
static_assert(alignof(URCUiGenericButton) == 0x000008, "Wrong alignment on URCUiGenericButton");
static_assert(sizeof(URCUiGenericButton) == 0x000328, "Wrong size on URCUiGenericButton");

// Class RC.RCDebugInfoActor
// 0x0268 (0x0488 - 0x0220)
class ARCDebugInfoActor final : public AActor
{
public:
	struct FChapterInfo                           NowChapterInfo;                                    // 0x0220(0x001C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FChapterInfo                           NextChapterInfo;                                   // 0x023C(0x001C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FChapterInfo                           OldChapterInfo;                                    // 0x0258(0x001C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   LastAccessActorName;                               // 0x0274(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MainQuestPhase;                                    // 0x027C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVariableInfo>                  GameVariable;                                      // 0x0280(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FVariableInfo>                  ChapterVariable;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FVariableInfo>                  SheneVariable;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	int32                                         TotalTanteiPoint;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TanteiRank;                                        // 0x02B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPlayerMove;                                     // 0x02B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RealPlayerGameMode;                                // 0x02BC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ResearchVisionTimeMode;                            // 0x02C4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCRealEventAllMapInfo*                 AllMapInfo;                                        // 0x02D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTopMenuAccess;                                    // 0x02D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCGameMenuType                               TopMenuType;                                       // 0x02D9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawWorldMap;                                     // 0x02DA(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerUnknown;                                    // 0x02DB(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFastTravel;                                       // 0x02DC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopMenuNextQuestTextID;                            // 0x02E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCVariableGameMenuTopSelectInfo> MenuSelectInfoList;                                // 0x02E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bWorldMapAccess;                                   // 0x02F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuMapIconInfo> MapIconList;                                       // 0x0300(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FRCVariableGameMenuMapLineInfo> MapLineList;                                       // 0x0310(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bKaikagiMenuAccess;                                // 0x0320(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuKaikagiInfo> KaikagiInfoList;                                   // 0x0328(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bQuestMenuAccess;                                  // 0x0338(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuQuestInfo>   MainQuestInfoList;                                 // 0x0340(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FRCVariableGameMenuQuestInfo>   SubQuestInfoList;                                  // 0x0350(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FRCVariableGameMenuQuestInfo>   DlcQuestInfoList;                                  // 0x0360(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bCharacterInfoMenuAccess;                          // 0x0370(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuCharacterInfo> CharacterInfoList;                                 // 0x0378(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bGlossaryMenuAccess;                               // 0x0388(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuGlossaryInfo> GlossaryInfoList;                                  // 0x0390(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FRCVariableFigureInfo>          FigureInfoList;                                    // 0x03A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bSubLevelLoadEnd;                                  // 0x03B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LoadMapID;                                         // 0x03B4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BgSublevelList;                                    // 0x03C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	class FName                                   EventSubLevelListFilename;                         // 0x03D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventCommonSubLevelListFilename;                   // 0x03D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventSubQuestSubLevelListFilename;                 // 0x03E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EventCommonAddSubLevelListFilename;                // 0x03E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AddSublevelList;                                   // 0x03F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BgNextSublevelList;                                // 0x0400(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AddNextSublevelList;                               // 0x0410(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FString>                         CharacterSettingFileList;                          // 0x0420(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FEventSettingInfo>              EventSettingFileList;                              // 0x0430(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FAssetInfo>                     AssetList;                                         // 0x0440(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FAssetInfo>                     LoadAssetList;                                     // 0x0450(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           CharacterList;                                     // 0x0460(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	int32                                         InstanceCharacterActorNum;                         // 0x0470(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstancePawnActorNum;                              // 0x0474(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowCharacterActorNum;                              // 0x0478(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowPawnActorNum;                                   // 0x047C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NowKakiwariActorNum;                               // 0x0480(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugInfoActor">();
	}
	static class ARCDebugInfoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCDebugInfoActor>();
	}
};
static_assert(alignof(ARCDebugInfoActor) == 0x000008, "Wrong alignment on ARCDebugInfoActor");
static_assert(sizeof(ARCDebugInfoActor) == 0x000488, "Wrong size on ARCDebugInfoActor");
static_assert(offsetof(ARCDebugInfoActor, NowChapterInfo) == 0x000220, "Member 'ARCDebugInfoActor::NowChapterInfo' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, NextChapterInfo) == 0x00023C, "Member 'ARCDebugInfoActor::NextChapterInfo' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, OldChapterInfo) == 0x000258, "Member 'ARCDebugInfoActor::OldChapterInfo' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, LastAccessActorName) == 0x000274, "Member 'ARCDebugInfoActor::LastAccessActorName' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, MainQuestPhase) == 0x00027C, "Member 'ARCDebugInfoActor::MainQuestPhase' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, GameVariable) == 0x000280, "Member 'ARCDebugInfoActor::GameVariable' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, ChapterVariable) == 0x000290, "Member 'ARCDebugInfoActor::ChapterVariable' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, SheneVariable) == 0x0002A0, "Member 'ARCDebugInfoActor::SheneVariable' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, TotalTanteiPoint) == 0x0002B0, "Member 'ARCDebugInfoActor::TotalTanteiPoint' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, TanteiRank) == 0x0002B4, "Member 'ARCDebugInfoActor::TanteiRank' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bIsPlayerMove) == 0x0002B8, "Member 'ARCDebugInfoActor::bIsPlayerMove' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, RealPlayerGameMode) == 0x0002BC, "Member 'ARCDebugInfoActor::RealPlayerGameMode' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, ResearchVisionTimeMode) == 0x0002C4, "Member 'ARCDebugInfoActor::ResearchVisionTimeMode' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, AllMapInfo) == 0x0002D0, "Member 'ARCDebugInfoActor::AllMapInfo' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bTopMenuAccess) == 0x0002D8, "Member 'ARCDebugInfoActor::bTopMenuAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, TopMenuType) == 0x0002D9, "Member 'ARCDebugInfoActor::TopMenuType' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bDrawWorldMap) == 0x0002DA, "Member 'ARCDebugInfoActor::bDrawWorldMap' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bPlayerUnknown) == 0x0002DB, "Member 'ARCDebugInfoActor::bPlayerUnknown' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bFastTravel) == 0x0002DC, "Member 'ARCDebugInfoActor::bFastTravel' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, TopMenuNextQuestTextID) == 0x0002E0, "Member 'ARCDebugInfoActor::TopMenuNextQuestTextID' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, MenuSelectInfoList) == 0x0002E8, "Member 'ARCDebugInfoActor::MenuSelectInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bWorldMapAccess) == 0x0002F8, "Member 'ARCDebugInfoActor::bWorldMapAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, MapIconList) == 0x000300, "Member 'ARCDebugInfoActor::MapIconList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, MapLineList) == 0x000310, "Member 'ARCDebugInfoActor::MapLineList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bKaikagiMenuAccess) == 0x000320, "Member 'ARCDebugInfoActor::bKaikagiMenuAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, KaikagiInfoList) == 0x000328, "Member 'ARCDebugInfoActor::KaikagiInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bQuestMenuAccess) == 0x000338, "Member 'ARCDebugInfoActor::bQuestMenuAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, MainQuestInfoList) == 0x000340, "Member 'ARCDebugInfoActor::MainQuestInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, SubQuestInfoList) == 0x000350, "Member 'ARCDebugInfoActor::SubQuestInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, DlcQuestInfoList) == 0x000360, "Member 'ARCDebugInfoActor::DlcQuestInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bCharacterInfoMenuAccess) == 0x000370, "Member 'ARCDebugInfoActor::bCharacterInfoMenuAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, CharacterInfoList) == 0x000378, "Member 'ARCDebugInfoActor::CharacterInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bGlossaryMenuAccess) == 0x000388, "Member 'ARCDebugInfoActor::bGlossaryMenuAccess' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, GlossaryInfoList) == 0x000390, "Member 'ARCDebugInfoActor::GlossaryInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, FigureInfoList) == 0x0003A0, "Member 'ARCDebugInfoActor::FigureInfoList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, bSubLevelLoadEnd) == 0x0003B0, "Member 'ARCDebugInfoActor::bSubLevelLoadEnd' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, LoadMapID) == 0x0003B4, "Member 'ARCDebugInfoActor::LoadMapID' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, BgSublevelList) == 0x0003C0, "Member 'ARCDebugInfoActor::BgSublevelList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, EventSubLevelListFilename) == 0x0003D0, "Member 'ARCDebugInfoActor::EventSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, EventCommonSubLevelListFilename) == 0x0003D8, "Member 'ARCDebugInfoActor::EventCommonSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, EventSubQuestSubLevelListFilename) == 0x0003E0, "Member 'ARCDebugInfoActor::EventSubQuestSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, EventCommonAddSubLevelListFilename) == 0x0003E8, "Member 'ARCDebugInfoActor::EventCommonAddSubLevelListFilename' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, AddSublevelList) == 0x0003F0, "Member 'ARCDebugInfoActor::AddSublevelList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, BgNextSublevelList) == 0x000400, "Member 'ARCDebugInfoActor::BgNextSublevelList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, AddNextSublevelList) == 0x000410, "Member 'ARCDebugInfoActor::AddNextSublevelList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, CharacterSettingFileList) == 0x000420, "Member 'ARCDebugInfoActor::CharacterSettingFileList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, EventSettingFileList) == 0x000430, "Member 'ARCDebugInfoActor::EventSettingFileList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, AssetList) == 0x000440, "Member 'ARCDebugInfoActor::AssetList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, LoadAssetList) == 0x000450, "Member 'ARCDebugInfoActor::LoadAssetList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, CharacterList) == 0x000460, "Member 'ARCDebugInfoActor::CharacterList' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, InstanceCharacterActorNum) == 0x000470, "Member 'ARCDebugInfoActor::InstanceCharacterActorNum' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, InstancePawnActorNum) == 0x000474, "Member 'ARCDebugInfoActor::InstancePawnActorNum' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, NowCharacterActorNum) == 0x000478, "Member 'ARCDebugInfoActor::NowCharacterActorNum' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, NowPawnActorNum) == 0x00047C, "Member 'ARCDebugInfoActor::NowPawnActorNum' has a wrong offset!");
static_assert(offsetof(ARCDebugInfoActor, NowKakiwariActorNum) == 0x000480, "Member 'ARCDebugInfoActor::NowKakiwariActorNum' has a wrong offset!");

// Class RC.RCMovieManagerBFL
// 0x0000 (0x0028 - 0x0028)
class URCMovieManagerBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool GetIsLoop();
	static int32 GetMovieIndex();
	static float GetMovieTime();
	static bool IsAssetLoading();
	static bool IsLoadedMovie();
	static bool IsMovieCansel();
	static bool IsMovieEnd();
	static bool IsMoviePlaying();
	static void Pause(bool IsPause);
	static void PlayMovie();
	static class UMaterialInstanceDynamic* ReadyMovieMaterial();
	static void Reset();
	static void ResetSkipGauge();
	static void SetBpMovieIndex(int32 MovieIndex);
	static void SetIsLoop(bool IsLoop);
	static void SetMovie(const class FString& MovieID, class URCUserWidget* Widget, class URCManaComponent* ManaComponent);
	static void SetOpeningMovieFLag(bool isOpening);
	static void SetSaveDataMovieIndex(int32 MovieIndex);
	static void SetSkipTime(float skipTime);
	static void Update();
	static void WidgetToRemoveFromViewport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMovieManagerBFL">();
	}
	static class URCMovieManagerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMovieManagerBFL>();
	}
};
static_assert(alignof(URCMovieManagerBFL) == 0x000008, "Wrong alignment on URCMovieManagerBFL");
static_assert(sizeof(URCMovieManagerBFL) == 0x000028, "Wrong size on URCMovieManagerBFL");

// Class RC.RCDebugRain
// 0x0020 (0x0240 - 0x0220)
class ARCDebugRain final : public AActor
{
public:
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDebugRain">();
	}
	static class ARCDebugRain* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCDebugRain>();
	}
};
static_assert(alignof(ARCDebugRain) == 0x000008, "Wrong alignment on ARCDebugRain");
static_assert(sizeof(ARCDebugRain) == 0x000240, "Wrong size on ARCDebugRain");

// Class RC.RCTitleGalleryMovie
// 0x0040 (0x0318 - 0x02D8)
class URCTitleGalleryMovie : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_In;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_Out;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryMovie">();
	}
	static class URCTitleGalleryMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryMovie>();
	}
};
static_assert(alignof(URCTitleGalleryMovie) == 0x000008, "Wrong alignment on URCTitleGalleryMovie");
static_assert(sizeof(URCTitleGalleryMovie) == 0x000318, "Wrong size on URCTitleGalleryMovie");
static_assert(offsetof(URCTitleGalleryMovie, AN_On) == 0x0002D8, "Member 'URCTitleGalleryMovie::AN_On' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovie, AN_Off) == 0x0002E0, "Member 'URCTitleGalleryMovie::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovie, AN_Flame_In) == 0x0002E8, "Member 'URCTitleGalleryMovie::AN_Flame_In' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovie, AN_Flame_Out) == 0x0002F0, "Member 'URCTitleGalleryMovie::AN_Flame_Out' has a wrong offset!");

// Class RC.RCDevelopmentSaveSetting
// 0x0048 (0x0070 - 0x0028)
class URCDevelopmentSaveSetting final : public UObject
{
public:
	struct FRCDevelopmentSave                     DevelopmentSave;                                   // 0x0028(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x14];                                      // 0x005C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDevelopmentSaveSetting">();
	}
	static class URCDevelopmentSaveSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDevelopmentSaveSetting>();
	}
};
static_assert(alignof(URCDevelopmentSaveSetting) == 0x000008, "Wrong alignment on URCDevelopmentSaveSetting");
static_assert(sizeof(URCDevelopmentSaveSetting) == 0x000070, "Wrong size on URCDevelopmentSaveSetting");
static_assert(offsetof(URCDevelopmentSaveSetting, DevelopmentSave) == 0x000028, "Member 'URCDevelopmentSaveSetting::DevelopmentSave' has a wrong offset!");

// Class RC.RCDitherFadeComponent
// 0x0060 (0x0110 - 0x00B0)
class URCDitherFadeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCameraNearFade;                                   // 0x00B4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraNearFadeOriginalFlag;                       // 0x00B5(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraNearFadeOriginalLengthMin;                   // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraNearFadeOriginalLengthMax;                   // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x00C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartValue;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowValue;                                          // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowTime;                                           // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCCameraNearType                             CameraNearType;                                    // 0x00D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLength;                                      // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraFadeEnable;                                 // 0x00E0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraStartValue;                                  // 0x00E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraEndValue;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraNowValue;                                    // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraEndTime;                                     // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraNowTime;                                     // 0x00F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARCCharacterRender*                     OwnerCharacter;                                    // 0x00F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARCPawnRender*                          OwnerPawn;                                         // 0x0100(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARCKakiwariRender*                      OwnerKakiwari;                                     // 0x0108(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDitherFadeComponent">();
	}
	static class URCDitherFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDitherFadeComponent>();
	}
};
static_assert(alignof(URCDitherFadeComponent) == 0x000008, "Wrong alignment on URCDitherFadeComponent");
static_assert(sizeof(URCDitherFadeComponent) == 0x000110, "Wrong size on URCDitherFadeComponent");
static_assert(offsetof(URCDitherFadeComponent, bCameraNearFade) == 0x0000B4, "Member 'URCDitherFadeComponent::bCameraNearFade' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, bCameraNearFadeOriginalFlag) == 0x0000B5, "Member 'URCDitherFadeComponent::bCameraNearFadeOriginalFlag' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraNearFadeOriginalLengthMin) == 0x0000B8, "Member 'URCDitherFadeComponent::CameraNearFadeOriginalLengthMin' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraNearFadeOriginalLengthMax) == 0x0000BC, "Member 'URCDitherFadeComponent::CameraNearFadeOriginalLengthMax' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, bEnable) == 0x0000C0, "Member 'URCDitherFadeComponent::bEnable' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, StartValue) == 0x0000C4, "Member 'URCDitherFadeComponent::StartValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, EndValue) == 0x0000C8, "Member 'URCDitherFadeComponent::EndValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, NowValue) == 0x0000CC, "Member 'URCDitherFadeComponent::NowValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, EndTime) == 0x0000D0, "Member 'URCDitherFadeComponent::EndTime' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, NowTime) == 0x0000D4, "Member 'URCDitherFadeComponent::NowTime' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraNearType) == 0x0000D8, "Member 'URCDitherFadeComponent::CameraNearType' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraLength) == 0x0000DC, "Member 'URCDitherFadeComponent::CameraLength' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, bCameraFadeEnable) == 0x0000E0, "Member 'URCDitherFadeComponent::bCameraFadeEnable' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraStartValue) == 0x0000E4, "Member 'URCDitherFadeComponent::CameraStartValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraEndValue) == 0x0000E8, "Member 'URCDitherFadeComponent::CameraEndValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraNowValue) == 0x0000EC, "Member 'URCDitherFadeComponent::CameraNowValue' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraEndTime) == 0x0000F0, "Member 'URCDitherFadeComponent::CameraEndTime' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, CameraNowTime) == 0x0000F4, "Member 'URCDitherFadeComponent::CameraNowTime' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, OwnerCharacter) == 0x0000F8, "Member 'URCDitherFadeComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, OwnerPawn) == 0x000100, "Member 'URCDitherFadeComponent::OwnerPawn' has a wrong offset!");
static_assert(offsetof(URCDitherFadeComponent, OwnerKakiwari) == 0x000108, "Member 'URCDitherFadeComponent::OwnerKakiwari' has a wrong offset!");

// Class RC.RCMenuButtonGauge
// 0x0078 (0x0398 - 0x0320)
class URCMenuButtonGauge final : public URCMenuButton
{
public:
	uint8                                         Pad_320[0x78];                                     // 0x0320(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDecValue();
	void OnIncValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuButtonGauge">();
	}
	static class URCMenuButtonGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuButtonGauge>();
	}
};
static_assert(alignof(URCMenuButtonGauge) == 0x000008, "Wrong alignment on URCMenuButtonGauge");
static_assert(sizeof(URCMenuButtonGauge) == 0x000398, "Wrong size on URCMenuButtonGauge");

// Class RC.RCTargetPoint
// 0x0030 (0x0250 - 0x0220)
class ARCTargetPoint : public ATargetPoint
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PointName;                                         // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           BaseColor;                                         // 0x0238(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScaleRate;                                         // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTargetPoint">();
	}
	static class ARCTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTargetPoint>();
	}
};
static_assert(alignof(ARCTargetPoint) == 0x000008, "Wrong alignment on ARCTargetPoint");
static_assert(sizeof(ARCTargetPoint) == 0x000250, "Wrong size on ARCTargetPoint");
static_assert(offsetof(ARCTargetPoint, PointName) == 0x000230, "Member 'ARCTargetPoint::PointName' has a wrong offset!");
static_assert(offsetof(ARCTargetPoint, BaseColor) == 0x000238, "Member 'ARCTargetPoint::BaseColor' has a wrong offset!");
static_assert(offsetof(ARCTargetPoint, ScaleRate) == 0x000248, "Member 'ARCTargetPoint::ScaleRate' has a wrong offset!");

// Class RC.RCDollyCameraActor
// 0x0170 (0x0930 - 0x07C0)
class ARCDollyCameraActor final : public ARCCameraActor
{
public:
	uint8                                         Pad_7C0[0xB8];                                     // 0x07C0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	ERCDollyCamPlane                              Plane;                                             // 0x0878(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_879[0x3];                                      // 0x0879(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ToleranceMin;                                      // 0x087C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ToleranceMax;                                      // 0x0884(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x088C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StickY;                                            // 0x0898(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_899[0x7];                                      // 0x0899(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x08A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Tracking;                                          // 0x08A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyOnOverlap;                                     // 0x08B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrackingAlways;                                    // 0x08B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B2[0x2];                                      // 0x08B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetTimeout;                                      // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Accelerate;                                        // 0x08B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B9[0x3];                                      // 0x08B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopDetectionTime;                                 // 0x08BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaybackDuration;                                   // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceMultiplier;                                   // 0x08C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationLimit;                                 // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Controllable;                                      // 0x08CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationInTolerance;                               // 0x08CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CE[0x2];                                      // 0x08CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AdditionalMask;                                    // 0x08D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x44];                                     // 0x08DC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         EndPoints;                                         // 0x0920(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void CameraComponentActivated(class UActorComponent* Comp, bool flag);
	void CameraComponentDeactivated(class UActorComponent* Comp);
	void ResetTracking(bool ResetRotation);
	void SetOffset(const struct FVector& NewOffset);
	void SetTarget(class AActor* NewTarget);
	void SetTargetPawn();
	void StopTracking();

	bool IsTracking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDollyCameraActor">();
	}
	static class ARCDollyCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCDollyCameraActor>();
	}
};
static_assert(alignof(ARCDollyCameraActor) == 0x000010, "Wrong alignment on ARCDollyCameraActor");
static_assert(sizeof(ARCDollyCameraActor) == 0x000930, "Wrong size on ARCDollyCameraActor");
static_assert(offsetof(ARCDollyCameraActor, Plane) == 0x000878, "Member 'ARCDollyCameraActor::Plane' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, ToleranceMin) == 0x00087C, "Member 'ARCDollyCameraActor::ToleranceMin' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, ToleranceMax) == 0x000884, "Member 'ARCDollyCameraActor::ToleranceMax' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, Offset) == 0x00088C, "Member 'ARCDollyCameraActor::Offset' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, StickY) == 0x000898, "Member 'ARCDollyCameraActor::StickY' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, Target) == 0x0008A0, "Member 'ARCDollyCameraActor::Target' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, Tracking) == 0x0008A8, "Member 'ARCDollyCameraActor::Tracking' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, OnlyOnOverlap) == 0x0008B0, "Member 'ARCDollyCameraActor::OnlyOnOverlap' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, TrackingAlways) == 0x0008B1, "Member 'ARCDollyCameraActor::TrackingAlways' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, ResetTimeout) == 0x0008B4, "Member 'ARCDollyCameraActor::ResetTimeout' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, Accelerate) == 0x0008B8, "Member 'ARCDollyCameraActor::Accelerate' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, StopDetectionTime) == 0x0008BC, "Member 'ARCDollyCameraActor::StopDetectionTime' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, WaybackDuration) == 0x0008C0, "Member 'ARCDollyCameraActor::WaybackDuration' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, ForceMultiplier) == 0x0008C4, "Member 'ARCDollyCameraActor::ForceMultiplier' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, AccelerationLimit) == 0x0008C8, "Member 'ARCDollyCameraActor::AccelerationLimit' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, Controllable) == 0x0008CC, "Member 'ARCDollyCameraActor::Controllable' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, RotationInTolerance) == 0x0008CD, "Member 'ARCDollyCameraActor::RotationInTolerance' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, AdditionalMask) == 0x0008D0, "Member 'ARCDollyCameraActor::AdditionalMask' has a wrong offset!");
static_assert(offsetof(ARCDollyCameraActor, EndPoints) == 0x000920, "Member 'ARCDollyCameraActor::EndPoints' has a wrong offset!");

// Class RC.RCShinigamiAIComponent
// 0x0058 (0x0108 - 0x00B0)
class URCShinigamiAIComponent final : public UActorComponent
{
public:
	bool                                          bEnable;                                           // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoMoveAnimeEnable;                              // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiAIType                            AIType;                                            // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiEmotionType                       EmotionType;                                       // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCShinigamiAICommandTrigger*           CurrentCommandTrigger;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCShinigamiAICommandTrigger*           NextCommandTrigger;                                // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialize;                                       // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitializeSetup;                                  // 0x00C9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAiActionEnable;                                   // 0x00CA(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class URCShinigamiAnimation*                  Animation;                                         // 0x00D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIAction*                   AIAction;                                          // 0x00E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIMove*                     AIMove;                                            // 0x00E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIFollow*                   AIFollow;                                          // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIRoute*                    AIRoute;                                           // 0x00F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         WarpEfffect;                                       // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIComponent">();
	}
	static class URCShinigamiAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAIComponent>();
	}
};
static_assert(alignof(URCShinigamiAIComponent) == 0x000008, "Wrong alignment on URCShinigamiAIComponent");
static_assert(sizeof(URCShinigamiAIComponent) == 0x000108, "Wrong size on URCShinigamiAIComponent");
static_assert(offsetof(URCShinigamiAIComponent, bEnable) == 0x0000B0, "Member 'URCShinigamiAIComponent::bEnable' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, bAutoMoveAnimeEnable) == 0x0000B1, "Member 'URCShinigamiAIComponent::bAutoMoveAnimeEnable' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, AIType) == 0x0000B2, "Member 'URCShinigamiAIComponent::AIType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, EmotionType) == 0x0000B3, "Member 'URCShinigamiAIComponent::EmotionType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, CurrentCommandTrigger) == 0x0000B8, "Member 'URCShinigamiAIComponent::CurrentCommandTrigger' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, NextCommandTrigger) == 0x0000C0, "Member 'URCShinigamiAIComponent::NextCommandTrigger' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, bInitialize) == 0x0000C8, "Member 'URCShinigamiAIComponent::bInitialize' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, bInitializeSetup) == 0x0000C9, "Member 'URCShinigamiAIComponent::bInitializeSetup' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, bAiActionEnable) == 0x0000CA, "Member 'URCShinigamiAIComponent::bAiActionEnable' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, Animation) == 0x0000D0, "Member 'URCShinigamiAIComponent::Animation' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, Movement) == 0x0000D8, "Member 'URCShinigamiAIComponent::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, AIAction) == 0x0000E0, "Member 'URCShinigamiAIComponent::AIAction' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, AIMove) == 0x0000E8, "Member 'URCShinigamiAIComponent::AIMove' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, AIFollow) == 0x0000F0, "Member 'URCShinigamiAIComponent::AIFollow' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, AIRoute) == 0x0000F8, "Member 'URCShinigamiAIComponent::AIRoute' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIComponent, WarpEfffect) == 0x000100, "Member 'URCShinigamiAIComponent::WarpEfffect' has a wrong offset!");

// Class RC.RCDPICustomScalingRule
// 0x0000 (0x0028 - 0x0028)
class URCDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDPICustomScalingRule">();
	}
	static class URCDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDPICustomScalingRule>();
	}
};
static_assert(alignof(URCDPICustomScalingRule) == 0x000008, "Wrong alignment on URCDPICustomScalingRule");
static_assert(sizeof(URCDPICustomScalingRule) == 0x000028, "Wrong size on URCDPICustomScalingRule");

// Class RC.RCDroneActor
// 0x0080 (0x0308 - 0x0288)
class ARCDroneActor final : public ARCActor
{
public:
	class URCDroneControlComponent*               ControlComp;                                       // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCDroneAnimCtrl*                       AnimCtrlComp;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterName;                                     // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Height;                                            // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoHeight;                                       // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A5[0x1B];                                     // 0x02A5(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MapAmbientLightColor;                              // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MapDirectionalLightColor;                          // 0x02D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         MeshArray;                                         // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterialArray;                              // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDroneActor">();
	}
	static class ARCDroneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCDroneActor>();
	}
};
static_assert(alignof(ARCDroneActor) == 0x000008, "Wrong alignment on ARCDroneActor");
static_assert(sizeof(ARCDroneActor) == 0x000308, "Wrong size on ARCDroneActor");
static_assert(offsetof(ARCDroneActor, ControlComp) == 0x000288, "Member 'ARCDroneActor::ControlComp' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, AnimCtrlComp) == 0x000290, "Member 'ARCDroneActor::AnimCtrlComp' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, CharacterName) == 0x000298, "Member 'ARCDroneActor::CharacterName' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, Height) == 0x0002A0, "Member 'ARCDroneActor::Height' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, bAutoHeight) == 0x0002A4, "Member 'ARCDroneActor::bAutoHeight' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, MapAmbientLightColor) == 0x0002C0, "Member 'ARCDroneActor::MapAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, MapDirectionalLightColor) == 0x0002D0, "Member 'ARCDroneActor::MapDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, MeshArray) == 0x0002E0, "Member 'ARCDroneActor::MeshArray' has a wrong offset!");
static_assert(offsetof(ARCDroneActor, DynamicMaterialArray) == 0x0002F0, "Member 'ARCDroneActor::DynamicMaterialArray' has a wrong offset!");

// Class RC.RCHardwareManager
// 0x0000 (0x0028 - 0x0028)
class URCHardwareManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCHardwareManager">();
	}
	static class URCHardwareManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCHardwareManager>();
	}
};
static_assert(alignof(URCHardwareManager) == 0x000008, "Wrong alignment on URCHardwareManager");
static_assert(sizeof(URCHardwareManager) == 0x000028, "Wrong size on URCHardwareManager");

// Class RC.RCTitleGalleryBGMList
// 0x00A8 (0x03A0 - 0x02F8)
class URCTitleGalleryBGMList : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x70];                                     // 0x02F8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x34];                                     // 0x036C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* BGMNavigation(EUINavigation InNavigation);
	void SelectBGM();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryBGMList">();
	}
	static class URCTitleGalleryBGMList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryBGMList>();
	}
};
static_assert(alignof(URCTitleGalleryBGMList) == 0x000008, "Wrong alignment on URCTitleGalleryBGMList");
static_assert(sizeof(URCTitleGalleryBGMList) == 0x0003A0, "Wrong size on URCTitleGalleryBGMList");
static_assert(offsetof(URCTitleGalleryBGMList, MaxBarOfPage) == 0x000368, "Member 'URCTitleGalleryBGMList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCDroneAnimCtrl
// 0x0030 (0x00E0 - 0x00B0)
class URCDroneAnimCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCDroneAnimInstance*>           AnimInstanceArray;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDroneAnimCtrl">();
	}
	static class URCDroneAnimCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDroneAnimCtrl>();
	}
};
static_assert(alignof(URCDroneAnimCtrl) == 0x000008, "Wrong alignment on URCDroneAnimCtrl");
static_assert(sizeof(URCDroneAnimCtrl) == 0x0000E0, "Wrong size on URCDroneAnimCtrl");
static_assert(offsetof(URCDroneAnimCtrl, AnimInstanceArray) == 0x0000B8, "Member 'URCDroneAnimCtrl::AnimInstanceArray' has a wrong offset!");

// Class RC.RCNzResult
// 0x0178 (0x0450 - 0x02D8)
class URCNzResult : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute1_In;                                    // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute1_Rank;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute2_In;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute2_Rank;                                  // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute3_In;                                    // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute3_Rank;                                  // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute4_In;                                    // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute4_Rank;                                  // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute5_In;                                    // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Evalute5_Rank;                                  // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_BonusPoints_In;                                 // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_AddPoints_In;                                   // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Menu_In;                                        // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_All_Wait;                                       // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Detail_On;                                      // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Detail_Off;                                     // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Canvas_Bonus;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                OL_AddPoints;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x30];                                     // 0x0378(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_BasePoint;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_BonusPoint;                                   // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_AddPoint;                                     // 0x03B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_BasePoint_Label;                              // 0x03C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_BonusPoint_Label;                             // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_BasePoint_Label_1;                            // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x48];                                     // 0x03D8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzResultRankCalculator*              ResultRankCalculator;                              // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCNzResultStateType                          StateType;                                         // 0x0428(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCNzResultType                               ResultType;                                        // 0x0429(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42A[0x26];                                     // 0x042A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void mCloseResultWrap(ERCInputKeyType InKeyType);
	void mOffDetailWrap(ERCInputKeyType InKeyType);
	void mOnDetailWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzResult">();
	}
	static class URCNzResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzResult>();
	}
};
static_assert(alignof(URCNzResult) == 0x000008, "Wrong alignment on URCNzResult");
static_assert(sizeof(URCNzResult) == 0x000450, "Wrong size on URCNzResult");
static_assert(offsetof(URCNzResult, AN_Start) == 0x0002D8, "Member 'URCNzResult::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute1_In) == 0x0002E0, "Member 'URCNzResult::AN_Evalute1_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute1_Rank) == 0x0002E8, "Member 'URCNzResult::AN_Evalute1_Rank' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute2_In) == 0x0002F0, "Member 'URCNzResult::AN_Evalute2_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute2_Rank) == 0x0002F8, "Member 'URCNzResult::AN_Evalute2_Rank' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute3_In) == 0x000300, "Member 'URCNzResult::AN_Evalute3_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute3_Rank) == 0x000308, "Member 'URCNzResult::AN_Evalute3_Rank' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute4_In) == 0x000310, "Member 'URCNzResult::AN_Evalute4_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute4_Rank) == 0x000318, "Member 'URCNzResult::AN_Evalute4_Rank' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute5_In) == 0x000320, "Member 'URCNzResult::AN_Evalute5_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Evalute5_Rank) == 0x000328, "Member 'URCNzResult::AN_Evalute5_Rank' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_BonusPoints_In) == 0x000330, "Member 'URCNzResult::AN_BonusPoints_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_AddPoints_In) == 0x000338, "Member 'URCNzResult::AN_AddPoints_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Menu_In) == 0x000340, "Member 'URCNzResult::AN_Menu_In' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_All_Wait) == 0x000348, "Member 'URCNzResult::AN_All_Wait' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Detail_On) == 0x000350, "Member 'URCNzResult::AN_Detail_On' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Detail_Off) == 0x000358, "Member 'URCNzResult::AN_Detail_Off' has a wrong offset!");
static_assert(offsetof(URCNzResult, AN_Finish) == 0x000360, "Member 'URCNzResult::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzResult, Canvas_Bonus) == 0x000368, "Member 'URCNzResult::Canvas_Bonus' has a wrong offset!");
static_assert(offsetof(URCNzResult, OL_AddPoints) == 0x000370, "Member 'URCNzResult::OL_AddPoints' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_BasePoint) == 0x0003A8, "Member 'URCNzResult::Text_BasePoint' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_BonusPoint) == 0x0003B0, "Member 'URCNzResult::Text_BonusPoint' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_AddPoint) == 0x0003B8, "Member 'URCNzResult::Text_AddPoint' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_BasePoint_Label) == 0x0003C0, "Member 'URCNzResult::Text_BasePoint_Label' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_BonusPoint_Label) == 0x0003C8, "Member 'URCNzResult::Text_BonusPoint_Label' has a wrong offset!");
static_assert(offsetof(URCNzResult, Text_BasePoint_Label_1) == 0x0003D0, "Member 'URCNzResult::Text_BasePoint_Label_1' has a wrong offset!");
static_assert(offsetof(URCNzResult, ResultRankCalculator) == 0x000420, "Member 'URCNzResult::ResultRankCalculator' has a wrong offset!");
static_assert(offsetof(URCNzResult, StateType) == 0x000428, "Member 'URCNzResult::StateType' has a wrong offset!");
static_assert(offsetof(URCNzResult, ResultType) == 0x000429, "Member 'URCNzResult::ResultType' has a wrong offset!");

// Class RC.RCDroneAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class URCDroneAnimInstance final : public URCAnimInstance
{
public:
	struct FRotator                               ClockwiseRotator;                                  // 0x02B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AntiClockwiseRotator;                              // 0x02C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDroneAnimInstance">();
	}
	static class URCDroneAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDroneAnimInstance>();
	}
};
static_assert(alignof(URCDroneAnimInstance) == 0x000010, "Wrong alignment on URCDroneAnimInstance");
static_assert(sizeof(URCDroneAnimInstance) == 0x0002D0, "Wrong size on URCDroneAnimInstance");
static_assert(offsetof(URCDroneAnimInstance, ClockwiseRotator) == 0x0002B8, "Member 'URCDroneAnimInstance::ClockwiseRotator' has a wrong offset!");
static_assert(offsetof(URCDroneAnimInstance, AntiClockwiseRotator) == 0x0002C4, "Member 'URCDroneAnimInstance::AntiClockwiseRotator' has a wrong offset!");

// Class RC.RCTitleHUD
// 0x0118 (0x0550 - 0x0438)
class ARCTitleHUD final : public ARCUiFaderHUD
{
public:
	int32                                         GenericWindowPriority;                             // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiGenericWindow*                     GenericWindowWidget;                               // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CollectionMenuWidgetPriority;                      // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCMenuCollectionLayout*                CollectionMenuWidget;                              // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CollectionWindowWidgetPriority;                    // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCMenuCollectionWindow*                CollectionWindowWidget;                            // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleLogoWidgetPriority;                           // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleLogo*                           TitleLogoWidget;                                   // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleLangaugeWidgetPriority;                       // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleLanguage*                       TitleLanguageWidget;                               // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleChapterSelectWidgetPriority;                  // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleChapterSelect*                  TitleChapterSelectWidget;                          // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChapterSelectSceneID;                              // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChapterSelectChapterNum;                           // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleSaveCheckWidgetPriority;                      // 0x04A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleSaveCheck*                      TitleSaveCheckWidget;                              // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleSaveCheckConnectWidgetPriority;               // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleSaveCheckConnect*               TitleSaveCheckConnectWidget;                       // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleSubStoryWidgetPriority;                       // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleSubStory*                       TitleSubStoryWidget;                               // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleSubStoryChapter;                              // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TitleSubStorySceneID;                              // 0x04D4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubStorySelectIndex;                               // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitleMenuWidgetPriority;                           // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleMenu*                           TitleMenuWidget;                                   // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NzResultWidgetPriority;                            // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzResult*                            NzResultWidget;                                    // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TutorialWindowPriority;                            // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TutorialWindowPath;                                // 0x0504(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiTutorialWindow*                    TutorialWindow;                                    // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GalleryWidgetPriority;                             // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GalleryWidgetPath;                                 // 0x051C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTitleGalleryBase*                    GalleryWidget;                                     // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x4];                                      // 0x0530(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LicenseWidgetPriority;                             // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LicenseWidgetPath;                                 // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleLicense*                        LicenseWidget;                                     // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckNzResultClose();
	bool CheckNzResultFinished();
	bool CheckNzResultStarted();
	void ChunkInstallEvent(uint32 InChunkID, bool InSuccess);
	bool NzResultFinish();
	bool NzResultStart(const int32 InChapterNumber);
	void Tutorial_CloseTutorial();
	bool Tutorial_CreateWidget();
	bool Tutorial_IsFinished();
	bool Tutorial_IsShowWindow();
	bool Tutorial_Load();
	void Tutorial_RemoveTutorialWindow();
	void Tutorial_StartTutorial(class FName ID, bool isAnytimeClosable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleHUD">();
	}
	static class ARCTitleHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitleHUD>();
	}
};
static_assert(alignof(ARCTitleHUD) == 0x000008, "Wrong alignment on ARCTitleHUD");
static_assert(sizeof(ARCTitleHUD) == 0x000550, "Wrong size on ARCTitleHUD");
static_assert(offsetof(ARCTitleHUD, GenericWindowPriority) == 0x000438, "Member 'ARCTitleHUD::GenericWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, GenericWindowWidget) == 0x000440, "Member 'ARCTitleHUD::GenericWindowWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, CollectionMenuWidgetPriority) == 0x000448, "Member 'ARCTitleHUD::CollectionMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, CollectionMenuWidget) == 0x000450, "Member 'ARCTitleHUD::CollectionMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, CollectionWindowWidgetPriority) == 0x000458, "Member 'ARCTitleHUD::CollectionWindowWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, CollectionWindowWidget) == 0x000460, "Member 'ARCTitleHUD::CollectionWindowWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleLogoWidgetPriority) == 0x000468, "Member 'ARCTitleHUD::TitleLogoWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleLogoWidget) == 0x000470, "Member 'ARCTitleHUD::TitleLogoWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleLangaugeWidgetPriority) == 0x000478, "Member 'ARCTitleHUD::TitleLangaugeWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleLanguageWidget) == 0x000480, "Member 'ARCTitleHUD::TitleLanguageWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleChapterSelectWidgetPriority) == 0x000488, "Member 'ARCTitleHUD::TitleChapterSelectWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleChapterSelectWidget) == 0x000490, "Member 'ARCTitleHUD::TitleChapterSelectWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, ChapterSelectSceneID) == 0x000498, "Member 'ARCTitleHUD::ChapterSelectSceneID' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, ChapterSelectChapterNum) == 0x0004A0, "Member 'ARCTitleHUD::ChapterSelectChapterNum' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSaveCheckWidgetPriority) == 0x0004A4, "Member 'ARCTitleHUD::TitleSaveCheckWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSaveCheckWidget) == 0x0004A8, "Member 'ARCTitleHUD::TitleSaveCheckWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSaveCheckConnectWidgetPriority) == 0x0004B0, "Member 'ARCTitleHUD::TitleSaveCheckConnectWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSaveCheckConnectWidget) == 0x0004B8, "Member 'ARCTitleHUD::TitleSaveCheckConnectWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSubStoryWidgetPriority) == 0x0004C0, "Member 'ARCTitleHUD::TitleSubStoryWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSubStoryWidget) == 0x0004C8, "Member 'ARCTitleHUD::TitleSubStoryWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSubStoryChapter) == 0x0004D0, "Member 'ARCTitleHUD::TitleSubStoryChapter' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleSubStorySceneID) == 0x0004D4, "Member 'ARCTitleHUD::TitleSubStorySceneID' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, SubStorySelectIndex) == 0x0004DC, "Member 'ARCTitleHUD::SubStorySelectIndex' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleMenuWidgetPriority) == 0x0004E0, "Member 'ARCTitleHUD::TitleMenuWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TitleMenuWidget) == 0x0004E8, "Member 'ARCTitleHUD::TitleMenuWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, NzResultWidgetPriority) == 0x0004F0, "Member 'ARCTitleHUD::NzResultWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, NzResultWidget) == 0x0004F8, "Member 'ARCTitleHUD::NzResultWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TutorialWindowPriority) == 0x000500, "Member 'ARCTitleHUD::TutorialWindowPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TutorialWindowPath) == 0x000504, "Member 'ARCTitleHUD::TutorialWindowPath' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, TutorialWindow) == 0x000510, "Member 'ARCTitleHUD::TutorialWindow' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, GalleryWidgetPriority) == 0x000518, "Member 'ARCTitleHUD::GalleryWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, GalleryWidgetPath) == 0x00051C, "Member 'ARCTitleHUD::GalleryWidgetPath' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, GalleryWidget) == 0x000528, "Member 'ARCTitleHUD::GalleryWidget' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, LicenseWidgetPriority) == 0x000534, "Member 'ARCTitleHUD::LicenseWidgetPriority' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, LicenseWidgetPath) == 0x000538, "Member 'ARCTitleHUD::LicenseWidgetPath' has a wrong offset!");
static_assert(offsetof(ARCTitleHUD, LicenseWidget) == 0x000540, "Member 'ARCTitleHUD::LicenseWidget' has a wrong offset!");

// Class RC.RCDroneControlComponent
// 0x0110 (0x01C0 - 0x00B0)
class URCDroneControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	ERCDroneBehaviorType                          BehaviorType;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ShakeLocation;                                     // 0x00E4(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               ShakeRotator;                                      // 0x00F0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         ShakeZMovementAmount;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShakePitchAmount;                                  // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShakeYawAmount;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShakeRollAmount;                                   // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSpeedyRotation;                                 // 0x010C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedyRotationSpan;                                // 0x0110(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedyRotationSpanMax;                             // 0x0114(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedyRotationSpanMin;                             // 0x0118(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               SpeedyRotationRotator;                             // 0x011C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WalkLocation;                                      // 0x0130(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               WalkRotator;                                       // 0x013C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkMovementAmount;                                // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationWalkMovementSec;                           // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x18];                                     // 0x016C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSlopeAmount;                                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x4];                                      // 0x0188(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationWalkSlopeSec;                              // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x30];                                     // 0x0190(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCDroneControlComponent">();
	}
	static class URCDroneControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCDroneControlComponent>();
	}
};
static_assert(alignof(URCDroneControlComponent) == 0x000008, "Wrong alignment on URCDroneControlComponent");
static_assert(sizeof(URCDroneControlComponent) == 0x0001C0, "Wrong size on URCDroneControlComponent");
static_assert(offsetof(URCDroneControlComponent, BehaviorType) == 0x0000E0, "Member 'URCDroneControlComponent::BehaviorType' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakeLocation) == 0x0000E4, "Member 'URCDroneControlComponent::ShakeLocation' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakeRotator) == 0x0000F0, "Member 'URCDroneControlComponent::ShakeRotator' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakeZMovementAmount) == 0x0000FC, "Member 'URCDroneControlComponent::ShakeZMovementAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakePitchAmount) == 0x000100, "Member 'URCDroneControlComponent::ShakePitchAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakeYawAmount) == 0x000104, "Member 'URCDroneControlComponent::ShakeYawAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, ShakeRollAmount) == 0x000108, "Member 'URCDroneControlComponent::ShakeRollAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, bIsSpeedyRotation) == 0x00010C, "Member 'URCDroneControlComponent::bIsSpeedyRotation' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, SpeedyRotationSpan) == 0x000110, "Member 'URCDroneControlComponent::SpeedyRotationSpan' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, SpeedyRotationSpanMax) == 0x000114, "Member 'URCDroneControlComponent::SpeedyRotationSpanMax' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, SpeedyRotationSpanMin) == 0x000118, "Member 'URCDroneControlComponent::SpeedyRotationSpanMin' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, SpeedyRotationRotator) == 0x00011C, "Member 'URCDroneControlComponent::SpeedyRotationRotator' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, WalkLocation) == 0x000130, "Member 'URCDroneControlComponent::WalkLocation' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, WalkRotator) == 0x00013C, "Member 'URCDroneControlComponent::WalkRotator' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, WalkMovementAmount) == 0x000160, "Member 'URCDroneControlComponent::WalkMovementAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, DurationWalkMovementSec) == 0x000168, "Member 'URCDroneControlComponent::DurationWalkMovementSec' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, WalkSlopeAmount) == 0x000184, "Member 'URCDroneControlComponent::WalkSlopeAmount' has a wrong offset!");
static_assert(offsetof(URCDroneControlComponent, DurationWalkSlopeSec) == 0x00018C, "Member 'URCDroneControlComponent::DurationWalkSlopeSec' has a wrong offset!");

// Class RC.RCEffectComponent
// 0x0028 (0x00D8 - 0x00B0)
class URCEffectComponent : public UActorComponent
{
public:
	class URCEffectManager*                       EffectManager;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEffectActive(struct FRCEffectComponentData& InEffectData);
	bool EffectActivate(struct FRCEffectComponentData& InEffectData);
	bool EffectDeactivate(struct FRCEffectComponentData& InEffectData);
	bool EffectDestroy(struct FRCEffectComponentData& InEffectData);
	class FName SpawnEffectAtLocation(struct FRCEffectComponentData& InEffectData, const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const struct FVector& InScale, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectAtLocationWithManagedID(struct FRCEffectComponentData& InEffectData, class FName InManagedID, const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const struct FVector& InScale, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	class FName SpawnEffectAttached(struct FRCEffectComponentData& InEffectData, class USceneComponent* InAttachToComponent, class FName InAttachPointName, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectAttachedWithManagedID(struct FRCEffectComponentData& InEffectData, class FName InManagedID, class USceneComponent* InAttachToComponent, class FName InAttachPointName, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectRainSplashAttachedWithManagedID(struct FRCEffectComponentData& InEffectData, class FName InManagedID, class USceneComponent* InAttachToComponent, class FName InAttachPointName, class UStaticMesh* InEmitterMesh, float InOffset, float InSpawnRate, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEffectComponent">();
	}
	static class URCEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEffectComponent>();
	}
};
static_assert(alignof(URCEffectComponent) == 0x000008, "Wrong alignment on URCEffectComponent");
static_assert(sizeof(URCEffectComponent) == 0x0000D8, "Wrong size on URCEffectComponent");
static_assert(offsetof(URCEffectComponent, EffectManager) == 0x0000B0, "Member 'URCEffectComponent::EffectManager' has a wrong offset!");

// Class RC.RCMenuCollectionHint
// 0x0128 (0x0398 - 0x0270)
class URCMenuCollectionHint : public URCUserWidget
{
public:
	class UTextBlock*                             Text_Hint_000;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_000_00;                               // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_000_01;                               // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_000_02;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_000_03;                               // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_000_04;                               // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_001;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_001_00;                               // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_001_01;                               // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_001_02;                               // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_001_03;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_001_04;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_002;                                     // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_002_00;                               // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_002_01;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_002_02;                               // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_002_03;                               // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_002_04;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_003;                                     // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_003_00;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_003_01;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_003_02;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_003_03;                               // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_003_04;                               // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_004;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_004_00;                               // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_004_01;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_004_02;                               // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_004_03;                               // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Hint_Ep_004_04;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionClear*                 Icon_Clear_000;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionClear*                 Icon_Clear_001;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionClear*                 Icon_Clear_002;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionClear*                 Icon_Clear_003;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionClear*                 Icon_Clear_004;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCCollectionHint>              hintObjectArray;                                   // 0x0388(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionHint">();
	}
	static class URCMenuCollectionHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionHint>();
	}
};
static_assert(alignof(URCMenuCollectionHint) == 0x000008, "Wrong alignment on URCMenuCollectionHint");
static_assert(sizeof(URCMenuCollectionHint) == 0x000398, "Wrong size on URCMenuCollectionHint");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_000) == 0x000270, "Member 'URCMenuCollectionHint::Text_Hint_000' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_000_00) == 0x000278, "Member 'URCMenuCollectionHint::Text_Hint_Ep_000_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_000_01) == 0x000280, "Member 'URCMenuCollectionHint::Text_Hint_Ep_000_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_000_02) == 0x000288, "Member 'URCMenuCollectionHint::Text_Hint_Ep_000_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_000_03) == 0x000290, "Member 'URCMenuCollectionHint::Text_Hint_Ep_000_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_000_04) == 0x000298, "Member 'URCMenuCollectionHint::Text_Hint_Ep_000_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_001) == 0x0002A0, "Member 'URCMenuCollectionHint::Text_Hint_001' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_001_00) == 0x0002A8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_001_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_001_01) == 0x0002B0, "Member 'URCMenuCollectionHint::Text_Hint_Ep_001_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_001_02) == 0x0002B8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_001_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_001_03) == 0x0002C0, "Member 'URCMenuCollectionHint::Text_Hint_Ep_001_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_001_04) == 0x0002C8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_001_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_002) == 0x0002D0, "Member 'URCMenuCollectionHint::Text_Hint_002' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_002_00) == 0x0002D8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_002_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_002_01) == 0x0002E0, "Member 'URCMenuCollectionHint::Text_Hint_Ep_002_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_002_02) == 0x0002E8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_002_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_002_03) == 0x0002F0, "Member 'URCMenuCollectionHint::Text_Hint_Ep_002_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_002_04) == 0x0002F8, "Member 'URCMenuCollectionHint::Text_Hint_Ep_002_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_003) == 0x000300, "Member 'URCMenuCollectionHint::Text_Hint_003' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_003_00) == 0x000308, "Member 'URCMenuCollectionHint::Text_Hint_Ep_003_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_003_01) == 0x000310, "Member 'URCMenuCollectionHint::Text_Hint_Ep_003_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_003_02) == 0x000318, "Member 'URCMenuCollectionHint::Text_Hint_Ep_003_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_003_03) == 0x000320, "Member 'URCMenuCollectionHint::Text_Hint_Ep_003_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_003_04) == 0x000328, "Member 'URCMenuCollectionHint::Text_Hint_Ep_003_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_004) == 0x000330, "Member 'URCMenuCollectionHint::Text_Hint_004' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_004_00) == 0x000338, "Member 'URCMenuCollectionHint::Text_Hint_Ep_004_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_004_01) == 0x000340, "Member 'URCMenuCollectionHint::Text_Hint_Ep_004_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_004_02) == 0x000348, "Member 'URCMenuCollectionHint::Text_Hint_Ep_004_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_004_03) == 0x000350, "Member 'URCMenuCollectionHint::Text_Hint_Ep_004_03' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Text_Hint_Ep_004_04) == 0x000358, "Member 'URCMenuCollectionHint::Text_Hint_Ep_004_04' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Icon_Clear_000) == 0x000360, "Member 'URCMenuCollectionHint::Icon_Clear_000' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Icon_Clear_001) == 0x000368, "Member 'URCMenuCollectionHint::Icon_Clear_001' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Icon_Clear_002) == 0x000370, "Member 'URCMenuCollectionHint::Icon_Clear_002' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Icon_Clear_003) == 0x000378, "Member 'URCMenuCollectionHint::Icon_Clear_003' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, Icon_Clear_004) == 0x000380, "Member 'URCMenuCollectionHint::Icon_Clear_004' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionHint, hintObjectArray) == 0x000388, "Member 'URCMenuCollectionHint::hintObjectArray' has a wrong offset!");

// Class RC.RCTitleSaveCheckConnect
// 0x0040 (0x0318 - 0x02D8)
class URCTitleSaveCheckConnect : public URCUiWidgetBase
{
public:
	TArray<class UTextBlock*>                     checkTextArray;                                    // 0x02D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTextBlock*                             finalCheckText;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleSaveCheckConnectWindow*         connectWindow;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFinishedCheck;                                   // 0x0310(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCTitleSaveCheckConnectState                 State;                                             // 0x0311(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCTitleSaveCheckConnectLastInfoType          lastInfoType;                                      // 0x0312(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isTitle;                                           // 0x0313(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSaveCheckConnect">();
	}
	static class URCTitleSaveCheckConnect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSaveCheckConnect>();
	}
};
static_assert(alignof(URCTitleSaveCheckConnect) == 0x000008, "Wrong alignment on URCTitleSaveCheckConnect");
static_assert(sizeof(URCTitleSaveCheckConnect) == 0x000318, "Wrong size on URCTitleSaveCheckConnect");
static_assert(offsetof(URCTitleSaveCheckConnect, checkTextArray) == 0x0002D8, "Member 'URCTitleSaveCheckConnect::checkTextArray' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, finalCheckText) == 0x0002E8, "Member 'URCTitleSaveCheckConnect::finalCheckText' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, connectWindow) == 0x0002F0, "Member 'URCTitleSaveCheckConnect::connectWindow' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, AN_Start) == 0x0002F8, "Member 'URCTitleSaveCheckConnect::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, AN_Wait) == 0x000300, "Member 'URCTitleSaveCheckConnect::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, AN_Finish) == 0x000308, "Member 'URCTitleSaveCheckConnect::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, isFinishedCheck) == 0x000310, "Member 'URCTitleSaveCheckConnect::isFinishedCheck' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, State) == 0x000311, "Member 'URCTitleSaveCheckConnect::State' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, lastInfoType) == 0x000312, "Member 'URCTitleSaveCheckConnect::lastInfoType' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnect, isTitle) == 0x000313, "Member 'URCTitleSaveCheckConnect::isTitle' has a wrong offset!");

// Class RC.RCEffectManager
// 0x00C8 (0x00F0 - 0x0028)
class URCEffectManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRCEffectData>       EffectDataMap;                                     // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRCEffectManagedData> EffectManagedDataMap;                              // 0x0098(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEffectActive(class FName InManagedID);
	bool CheckEffectLoaded(class FName InEffectID);
	bool EffectActivate(class FName InManagedID, bool bInReset);
	bool EffectDeactivate(class FName InManagedID);
	bool EffectDestroy(class FName InManagedID);
	struct FRCEffectManagedData GetManagedData(class FName InManagedID);
	int32 GetManagedDataNum();
	bool LoadEffect(class FName InEffectID);
	void OnEffectSequenceFinished(class URCEffectSequence* InEffectSequence);
	void OnNiagaraFinished(class UNiagaraComponent* InNComponent);
	void OnParticleFinished(class UParticleSystemComponent* InPSComponent);
	bool ReleaseEffect(class FName InEffectID);
	class FName SpawnEffectAtLocation(class UObject* InWorldContextObject, class FName InEffectID, const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const struct FVector& InScale, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectAtLocationWithManagedID(class UObject* InWorldContextObject, class FName InManagedID, class FName InEffectID, const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const struct FVector& InScale, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	class FName SpawnEffectAttached(class FName InEffectID, class USceneComponent* InAttachToComponent, class FName InAttachPointName, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectAttachedWithManagedID(class FName InManagedID, class FName InEffectID, class USceneComponent* InAttachToComponent, class FName InAttachPointName, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	bool SpawnEffectRainSplashAttachedWithManagedID(class FName InManagedID, class FName InEffectID, class USceneComponent* InAttachToComponent, class FName InAttachPointName, class UStaticMesh* InEmitterMesh, float InOffset, float InSpawnRate, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEffectManager">();
	}
	static class URCEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEffectManager>();
	}
};
static_assert(alignof(URCEffectManager) == 0x000008, "Wrong alignment on URCEffectManager");
static_assert(sizeof(URCEffectManager) == 0x0000F0, "Wrong size on URCEffectManager");
static_assert(offsetof(URCEffectManager, EffectDataMap) == 0x000038, "Member 'URCEffectManager::EffectDataMap' has a wrong offset!");
static_assert(offsetof(URCEffectManager, EffectManagedDataMap) == 0x000098, "Member 'URCEffectManager::EffectManagedDataMap' has a wrong offset!");

// Class RC.RCNazoPlayableLoopLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCNazoPlayableLoopLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCNazoPlayableLoopLevelScriptActor* GetPlayableLoopLevelScriptActor();
	static bool IsInitialized();
	static bool PlayableLoopCheckFinishedBehindWallClosed();
	static bool PlayableLoopCloseBehindWall();
	static bool PlayableLoopFinishLoop();
	static int32 PlayableLoopGetWarpCount();
	static bool PlayableLoopOpenFrontWall();
	static void PlayableLoopSetFreeMoveSkipEnable(bool bEnable);
	static bool PlayableLoopWarp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoPlayableLoopLevelScriptActorBFL">();
	}
	static class URCNazoPlayableLoopLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoPlayableLoopLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCNazoPlayableLoopLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCNazoPlayableLoopLevelScriptActorBFL");
static_assert(sizeof(URCNazoPlayableLoopLevelScriptActorBFL) == 0x000028, "Wrong size on URCNazoPlayableLoopLevelScriptActorBFL");

// Class RC.RCEffectSequence
// 0x0068 (0x0090 - 0x0028)
class URCEffectSequence final : public UObject
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        AttachToComponent;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x38];                                      // 0x0048(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URCEffectSequence* InEffectSequence)> OnFinished;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class URCEffectSequence* SpawnEffectSequenceAtLocation(class UObject* InWorldContextObject, class ULevelSequence* InLevelSequence, const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const struct FVector& InScale, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);
	static class URCEffectSequence* SpawnEffectSequenceAttached(class ULevelSequence* InLevelSequence, class USceneComponent* InAttachToComponent, class FName InAttachPointName, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale, EAttachLocation InLocationType, bool bInAutoDestroy, EPSCPoolMethod InPoolingMethod);

	bool Activate(bool bInReset);
	bool Deactivate();
	bool Destroy();
	bool IsActive();
	void LevelSequenceFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEffectSequence">();
	}
	static class URCEffectSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEffectSequence>();
	}
};
static_assert(alignof(URCEffectSequence) == 0x000008, "Wrong alignment on URCEffectSequence");
static_assert(sizeof(URCEffectSequence) == 0x000090, "Wrong size on URCEffectSequence");
static_assert(offsetof(URCEffectSequence, LevelSequence) == 0x000028, "Member 'URCEffectSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(URCEffectSequence, LevelSequenceActor) == 0x000030, "Member 'URCEffectSequence::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(URCEffectSequence, LevelSequencePlayer) == 0x000038, "Member 'URCEffectSequence::LevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(URCEffectSequence, AttachToComponent) == 0x000040, "Member 'URCEffectSequence::AttachToComponent' has a wrong offset!");
static_assert(offsetof(URCEffectSequence, OnFinished) == 0x000080, "Member 'URCEffectSequence::OnFinished' has a wrong offset!");

// Class RC.RCShinigamiAnimation
// 0x00E8 (0x0110 - 0x0028)
class URCShinigamiAnimation final : public UObject
{
public:
	uint8                                         Pad_28[0xA0];                                      // 0x0028(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIComponent*                ParrentComponent;                                  // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterAnimCtrl*                   AnimeControlComp;                                  // 0x00E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimeSpeedMultiUpDown;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimeRunSpeed;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimeYawSpeed;                                     // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimeBlendTime;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimeBlendTimeIlde;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnable;                                           // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiAnimeType                         AnimeType;                                         // 0x00FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowMoveSpeed;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NowYawSpeed;                                       // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NowUpDownSpeed;                                    // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAnimation">();
	}
	static class URCShinigamiAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAnimation>();
	}
};
static_assert(alignof(URCShinigamiAnimation) == 0x000008, "Wrong alignment on URCShinigamiAnimation");
static_assert(sizeof(URCShinigamiAnimation) == 0x000110, "Wrong size on URCShinigamiAnimation");
static_assert(offsetof(URCShinigamiAnimation, ShinigamiActor) == 0x0000C8, "Member 'URCShinigamiAnimation::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, ParrentComponent) == 0x0000D0, "Member 'URCShinigamiAnimation::ParrentComponent' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, Movement) == 0x0000D8, "Member 'URCShinigamiAnimation::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeControlComp) == 0x0000E0, "Member 'URCShinigamiAnimation::AnimeControlComp' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeSpeedMultiUpDown) == 0x0000E8, "Member 'URCShinigamiAnimation::AnimeSpeedMultiUpDown' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeRunSpeed) == 0x0000EC, "Member 'URCShinigamiAnimation::AnimeRunSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeYawSpeed) == 0x0000F0, "Member 'URCShinigamiAnimation::AnimeYawSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeBlendTime) == 0x0000F4, "Member 'URCShinigamiAnimation::AnimeBlendTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeBlendTimeIlde) == 0x0000F8, "Member 'URCShinigamiAnimation::AnimeBlendTimeIlde' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, bEnable) == 0x0000FC, "Member 'URCShinigamiAnimation::bEnable' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, AnimeType) == 0x0000FD, "Member 'URCShinigamiAnimation::AnimeType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, NowMoveSpeed) == 0x000100, "Member 'URCShinigamiAnimation::NowMoveSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, NowYawSpeed) == 0x000104, "Member 'URCShinigamiAnimation::NowYawSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiAnimation, NowUpDownSpeed) == 0x000108, "Member 'URCShinigamiAnimation::NowUpDownSpeed' has a wrong offset!");

// Class RC.RCEnvironmentBFL
// 0x0000 (0x0028 - 0x0028)
class URCEnvironmentBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeAreaNameID(class FName InAreaNameID);
	static void ChangeCamera(class FName InCameraID, bool bDirect);
	static void ChangeCharacterDrawLayerList(const TArray<class FName>& IncharacterDrawLayerList);
	static void ChangeCharacterMaterialID(class ARCCharacterRender* InCharacterActor, class FName InPlayerMaterialID, bool bDirect);
	static void ChangeCharacterRainMaterialID(class ARCCharacterRender* InCharacterActor, ERCEnvironmentChangeRainType InRainType, bool bDirect);
	static void ChangeFaceFilterID(class FName InFaceFilterID);
	static void ChangeFogID(class FName InFogID, bool bDirect);
	static void ChangeMinimapID(class FName InMinimapID);
	static void ChangePlayerMoveSpeed(ERCEnvironmentChangeSpeedType InSpeedType);
	static void ChangeRainDraw(ERCEnvironmentChangeRainType InRainType);
	static void ChangeShinigamiMaterialID(class ARCCharacterRender* InCharacterActor, class FName InPlayerMaterialID, bool bDirect);
	static void ChangeWind(class FName InWindActorName, class FName InWindEventName);
	static class FName GetAreaNameID();
	static class FName GetCamera();
	static class ARCEnvironmentChangeTrigger* GetEnvironmentChangeTrigger(class FName InName);
	static class FName GetFogID();
	static class FName GetMinimapID();
	static ERCEnvironmentChangeSpeedType GetPlayerMoveSpeed();
	static ERCEnvironmentChangeRainType GetRainDraw();
	static void LoadRecovery();
	static void Reset();
	static void SearchFogActor();
	static void SetDefaultPlayerMoveType();
	static void SetDefautFogID();
	static void SetDefautMaterialD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEnvironmentBFL">();
	}
	static class URCEnvironmentBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEnvironmentBFL>();
	}
};
static_assert(alignof(URCEnvironmentBFL) == 0x000008, "Wrong alignment on URCEnvironmentBFL");
static_assert(sizeof(URCEnvironmentBFL) == 0x000028, "Wrong size on URCEnvironmentBFL");

// Class RC.RCEnvironmentChangeTrigger
// 0x0100 (0x0388 - 0x0288)
class ARCEnvironmentChangeTrigger final : public ARCActor
{
public:
	bool                                          bCheckCameraCollision;                             // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCEnvironmentChangeTrigger*            ParentTrigger;                                     // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CameraID;                                          // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCEnvironmentChangeSpeedType                 PlayerMoveSpeedType;                               // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FogID;                                             // 0x02A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CharacterMaterialID;                               // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCEnvironmentChangeRainType                  RainChangeType;                                    // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AreaNameID;                                        // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MinimapID;                                         // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCharacterDrawLayerChange;                         // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CharacterDrawLayerList;                            // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   FaceFilterID;                                      // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ChangeWindActorName;                               // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ChangeWindEventName;                               // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExitCameraID;                                      // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCEnvironmentChangeSpeedType                 ExitPlayerMoveSpeedType;                           // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExitFogID;                                         // 0x0304(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExitCharacterMaterialID;                           // 0x030C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCEnvironmentChangeRainType                  ExitRainChangeType;                                // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExitAreaNameID;                                    // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExitMinimapID;                                     // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExitCharacterDrawLayerChange;                     // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExitCharacterDrawLayerList;                        // 0x0330(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   ExitFaceFilterID;                                  // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExitChangeWindActorName;                           // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExitChangeWindEventName;                           // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         CollisionHitActorList;                             // 0x0360(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class ARCEnvironmentChangeTrigger*>    ChildTriggerList;                                  // 0x0370(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bInPlayer;                                         // 0x0380(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEnvironmentChangeTrigger">();
	}
	static class ARCEnvironmentChangeTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEnvironmentChangeTrigger>();
	}
};
static_assert(alignof(ARCEnvironmentChangeTrigger) == 0x000008, "Wrong alignment on ARCEnvironmentChangeTrigger");
static_assert(sizeof(ARCEnvironmentChangeTrigger) == 0x000388, "Wrong size on ARCEnvironmentChangeTrigger");
static_assert(offsetof(ARCEnvironmentChangeTrigger, bCheckCameraCollision) == 0x000288, "Member 'ARCEnvironmentChangeTrigger::bCheckCameraCollision' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ParentTrigger) == 0x000290, "Member 'ARCEnvironmentChangeTrigger::ParentTrigger' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, CameraID) == 0x000298, "Member 'ARCEnvironmentChangeTrigger::CameraID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, PlayerMoveSpeedType) == 0x0002A0, "Member 'ARCEnvironmentChangeTrigger::PlayerMoveSpeedType' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, FogID) == 0x0002A4, "Member 'ARCEnvironmentChangeTrigger::FogID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, CharacterMaterialID) == 0x0002AC, "Member 'ARCEnvironmentChangeTrigger::CharacterMaterialID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, RainChangeType) == 0x0002B4, "Member 'ARCEnvironmentChangeTrigger::RainChangeType' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, AreaNameID) == 0x0002B8, "Member 'ARCEnvironmentChangeTrigger::AreaNameID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, MinimapID) == 0x0002C0, "Member 'ARCEnvironmentChangeTrigger::MinimapID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, bCharacterDrawLayerChange) == 0x0002C8, "Member 'ARCEnvironmentChangeTrigger::bCharacterDrawLayerChange' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, CharacterDrawLayerList) == 0x0002D0, "Member 'ARCEnvironmentChangeTrigger::CharacterDrawLayerList' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, FaceFilterID) == 0x0002E0, "Member 'ARCEnvironmentChangeTrigger::FaceFilterID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ChangeWindActorName) == 0x0002E8, "Member 'ARCEnvironmentChangeTrigger::ChangeWindActorName' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ChangeWindEventName) == 0x0002F0, "Member 'ARCEnvironmentChangeTrigger::ChangeWindEventName' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitCameraID) == 0x0002F8, "Member 'ARCEnvironmentChangeTrigger::ExitCameraID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitPlayerMoveSpeedType) == 0x000300, "Member 'ARCEnvironmentChangeTrigger::ExitPlayerMoveSpeedType' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitFogID) == 0x000304, "Member 'ARCEnvironmentChangeTrigger::ExitFogID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitCharacterMaterialID) == 0x00030C, "Member 'ARCEnvironmentChangeTrigger::ExitCharacterMaterialID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitRainChangeType) == 0x000314, "Member 'ARCEnvironmentChangeTrigger::ExitRainChangeType' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitAreaNameID) == 0x000318, "Member 'ARCEnvironmentChangeTrigger::ExitAreaNameID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitMinimapID) == 0x000320, "Member 'ARCEnvironmentChangeTrigger::ExitMinimapID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, bExitCharacterDrawLayerChange) == 0x000328, "Member 'ARCEnvironmentChangeTrigger::bExitCharacterDrawLayerChange' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitCharacterDrawLayerList) == 0x000330, "Member 'ARCEnvironmentChangeTrigger::ExitCharacterDrawLayerList' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitFaceFilterID) == 0x000340, "Member 'ARCEnvironmentChangeTrigger::ExitFaceFilterID' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitChangeWindActorName) == 0x000348, "Member 'ARCEnvironmentChangeTrigger::ExitChangeWindActorName' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ExitChangeWindEventName) == 0x000350, "Member 'ARCEnvironmentChangeTrigger::ExitChangeWindEventName' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, bDebugDraw) == 0x000358, "Member 'ARCEnvironmentChangeTrigger::bDebugDraw' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, CollisionHitActorList) == 0x000360, "Member 'ARCEnvironmentChangeTrigger::CollisionHitActorList' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, ChildTriggerList) == 0x000370, "Member 'ARCEnvironmentChangeTrigger::ChildTriggerList' has a wrong offset!");
static_assert(offsetof(ARCEnvironmentChangeTrigger, bInPlayer) == 0x000380, "Member 'ARCEnvironmentChangeTrigger::bInPlayer' has a wrong offset!");

// Class RC.RCNazoLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCNazoLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeCheckPointScene(bool* bSuccess);
	static void ChangeCheckPointSceneAtGameOver(bool* bSuccess);
	static void ChangeFirstScene(bool* bSuccess);
	static void ChangeNextScene(bool* bSuccess);
	static void ChangeScene(bool* bSuccess, class FName SceneID);
	static class FName GetCurrentSceneID();
	static class ALevelScriptActor* GetCurrentSceneLevelScriptActor();
	static class ARCNazoLevelScriptActor* GetLevelScriptActor();
	static void GotoTitle(bool* bSuccess);
	static bool IsCurrentSceneReady();
	static bool IsCurrentSceneVisibleCompleted();
	static bool IsInitialized();
	static bool IsLoadSceneCompleted(class FName SceneID);
	static void LoadNextScene();
	static void LoadScene(class FName SceneID);
	static void ReleaseCurrentScene();
	static void ReleaseScene(class FName SceneID);
	static void StartScene(class FName SceneID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoLevelScriptActorBFL">();
	}
	static class URCNazoLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCNazoLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCNazoLevelScriptActorBFL");
static_assert(sizeof(URCNazoLevelScriptActorBFL) == 0x000028, "Wrong size on URCNazoLevelScriptActorBFL");

// Class RC.RCTitleGameModeBase
// 0x0000 (0x02D0 - 0x02D0)
class ARCTitleGameModeBase final : public ARCMenuGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGameModeBase">();
	}
	static class ARCTitleGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitleGameModeBase>();
	}
};
static_assert(alignof(ARCTitleGameModeBase) == 0x000008, "Wrong alignment on ARCTitleGameModeBase");
static_assert(sizeof(ARCTitleGameModeBase) == 0x0002D0, "Wrong size on ARCTitleGameModeBase");

// Class RC.RCEvaluationTitle
// 0x0040 (0x0318 - 0x02D8)
class URCEvaluationTitle final : public URCUiWidgetBase
{
public:
	class URCEvaluationTitleStart*                WBP_StartEvaluationVersion_New;                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCEvaluationTitleLoad*                 WBP_StartEvaluationVersion_Load;                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCEvaluationTitleWalkThrough*          WBP_StartEvaluationVersion_Walk;                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEvaluationTitleState                         State;                                             // 0x030C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETITLE_SELECT                                 selectResult;                                      // 0x0310(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCancel;                                          // 0x0314(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeData();
	void Open();
	void PlayFinishAnimation();
	void PlayStartAnimation();
	void PlayWaitAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEvaluationTitle">();
	}
	static class URCEvaluationTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEvaluationTitle>();
	}
};
static_assert(alignof(URCEvaluationTitle) == 0x000008, "Wrong alignment on URCEvaluationTitle");
static_assert(sizeof(URCEvaluationTitle) == 0x000318, "Wrong size on URCEvaluationTitle");
static_assert(offsetof(URCEvaluationTitle, WBP_StartEvaluationVersion_New) == 0x0002D8, "Member 'URCEvaluationTitle::WBP_StartEvaluationVersion_New' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, WBP_StartEvaluationVersion_Load) == 0x0002E0, "Member 'URCEvaluationTitle::WBP_StartEvaluationVersion_Load' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, WBP_StartEvaluationVersion_Walk) == 0x0002E8, "Member 'URCEvaluationTitle::WBP_StartEvaluationVersion_Walk' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, AN_Start) == 0x0002F0, "Member 'URCEvaluationTitle::AN_Start' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, AN_Wait) == 0x0002F8, "Member 'URCEvaluationTitle::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, AN_Finish) == 0x000300, "Member 'URCEvaluationTitle::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, SelectIndex) == 0x000308, "Member 'URCEvaluationTitle::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, State) == 0x00030C, "Member 'URCEvaluationTitle::State' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, selectResult) == 0x000310, "Member 'URCEvaluationTitle::selectResult' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitle, isCancel) == 0x000314, "Member 'URCEvaluationTitle::isCancel' has a wrong offset!");

// Class RC.RCEvaluationTitleLoad
// 0x0020 (0x0340 - 0x0320)
class URCEvaluationTitleLoad final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Active;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_InActive;                                       // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Pressed;                                        // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentMouseSelect;                              // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEvaluationTitleLoad">();
	}
	static class URCEvaluationTitleLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEvaluationTitleLoad>();
	}
};
static_assert(alignof(URCEvaluationTitleLoad) == 0x000008, "Wrong alignment on URCEvaluationTitleLoad");
static_assert(sizeof(URCEvaluationTitleLoad) == 0x000340, "Wrong size on URCEvaluationTitleLoad");
static_assert(offsetof(URCEvaluationTitleLoad, AN_Active) == 0x000320, "Member 'URCEvaluationTitleLoad::AN_Active' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleLoad, AN_InActive) == 0x000328, "Member 'URCEvaluationTitleLoad::AN_InActive' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleLoad, AN_Pressed) == 0x000330, "Member 'URCEvaluationTitleLoad::AN_Pressed' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleLoad, isCurrentMouseSelect) == 0x000338, "Member 'URCEvaluationTitleLoad::isCurrentMouseSelect' has a wrong offset!");

// Class RC.RCEvaluationTitleWalkThrough
// 0x0020 (0x0340 - 0x0320)
class URCEvaluationTitleWalkThrough final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Active;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_InActive;                                       // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Pressed;                                        // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentMouseSelect;                              // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEvaluationTitleWalkThrough">();
	}
	static class URCEvaluationTitleWalkThrough* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEvaluationTitleWalkThrough>();
	}
};
static_assert(alignof(URCEvaluationTitleWalkThrough) == 0x000008, "Wrong alignment on URCEvaluationTitleWalkThrough");
static_assert(sizeof(URCEvaluationTitleWalkThrough) == 0x000340, "Wrong size on URCEvaluationTitleWalkThrough");
static_assert(offsetof(URCEvaluationTitleWalkThrough, AN_Active) == 0x000320, "Member 'URCEvaluationTitleWalkThrough::AN_Active' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleWalkThrough, AN_InActive) == 0x000328, "Member 'URCEvaluationTitleWalkThrough::AN_InActive' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleWalkThrough, AN_Pressed) == 0x000330, "Member 'URCEvaluationTitleWalkThrough::AN_Pressed' has a wrong offset!");
static_assert(offsetof(URCEvaluationTitleWalkThrough, isCurrentMouseSelect) == 0x000338, "Member 'URCEvaluationTitleWalkThrough::isCurrentMouseSelect' has a wrong offset!");

// Class RC.RCEventCharacterFacialCtrl
// 0x0018 (0x0278 - 0x0260)
class URCEventCharacterFacialCtrl final : public URCCharacterFacialCtrl
{
public:
	class URCMorphBlender*                        ShellEyeMorphBlend;                                // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        ShellEyebrowMorphBlend;                            // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        ShellMouthMorphBlend;                              // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventCharacterFacialCtrl">();
	}
	static class URCEventCharacterFacialCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCEventCharacterFacialCtrl>();
	}
};
static_assert(alignof(URCEventCharacterFacialCtrl) == 0x000008, "Wrong alignment on URCEventCharacterFacialCtrl");
static_assert(sizeof(URCEventCharacterFacialCtrl) == 0x000278, "Wrong size on URCEventCharacterFacialCtrl");
static_assert(offsetof(URCEventCharacterFacialCtrl, ShellEyeMorphBlend) == 0x000260, "Member 'URCEventCharacterFacialCtrl::ShellEyeMorphBlend' has a wrong offset!");
static_assert(offsetof(URCEventCharacterFacialCtrl, ShellEyebrowMorphBlend) == 0x000268, "Member 'URCEventCharacterFacialCtrl::ShellEyebrowMorphBlend' has a wrong offset!");
static_assert(offsetof(URCEventCharacterFacialCtrl, ShellMouthMorphBlend) == 0x000270, "Member 'URCEventCharacterFacialCtrl::ShellMouthMorphBlend' has a wrong offset!");

// Class RC.RCEventTriggerBox
// 0x0020 (0x0320 - 0x0300)
class ARCEventTriggerBox : public ARCEventTrigger
{
public:
	class USceneComponent*                        Scene;                                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComp;                                           // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTriggerBox">();
	}
	static class ARCEventTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEventTriggerBox>();
	}
};
static_assert(alignof(ARCEventTriggerBox) == 0x000008, "Wrong alignment on ARCEventTriggerBox");
static_assert(sizeof(ARCEventTriggerBox) == 0x000320, "Wrong size on ARCEventTriggerBox");
static_assert(offsetof(ARCEventTriggerBox, Scene) == 0x000300, "Member 'ARCEventTriggerBox::Scene' has a wrong offset!");
static_assert(offsetof(ARCEventTriggerBox, BoxComp) == 0x000308, "Member 'ARCEventTriggerBox::BoxComp' has a wrong offset!");

// Class RC.RCEventTriggerSequencerBox
// 0x0008 (0x0328 - 0x0320)
class ARCEventTriggerSequencerBox final : public ARCEventTriggerBox
{
public:
	class URCEventTriggerSequencerComponent*      SequencerComp;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActorBeginOverlapPlayerEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnWarp();
	void OnWarpEnd();
	void OnWarpToLast();
	bool ResetSequencer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCEventTriggerSequencerBox">();
	}
	static class ARCEventTriggerSequencerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCEventTriggerSequencerBox>();
	}
};
static_assert(alignof(ARCEventTriggerSequencerBox) == 0x000008, "Wrong alignment on ARCEventTriggerSequencerBox");
static_assert(sizeof(ARCEventTriggerSequencerBox) == 0x000328, "Wrong size on ARCEventTriggerSequencerBox");
static_assert(offsetof(ARCEventTriggerSequencerBox, SequencerComp) == 0x000320, "Member 'ARCEventTriggerSequencerBox::SequencerComp' has a wrong offset!");

// Class RC.RCExtraMotionCtrl
// 0x0028 (0x00D8 - 0x00B0)
class URCExtraMotionCtrl final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPermissionExtraIdle;                              // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtraIdleNum;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtraIdleTransitionTime;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentExtraIdleTransitionTime;                    // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExtraIdleTransition;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseExtraIdleIndex;                                 // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCCharacterRender*                     CharacterBase;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCExtraMotionCtrl">();
	}
	static class URCExtraMotionCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCExtraMotionCtrl>();
	}
};
static_assert(alignof(URCExtraMotionCtrl) == 0x000008, "Wrong alignment on URCExtraMotionCtrl");
static_assert(sizeof(URCExtraMotionCtrl) == 0x0000D8, "Wrong size on URCExtraMotionCtrl");
static_assert(offsetof(URCExtraMotionCtrl, bPermissionExtraIdle) == 0x0000B8, "Member 'URCExtraMotionCtrl::bPermissionExtraIdle' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, ExtraIdleNum) == 0x0000BC, "Member 'URCExtraMotionCtrl::ExtraIdleNum' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, ExtraIdleTransitionTime) == 0x0000C0, "Member 'URCExtraMotionCtrl::ExtraIdleTransitionTime' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, CurrentExtraIdleTransitionTime) == 0x0000C4, "Member 'URCExtraMotionCtrl::CurrentExtraIdleTransitionTime' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, bExtraIdleTransition) == 0x0000C8, "Member 'URCExtraMotionCtrl::bExtraIdleTransition' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, UseExtraIdleIndex) == 0x0000CC, "Member 'URCExtraMotionCtrl::UseExtraIdleIndex' has a wrong offset!");
static_assert(offsetof(URCExtraMotionCtrl, CharacterBase) == 0x0000D0, "Member 'URCExtraMotionCtrl::CharacterBase' has a wrong offset!");

// Class RC.RCForceFeedBackBFL
// 0x0000 (0x0028 - 0x0028)
class URCForceFeedBackBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool StartForceFeedBack(class FName InID, bool bSkipPlay, bool bIgnoreTimeDilation);
	static void StopForceFeedBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCForceFeedBackBFL">();
	}
	static class URCForceFeedBackBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCForceFeedBackBFL>();
	}
};
static_assert(alignof(URCForceFeedBackBFL) == 0x000008, "Wrong alignment on URCForceFeedBackBFL");
static_assert(sizeof(URCForceFeedBackBFL) == 0x000028, "Wrong size on URCForceFeedBackBFL");

// Class RC.RCFPSCameraActor
// 0x0090 (0x0850 - 0x07C0)
class ARCFPSCameraActor final : public ARCCameraActor
{
public:
	uint8                                         Pad_7C0[0x34];                                     // 0x07C0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetX;                                           // 0x07F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetY;                                           // 0x07F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetZ;                                           // 0x07FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationSpeed;                                     // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitCheck;                                       // 0x0808(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAngleCharacter;                                   // 0x0809(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80A[0x2];                                      // 0x080A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalAngle;                                     // 0x0814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Length;                                            // 0x0818(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LengthSpeed;                                       // 0x081C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOV;                                               // 0x0820(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitAngleMin;                                     // 0x0824(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitAngleMax;                                     // 0x0828(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitVerticalAngleMin;                             // 0x082C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitVerticalAngleMax;                             // 0x0830(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitLengthMin;                                    // 0x0834(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitLengthMax;                                    // 0x0838(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSurveyType;                                       // 0x083C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83D[0x13];                                     // 0x083D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCFPSCameraActor">();
	}
	static class ARCFPSCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCFPSCameraActor>();
	}
};
static_assert(alignof(ARCFPSCameraActor) == 0x000010, "Wrong alignment on ARCFPSCameraActor");
static_assert(sizeof(ARCFPSCameraActor) == 0x000850, "Wrong size on ARCFPSCameraActor");
static_assert(offsetof(ARCFPSCameraActor, OffsetX) == 0x0007F4, "Member 'ARCFPSCameraActor::OffsetX' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, OffsetY) == 0x0007F8, "Member 'ARCFPSCameraActor::OffsetY' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, OffsetZ) == 0x0007FC, "Member 'ARCFPSCameraActor::OffsetZ' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, RotationSpeed) == 0x000800, "Member 'ARCFPSCameraActor::RotationSpeed' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, Speed) == 0x000804, "Member 'ARCFPSCameraActor::Speed' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, bLimitCheck) == 0x000808, "Member 'ARCFPSCameraActor::bLimitCheck' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, bAngleCharacter) == 0x000809, "Member 'ARCFPSCameraActor::bAngleCharacter' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, Height) == 0x00080C, "Member 'ARCFPSCameraActor::Height' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, Angle) == 0x000810, "Member 'ARCFPSCameraActor::Angle' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, VerticalAngle) == 0x000814, "Member 'ARCFPSCameraActor::VerticalAngle' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, Length) == 0x000818, "Member 'ARCFPSCameraActor::Length' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LengthSpeed) == 0x00081C, "Member 'ARCFPSCameraActor::LengthSpeed' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, FOV) == 0x000820, "Member 'ARCFPSCameraActor::FOV' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitAngleMin) == 0x000824, "Member 'ARCFPSCameraActor::LimitAngleMin' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitAngleMax) == 0x000828, "Member 'ARCFPSCameraActor::LimitAngleMax' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitVerticalAngleMin) == 0x00082C, "Member 'ARCFPSCameraActor::LimitVerticalAngleMin' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitVerticalAngleMax) == 0x000830, "Member 'ARCFPSCameraActor::LimitVerticalAngleMax' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitLengthMin) == 0x000834, "Member 'ARCFPSCameraActor::LimitLengthMin' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, LimitLengthMax) == 0x000838, "Member 'ARCFPSCameraActor::LimitLengthMax' has a wrong offset!");
static_assert(offsetof(ARCFPSCameraActor, bSurveyType) == 0x00083C, "Member 'ARCFPSCameraActor::bSurveyType' has a wrong offset!");

// Class RC.RCGameInstance
// 0x01B0 (0x0358 - 0x01A8)
class URCGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x28];                                     // 0x01A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class URCAssetManager*                        AssetManager;                                      // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCLoadingManager*                      LoadingManager;                                    // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCCharacterProxyManager*               CharacterProxyManager;                             // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URCEffectManager*                       EffectManager;                                     // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCVariableManager*                     VariableManager;                                   // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCSequenceManager*                     SequenceManager;                                   // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCBgActorManager*                      BgActorManager;                                    // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTimeManager*                         TimeManager;                                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCSoundManager*                        SoundManager;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARCMovieManager*                        MovieManager;                                      // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCSaveGameManager*                     SaveGameManager;                                   // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCAchievementManager*                  AchievementManager;                                // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCOnlineStoreManager*                  OnlineStoreManager;                                // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCInstallManager*                      InstallManager;                                    // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCActivityManager*                     ActivityManager;                                   // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCRealEventManager*                    RealEventManager;                                  // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCHardwareManager*                     HardwareManager;                                   // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCForceFeedBackManager*                ForceFeedBackManager;                              // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCRainActorManager*                    RainActorManager;                                  // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTipsManager*                         TipsManager;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCDebugAutoPlayManager*                DebugAutoPlayManager;                              // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCDebugAutoMoveManager*                DebugAutoMoveManager;                              // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCSceneChangeMediator*                 SceneChangeMediator;                               // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCScreenshotManager*                   ScreenshotManager;                                 // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IRCPlatformUserInterface> PlatformUser;                                      // 0x0300(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TScriptInterface<class IRCPlatformUserReactProcessInterface> PlatformUserReactProcess;                          // 0x0310(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x12];                                     // 0x0320(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCharacterViewerMode;                              // 0x0332(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_333[0x25];                                     // 0x0333(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CheckAssetList();
	static class URCEffectManager* GetEffectManager();
	static class ARCMovieManager* GetMovieManager();
	static TScriptInterface<class IRCPlatformUserInterface> GetPlatformUser();
	static class ARCSoundManager* GetSoundManager();
	static ERCProduction GetStatusProduction();
	static bool IsStatusDlcInstall(ERCDlcInstall InDlc);
	static bool IsStatusGalleryEnable();
	static void PrintLogBlueprintCallstack();
	static void QuitGame();
	static void SetDrawDebugPrint(bool bDebugDraw);
	static void SetStatusProduction(ERCProduction InProduction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGameInstance">();
	}
	static class URCGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCGameInstance>();
	}
};
static_assert(alignof(URCGameInstance) == 0x000008, "Wrong alignment on URCGameInstance");
static_assert(sizeof(URCGameInstance) == 0x000358, "Wrong size on URCGameInstance");
static_assert(offsetof(URCGameInstance, AssetManager) == 0x0001D0, "Member 'URCGameInstance::AssetManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, LoadingManager) == 0x0001D8, "Member 'URCGameInstance::LoadingManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, CharacterProxyManager) == 0x0001E0, "Member 'URCGameInstance::CharacterProxyManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, EffectManager) == 0x000200, "Member 'URCGameInstance::EffectManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, VariableManager) == 0x000218, "Member 'URCGameInstance::VariableManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, SequenceManager) == 0x000220, "Member 'URCGameInstance::SequenceManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, BgActorManager) == 0x000228, "Member 'URCGameInstance::BgActorManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, TimeManager) == 0x000258, "Member 'URCGameInstance::TimeManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, SoundManager) == 0x000268, "Member 'URCGameInstance::SoundManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, MovieManager) == 0x000270, "Member 'URCGameInstance::MovieManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, SaveGameManager) == 0x000280, "Member 'URCGameInstance::SaveGameManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, AchievementManager) == 0x000288, "Member 'URCGameInstance::AchievementManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, OnlineStoreManager) == 0x000290, "Member 'URCGameInstance::OnlineStoreManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, InstallManager) == 0x000298, "Member 'URCGameInstance::InstallManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, ActivityManager) == 0x0002A0, "Member 'URCGameInstance::ActivityManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, RealEventManager) == 0x0002B8, "Member 'URCGameInstance::RealEventManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, HardwareManager) == 0x0002C0, "Member 'URCGameInstance::HardwareManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, ForceFeedBackManager) == 0x0002C8, "Member 'URCGameInstance::ForceFeedBackManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, RainActorManager) == 0x0002D0, "Member 'URCGameInstance::RainActorManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, TipsManager) == 0x0002D8, "Member 'URCGameInstance::TipsManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, DebugAutoPlayManager) == 0x0002E0, "Member 'URCGameInstance::DebugAutoPlayManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, DebugAutoMoveManager) == 0x0002E8, "Member 'URCGameInstance::DebugAutoMoveManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, SceneChangeMediator) == 0x0002F0, "Member 'URCGameInstance::SceneChangeMediator' has a wrong offset!");
static_assert(offsetof(URCGameInstance, ScreenshotManager) == 0x0002F8, "Member 'URCGameInstance::ScreenshotManager' has a wrong offset!");
static_assert(offsetof(URCGameInstance, PlatformUser) == 0x000300, "Member 'URCGameInstance::PlatformUser' has a wrong offset!");
static_assert(offsetof(URCGameInstance, PlatformUserReactProcess) == 0x000310, "Member 'URCGameInstance::PlatformUserReactProcess' has a wrong offset!");
static_assert(offsetof(URCGameInstance, bCharacterViewerMode) == 0x000332, "Member 'URCGameInstance::bCharacterViewerMode' has a wrong offset!");

// Class RC.RCGrassRipple
// 0x0060 (0x0280 - 0x0220)
class ARCGrassRipple final : public AActor
{
public:
	float                                         Radius;                                            // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BindingDuration;                                   // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleSpeed;                                       // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleInterval;                                    // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Waveform;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Attenuation;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedScale;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DeformCurve;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RippleRadius;                                      // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BindingBlend;                                      // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARCGrassRippleTransformer*>      GrassRippleTransformer;                            // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         TickDelta;                                         // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BindingTimer;                                      // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateGrassTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassRipple">();
	}
	static class ARCGrassRipple* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassRipple>();
	}
};
static_assert(alignof(ARCGrassRipple) == 0x000008, "Wrong alignment on ARCGrassRipple");
static_assert(sizeof(ARCGrassRipple) == 0x000280, "Wrong size on ARCGrassRipple");
static_assert(offsetof(ARCGrassRipple, Radius) == 0x000220, "Member 'ARCGrassRipple::Radius' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, BindingDuration) == 0x000224, "Member 'ARCGrassRipple::BindingDuration' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, RippleSpeed) == 0x000228, "Member 'ARCGrassRipple::RippleSpeed' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, RippleInterval) == 0x00022C, "Member 'ARCGrassRipple::RippleInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, Waveform) == 0x000230, "Member 'ARCGrassRipple::Waveform' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, Attenuation) == 0x000238, "Member 'ARCGrassRipple::Attenuation' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, SpeedScale) == 0x000240, "Member 'ARCGrassRipple::SpeedScale' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, DeformCurve) == 0x000248, "Member 'ARCGrassRipple::DeformCurve' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, RippleRadius) == 0x000250, "Member 'ARCGrassRipple::RippleRadius' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, BindingBlend) == 0x000260, "Member 'ARCGrassRipple::BindingBlend' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, GrassRippleTransformer) == 0x000268, "Member 'ARCGrassRipple::GrassRippleTransformer' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, TickDelta) == 0x000278, "Member 'ARCGrassRipple::TickDelta' has a wrong offset!");
static_assert(offsetof(ARCGrassRipple, BindingTimer) == 0x00027C, "Member 'ARCGrassRipple::BindingTimer' has a wrong offset!");

// Class RC.RCGrassRippleTransformer
// 0x0008 (0x0288 - 0x0280)
class ARCGrassRippleTransformer final : public ARCGrassTransformer
{
public:
	class ARCGrassRipple*                         GrassRipple;                                       // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void MakeOriginalTransformArray(TMap<int32, struct FRCGrassTransformParameter>* OutTransformParameters);
	void UpdateGrassTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassRippleTransformer">();
	}
	static class ARCGrassRippleTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassRippleTransformer>();
	}
};
static_assert(alignof(ARCGrassRippleTransformer) == 0x000008, "Wrong alignment on ARCGrassRippleTransformer");
static_assert(sizeof(ARCGrassRippleTransformer) == 0x000288, "Wrong size on ARCGrassRippleTransformer");
static_assert(offsetof(ARCGrassRippleTransformer, GrassRipple) == 0x000280, "Member 'ARCGrassRippleTransformer::GrassRipple' has a wrong offset!");

// Class RC.RCGrassSweepTransformer
// 0x0070 (0x02F0 - 0x0280)
class ARCGrassSweepTransformer final : public ARCGrassTransformer
{
public:
	class ARCGrassSweep*                          GrassSweep;                                        // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLimit;                                     // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BindingDuration;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleSpeed;                                       // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleInterval;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Waveform;                                          // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Attenuation;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedScale;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FormingDirection;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DeformCurve;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RippleRadius;                                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         RippleGenerateTimer;                               // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeformTimer;                                       // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviouseGrassSweepLocation;                       // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static struct FRotator CalcLookTiltRotator(const struct FVector& TargetDirection, float RotationAngle);

	void AppendInteractGrasses();
	void DeformInitialize();
	void UpdateGrassDeform();
	void UpdateGrassTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCGrassSweepTransformer">();
	}
	static class ARCGrassSweepTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCGrassSweepTransformer>();
	}
};
static_assert(alignof(ARCGrassSweepTransformer) == 0x000008, "Wrong alignment on ARCGrassSweepTransformer");
static_assert(sizeof(ARCGrassSweepTransformer) == 0x0002F0, "Wrong size on ARCGrassSweepTransformer");
static_assert(offsetof(ARCGrassSweepTransformer, GrassSweep) == 0x000280, "Member 'ARCGrassSweepTransformer::GrassSweep' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, Radius) == 0x000288, "Member 'ARCGrassSweepTransformer::Radius' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, Thickness) == 0x00028C, "Member 'ARCGrassSweepTransformer::Thickness' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, RotationLimit) == 0x000290, "Member 'ARCGrassSweepTransformer::RotationLimit' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, BindingDuration) == 0x000294, "Member 'ARCGrassSweepTransformer::BindingDuration' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, RippleSpeed) == 0x000298, "Member 'ARCGrassSweepTransformer::RippleSpeed' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, RippleInterval) == 0x00029C, "Member 'ARCGrassSweepTransformer::RippleInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, Waveform) == 0x0002A0, "Member 'ARCGrassSweepTransformer::Waveform' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, Attenuation) == 0x0002A8, "Member 'ARCGrassSweepTransformer::Attenuation' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, SpeedScale) == 0x0002B0, "Member 'ARCGrassSweepTransformer::SpeedScale' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, FormingDirection) == 0x0002B8, "Member 'ARCGrassSweepTransformer::FormingDirection' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, DeformCurve) == 0x0002C0, "Member 'ARCGrassSweepTransformer::DeformCurve' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, RippleRadius) == 0x0002C8, "Member 'ARCGrassSweepTransformer::RippleRadius' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, RippleGenerateTimer) == 0x0002D8, "Member 'ARCGrassSweepTransformer::RippleGenerateTimer' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, DeformTimer) == 0x0002DC, "Member 'ARCGrassSweepTransformer::DeformTimer' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, UpdateInterval) == 0x0002E0, "Member 'ARCGrassSweepTransformer::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ARCGrassSweepTransformer, PreviouseGrassSweepLocation) == 0x0002E4, "Member 'ARCGrassSweepTransformer::PreviouseGrassSweepLocation' has a wrong offset!");

// Class RC.RCHardwareWindows
// 0x0000 (0x0028 - 0x0028)
class URCHardwareWindows final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCHardwareWindows">();
	}
	static class URCHardwareWindows* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCHardwareWindows>();
	}
};
static_assert(alignof(URCHardwareWindows) == 0x000008, "Wrong alignment on URCHardwareWindows");
static_assert(sizeof(URCHardwareWindows) == 0x000028, "Wrong size on URCHardwareWindows");

// Class RC.RCHUDLoadComponent
// 0x0078 (0x0128 - 0x00B0)
class URCHUDLoadComponent final : public UActorComponent
{
public:
	class ARCUiFaderHUD*                          FaderHUD;                                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadStarted;                                      // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadAllWBPsCompleted;                             // 0x00BA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB[0x45];                                      // 0x00BB(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadingWidgetsCompleted;                          // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCUiWidgetBase*>                LoadingWidgets;                                    // 0x0108(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnLoadCompleted;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCHUDLoadComponent">();
	}
	static class URCHUDLoadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCHUDLoadComponent>();
	}
};
static_assert(alignof(URCHUDLoadComponent) == 0x000008, "Wrong alignment on URCHUDLoadComponent");
static_assert(sizeof(URCHUDLoadComponent) == 0x000128, "Wrong size on URCHUDLoadComponent");
static_assert(offsetof(URCHUDLoadComponent, FaderHUD) == 0x0000B0, "Member 'URCHUDLoadComponent::FaderHUD' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, bInitialized) == 0x0000B8, "Member 'URCHUDLoadComponent::bInitialized' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, bLoadStarted) == 0x0000B9, "Member 'URCHUDLoadComponent::bLoadStarted' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, bLoadAllWBPsCompleted) == 0x0000BA, "Member 'URCHUDLoadComponent::bLoadAllWBPsCompleted' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, bLoadingWidgetsCompleted) == 0x000100, "Member 'URCHUDLoadComponent::bLoadingWidgetsCompleted' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, LoadingWidgets) == 0x000108, "Member 'URCHUDLoadComponent::LoadingWidgets' has a wrong offset!");
static_assert(offsetof(URCHUDLoadComponent, OnLoadCompleted) == 0x000118, "Member 'URCHUDLoadComponent::OnLoadCompleted' has a wrong offset!");

// Class RC.RCInputManager
// 0x0090 (0x00B8 - 0x0028)
class URCInputManager final : public UObject
{
public:
	class URCKeyTypeManager*                      KeyTypeManager;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCKeyInfo*>                     KeyInfoList;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ARCPlayerController*                    PlayerController;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BackDeltaTime;                                     // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputPlatform                              InputPlatform;                                     // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCInputHardwareDrawType                      InputHardwareDrawType;                             // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMouseMoveCkeck;                                   // 0x004E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MousePosition;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MouseMove;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MouseScreenPosition;                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FKey>                           AnyKeysPadList;                                    // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FKey>                           AnyKeysKeyboardList;                               // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRCInputMode>                   InputModeList;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	ERCInputMode                                  InputMode;                                         // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawMouseCursol;                                  // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A[0x1E];                                      // 0x009A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInputManager">();
	}
	static class URCInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInputManager>();
	}
};
static_assert(alignof(URCInputManager) == 0x000008, "Wrong alignment on URCInputManager");
static_assert(sizeof(URCInputManager) == 0x0000B8, "Wrong size on URCInputManager");
static_assert(offsetof(URCInputManager, KeyTypeManager) == 0x000028, "Member 'URCInputManager::KeyTypeManager' has a wrong offset!");
static_assert(offsetof(URCInputManager, KeyInfoList) == 0x000030, "Member 'URCInputManager::KeyInfoList' has a wrong offset!");
static_assert(offsetof(URCInputManager, PlayerController) == 0x000040, "Member 'URCInputManager::PlayerController' has a wrong offset!");
static_assert(offsetof(URCInputManager, BackDeltaTime) == 0x000048, "Member 'URCInputManager::BackDeltaTime' has a wrong offset!");
static_assert(offsetof(URCInputManager, InputPlatform) == 0x00004C, "Member 'URCInputManager::InputPlatform' has a wrong offset!");
static_assert(offsetof(URCInputManager, InputHardwareDrawType) == 0x00004D, "Member 'URCInputManager::InputHardwareDrawType' has a wrong offset!");
static_assert(offsetof(URCInputManager, bMouseMoveCkeck) == 0x00004E, "Member 'URCInputManager::bMouseMoveCkeck' has a wrong offset!");
static_assert(offsetof(URCInputManager, MousePosition) == 0x000050, "Member 'URCInputManager::MousePosition' has a wrong offset!");
static_assert(offsetof(URCInputManager, MouseMove) == 0x000058, "Member 'URCInputManager::MouseMove' has a wrong offset!");
static_assert(offsetof(URCInputManager, MouseScreenPosition) == 0x000060, "Member 'URCInputManager::MouseScreenPosition' has a wrong offset!");
static_assert(offsetof(URCInputManager, AnyKeysPadList) == 0x000068, "Member 'URCInputManager::AnyKeysPadList' has a wrong offset!");
static_assert(offsetof(URCInputManager, AnyKeysKeyboardList) == 0x000078, "Member 'URCInputManager::AnyKeysKeyboardList' has a wrong offset!");
static_assert(offsetof(URCInputManager, InputModeList) == 0x000088, "Member 'URCInputManager::InputModeList' has a wrong offset!");
static_assert(offsetof(URCInputManager, InputMode) == 0x000098, "Member 'URCInputManager::InputMode' has a wrong offset!");
static_assert(offsetof(URCInputManager, bDrawMouseCursol) == 0x000099, "Member 'URCInputManager::bDrawMouseCursol' has a wrong offset!");

// Class RC.RCInstallInterface
// 0x0000 (0x0028 - 0x0028)
class URCInstallInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInstallInterface">();
	}
	static class URCInstallInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInstallInterface>();
	}
};
static_assert(alignof(URCInstallInterface) == 0x000008, "Wrong alignment on URCInstallInterface");
static_assert(sizeof(URCInstallInterface) == 0x000028, "Wrong size on URCInstallInterface");

// Class RC.RCInstallMonitorXboxSX
// 0x0008 (0x0030 - 0x0028)
class URCInstallMonitorXboxSX final : public URCInstallInterface
{
public:
	bool                                          bIsAllChunkInstalled;                              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInstallMonitorXboxSX">();
	}
	static class URCInstallMonitorXboxSX* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInstallMonitorXboxSX>();
	}
};
static_assert(alignof(URCInstallMonitorXboxSX) == 0x000008, "Wrong alignment on URCInstallMonitorXboxSX");
static_assert(sizeof(URCInstallMonitorXboxSX) == 0x000030, "Wrong size on URCInstallMonitorXboxSX");
static_assert(offsetof(URCInstallMonitorXboxSX, bIsAllChunkInstalled) == 0x000028, "Member 'URCInstallMonitorXboxSX::bIsAllChunkInstalled' has a wrong offset!");

// Class RC.RCInteractiveFoliageComponent
// 0x0100 (0x07B0 - 0x06B0)
class URCInteractiveFoliageComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	TArray<struct FTransform>                     OriginalInstanceTransforms;                        // 0x06A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUnDeformAtFinished;                               // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B9[0x7];                                      // 0x06B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class ARCGrassTransformer*>       Transformers;                                      // 0x06C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x50];                                     // 0x0710(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            WaitingToResumeGrowList;                           // 0x0760(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void AddGrassStatus(int32 InstanceIndex, ERCGrassStatus Status);
	void AddGrassTransformer(int32 InstanceIndex, class ARCGrassTransformer* Transformer);
	class ARCGrassTransformer* GetGrassTransformer(int32 InstanceIndex);
	TArray<int32> GetInstancesOverlappingMultiSphereTrace_Hierarchial(const struct FVector& Start, const struct FVector& End, float Radius);
	TArray<int32> GetInstancesOverlappingMultiSphereTrace_InstancedStaticMesh(const struct FVector& Start, const struct FVector& End, float Radius);
	bool IsGrassChangingTransform(int32 InstanceIndex);
	bool IsGrassDeformed(int32 InstanceIndex);
	bool IsGrassFreshlyDeformed(int32 InstanceIndex);
	bool IsGrassTrampled(int32 InstanceIndex);
	bool IsGrassUnDeforming(int32 InstanceIndex);
	bool IsGrassUnTrampling(int32 InstanceIndex);
	void RemoveGrassStatus(int32 InstanceIndex, ERCGrassStatus Status);
	void RemoveGrassTransformer(int32 InstanceIndex);
	void SetupOriginalTransformsToDevidedComponents(const struct FVector& UpperLeft, float ChunkSize, int32 ChunkAmountX, TArray<class URCInteractiveFoliageComponent*>& ChunkedComponents);
	void StopUpdateTransformerInstances(const TArray<int32>& Instances);

	float GetGrassWaitingToResumeGrowAlpha(int32 InstanceIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInteractiveFoliageComponent">();
	}
	static class URCInteractiveFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCInteractiveFoliageComponent>();
	}
};
static_assert(alignof(URCInteractiveFoliageComponent) == 0x000010, "Wrong alignment on URCInteractiveFoliageComponent");
static_assert(sizeof(URCInteractiveFoliageComponent) == 0x0007B0, "Wrong size on URCInteractiveFoliageComponent");
static_assert(offsetof(URCInteractiveFoliageComponent, OriginalInstanceTransforms) == 0x0006A8, "Member 'URCInteractiveFoliageComponent::OriginalInstanceTransforms' has a wrong offset!");
static_assert(offsetof(URCInteractiveFoliageComponent, bUnDeformAtFinished) == 0x0006B8, "Member 'URCInteractiveFoliageComponent::bUnDeformAtFinished' has a wrong offset!");
static_assert(offsetof(URCInteractiveFoliageComponent, Transformers) == 0x0006C0, "Member 'URCInteractiveFoliageComponent::Transformers' has a wrong offset!");
static_assert(offsetof(URCInteractiveFoliageComponent, WaitingToResumeGrowList) == 0x000760, "Member 'URCInteractiveFoliageComponent::WaitingToResumeGrowList' has a wrong offset!");

// Class RC.RCInterpolationTPSCamera
// 0x0000 (0x0950 - 0x0950)
class ARCInterpolationTPSCamera final : public ARCTPSCamera
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCInterpolationTPSCamera">();
	}
	static class ARCInterpolationTPSCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCInterpolationTPSCamera>();
	}
};
static_assert(alignof(ARCInterpolationTPSCamera) == 0x000010, "Wrong alignment on ARCInterpolationTPSCamera");
static_assert(sizeof(ARCInterpolationTPSCamera) == 0x000950, "Wrong size on ARCInterpolationTPSCamera");

// Class RC.RCKeyTypeManager
// 0x0038 (0x0060 - 0x0028)
class URCKeyTypeManager final : public UObject
{
public:
	bool                                          bIsInit;                                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERCInputKeyConfigType>                 InputKeyTypeList;                                  // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FRCKeyConfigInfo                       KeyConfigInfo;                                     // 0x0040(0x0020)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCKeyTypeManager">();
	}
	static class URCKeyTypeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCKeyTypeManager>();
	}
};
static_assert(alignof(URCKeyTypeManager) == 0x000008, "Wrong alignment on URCKeyTypeManager");
static_assert(sizeof(URCKeyTypeManager) == 0x000060, "Wrong size on URCKeyTypeManager");
static_assert(offsetof(URCKeyTypeManager, bIsInit) == 0x000028, "Member 'URCKeyTypeManager::bIsInit' has a wrong offset!");
static_assert(offsetof(URCKeyTypeManager, InputKeyTypeList) == 0x000030, "Member 'URCKeyTypeManager::InputKeyTypeList' has a wrong offset!");
static_assert(offsetof(URCKeyTypeManager, KeyConfigInfo) == 0x000040, "Member 'URCKeyTypeManager::KeyConfigInfo' has a wrong offset!");

// Class RC.RCLevel
// 0x0000 (0x0028 - 0x0028)
class URCLevel final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeGameLevel(int32 InChapter, class FName InScene);
	static bool ChangeTitle();
	static void SetAllMeshVisible(bool bVisible, bool bIsActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLevel">();
	}
	static class URCLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCLevel>();
	}
};
static_assert(alignof(URCLevel) == 0x000008, "Wrong alignment on URCLevel");
static_assert(sizeof(URCLevel) == 0x000028, "Wrong size on URCLevel");

// Class RC.RCLevelSaveSetting
// 0x0048 (0x0070 - 0x0028)
class URCLevelSaveSetting final : public UObject
{
public:
	struct FRCLevelSave                           LevelSave;                                         // 0x0028(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLevelSaveSetting">();
	}
	static class URCLevelSaveSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCLevelSaveSetting>();
	}
};
static_assert(alignof(URCLevelSaveSetting) == 0x000008, "Wrong alignment on URCLevelSaveSetting");
static_assert(sizeof(URCLevelSaveSetting) == 0x000070, "Wrong size on URCLevelSaveSetting");
static_assert(offsetof(URCLevelSaveSetting, LevelSave) == 0x000028, "Member 'URCLevelSaveSetting::LevelSave' has a wrong offset!");

// Class RC.RCLevelStreamingDynamic
// 0x0000 (0x0150 - 0x0150)
class URCLevelStreamingDynamic final : public ULevelStreaming
{
public:
	uint8                                         bInitiallyLoaded : 1;                              // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bInitiallyVisible : 1;                             // 0x0148(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URCLevelStreamingDynamic* LoadLevelInstance(class UObject* WorldContextObject, const class FString& LevelName, bool bInInitiallyVisible, bool* bOutSuccess);
	static void UnLoadLevelInstance(class UObject* WorldContextObject, class URCLevelStreamingDynamic* StreamingLevel, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLevelStreamingDynamic">();
	}
	static class URCLevelStreamingDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCLevelStreamingDynamic>();
	}
};
static_assert(alignof(URCLevelStreamingDynamic) == 0x000010, "Wrong alignment on URCLevelStreamingDynamic");
static_assert(sizeof(URCLevelStreamingDynamic) == 0x000150, "Wrong size on URCLevelStreamingDynamic");

// Class RC.RCLoadingManager
// 0x0060 (0x0088 - 0x0028)
class URCLoadingManager final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTimer*                               LoadingTimer;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLoadingManager">();
	}
	static class URCLoadingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCLoadingManager>();
	}
};
static_assert(alignof(URCLoadingManager) == 0x000008, "Wrong alignment on URCLoadingManager");
static_assert(sizeof(URCLoadingManager) == 0x000088, "Wrong size on URCLoadingManager");
static_assert(offsetof(URCLoadingManager, LoadingTimer) == 0x000068, "Member 'URCLoadingManager::LoadingTimer' has a wrong offset!");

// Class RC.RCText3DActor
// 0x0018 (0x0238 - 0x0220)
class ARCText3DActor : public AActor
{
public:
	class FName                                   ActorName;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCText3DComponent*                     Text3DComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialize;                                       // 0x0230(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleActor;                                     // 0x0232(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPause;                                            // 0x0233(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetText();
	void GetTextSize(struct FVector* OutTextSize);
	bool IsPause();
	bool IsVisibility();
	void SetPause(bool bInPause, bool bDirect);
	void SetVisibility(bool bInVisible, bool bDirect);
	void SetWidth(float Width, bool bActorScale, bool bExceptJA);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCText3DActor">();
	}
	static class ARCText3DActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCText3DActor>();
	}
};
static_assert(alignof(ARCText3DActor) == 0x000008, "Wrong alignment on ARCText3DActor");
static_assert(sizeof(ARCText3DActor) == 0x000238, "Wrong size on ARCText3DActor");
static_assert(offsetof(ARCText3DActor, ActorName) == 0x000220, "Member 'ARCText3DActor::ActorName' has a wrong offset!");
static_assert(offsetof(ARCText3DActor, Text3DComponent) == 0x000228, "Member 'ARCText3DActor::Text3DComponent' has a wrong offset!");
static_assert(offsetof(ARCText3DActor, bInitialize) == 0x000230, "Member 'ARCText3DActor::bInitialize' has a wrong offset!");
static_assert(offsetof(ARCText3DActor, bVisible) == 0x000231, "Member 'ARCText3DActor::bVisible' has a wrong offset!");
static_assert(offsetof(ARCText3DActor, bVisibleActor) == 0x000232, "Member 'ARCText3DActor::bVisibleActor' has a wrong offset!");
static_assert(offsetof(ARCText3DActor, bPause) == 0x000233, "Member 'ARCText3DActor::bPause' has a wrong offset!");

// Class RC.RCLocalizeText3DActor
// 0x0010 (0x0248 - 0x0238)
class ARCLocalizeText3DActor : public ARCText3DActor
{
public:
	class FName                                   TextID;                                            // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTextIdChanged;                                    // 0x0240(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetTextID();
	void SetTextID(class FName InTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCLocalizeText3DActor">();
	}
	static class ARCLocalizeText3DActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCLocalizeText3DActor>();
	}
};
static_assert(alignof(ARCLocalizeText3DActor) == 0x000008, "Wrong alignment on ARCLocalizeText3DActor");
static_assert(sizeof(ARCLocalizeText3DActor) == 0x000248, "Wrong size on ARCLocalizeText3DActor");
static_assert(offsetof(ARCLocalizeText3DActor, TextID) == 0x000238, "Member 'ARCLocalizeText3DActor::TextID' has a wrong offset!");
static_assert(offsetof(ARCLocalizeText3DActor, bTextIdChanged) == 0x000240, "Member 'ARCLocalizeText3DActor::bTextIdChanged' has a wrong offset!");

// Class RC.RCMapMoveEventTrigger
// 0x0008 (0x0308 - 0x0300)
class ARCMapMoveEventTrigger final : public ARCEventTrigger
{
public:
	ERCRealEventMapConnectStatus                  MoveConnectStatus;                                 // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMapMoveEventTrigger">();
	}
	static class ARCMapMoveEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMapMoveEventTrigger>();
	}
};
static_assert(alignof(ARCMapMoveEventTrigger) == 0x000008, "Wrong alignment on ARCMapMoveEventTrigger");
static_assert(sizeof(ARCMapMoveEventTrigger) == 0x000308, "Wrong size on ARCMapMoveEventTrigger");
static_assert(offsetof(ARCMapMoveEventTrigger, MoveConnectStatus) == 0x000300, "Member 'ARCMapMoveEventTrigger::MoveConnectStatus' has a wrong offset!");

// Class RC.RCMenuButtonChip
// 0x0048 (0x0328 - 0x02E0)
class URCMenuButtonChip final : public URCMenuWidget
{
public:
	class UTextLayoutWidget*                      Caption;                                           // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Text;                                              // 0x02E8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsDisabled;                                       // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDecided;                                         // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeDecide();
	void ChangeNormal();
	void ChangeSelect();
	void OnChangeDecide();
	void OnChangeDisable();
	void OnChangeNormal();
	void OnChangeSelect();
	void OnDecideHideStarted();
	void OnDisableHideStarted();
	void OnDisableShowStarted();
	void OnNormalHideStarted();
	void OnNormalShowStarted();
	void OnSelectHideStarted();
	void OnValueDownKey();
	void OnValueMax();
	void OnValueMin();
	void OnValueNonMax();
	void OnValueNonMin();
	void OnValueUpKey();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuButtonChip">();
	}
	static class URCMenuButtonChip* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuButtonChip>();
	}
};
static_assert(alignof(URCMenuButtonChip) == 0x000008, "Wrong alignment on URCMenuButtonChip");
static_assert(sizeof(URCMenuButtonChip) == 0x000328, "Wrong size on URCMenuButtonChip");
static_assert(offsetof(URCMenuButtonChip, Caption) == 0x0002E0, "Member 'URCMenuButtonChip::Caption' has a wrong offset!");
static_assert(offsetof(URCMenuButtonChip, Text) == 0x0002E8, "Member 'URCMenuButtonChip::Text' has a wrong offset!");
static_assert(offsetof(URCMenuButtonChip, bIsDisabled) == 0x000300, "Member 'URCMenuButtonChip::bIsDisabled' has a wrong offset!");
static_assert(offsetof(URCMenuButtonChip, OnDecided) == 0x000308, "Member 'URCMenuButtonChip::OnDecided' has a wrong offset!");

// Class RC.RCMenuButtonText
// 0x0090 (0x03B0 - 0x0320)
class URCMenuButtonText final : public URCMenuButton
{
public:
	class FText                                   ItemListText;                                      // 0x0320(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x78];                                     // 0x0338(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNextItem();
	void OnPreviousItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuButtonText">();
	}
	static class URCMenuButtonText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuButtonText>();
	}
};
static_assert(alignof(URCMenuButtonText) == 0x000008, "Wrong alignment on URCMenuButtonText");
static_assert(sizeof(URCMenuButtonText) == 0x0003B0, "Wrong size on URCMenuButtonText");
static_assert(offsetof(URCMenuButtonText, ItemListText) == 0x000320, "Member 'URCMenuButtonText::ItemListText' has a wrong offset!");

// Class RC.RCMenuCollection
// 0x0070 (0x0368 - 0x02F8)
class URCMenuCollection : public URCMenuManager
{
public:
	class URCMenuCollectionFace*                  Menu_Collect_Face;                                 // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionList*                  Menu_Collect_List;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionHint*                  Menu_Collect_Hint;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionFigure*                Menu_Collect_Figure;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuCommonTab*                     Menu_Com_Tab;                                      // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollectionState                              CurrentState;                                      // 0x0338(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDialigType                                   dialogType;                                        // 0x033C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         selectCharaIndex;                                  // 0x0340(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           charaIDArray;                                      // 0x0348(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         selectStoryIndex;                                  // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInitialized;                                     // 0x035C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x035D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCancel;                                          // 0x035E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isComebackStoryScene;                              // 0x035F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isUseGenericWindow;                                // 0x0360(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTutorial;                                        // 0x0361(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isJumpCollection;                                  // 0x0362(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_363[0x5];                                      // 0x0363(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* CollectionSelectNavigation(EUINavigation InNavigation);
	void PageJump(int32 InPageIndex);
	void PageNext();
	void PagePrev();
	void PushDecide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollection">();
	}
	static class URCMenuCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollection>();
	}
};
static_assert(alignof(URCMenuCollection) == 0x000008, "Wrong alignment on URCMenuCollection");
static_assert(sizeof(URCMenuCollection) == 0x000368, "Wrong size on URCMenuCollection");
static_assert(offsetof(URCMenuCollection, Menu_Collect_Face) == 0x0002F8, "Member 'URCMenuCollection::Menu_Collect_Face' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, Menu_Collect_List) == 0x000300, "Member 'URCMenuCollection::Menu_Collect_List' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, Menu_Collect_Hint) == 0x000308, "Member 'URCMenuCollection::Menu_Collect_Hint' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, Menu_Collect_Figure) == 0x000310, "Member 'URCMenuCollection::Menu_Collect_Figure' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, Menu_Com_Tab) == 0x000318, "Member 'URCMenuCollection::Menu_Com_Tab' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, AN_Start) == 0x000320, "Member 'URCMenuCollection::AN_Start' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, AN_Wait) == 0x000328, "Member 'URCMenuCollection::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, AN_Finish) == 0x000330, "Member 'URCMenuCollection::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, CurrentState) == 0x000338, "Member 'URCMenuCollection::CurrentState' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, dialogType) == 0x00033C, "Member 'URCMenuCollection::dialogType' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, selectCharaIndex) == 0x000340, "Member 'URCMenuCollection::selectCharaIndex' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, charaIDArray) == 0x000348, "Member 'URCMenuCollection::charaIDArray' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, selectStoryIndex) == 0x000358, "Member 'URCMenuCollection::selectStoryIndex' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, IsInitialized) == 0x00035C, "Member 'URCMenuCollection::IsInitialized' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, bListLoop) == 0x00035D, "Member 'URCMenuCollection::bListLoop' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, isCancel) == 0x00035E, "Member 'URCMenuCollection::isCancel' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, isComebackStoryScene) == 0x00035F, "Member 'URCMenuCollection::isComebackStoryScene' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, isUseGenericWindow) == 0x000360, "Member 'URCMenuCollection::isUseGenericWindow' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, IsTutorial) == 0x000361, "Member 'URCMenuCollection::IsTutorial' has a wrong offset!");
static_assert(offsetof(URCMenuCollection, isJumpCollection) == 0x000362, "Member 'URCMenuCollection::isJumpCollection' has a wrong offset!");

// Class RC.RCMenuCollectionClear
// 0x0020 (0x0290 - 0x0270)
class URCMenuCollectionClear : public URCUserWidget
{
public:
	class UImage*                                 Icon_Clear;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Start;                                       // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On;                                             // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionClear">();
	}
	static class URCMenuCollectionClear* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionClear>();
	}
};
static_assert(alignof(URCMenuCollectionClear) == 0x000008, "Wrong alignment on URCMenuCollectionClear");
static_assert(sizeof(URCMenuCollectionClear) == 0x000290, "Wrong size on URCMenuCollectionClear");
static_assert(offsetof(URCMenuCollectionClear, Icon_Clear) == 0x000270, "Member 'URCMenuCollectionClear::Icon_Clear' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionClear, AN_On_Start) == 0x000278, "Member 'URCMenuCollectionClear::AN_On_Start' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionClear, AN_On) == 0x000280, "Member 'URCMenuCollectionClear::AN_On' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionClear, AN_Off) == 0x000288, "Member 'URCMenuCollectionClear::AN_Off' has a wrong offset!");

// Class RC.RCMenuCollectionFigure
// 0x0018 (0x0288 - 0x0270)
class URCMenuCollectionFigure : public URCUserWidget
{
public:
	class UImage*                                 Figure_Dummy_000;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_FigureName;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Figure_Number;                                // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionFigure">();
	}
	static class URCMenuCollectionFigure* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionFigure>();
	}
};
static_assert(alignof(URCMenuCollectionFigure) == 0x000008, "Wrong alignment on URCMenuCollectionFigure");
static_assert(sizeof(URCMenuCollectionFigure) == 0x000288, "Wrong size on URCMenuCollectionFigure");
static_assert(offsetof(URCMenuCollectionFigure, Figure_Dummy_000) == 0x000270, "Member 'URCMenuCollectionFigure::Figure_Dummy_000' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionFigure, Text_FigureName) == 0x000278, "Member 'URCMenuCollectionFigure::Text_FigureName' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionFigure, Text_Figure_Number) == 0x000280, "Member 'URCMenuCollectionFigure::Text_Figure_Number' has a wrong offset!");

// Class RC.RCMenuCollectionLayout
// 0x0030 (0x0308 - 0x02D8)
class URCMenuCollectionLayout : public URCUiWidgetBase
{
public:
	class URCUiMenuBackground*                    Menu_BackGround;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuTitleName*                     Menu_TitleName;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollection*                      Menu_Collection;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuHelp*                          Menu_Help;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       Menu_BTNGuide;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isFinishAnim;                                      // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelWrap(ERCInputKeyType InKeyType);
	void DecideWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionLayout">();
	}
	static class URCMenuCollectionLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionLayout>();
	}
};
static_assert(alignof(URCMenuCollectionLayout) == 0x000008, "Wrong alignment on URCMenuCollectionLayout");
static_assert(sizeof(URCMenuCollectionLayout) == 0x000308, "Wrong size on URCMenuCollectionLayout");
static_assert(offsetof(URCMenuCollectionLayout, Menu_BackGround) == 0x0002D8, "Member 'URCMenuCollectionLayout::Menu_BackGround' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionLayout, Menu_TitleName) == 0x0002E0, "Member 'URCMenuCollectionLayout::Menu_TitleName' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionLayout, Menu_Collection) == 0x0002E8, "Member 'URCMenuCollectionLayout::Menu_Collection' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionLayout, Menu_Help) == 0x0002F0, "Member 'URCMenuCollectionLayout::Menu_Help' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionLayout, Menu_BTNGuide) == 0x0002F8, "Member 'URCMenuCollectionLayout::Menu_BTNGuide' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionLayout, isFinishAnim) == 0x000300, "Member 'URCMenuCollectionLayout::isFinishAnim' has a wrong offset!");

// Class RC.RCMenuCollectionListBar
// 0x0028 (0x0348 - 0x0320)
class URCMenuCollectionListBar : public URCMenuButton
{
public:
	class URCMenuCollectionListBarClose*          ListBar_Close;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionListBarOpen*           ListBar_Open;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Open;                                           // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close;                                          // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isRelease;                                         // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isMouseCurrentSelect;                              // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentPressDecide;                              // 0x0342(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isSelectedAnimation;                               // 0x0343(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionListBar">();
	}
	static class URCMenuCollectionListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionListBar>();
	}
};
static_assert(alignof(URCMenuCollectionListBar) == 0x000008, "Wrong alignment on URCMenuCollectionListBar");
static_assert(sizeof(URCMenuCollectionListBar) == 0x000348, "Wrong size on URCMenuCollectionListBar");
static_assert(offsetof(URCMenuCollectionListBar, ListBar_Close) == 0x000320, "Member 'URCMenuCollectionListBar::ListBar_Close' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, ListBar_Open) == 0x000328, "Member 'URCMenuCollectionListBar::ListBar_Open' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, AN_Open) == 0x000330, "Member 'URCMenuCollectionListBar::AN_Open' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, AN_Close) == 0x000338, "Member 'URCMenuCollectionListBar::AN_Close' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, isRelease) == 0x000340, "Member 'URCMenuCollectionListBar::isRelease' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, isMouseCurrentSelect) == 0x000341, "Member 'URCMenuCollectionListBar::isMouseCurrentSelect' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, isCurrentPressDecide) == 0x000342, "Member 'URCMenuCollectionListBar::isCurrentPressDecide' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBar, isSelectedAnimation) == 0x000343, "Member 'URCMenuCollectionListBar::isSelectedAnimation' has a wrong offset!");

// Class RC.RCMenuCollectionListBarClose
// 0x0040 (0x02B0 - 0x0270)
class URCMenuCollectionListBarClose : public URCUserWidget
{
public:
	class UUserWidget*                            ListBar_Ef;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ListName;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Number;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Default;                                        // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionListBarClose">();
	}
	static class URCMenuCollectionListBarClose* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionListBarClose>();
	}
};
static_assert(alignof(URCMenuCollectionListBarClose) == 0x000008, "Wrong alignment on URCMenuCollectionListBarClose");
static_assert(sizeof(URCMenuCollectionListBarClose) == 0x0002B0, "Wrong size on URCMenuCollectionListBarClose");
static_assert(offsetof(URCMenuCollectionListBarClose, ListBar_Ef) == 0x000270, "Member 'URCMenuCollectionListBarClose::ListBar_Ef' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, Text_ListName) == 0x000278, "Member 'URCMenuCollectionListBarClose::Text_ListName' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, Text_Number) == 0x000280, "Member 'URCMenuCollectionListBarClose::Text_Number' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, AN_Default) == 0x000288, "Member 'URCMenuCollectionListBarClose::AN_Default' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, AN_OnCursor) == 0x000290, "Member 'URCMenuCollectionListBarClose::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, AN_OnCursor_Wait) == 0x000298, "Member 'URCMenuCollectionListBarClose::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, AN_OutCursor) == 0x0002A0, "Member 'URCMenuCollectionListBarClose::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarClose, AN_Push) == 0x0002A8, "Member 'URCMenuCollectionListBarClose::AN_Push' has a wrong offset!");

// Class RC.RCVariableBFL
// 0x0000 (0x0028 - 0x0028)
class URCVariableBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AddChapterValueDirect(class FName InChapterVariableName, int32 InValue);
	static void AddGameValueDirect(class FName InGameVariableName, int32 InValue);
	static void AddLog(int32 InCharacterFaceID, int32 InCharacterFacialID, class FName InTextID, class FName InVoiceID);
	static void AddMainQuestPhase();
	static void AddNazoBattleAssist();
	static void AddNazoBattleClear3Way();
	static void AddNazoBattleGayaSlash();
	static void AddNazoBattleHajiki();
	static void AddNazoBattleHanronSlash();
	static void AddNazoBattleJustMove();
	static void AddNazoResultContinue(int32 InRound, class FName InMinigameID);
	static void AddNazoResultFailureCount(class FName InMinigameID);
	static void AddNazoResultFailureCount2(class FName InMinigameID);
	static int32 AddResultTanteiPoint(int32 InChapter, int32 InTanteiPoint);
	static void AddSceneValueDirect(class FName InSceneVariableName, int32 InValue);
	static int32 AddTanteiPoint(class FName InTanteiPointID);
	static void ClearBusStopMove();
	static void ClearBusStopStatusFromAreamap();
	static void ClearMainQuestPhase();
	static void ClearNazoResult(int32 InChapter);
	static void ClearNazoResultContinue(int32 InRound, class FName InMinigameID);
	static void ClearNazoResultCount();
	static void ClearSaveGameLevelInfo();
	static void CreateSaveGameLevelInfo(int32 InChapter, class FName InScene);
	static void EndNazoResultScene();
	static ERCRealEventMapConnectStatus GetBusStopStatus();
	static ERCRealEventMapConnectBusStopStatus GetBusStopStatusFromAreamap(class FName InMapID);
	static int32 GetChapter();
	static int32 GetChapterVariableDirect(class FName InChapterVariableName);
	static int32 GetEndLogNum();
	static int32 GetGalleryMenuMovieListIndex();
	static class UDataTable* GetGalleryMenuMovieSoundTable();
	static class FName GetGalleryMenuPlayingMovieID();
	static ERCGameMode GetGameMode();
	static int32 GetGameVariableDirect(class FName InGameVariableName);
	static class FName GetLastAccessActorName();
	static class FName GetLastCameraTagName();
	static int32 GetLastLogNum();
	static bool GetLog(TArray<struct FRCVariableLogInfo>* OutLogList, int32 StartLogNum, int32 EndLogNum);
	static int32 GetLogMax();
	static int32 GetMainQuestPhase();
	static class FName GetMapID();
	static class FName GetMapIDLong();
	static void GetNazoResult(struct FRCVariableNazoResultList* OutData, int32 InChapter, bool bCurrent);
	static int32 GetNazoResultContinue(int32 InRound, class FName InMinigameID);
	static class FName GetNazoResultNowMinigameID();
	static int32 GetNextChapter();
	static class FName GetNextMapID();
	static class FName GetNextMapIDLong();
	static class FName GetNextPlayerStartName();
	static class FName GetNextScene();
	static int32 GetOldChapter();
	static class FName GetOldMapID();
	static class FName GetOldMapIDLong();
	static class FName GetOldScene();
	static class FName GetPlayerStartName();
	static class FName GetSaveLoadMapName();
	static class FName GetScene();
	static int32 GetSceneVariableDirect(class FName InSceneVariableName);
	static ERCStoryMode GetStoryMode();
	static int32 GetTitleBackListIndex();
	static bool GetTitleCollectionEvent();
	static int32 GetTitleFrontListIndex();
	static bool GetTitleGalleryMovieEvent();
	static int32 GetTotalTanteiPoint();
	static void InitNazoResult();
	static bool IsBusStopMove();
	static bool IsChapterClear(ERCChapter InChapter);
	static bool IsChapterValueEqualDirect(class FName InChapterVariableName, int32 InValue);
	static bool IsChapterValueLargeDirect(class FName InChapterVariableName, int32 InValue, bool bEqual);
	static bool IsChapterValueNotZeroDirect(class FName InChapterVariableName);
	static bool IsChapterValuesAndEqualDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue);
	static bool IsChapterValuesAndLargeDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue, bool bEqual);
	static bool IsChapterValuesAndNotZeroDirect(const TArray<class FName>& InChapterVariableNameList);
	static bool IsChapterValuesAndSmallDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue, bool bEqual);
	static bool IsChapterValuesAndZeroDirect(const TArray<class FName>& InChapterVariableNameList);
	static bool IsChapterValueSmallDirect(class FName InChapterVariableName, int32 InValue, bool bEqual);
	static bool IsChapterValuesOrEqualDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue);
	static bool IsChapterValuesOrLargeDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue, bool bEqual);
	static bool IsChapterValuesOrNotZeroDirect(const TArray<class FName>& InChapterVariableNameList);
	static bool IsChapterValuesOrSmallDirect(const TArray<class FName>& InChapterVariableNameList, int32 InValue, bool bEqual);
	static bool IsChapterValuesOrZeroDirect(const TArray<class FName>& InChapterVariableNameList);
	static bool IsChapterValueZeroDirect(class FName InChapterVariableName);
	static bool IsCollectionEvent();
	static bool IsCollectionEventStart();
	static bool IsCollectionStoryScene();
	static bool IsDataLoadReturn();
	static bool IsDrawDisableSubQuest();
	static bool IsEnableSaveData();
	static bool IsEnableSaveDataSubStory();
	static bool IsExecMenuSceneLoad();
	static bool IsFreeMoveSkipEnable();
	static bool IsGalleryMode();
	static bool IsGameClear();
	static bool IsGameValueEqualDirect(class FName InGameVariableName, int32 InValue);
	static bool IsGameValueLargeDirect(class FName InGameVariableName, int32 InValue, bool bEqual);
	static bool IsGameValueNotZeroDirect(class FName InGameVariableName);
	static bool IsGameValuesAndEqualDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue);
	static bool IsGameValuesAndLargeDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue, bool bEqual);
	static bool IsGameValuesAndNotZeroDirect(const TArray<class FName>& InGameVariableNameList);
	static bool IsGameValuesAndSmallDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue, bool bEqual);
	static bool IsGameValuesAndZeroDirect(const TArray<class FName>& InGameVariableNameList);
	static bool IsGameValueSmallDirect(class FName InGameVariableName, int32 InValue, bool bEqual);
	static bool IsGameValuesOrEqualDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue);
	static bool IsGameValuesOrLargeDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue, bool bEqual);
	static bool IsGameValuesOrNotZeroDirect(const TArray<class FName>& InGameVariableNameList);
	static bool IsGameValuesOrSmallDirect(const TArray<class FName>& InGameVariableNameList, int32 InValue, bool bEqual);
	static bool IsGameValuesOrZeroDirect(const TArray<class FName>& InGameVariableNameList);
	static bool IsGameValueZeroDirect(class FName InGameVariableName);
	static bool IsMessageAuto();
	static bool IsMovieSkipEnable();
	static bool IsSaveEnable();
	static bool IsSceneChange();
	static bool IsSceneValueEqualDirect(class FName InSceneVariableName, int32 InValue);
	static bool IsSceneValueLargeDirect(class FName InSceneVariableName, int32 InValue, bool bEqual);
	static bool IsSceneValueNotZeroDirect(class FName InSceneVariableName);
	static bool IsSceneValuesAndEqualDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue);
	static bool IsSceneValuesAndLargeDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue, bool bEqual);
	static bool IsSceneValuesAndNotZeroDirect(const TArray<class FName>& InSceneVariableNameList);
	static bool IsSceneValuesAndSmallDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue, bool bEqual);
	static bool IsSceneValuesAndZeroDirect(const TArray<class FName>& InSceneVariableNameList);
	static bool IsSceneValueSmallDirect(class FName InSceneVariableName, int32 InValue, bool bEqual);
	static bool IsSceneValuesOrEqualDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue);
	static bool IsSceneValuesOrLargeDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue, bool bEqual);
	static bool IsSceneValuesOrNotZeroDirect(const TArray<class FName>& InSceneVariableNameList);
	static bool IsSceneValuesOrSmallDirect(const TArray<class FName>& InSceneVariableNameList, int32 InValue, bool bEqual);
	static bool IsSceneValuesOrZeroDirect(const TArray<class FName>& InSceneVariableNameList);
	static bool IsSceneValueZeroDirect(class FName InSceneVariableName);
	static bool IsSelectAlready(class FName InSceneID, class FName InTextID);
	static bool IsSkipEnable();
	static bool IsStartDebugMenuDraw();
	static bool IsTitleMenuInitListFlag();
	static void OpenDebugMenu();
	static void ResetCollectionEvent();
	static void ResetSaveLoadMapName();
	static void SetBusStopStatus(ERCRealEventMapConnectStatus InBusStopStatus);
	static void SetBusStopStatusFromAreamap(class FName InMapID, ERCRealEventMapConnectBusStopStatus InSatus);
	static void SetChapterClear(ERCChapter InChapter);
	static void SetChapterVariableDirect(class FName InChapterVariableName, int32 InValue);
	static void SetCollectionEventBack();
	static void SetCollectionEventStart(int32 InChapter, class FName InScene);
	static void SetDataLoadReturn(bool bIsFlag);
	static void SetDrawDisableSubQuest(bool bInFlag);
	static void SetEnableSaveData(bool IsEnable);
	static void SetEnableSaveDataSubStory(bool IsEnable);
	static void SetExecMenuSceneLoad(bool bInFlag);
	static void SetFreeMoveSkipEnable(bool bInFlag);
	static void SetGalleryMenuMovieListIndex(int32 InListIndex);
	static void SetGalleryMenuMovieSoundTable(class UDataTable* InSoundTable);
	static void SetGalleryMenuPlayingMovieID(class FName InMovieID);
	static void SetGalleryMode(bool bInFlag);
	static void SetGameClear();
	static void SetGameMode(ERCGameMode InGameMode);
	static void SetGameVariableDirect(class FName InGameVariableName, int32 InValue);
	static void SetLastCameraTagName(class FName InCameraTagName);
	static void SetMainQuestPhase(int32 InValue);
	static void SetMessageAuto(bool bInFlag);
	static void SetMovieSkipEnable(bool bInFlag);
	static void SetNazoResultContinueCount(int32 InChapter, int32 InCount);
	static void SetNazoResultFailureCount(int32 InCount, class FName InMinigameID);
	static void SetNazoResultHpRank(int32 InChapter, ERCNzResultRankValue InRank);
	static void SetNazoResultPoint(int32 InChapter, int32 InPoint);
	static void SetNazoResultRank(int32 InChapter, ERCNzResultRankValue InRank);
	static void SetNazoResultSave();
	static void SetNazoResultScene(class FName InMinigameID);
	static void SetNazoResultTanteiPoint(int32 InTanteiPoint, class FName InMinigameID);
	static void SetNazoResultTanteiPoint2(int32 InTanteiPoint, class FName InMinigameID);
	static void SetNazoRewardPoint(int32 InChapter, int32 InRewardPoint);
	static void SetNewGame(ERCStoryMode InStoryMode);
	static void SetNextAutoGameLevelInfoFromData();
	static void SetNextBusStopMove(class FName InMapID);
	static void SetNextGameLevelInfo(int32 InChapter, class FName InScene, class FName InMapID, class FName InPlayerStartName);
	static void SetNextGameLevelInfoFromData(int32 InChapter, class FName InScene);
	static void SetNextMapID(class FName InMapID, class FName InPlayerStartName);
	static void SetNextMapIDLong(class FName InMapID);
	static void SetNextScene(class FName InScene, class FName InMapID, class FName InPlayerStartName);
	static void SetNowGameLevelInfo(class FName InMapID);
	static void SetNowGameLevelInfoDetail(int32 InChapter, class FName InScene, class FName InMapID, class FName InPlayerStartName);
	static void SetNowMapIDLong(class FName InMapID);
	static void SetSaveEnable(bool bInFlag);
	static void SetSaveLoadMapName(class FName InSaveLoadMapName);
	static void SetSceneVariableDirect(class FName InSceneVariableName, int32 InValue);
	static void SetSelectAlready(class FName InSceneID, class FName InTextID);
	static void SetSkipEnable(bool bInFlag);
	static void SetStartDebugMenuDraw(bool bInFlag);
	static void SetStoryMode(ERCStoryMode InStoryMode);
	static void SetTitleBackListIndex(int32 SelectedIndex);
	static void SetTitleCollectionEvent(bool isTitle);
	static void SetTitleFrontListIndex(int32 SelectedIndex);
	static void SetTitleGalleryMovieEvent(bool bInFlag);
	static void SetTitleMenuInitListFlag(bool isFront);
	static void SubChapterValueDirect(class FName InChapterVariableName, int32 InValue, bool bZeroStop);
	static void SubGameValueDirect(class FName InGameVariableName, int32 InValue, bool bZeroStop);
	static void SubSceneValueDirect(class FName InSceneVariableName, int32 InValue, bool bZeroStop);
	static void SubTanteiPoint(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableBFL">();
	}
	static class URCVariableBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableBFL>();
	}
};
static_assert(alignof(URCVariableBFL) == 0x000008, "Wrong alignment on URCVariableBFL");
static_assert(sizeof(URCVariableBFL) == 0x000028, "Wrong size on URCVariableBFL");

// Class RC.RCMenuCollectionListBarOpen
// 0x0058 (0x02C8 - 0x0270)
class URCMenuCollectionListBarOpen : public URCUserWidget
{
public:
	class UUserWidget*                            ListBar_Ef;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Number;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ListName;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCMenuCollectionCheckIcon*             Icon_Kidoku;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            Icon_ListUpdate;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            Icon_ListNew;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Default;                                        // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionListBarOpen">();
	}
	static class URCMenuCollectionListBarOpen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionListBarOpen>();
	}
};
static_assert(alignof(URCMenuCollectionListBarOpen) == 0x000008, "Wrong alignment on URCMenuCollectionListBarOpen");
static_assert(sizeof(URCMenuCollectionListBarOpen) == 0x0002C8, "Wrong size on URCMenuCollectionListBarOpen");
static_assert(offsetof(URCMenuCollectionListBarOpen, ListBar_Ef) == 0x000270, "Member 'URCMenuCollectionListBarOpen::ListBar_Ef' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, Text_Number) == 0x000278, "Member 'URCMenuCollectionListBarOpen::Text_Number' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, Text_ListName) == 0x000280, "Member 'URCMenuCollectionListBarOpen::Text_ListName' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, Icon_Kidoku) == 0x000288, "Member 'URCMenuCollectionListBarOpen::Icon_Kidoku' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, Icon_ListUpdate) == 0x000290, "Member 'URCMenuCollectionListBarOpen::Icon_ListUpdate' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, Icon_ListNew) == 0x000298, "Member 'URCMenuCollectionListBarOpen::Icon_ListNew' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, AN_Default) == 0x0002A0, "Member 'URCMenuCollectionListBarOpen::AN_Default' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, AN_OnCursor) == 0x0002A8, "Member 'URCMenuCollectionListBarOpen::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, AN_OnCursor_Wait) == 0x0002B0, "Member 'URCMenuCollectionListBarOpen::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, AN_OutCursor) == 0x0002B8, "Member 'URCMenuCollectionListBarOpen::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionListBarOpen, AN_Push) == 0x0002C0, "Member 'URCMenuCollectionListBarOpen::AN_Push' has a wrong offset!");

// Class RC.RCMenuCollectionTab
// 0x0000 (0x0270 - 0x0270)
class URCMenuCollectionTab final : public URCUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionTab">();
	}
	static class URCMenuCollectionTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionTab>();
	}
};
static_assert(alignof(URCMenuCollectionTab) == 0x000008, "Wrong alignment on URCMenuCollectionTab");
static_assert(sizeof(URCMenuCollectionTab) == 0x000270, "Wrong size on URCMenuCollectionTab");

// Class RC.RCMenuCollectionWindow
// 0x0050 (0x0348 - 0x02F8)
class URCMenuCollectionWindow : public URCMenuManager
{
public:
	class UTextBlock*                             Txt_Header;                                        // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Label;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Txt_Conditions_00;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Txt_Conditions_01;                                 // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Txt_Conditions_02;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiGenericButtonParts*                Button_000;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFinished;                                        // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isDecide;                                          // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* CollectionSelectNavigation(EUINavigation InNavigation);
	void PushDecide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuCollectionWindow">();
	}
	static class URCMenuCollectionWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuCollectionWindow>();
	}
};
static_assert(alignof(URCMenuCollectionWindow) == 0x000008, "Wrong alignment on URCMenuCollectionWindow");
static_assert(sizeof(URCMenuCollectionWindow) == 0x000348, "Wrong size on URCMenuCollectionWindow");
static_assert(offsetof(URCMenuCollectionWindow, Txt_Header) == 0x0002F8, "Member 'URCMenuCollectionWindow::Txt_Header' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, Txt_Label) == 0x000300, "Member 'URCMenuCollectionWindow::Txt_Label' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, Txt_Conditions_00) == 0x000308, "Member 'URCMenuCollectionWindow::Txt_Conditions_00' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, Txt_Conditions_01) == 0x000310, "Member 'URCMenuCollectionWindow::Txt_Conditions_01' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, Txt_Conditions_02) == 0x000318, "Member 'URCMenuCollectionWindow::Txt_Conditions_02' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, Button_000) == 0x000320, "Member 'URCMenuCollectionWindow::Button_000' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, AN_Start) == 0x000328, "Member 'URCMenuCollectionWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, AN_Wait) == 0x000330, "Member 'URCMenuCollectionWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, AN_Finish) == 0x000338, "Member 'URCMenuCollectionWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, IsFinished) == 0x000340, "Member 'URCMenuCollectionWindow::IsFinished' has a wrong offset!");
static_assert(offsetof(URCMenuCollectionWindow, isDecide) == 0x000341, "Member 'URCMenuCollectionWindow::isDecide' has a wrong offset!");

// Class RC.RCVariableGameMenuBFL
// 0x0000 (0x0028 - 0x0028)
class URCVariableGameMenuBFL final : public UBlueprintFunctionLibrary
{
public:
	static void AddCharacter(class FName InCharacterID, int32 InPhase);
	static void AddGlossary(class FName InGlossaryID, int32 InPhase);
	static void AddKaikagi(class FName InKaiKagiID, int32 InPhase);
	static void AddQuest(class FName InQuestID, int32 InPhase);
	static void AddTutorial(class FName InTutorialID);
	static void CheckListTable();
	static void ClearKaikagiList();
	static ERCGameMenuMapM03IconType GetMapM03IconType();
	static ERCGameMenuMapM07IconType GetMapM07IconType();
	static class FName GetNowMainQuestID();
	static ERCGameMenuPlayerIconType GetPlayerIconType();
	static int32 GetQuestPhase(class FName InQuestID);
	static ERCGameMenuQuestStatus GetQuestStatus(class FName InQuestID);
	static ERCGameMenuType GetTopMenuType();
	static bool IsAllQuestCheckActor(class FName InQuestID);
	static bool IsDrawWorldMap();
	static bool IsFastTravel();
	static bool IsPlayerUnknown();
	static bool IsQuestCheckActor(class FName InQuestID, class FName InActorName);
	static bool IsTanteiPointDraw();
	static bool IsTutorial(class FName InTutorialID);
	static void RemoveKaikagi(class FName InKaiKagiID);
	static void ResetHP();
	static void ResetTopMenu(int32 InChapter, class FName InScene);
	static void SetAllSubQuestFailure();
	static bool SetQuestCheckActor(class FName InQuestID, class FName InActorName);
	static void SetQuestComplete(class FName InQuestID);
	static void SetQuestFailure(class FName InQuestID);
	static bool SetTopMenuID(class FName InMenuID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuBFL">();
	}
	static class URCVariableGameMenuBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuBFL>();
	}
};
static_assert(alignof(URCVariableGameMenuBFL) == 0x000008, "Wrong alignment on URCVariableGameMenuBFL");
static_assert(sizeof(URCVariableGameMenuBFL) == 0x000028, "Wrong size on URCVariableGameMenuBFL");

// Class RC.RCMenuItemPanel
// 0x0008 (0x02E8 - 0x02E0)
class URCMenuItemPanel final : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x2];                                      // 0x02E0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDisabled;                                       // 0x02E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E3[0x5];                                      // 0x02E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeDisable();
	void OnChangeNormal();
	void OnChangeSelect();
	void OnDisableHideStarted();
	void OnDisableShowStarted();
	void OnNormalHideStarted();
	void OnNormalShowStarted();
	void OnSelectHideStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMenuItemPanel">();
	}
	static class URCMenuItemPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMenuItemPanel>();
	}
};
static_assert(alignof(URCMenuItemPanel) == 0x000008, "Wrong alignment on URCMenuItemPanel");
static_assert(sizeof(URCMenuItemPanel) == 0x0002E8, "Wrong size on URCMenuItemPanel");
static_assert(offsetof(URCMenuItemPanel, bIsDisabled) == 0x0002E2, "Member 'URCMenuItemPanel::bIsDisabled' has a wrong offset!");

// Class RC.RCPawnRender
// 0x0158 (0x0498 - 0x0340)
class ARCPawnRender : public ARCPawnScript
{
public:
	class FName                                   CharacterId;                                       // 0x0340(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseCharacterId;                                   // 0x0348(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterVariationId;                              // 0x0350(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CurrentPreset;                                     // 0x0358(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoneNameList;                                      // 0x0360(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           SocketNameList;                                    // 0x0370(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class URCDitherFadeComponent*                 DitherFadeComp;                                    // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x21];                                     // 0x0388(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyColorByTick;                                 // 0x03A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AA[0x2];                                      // 0x03AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CurrentAmbientLightColor;                          // 0x03AC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           CurrentDirectionalLightColor;                      // 0x03BC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PreAmbientLightColor;                              // 0x03CC(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PreDirectionalLightColor;                          // 0x03DC(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PostAmbientLightColor;                             // 0x03EC(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PostDirectionalLightColor;                         // 0x03FC(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MapAmbientLightColor;                              // 0x040C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MapDirectionalLightColor;                          // 0x041C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0xC];                                      // 0x042C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterialArray;                              // 0x0438(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x21];                                     // 0x0448(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCameraNearFade;                                   // 0x0469(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCameraNearFadeOriginalFlag;                       // 0x046A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46B[0x1];                                      // 0x046B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraNearFadeOriginalLengthMin;                   // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraNearFadeOriginalLengthMax;                   // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MobAmbientLightColor;                              // 0x0478(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MobDirectionalLightColor;                          // 0x0488(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeColorOfMaterials(const struct FLinearColor& InAmbientColor, const struct FLinearColor& InDirectionalColor, float InDurationSec);
	bool IsCameraFadeEnable();
	bool IsFadeEnd();
	void SetCameraFadeEnable(bool bFlag);
	void SetupBgCharacterMaterial(float InDurationSec);
	void StartFadeIn(float InTime, bool InDirect);
	void StartFadeOut(float InTime, bool InDirect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPawnRender">();
	}
	static class ARCPawnRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPawnRender>();
	}
};
static_assert(alignof(ARCPawnRender) == 0x000008, "Wrong alignment on ARCPawnRender");
static_assert(sizeof(ARCPawnRender) == 0x000498, "Wrong size on ARCPawnRender");
static_assert(offsetof(ARCPawnRender, CharacterId) == 0x000340, "Member 'ARCPawnRender::CharacterId' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, BaseCharacterId) == 0x000348, "Member 'ARCPawnRender::BaseCharacterId' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CharacterVariationId) == 0x000350, "Member 'ARCPawnRender::CharacterVariationId' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CurrentPreset) == 0x000358, "Member 'ARCPawnRender::CurrentPreset' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, BoneNameList) == 0x000360, "Member 'ARCPawnRender::BoneNameList' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, SocketNameList) == 0x000370, "Member 'ARCPawnRender::SocketNameList' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, DitherFadeComp) == 0x000380, "Member 'ARCPawnRender::DitherFadeComp' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, bApplyColorByTick) == 0x0003A9, "Member 'ARCPawnRender::bApplyColorByTick' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CurrentAmbientLightColor) == 0x0003AC, "Member 'ARCPawnRender::CurrentAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CurrentDirectionalLightColor) == 0x0003BC, "Member 'ARCPawnRender::CurrentDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, PreAmbientLightColor) == 0x0003CC, "Member 'ARCPawnRender::PreAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, PreDirectionalLightColor) == 0x0003DC, "Member 'ARCPawnRender::PreDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, PostAmbientLightColor) == 0x0003EC, "Member 'ARCPawnRender::PostAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, PostDirectionalLightColor) == 0x0003FC, "Member 'ARCPawnRender::PostDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, MapAmbientLightColor) == 0x00040C, "Member 'ARCPawnRender::MapAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, MapDirectionalLightColor) == 0x00041C, "Member 'ARCPawnRender::MapDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, DynamicMaterialArray) == 0x000438, "Member 'ARCPawnRender::DynamicMaterialArray' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, bCameraNearFade) == 0x000469, "Member 'ARCPawnRender::bCameraNearFade' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, bCameraNearFadeOriginalFlag) == 0x00046A, "Member 'ARCPawnRender::bCameraNearFadeOriginalFlag' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CameraNearFadeOriginalLengthMin) == 0x00046C, "Member 'ARCPawnRender::CameraNearFadeOriginalLengthMin' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, CameraNearFadeOriginalLengthMax) == 0x000470, "Member 'ARCPawnRender::CameraNearFadeOriginalLengthMax' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, MobAmbientLightColor) == 0x000478, "Member 'ARCPawnRender::MobAmbientLightColor' has a wrong offset!");
static_assert(offsetof(ARCPawnRender, MobDirectionalLightColor) == 0x000488, "Member 'ARCPawnRender::MobDirectionalLightColor' has a wrong offset!");

// Class RC.RCMobCharacter
// 0x0068 (0x0500 - 0x0498)
class ARCMobCharacter final : public ARCPawnRender
{
public:
	class FName                                   MobID;                                             // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLoad;                                           // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        MobDefaultAnimationData;                           // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MobDefaultAnimationId;                             // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MobMoveAnimationId;                                // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopMotionPlayStartPos;                            // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollision;                                        // 0x04C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCull;                                             // 0x04C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C6[0x2];                                      // 0x04C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ToolFormId;                                        // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x18];                                     // 0x04D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInit;                                             // 0x04E8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FormMotionFolderName;                              // 0x04EC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x2];                                      // 0x04F4(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCurrentCollision;                                 // 0x04F6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCOptionMobQuality                           CurrentMobQuality;                                 // 0x04F7(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSwitchedIntegration;                              // 0x04F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCAssetPriority                              ReadPriorily;                                      // 0x04F9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4FA[0x6];                                      // 0x04FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URCCharacterAnimCtrl* GetAnimCtrl();
	void Setup(class FName InMobId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMobCharacter">();
	}
	static class ARCMobCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMobCharacter>();
	}
};
static_assert(alignof(ARCMobCharacter) == 0x000008, "Wrong alignment on ARCMobCharacter");
static_assert(sizeof(ARCMobCharacter) == 0x000500, "Wrong size on ARCMobCharacter");
static_assert(offsetof(ARCMobCharacter, MobID) == 0x000498, "Member 'ARCMobCharacter::MobID' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bOnLoad) == 0x0004A0, "Member 'ARCMobCharacter::bOnLoad' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, MobDefaultAnimationData) == 0x0004A8, "Member 'ARCMobCharacter::MobDefaultAnimationData' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, MobDefaultAnimationId) == 0x0004B0, "Member 'ARCMobCharacter::MobDefaultAnimationId' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, MobMoveAnimationId) == 0x0004B8, "Member 'ARCMobCharacter::MobMoveAnimationId' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, LoopMotionPlayStartPos) == 0x0004C0, "Member 'ARCMobCharacter::LoopMotionPlayStartPos' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bCollision) == 0x0004C4, "Member 'ARCMobCharacter::bCollision' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bCull) == 0x0004C5, "Member 'ARCMobCharacter::bCull' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, ToolFormId) == 0x0004C8, "Member 'ARCMobCharacter::ToolFormId' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bInit) == 0x0004E8, "Member 'ARCMobCharacter::bInit' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, FormMotionFolderName) == 0x0004EC, "Member 'ARCMobCharacter::FormMotionFolderName' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bCurrentCollision) == 0x0004F6, "Member 'ARCMobCharacter::bCurrentCollision' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, CurrentMobQuality) == 0x0004F7, "Member 'ARCMobCharacter::CurrentMobQuality' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, bSwitchedIntegration) == 0x0004F8, "Member 'ARCMobCharacter::bSwitchedIntegration' has a wrong offset!");
static_assert(offsetof(ARCMobCharacter, ReadPriorily) == 0x0004F9, "Member 'ARCMobCharacter::ReadPriorily' has a wrong offset!");

// Class RC.RCVariableGameMenuGalleryBgm
// 0x0010 (0x0038 - 0x0028)
class URCVariableGameMenuGalleryBgm final : public UObject
{
public:
	struct FRCVariableGameMenuGalleryBgmMenuInfo  BgmGalleryMenuInfo;                                // 0x0028(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuGalleryBgm">();
	}
	static class URCVariableGameMenuGalleryBgm* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuGalleryBgm>();
	}
};
static_assert(alignof(URCVariableGameMenuGalleryBgm) == 0x000008, "Wrong alignment on URCVariableGameMenuGalleryBgm");
static_assert(sizeof(URCVariableGameMenuGalleryBgm) == 0x000038, "Wrong size on URCVariableGameMenuGalleryBgm");
static_assert(offsetof(URCVariableGameMenuGalleryBgm, BgmGalleryMenuInfo) == 0x000028, "Member 'URCVariableGameMenuGalleryBgm::BgmGalleryMenuInfo' has a wrong offset!");

// Class RC.RCMobCharacterAnimInstance
// 0x0010 (0x0580 - 0x0570)
class URCMobCharacterAnimInstance final : public URCCharacterAnimInstance
{
public:
	class UAnimationAsset*                        MobDefaultAnimationData;                           // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobDefaultLoopMotionPlayStartPos;                  // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMobCharacterAnimInstance">();
	}
	static class URCMobCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMobCharacterAnimInstance>();
	}
};
static_assert(alignof(URCMobCharacterAnimInstance) == 0x000010, "Wrong alignment on URCMobCharacterAnimInstance");
static_assert(sizeof(URCMobCharacterAnimInstance) == 0x000580, "Wrong size on URCMobCharacterAnimInstance");
static_assert(offsetof(URCMobCharacterAnimInstance, MobDefaultAnimationData) == 0x000570, "Member 'URCMobCharacterAnimInstance::MobDefaultAnimationData' has a wrong offset!");
static_assert(offsetof(URCMobCharacterAnimInstance, MobDefaultLoopMotionPlayStartPos) == 0x000578, "Member 'URCMobCharacterAnimInstance::MobDefaultLoopMotionPlayStartPos' has a wrong offset!");

// Class RC.RCMobCharacterDataAsset
// 0x0028 (0x0058 - 0x0030)
class URCMobCharacterDataAsset final : public UDataAsset
{
public:
	TArray<class FString>                         KakiwariBPPathList;                                // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SoldierDataList;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMobCharacterDataAsset">();
	}
	static class URCMobCharacterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMobCharacterDataAsset>();
	}
};
static_assert(alignof(URCMobCharacterDataAsset) == 0x000008, "Wrong alignment on URCMobCharacterDataAsset");
static_assert(sizeof(URCMobCharacterDataAsset) == 0x000058, "Wrong size on URCMobCharacterDataAsset");
static_assert(offsetof(URCMobCharacterDataAsset, KakiwariBPPathList) == 0x000030, "Member 'URCMobCharacterDataAsset::KakiwariBPPathList' has a wrong offset!");
static_assert(offsetof(URCMobCharacterDataAsset, SoldierDataList) == 0x000040, "Member 'URCMobCharacterDataAsset::SoldierDataList' has a wrong offset!");

// Class RC.RCMojimichiBPDFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCMojimichiBPDFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanClose();
	static bool DisolveText(float DisolveTime);
	static void End();
	static bool IsEnd();
	static bool ShowText();
	static bool StartConstruction(class FName Meshtag);
	static bool StartConstructionWithActorTag(class FName Meshtag, class FName ActorTag);
	static bool StartFracture();
	static void StartSystem(class ACameraActor* CameraActor);
	static bool StopFracture();
	static bool WasTextCaptured();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMojimichiBPDFunctionLibrary">();
	}
	static class URCMojimichiBPDFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMojimichiBPDFunctionLibrary>();
	}
};
static_assert(alignof(URCMojimichiBPDFunctionLibrary) == 0x000008, "Wrong alignment on URCMojimichiBPDFunctionLibrary");
static_assert(sizeof(URCMojimichiBPDFunctionLibrary) == 0x000028, "Wrong size on URCMojimichiBPDFunctionLibrary");

// Class RC.RCVariableGameMenuMap
// 0x0028 (0x0050 - 0x0028)
class URCVariableGameMenuMap final : public UObject
{
public:
	struct FRCVariableGameMenuMapMenuInfo         MapMenuInfo;                                       // 0x0028(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuMap">();
	}
	static class URCVariableGameMenuMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuMap>();
	}
};
static_assert(alignof(URCVariableGameMenuMap) == 0x000008, "Wrong alignment on URCVariableGameMenuMap");
static_assert(sizeof(URCVariableGameMenuMap) == 0x000050, "Wrong size on URCVariableGameMenuMap");
static_assert(offsetof(URCVariableGameMenuMap, MapMenuInfo) == 0x000028, "Member 'URCVariableGameMenuMap::MapMenuInfo' has a wrong offset!");

// Class RC.RCMovieManager
// 0x0098 (0x02B8 - 0x0220)
class ARCMovieManager final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnLoadedEvent;                                     // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFinishedEvent;                                   // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartLoadEvent;                                  // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URCManaComponent*                       ManaComponent;                                     // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManaSource*                            MovieSource;                                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManaTexture*                           Texture;                                           // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              Material;                                          // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCUserWidget*                          Widget;                                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         bpMovieIndex;                                      // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isUpdateBpMovieIndex;                              // 0x027C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isLoadFinish;                                      // 0x027D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCallPlayEnd;                                     // 0x027E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27F[0x1];                                      // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         skipButtonCount;                                   // 0x0280(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLoop;                                            // 0x0284(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         skipTimeMax;                                       // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isOpening;                                         // 0x028C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         debugMovieStatusIndex;                             // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCheckPreparing;                                  // 0x0294(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isBeforeSkipEnable;                                // 0x0295(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCheckFinishFade;                                 // 0x0296(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDispSkipGauge;                                   // 0x0297(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDebugMovieSkip;                                  // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           movieDataPathArray;                                // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          isStartLoad;                                       // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckSkip(float DeltaTime);
	bool CheckSkipButtonCount(float DeltaTime);
	bool GetIsLoop();
	float GetMovieTime();
	void Initialize();
	bool IsLoadedMovie();
	bool IsPlayEnd();
	bool IsPlaying();
	void Pause(bool IsPause);
	void PlayMovie();
	class UMaterialInstanceDynamic* ReadyMovieMaterial();
	void Reset();
	void ResetBeforeLoadMovieData();
	void ResetLoadedMovieData();
	void ResetSkipGauge();
	void SetIsLoop(bool misloop);
	void SetMovieData(const class FString& mmovieID, class URCUserWidget* mwidget, class URCManaComponent* mmanaComponent);
	void SetOpeningFlag(bool isOpening_0);
	void SetRain(bool isPlay);
	void SetSkipTime(float skipTime);
	void Update(float DeltaTime);
	void UpdateSkipGauge();
	void WidgetToRemoveFromViewport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMovieManager">();
	}
	static class ARCMovieManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCMovieManager>();
	}
};
static_assert(alignof(ARCMovieManager) == 0x000008, "Wrong alignment on ARCMovieManager");
static_assert(sizeof(ARCMovieManager) == 0x0002B8, "Wrong size on ARCMovieManager");
static_assert(offsetof(ARCMovieManager, OnLoadedEvent) == 0x000220, "Member 'ARCMovieManager::OnLoadedEvent' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, OnFinishedEvent) == 0x000230, "Member 'ARCMovieManager::OnFinishedEvent' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, OnStartLoadEvent) == 0x000240, "Member 'ARCMovieManager::OnStartLoadEvent' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, ManaComponent) == 0x000250, "Member 'ARCMovieManager::ManaComponent' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, MovieSource) == 0x000258, "Member 'ARCMovieManager::MovieSource' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, Texture) == 0x000260, "Member 'ARCMovieManager::Texture' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, Material) == 0x000268, "Member 'ARCMovieManager::Material' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, Widget) == 0x000270, "Member 'ARCMovieManager::Widget' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, bpMovieIndex) == 0x000278, "Member 'ARCMovieManager::bpMovieIndex' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isUpdateBpMovieIndex) == 0x00027C, "Member 'ARCMovieManager::isUpdateBpMovieIndex' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isLoadFinish) == 0x00027D, "Member 'ARCMovieManager::isLoadFinish' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isCallPlayEnd) == 0x00027E, "Member 'ARCMovieManager::isCallPlayEnd' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, skipButtonCount) == 0x000280, "Member 'ARCMovieManager::skipButtonCount' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, IsLoop) == 0x000284, "Member 'ARCMovieManager::IsLoop' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, skipTimeMax) == 0x000288, "Member 'ARCMovieManager::skipTimeMax' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isOpening) == 0x00028C, "Member 'ARCMovieManager::isOpening' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, debugMovieStatusIndex) == 0x000290, "Member 'ARCMovieManager::debugMovieStatusIndex' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isCheckPreparing) == 0x000294, "Member 'ARCMovieManager::isCheckPreparing' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isBeforeSkipEnable) == 0x000295, "Member 'ARCMovieManager::isBeforeSkipEnable' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isCheckFinishFade) == 0x000296, "Member 'ARCMovieManager::isCheckFinishFade' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isDispSkipGauge) == 0x000297, "Member 'ARCMovieManager::isDispSkipGauge' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isDebugMovieSkip) == 0x000298, "Member 'ARCMovieManager::isDebugMovieSkip' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, movieDataPathArray) == 0x0002A0, "Member 'ARCMovieManager::movieDataPathArray' has a wrong offset!");
static_assert(offsetof(ARCMovieManager, isStartLoad) == 0x0002B0, "Member 'ARCMovieManager::isStartLoad' has a wrong offset!");

// Class RC.RCMovingActorComponent
// 0x0018 (0x00C8 - 0x00B0)
class URCMovingActorComponent final : public UActorComponent
{
public:
	class FString                                 engineSoundID;                                     // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isEngineSound;                                     // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableEngineSound(bool IsEnable);
	class FString GetEngineSoundID();
	bool IsEnableEngineSound();
	void SetEngineSoundID(const class FString& SoundId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMovingActorComponent">();
	}
	static class URCMovingActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMovingActorComponent>();
	}
};
static_assert(alignof(URCMovingActorComponent) == 0x000008, "Wrong alignment on URCMovingActorComponent");
static_assert(sizeof(URCMovingActorComponent) == 0x0000C8, "Wrong size on URCMovingActorComponent");
static_assert(offsetof(URCMovingActorComponent, engineSoundID) == 0x0000B0, "Member 'URCMovingActorComponent::engineSoundID' has a wrong offset!");
static_assert(offsetof(URCMovingActorComponent, isEngineSound) == 0x0000C0, "Member 'URCMovingActorComponent::isEngineSound' has a wrong offset!");

// Class RC.RCNazoBattleRebuttalLetter
// 0x0960 (0x0B80 - 0x0220)
class alignas(0x10) ARCNazoBattleRebuttalLetter : public AActor
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   RebuttalLetterMesh;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCText3DMeshedComponent*               RebuttalLetterText3D;                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      DecorationEffect;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HitBoxMesh;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   JustAvoidBoxMesh;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        ShadowDecal;                                       // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SlashedMesh;                                       // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AppearEffectInLp;                                  // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AppearEffectOt;                                    // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AttackLineEffect;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      EffectIn;                                          // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      EffectLp;                                          // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      EffectOt;                                          // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x590];                                    // 0x0290(0x0590)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               RebuttalLetterMeshMaterial;                        // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RebuttalLetterText3DFrontMaterial;                 // 0x0828(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RebuttalLetterText3DEdgeMaterial;                  // 0x0830(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ShadowDecalMaterial;                               // 0x0838(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               SlashedMeshMaterial;                               // 0x0840(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NiagaraIn;                                         // 0x0850(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NiagaraLp;                                         // 0x0858(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NiagaraOt;                                         // 0x0860(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x10];                                     // 0x0868(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             RebuttalLetterTexture;                             // 0x0878(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x1AC];                                    // 0x0880(0x01AC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowSpeed;                                          // 0x0A2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A30[0x78];                                     // 0x0A30(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnAttackEnable;                                    // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnAttackDisable;                                   // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnJustAvoidEnable;                                 // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnJustAvoidDisable;                                // 0x0AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnSlashed;                                         // 0x0AE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnSlashStopped;                                    // 0x0AF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnRepelled;                                        // 0x0B08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnRepelledHitKaijin;                               // 0x0B18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnRepelledPreventedByKaijin;                       // 0x0B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnHit;                                             // 0x0B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnOut;                                             // 0x0B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnDamage;                                          // 0x0B58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleRebuttalLetterNotifyData& NotifyData)> OnFinished;                                        // 0x0B68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnJustAvoidBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnJustAvoidBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetHitCharaEnable(bool InHitCharaEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoBattleRebuttalLetter">();
	}
	static class ARCNazoBattleRebuttalLetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoBattleRebuttalLetter>();
	}
};
static_assert(alignof(ARCNazoBattleRebuttalLetter) == 0x000010, "Wrong alignment on ARCNazoBattleRebuttalLetter");
static_assert(sizeof(ARCNazoBattleRebuttalLetter) == 0x000B80, "Wrong size on ARCNazoBattleRebuttalLetter");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, DefaultSceneRoot) == 0x000220, "Member 'ARCNazoBattleRebuttalLetter::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterMesh) == 0x000228, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterMesh' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterText3D) == 0x000230, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterText3D' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, DecorationEffect) == 0x000238, "Member 'ARCNazoBattleRebuttalLetter::DecorationEffect' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, HitBoxMesh) == 0x000240, "Member 'ARCNazoBattleRebuttalLetter::HitBoxMesh' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, JustAvoidBoxMesh) == 0x000248, "Member 'ARCNazoBattleRebuttalLetter::JustAvoidBoxMesh' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, ShadowDecal) == 0x000250, "Member 'ARCNazoBattleRebuttalLetter::ShadowDecal' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, SlashedMesh) == 0x000258, "Member 'ARCNazoBattleRebuttalLetter::SlashedMesh' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, AppearEffectInLp) == 0x000260, "Member 'ARCNazoBattleRebuttalLetter::AppearEffectInLp' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, AppearEffectOt) == 0x000268, "Member 'ARCNazoBattleRebuttalLetter::AppearEffectOt' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, AttackLineEffect) == 0x000270, "Member 'ARCNazoBattleRebuttalLetter::AttackLineEffect' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, EffectIn) == 0x000278, "Member 'ARCNazoBattleRebuttalLetter::EffectIn' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, EffectLp) == 0x000280, "Member 'ARCNazoBattleRebuttalLetter::EffectLp' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, EffectOt) == 0x000288, "Member 'ARCNazoBattleRebuttalLetter::EffectOt' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterMeshMaterial) == 0x000820, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterMeshMaterial' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterText3DFrontMaterial) == 0x000828, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterText3DFrontMaterial' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterText3DEdgeMaterial) == 0x000830, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterText3DEdgeMaterial' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, ShadowDecalMaterial) == 0x000838, "Member 'ARCNazoBattleRebuttalLetter::ShadowDecalMaterial' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, SlashedMeshMaterial) == 0x000840, "Member 'ARCNazoBattleRebuttalLetter::SlashedMeshMaterial' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, NiagaraIn) == 0x000850, "Member 'ARCNazoBattleRebuttalLetter::NiagaraIn' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, NiagaraLp) == 0x000858, "Member 'ARCNazoBattleRebuttalLetter::NiagaraLp' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, NiagaraOt) == 0x000860, "Member 'ARCNazoBattleRebuttalLetter::NiagaraOt' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, RebuttalLetterTexture) == 0x000878, "Member 'ARCNazoBattleRebuttalLetter::RebuttalLetterTexture' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, NowSpeed) == 0x000A2C, "Member 'ARCNazoBattleRebuttalLetter::NowSpeed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnAttackEnable) == 0x000AA8, "Member 'ARCNazoBattleRebuttalLetter::OnAttackEnable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnAttackDisable) == 0x000AB8, "Member 'ARCNazoBattleRebuttalLetter::OnAttackDisable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnJustAvoidEnable) == 0x000AC8, "Member 'ARCNazoBattleRebuttalLetter::OnJustAvoidEnable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnJustAvoidDisable) == 0x000AD8, "Member 'ARCNazoBattleRebuttalLetter::OnJustAvoidDisable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnSlashed) == 0x000AE8, "Member 'ARCNazoBattleRebuttalLetter::OnSlashed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnSlashStopped) == 0x000AF8, "Member 'ARCNazoBattleRebuttalLetter::OnSlashStopped' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnRepelled) == 0x000B08, "Member 'ARCNazoBattleRebuttalLetter::OnRepelled' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnRepelledHitKaijin) == 0x000B18, "Member 'ARCNazoBattleRebuttalLetter::OnRepelledHitKaijin' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnRepelledPreventedByKaijin) == 0x000B28, "Member 'ARCNazoBattleRebuttalLetter::OnRepelledPreventedByKaijin' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnHit) == 0x000B38, "Member 'ARCNazoBattleRebuttalLetter::OnHit' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnOut) == 0x000B48, "Member 'ARCNazoBattleRebuttalLetter::OnOut' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnDamage) == 0x000B58, "Member 'ARCNazoBattleRebuttalLetter::OnDamage' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleRebuttalLetter, OnFinished) == 0x000B68, "Member 'ARCNazoBattleRebuttalLetter::OnFinished' has a wrong offset!");

// Class RC.RCNazoBattleDisturbLetter
// 0x0490 (0x1010 - 0x0B80)
class ARCNazoBattleDisturbLetter final : public ARCNazoBattleRebuttalLetter
{
public:
	uint8                                         Pad_B80[0x408];                                    // 0x0B80(0x0408)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbAttackEnable;                             // 0x0F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbAttackDisable;                            // 0x0F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbSlashed;                                  // 0x0FA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbRepelled;                                 // 0x0FB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbHit;                                      // 0x0FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbOut;                                      // 0x0FD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbDamage;                                   // 0x0FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRCNazoBattleDisturbLetterNotifyData& NotifyData)> OnDisturbFinished;                                 // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1008[0x8];                                     // 0x1008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoBattleDisturbLetter">();
	}
	static class ARCNazoBattleDisturbLetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoBattleDisturbLetter>();
	}
};
static_assert(alignof(ARCNazoBattleDisturbLetter) == 0x000010, "Wrong alignment on ARCNazoBattleDisturbLetter");
static_assert(sizeof(ARCNazoBattleDisturbLetter) == 0x001010, "Wrong size on ARCNazoBattleDisturbLetter");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbAttackEnable) == 0x000F88, "Member 'ARCNazoBattleDisturbLetter::OnDisturbAttackEnable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbAttackDisable) == 0x000F98, "Member 'ARCNazoBattleDisturbLetter::OnDisturbAttackDisable' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbSlashed) == 0x000FA8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbSlashed' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbRepelled) == 0x000FB8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbRepelled' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbHit) == 0x000FC8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbHit' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbOut) == 0x000FD8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbOut' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbDamage) == 0x000FE8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbDamage' has a wrong offset!");
static_assert(offsetof(ARCNazoBattleDisturbLetter, OnDisturbFinished) == 0x000FF8, "Member 'ARCNazoBattleDisturbLetter::OnDisturbFinished' has a wrong offset!");

// Class RC.RCNazoBattleLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCNazoBattleLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool BattleAllRebuttalLetterForceFinish();
	static int32 BattleGameOverUI_GetSelectedIndex();
	static bool BattleGameOverUI_IsFinished();
	static bool BattleGameOverUI_Start();
	static void BattleGetCurrentRebuttalGroupNo(int32* RebuttalGroupNo);
	static bool BattleGetRebuttalPhaseParameter_AttackFailure(int32* RebuttalGroupNo, int32* RebuttalNo, ERCNazoBattleLSARebuttalAttackFailureType* FailureType, class FName* TalkID);
	static bool BattleGetRebuttalPhaseParameter_AttackSuccess(int32* RebuttalGroupNo, int32* RebuttalNo, class FName* TalkID);
	static bool BattleGetRebuttalPhaseParameter_ClearEvent(class FName* TalkID, TArray<class FName>* TalkIDArray);
	static bool BattleGetRebuttalPhaseParameter_CloseContest(int32* RebuttalGroupNo, int32* RebuttalNo, float* InputTime, int32* InputCount, int32* FailureDamage);
	static bool BattleGetRebuttalPhaseParameter_Confrontation(int32* RebuttalGroupNo, bool* bFirstChallenge, class FName* TalkID);
	static bool BattleGetRebuttalPhaseParameter_GameOver(int32* RebuttalGroupNo, int32* RebuttalNo, class FName* TalkID, class FName* HintTextId);
	static bool BattleGetRebuttalPhaseParameter_Interval(int32* RebuttalGroupNo, class FName* TalkID);
	static bool BattleGetRebuttalPhaseParameter_NextRebuttalEvent(int32* RebuttalGroupNo, class FName* TalkID);
	static bool BattleGetRebuttalPhaseParameter_PreEvent(class FName* TalkID);
	static bool BattleHintUI_IsFinished();
	static bool BattleHintUI_Start(class FName HintTextId);
	static bool BattleRebuttalEndCloseContest(bool bSuccess);
	static bool BattleRebuttalEndPhase();
	static bool BattleRebuttalResetPosition();
	static bool BattleStartUI_IsFinished();
	static bool BattleStartUI_Start();
	static TArray<struct FRCNazoBattleLSARebuttalData> GetActiveRebuttalDataArray();
	static class ARCNazoBattleLevelScriptActor* GetBattleLevelScriptActor();
	static struct FRCNazoBattleSettings GetBattleSettings();
	static bool GetDefaultKaijinPartVoiceID(class FName* PartVoiceID, float* DelayTime, ERCNazoBattleKaijinPartVoiceType PartVoiceType);
	static bool GetKaijinPartVoiceID(class FName* PartVoiceID, float* DelayTime, ERCNazoBattleKaijinPartVoiceType PartVoiceType, class FName KaijinTag);
	static bool GetPreEventPartVoiceKaijinTag(class FName* KaijinTag);
	static bool IsBattle();
	static bool IsBattleInitialized();
	static bool SetBattleInputEnable(bool bInputEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoBattleLevelScriptActorBFL">();
	}
	static class URCNazoBattleLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoBattleLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCNazoBattleLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCNazoBattleLevelScriptActorBFL");
static_assert(sizeof(URCNazoBattleLevelScriptActorBFL) == 0x000028, "Wrong size on URCNazoBattleLevelScriptActorBFL");

// Class RC.RCNazoCharacterAnimInstance
// 0x0000 (0x0570 - 0x0570)
class URCNazoCharacterAnimInstance final : public URCCharacterAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoCharacterAnimInstance">();
	}
	static class URCNazoCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoCharacterAnimInstance>();
	}
};
static_assert(alignof(URCNazoCharacterAnimInstance) == 0x000010, "Wrong alignment on URCNazoCharacterAnimInstance");
static_assert(sizeof(URCNazoCharacterAnimInstance) == 0x000570, "Wrong size on URCNazoCharacterAnimInstance");

// Class RC.RCNazoGameModeBase
// 0x0000 (0x02D0 - 0x02D0)
class ARCNazoGameModeBase final : public ARCGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoGameModeBase">();
	}
	static class ARCNazoGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoGameModeBase>();
	}
};
static_assert(alignof(ARCNazoGameModeBase) == 0x000008, "Wrong alignment on ARCNazoGameModeBase");
static_assert(sizeof(ARCNazoGameModeBase) == 0x0002D0, "Wrong size on ARCNazoGameModeBase");

// Class RC.RCNazoLoopLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCNazoLoopLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static class ARCNazoLoopLevelScriptActor* GetLoopLevelScriptActor();
	static bool IsInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoLoopLevelScriptActorBFL">();
	}
	static class URCNazoLoopLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoLoopLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCNazoLoopLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCNazoLoopLevelScriptActorBFL");
static_assert(sizeof(URCNazoLoopLevelScriptActorBFL) == 0x000028, "Wrong size on URCNazoLoopLevelScriptActorBFL");

// Class RC.RCNazoMotionViewerLevelScriptActor
// 0x0088 (0x0740 - 0x06B8)
class ARCNazoMotionViewerLevelScriptActor final : public ARCNazoSceneTestLevelScriptActor
{
public:
	uint8                                         Pad_6B8[0x50];                                     // 0x06B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCharacterRender*                     Chara;                                             // 0x0708(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x28];                                     // 0x0710(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ChangeNextTimerHandle;                             // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CloseMenu();
	void OpenMenu();
	void ToggleMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoMotionViewerLevelScriptActor">();
	}
	static class ARCNazoMotionViewerLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoMotionViewerLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoMotionViewerLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoMotionViewerLevelScriptActor");
static_assert(sizeof(ARCNazoMotionViewerLevelScriptActor) == 0x000740, "Wrong size on ARCNazoMotionViewerLevelScriptActor");
static_assert(offsetof(ARCNazoMotionViewerLevelScriptActor, Chara) == 0x000708, "Member 'ARCNazoMotionViewerLevelScriptActor::Chara' has a wrong offset!");
static_assert(offsetof(ARCNazoMotionViewerLevelScriptActor, ChangeNextTimerHandle) == 0x000738, "Member 'ARCNazoMotionViewerLevelScriptActor::ChangeNextTimerHandle' has a wrong offset!");

// Class RC.RCNazoMoveLoopLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCNazoMoveLoopLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeBackCamera(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	static void ChangeCamera(class ARCCineCameraActor* Camera, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	static void ChangeCameraBase(class AActor* CameraBase, class ARCCineCameraActor* Camera, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	static void ChangeCameraBaseFromTag(class FName CameraBaseTag, class FName CameraTag, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	static void ChangeCameraFromTag(class FName CameraTag, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	static void ChangePlayerSpeed(float Speed, float Time);
	static void FinishMoveLoop();
	static class ARCNazoMoveLoopLevelScriptActor* GetMoveLoopLevelScriptActor();
	static bool IsInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoMoveLoopLevelScriptActorBFL">();
	}
	static class URCNazoMoveLoopLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNazoMoveLoopLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCNazoMoveLoopLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCNazoMoveLoopLevelScriptActorBFL");
static_assert(sizeof(URCNazoMoveLoopLevelScriptActorBFL) == 0x000028, "Wrong size on URCNazoMoveLoopLevelScriptActorBFL");

// Class RC.RCNazoPlayableLoopLevelScriptActor
// 0x0278 (0x04B8 - 0x0240)
class ARCNazoPlayableLoopLevelScriptActor final : public ARCNazoLoopLevelScriptActor
{
public:
	ERCNazoPlayableLoopLSAState                   State;                                             // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DelayTimerHandle;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCNazoPlayableLoopLSALevelData        LevelData;                                         // 0x0250(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoPlayableLoopLSAPlayerData       PlayerData;                                        // 0x03C8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoPlayableLoopLSACameraData       CameraData;                                        // 0x0410(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoPlayableLoopLSAFollowerData     FollowerData;                                      // 0x0430(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRCNazoPlayableLoopLSABehindWallData   BehindWallData;                                    // 0x0480(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bWarp;                                             // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishedWarpNextFrame;                            // 0x04A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WarpFinishedCount;                                 // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestOpenFrontWall;                             // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestCloseBehindWall;                           // 0x04B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestFinishLoop;                                // 0x04B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B3[0x5];                                      // 0x04B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeStateEvent(ERCNazoPlayableLoopLSAState PlayableLoopState);
	bool CheckFinishedBehindWallClosed();
	bool CloseBehindWall();
	bool FinishLoop();
	int32 GetWarpCount();
	bool OpenFrontWall();
	bool Warp();
	void WarpFinishedEvent(int32 WarpCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoPlayableLoopLevelScriptActor">();
	}
	static class ARCNazoPlayableLoopLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoPlayableLoopLevelScriptActor>();
	}
};
static_assert(alignof(ARCNazoPlayableLoopLevelScriptActor) == 0x000008, "Wrong alignment on ARCNazoPlayableLoopLevelScriptActor");
static_assert(sizeof(ARCNazoPlayableLoopLevelScriptActor) == 0x0004B8, "Wrong size on ARCNazoPlayableLoopLevelScriptActor");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, State) == 0x000240, "Member 'ARCNazoPlayableLoopLevelScriptActor::State' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, DelayTimerHandle) == 0x000248, "Member 'ARCNazoPlayableLoopLevelScriptActor::DelayTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, LevelData) == 0x000250, "Member 'ARCNazoPlayableLoopLevelScriptActor::LevelData' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, PlayerData) == 0x0003C8, "Member 'ARCNazoPlayableLoopLevelScriptActor::PlayerData' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, CameraData) == 0x000410, "Member 'ARCNazoPlayableLoopLevelScriptActor::CameraData' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, FollowerData) == 0x000430, "Member 'ARCNazoPlayableLoopLevelScriptActor::FollowerData' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, BehindWallData) == 0x000480, "Member 'ARCNazoPlayableLoopLevelScriptActor::BehindWallData' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, bWarp) == 0x0004A8, "Member 'ARCNazoPlayableLoopLevelScriptActor::bWarp' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, bFinishedWarpNextFrame) == 0x0004A9, "Member 'ARCNazoPlayableLoopLevelScriptActor::bFinishedWarpNextFrame' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, WarpFinishedCount) == 0x0004AC, "Member 'ARCNazoPlayableLoopLevelScriptActor::WarpFinishedCount' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, bRequestOpenFrontWall) == 0x0004B0, "Member 'ARCNazoPlayableLoopLevelScriptActor::bRequestOpenFrontWall' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, bRequestCloseBehindWall) == 0x0004B1, "Member 'ARCNazoPlayableLoopLevelScriptActor::bRequestCloseBehindWall' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopLevelScriptActor, bRequestFinishLoop) == 0x0004B2, "Member 'ARCNazoPlayableLoopLevelScriptActor::bRequestFinishLoop' has a wrong offset!");

// Class RC.RCNazoPlayableLoopSequenceParentActor
// 0x0020 (0x0240 - 0x0220)
class ARCNazoPlayableLoopSequenceParentActor final : public AActor
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OffsetLocation;                                    // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoPlayableLoopSequenceParentActor">();
	}
	static class ARCNazoPlayableLoopSequenceParentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoPlayableLoopSequenceParentActor>();
	}
};
static_assert(alignof(ARCNazoPlayableLoopSequenceParentActor) == 0x000008, "Wrong alignment on ARCNazoPlayableLoopSequenceParentActor");
static_assert(sizeof(ARCNazoPlayableLoopSequenceParentActor) == 0x000240, "Wrong size on ARCNazoPlayableLoopSequenceParentActor");
static_assert(offsetof(ARCNazoPlayableLoopSequenceParentActor, DefaultSceneRoot) == 0x000220, "Member 'ARCNazoPlayableLoopSequenceParentActor::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopSequenceParentActor, SequenceActor) == 0x000228, "Member 'ARCNazoPlayableLoopSequenceParentActor::SequenceActor' has a wrong offset!");
static_assert(offsetof(ARCNazoPlayableLoopSequenceParentActor, OffsetLocation) == 0x000230, "Member 'ARCNazoPlayableLoopSequenceParentActor::OffsetLocation' has a wrong offset!");

// Class RC.RCNazoPlayerCharacter
// 0x0000 (0x0980 - 0x0980)
class ARCNazoPlayerCharacter final : public ARCPlayerCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoPlayerCharacter">();
	}
	static class ARCNazoPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoPlayerCharacter>();
	}
};
static_assert(alignof(ARCNazoPlayerCharacter) == 0x000010, "Wrong alignment on ARCNazoPlayerCharacter");
static_assert(sizeof(ARCNazoPlayerCharacter) == 0x000980, "Wrong size on ARCNazoPlayerCharacter");

// Class RC.RCNazoPlayerController
// 0x0000 (0x07B8 - 0x07B8)
class ARCNazoPlayerController final : public ARCRealPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNazoPlayerController">();
	}
	static class ARCNazoPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNazoPlayerController>();
	}
};
static_assert(alignof(ARCNazoPlayerController) == 0x000008, "Wrong alignment on ARCNazoPlayerController");
static_assert(sizeof(ARCNazoPlayerController) == 0x0007B8, "Wrong size on ARCNazoPlayerController");

// Class RC.RCNzCriminalButtonGuideList
// 0x0030 (0x0308 - 0x02D8)
class URCNzCriminalButtonGuideList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalButtonGuideList">();
	}
	static class URCNzCriminalButtonGuideList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalButtonGuideList>();
	}
};
static_assert(alignof(URCNzCriminalButtonGuideList) == 0x000008, "Wrong alignment on URCNzCriminalButtonGuideList");
static_assert(sizeof(URCNzCriminalButtonGuideList) == 0x000308, "Wrong size on URCNzCriminalButtonGuideList");

// Class RC.RCNzCriminalFailure
// 0x0020 (0x02F8 - 0x02D8)
class URCNzCriminalFailure final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalFailure">();
	}
	static class URCNzCriminalFailure* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalFailure>();
	}
};
static_assert(alignof(URCNzCriminalFailure) == 0x000008, "Wrong alignment on URCNzCriminalFailure");
static_assert(sizeof(URCNzCriminalFailure) == 0x0002F8, "Wrong size on URCNzCriminalFailure");
static_assert(offsetof(URCNzCriminalFailure, AN_Start) == 0x0002D8, "Member 'URCNzCriminalFailure::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzCriminalFailure, AN_Wait) == 0x0002E0, "Member 'URCNzCriminalFailure::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzCriminalFailure, AN_Finish) == 0x0002E8, "Member 'URCNzCriminalFailure::AN_Finish' has a wrong offset!");

// Class RC.RCNzCriminalManager
// 0x00E0 (0x0300 - 0x0220)
class ARCNzCriminalManager final : public AActor
{
public:
	ERCNzCriminalStateType                        StateType;                                         // 0x0220(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChapterNumber;                                     // 0x0224(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SceneNumber;                                       // 0x0228(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SceneID;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CriminalCharacterID;                               // 0x0238(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCSuspectCharacterData>        SuspectCharacterList;                              // 0x0240(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   QuestionTextID;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HintTextId;                                        // 0x0258(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCNzCriminalSceneData                 SceneData;                                         // 0x0260(0x0010)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCNzCriminalcameraSettingData         CameraSettingData;                                 // 0x0270(0x0020)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SuspectCharacterActorList;                         // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsEventProcess;                                   // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x1];                                      // 0x02A1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ERCNzCriminalEventType                        EventType;                                         // 0x02A2(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A3[0x1];                                      // 0x02A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectSuspectIndex;                                // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedSuspectIndex;                              // 0x02A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0xC];                                      // 0x02AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzCriminalMain*                      MainUi;                                            // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzCriminalStart*                     StartUI;                                           // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzCriminalFailure*                   FailureUi;                                         // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWaitPushKey;                                    // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNextState;                                        // 0x02F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0xE];                                      // 0x02F2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Correct();
	void GameOver();
	ERCNzCriminalEventType GetEvent();
	class FName GetFailureLineId();
	class FName GetHintTextId();
	int32 GetSelectedSuspectIndex();
	void GiveHint();
	void Incorrect();
	bool IsCorrectCriminal();
	bool IsGameOver();
	bool IsLoadedAsset();
	bool IsNextState();
	void NotifyFinishEvent();
	void NotifyStartEvent();
	void PlayFailureCharacter();
	void SetLineFromTextId(const class FName InLineTextId);
	void SetupBegin(const TArray<class AActor*>& InSuspectCharacterActorList);
	void SetupBeginProduction();
	void SetupCorrectProduction();
	void SetupHintProduction();
	void SetupIncorrectProduction();
	void SetupPreSelect();
	void SetupSelect();
	void SetWaitPushKey(bool bState);
	void StopPlayFailureCharacter();

	float GetCameraBlendTime(const int32 InCameraIndex) const;
	float GetCameraFocalLength(const int32 InCameraIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalManager">();
	}
	static class ARCNzCriminalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzCriminalManager>();
	}
};
static_assert(alignof(ARCNzCriminalManager) == 0x000008, "Wrong alignment on ARCNzCriminalManager");
static_assert(sizeof(ARCNzCriminalManager) == 0x000300, "Wrong size on ARCNzCriminalManager");
static_assert(offsetof(ARCNzCriminalManager, StateType) == 0x000220, "Member 'ARCNzCriminalManager::StateType' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, ChapterNumber) == 0x000224, "Member 'ARCNzCriminalManager::ChapterNumber' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SceneNumber) == 0x000228, "Member 'ARCNzCriminalManager::SceneNumber' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SceneID) == 0x000230, "Member 'ARCNzCriminalManager::SceneID' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, CriminalCharacterID) == 0x000238, "Member 'ARCNzCriminalManager::CriminalCharacterID' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SuspectCharacterList) == 0x000240, "Member 'ARCNzCriminalManager::SuspectCharacterList' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, QuestionTextID) == 0x000250, "Member 'ARCNzCriminalManager::QuestionTextID' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, HintTextId) == 0x000258, "Member 'ARCNzCriminalManager::HintTextId' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SceneData) == 0x000260, "Member 'ARCNzCriminalManager::SceneData' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, CameraSettingData) == 0x000270, "Member 'ARCNzCriminalManager::CameraSettingData' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SuspectCharacterActorList) == 0x000290, "Member 'ARCNzCriminalManager::SuspectCharacterActorList' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, bIsEventProcess) == 0x0002A0, "Member 'ARCNzCriminalManager::bIsEventProcess' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, EventType) == 0x0002A2, "Member 'ARCNzCriminalManager::EventType' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SelectSuspectIndex) == 0x0002A4, "Member 'ARCNzCriminalManager::SelectSuspectIndex' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, SelectedSuspectIndex) == 0x0002A8, "Member 'ARCNzCriminalManager::SelectedSuspectIndex' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, MainUi) == 0x0002B8, "Member 'ARCNzCriminalManager::MainUi' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, StartUI) == 0x0002D0, "Member 'ARCNzCriminalManager::StartUI' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, FailureUi) == 0x0002E8, "Member 'ARCNzCriminalManager::FailureUi' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, bIsWaitPushKey) == 0x0002F0, "Member 'ARCNzCriminalManager::bIsWaitPushKey' has a wrong offset!");
static_assert(offsetof(ARCNzCriminalManager, bNextState) == 0x0002F1, "Member 'ARCNzCriminalManager::bNextState' has a wrong offset!");

// Class RC.RCNzCriminalSelectElement
// 0x0018 (0x02F0 - 0x02D8)
class URCNzCriminalSelectElement final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalSelectElement">();
	}
	static class URCNzCriminalSelectElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalSelectElement>();
	}
};
static_assert(alignof(URCNzCriminalSelectElement) == 0x000008, "Wrong alignment on URCNzCriminalSelectElement");
static_assert(sizeof(URCNzCriminalSelectElement) == 0x0002F0, "Wrong size on URCNzCriminalSelectElement");
static_assert(offsetof(URCNzCriminalSelectElement, AN_On) == 0x0002D8, "Member 'URCNzCriminalSelectElement::AN_On' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSelectElement, AN_Off) == 0x0002E0, "Member 'URCNzCriminalSelectElement::AN_Off' has a wrong offset!");

// Class RC.RCUiStaffRollBackground
// 0x0038 (0x0310 - 0x02D8)
class URCUiStaffRollBackground final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollBackground">();
	}
	static class URCUiStaffRollBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollBackground>();
	}
};
static_assert(alignof(URCUiStaffRollBackground) == 0x000008, "Wrong alignment on URCUiStaffRollBackground");
static_assert(sizeof(URCUiStaffRollBackground) == 0x000310, "Wrong size on URCUiStaffRollBackground");
static_assert(offsetof(URCUiStaffRollBackground, AN_Start) == 0x0002D8, "Member 'URCUiStaffRollBackground::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiStaffRollBackground, AN_Wait) == 0x0002E0, "Member 'URCUiStaffRollBackground::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiStaffRollBackground, AN_Finish) == 0x0002E8, "Member 'URCUiStaffRollBackground::AN_Finish' has a wrong offset!");

// Class RC.RCNzCriminalSelectList
// 0x0020 (0x02F8 - 0x02D8)
class URCNzCriminalSelectList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCNzCriminalSelectElement*>     SelectList;                                        // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectElementNum;                                  // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalSelectList">();
	}
	static class URCNzCriminalSelectList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalSelectList>();
	}
};
static_assert(alignof(URCNzCriminalSelectList) == 0x000008, "Wrong alignment on URCNzCriminalSelectList");
static_assert(sizeof(URCNzCriminalSelectList) == 0x0002F8, "Wrong size on URCNzCriminalSelectList");
static_assert(offsetof(URCNzCriminalSelectList, SelectList) == 0x0002E0, "Member 'URCNzCriminalSelectList::SelectList' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSelectList, SelectElementNum) == 0x0002F0, "Member 'URCNzCriminalSelectList::SelectElementNum' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSelectList, SelectIndex) == 0x0002F4, "Member 'URCNzCriminalSelectList::SelectIndex' has a wrong offset!");

// Class RC.RCParamLipSyncDataAdjustData
// 0x0010 (0x0040 - 0x0030)
class URCParamLipSyncDataAdjustData final : public URCCSVData
{
public:
	TArray<struct FRCParamLipSyncDataAdjustTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamLipSyncDataAdjustData">();
	}
	static class URCParamLipSyncDataAdjustData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamLipSyncDataAdjustData>();
	}
};
static_assert(alignof(URCParamLipSyncDataAdjustData) == 0x000008, "Wrong alignment on URCParamLipSyncDataAdjustData");
static_assert(sizeof(URCParamLipSyncDataAdjustData) == 0x000040, "Wrong size on URCParamLipSyncDataAdjustData");
static_assert(offsetof(URCParamLipSyncDataAdjustData, Data) == 0x000030, "Member 'URCParamLipSyncDataAdjustData::Data' has a wrong offset!");

// Class RC.RCNzCriminalStart
// 0x0048 (0x0320 - 0x02D8)
class URCNzCriminalStart final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      SpText_StartQuestion;                              // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartQuestionFontSize;                             // 0x0310(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0xC];                                      // 0x0314(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalStart">();
	}
	static class URCNzCriminalStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalStart>();
	}
};
static_assert(alignof(URCNzCriminalStart) == 0x000008, "Wrong alignment on URCNzCriminalStart");
static_assert(sizeof(URCNzCriminalStart) == 0x000320, "Wrong size on URCNzCriminalStart");
static_assert(offsetof(URCNzCriminalStart, AN_Start) == 0x0002D8, "Member 'URCNzCriminalStart::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzCriminalStart, AN_Wait) == 0x0002E0, "Member 'URCNzCriminalStart::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzCriminalStart, AN_Finish) == 0x0002E8, "Member 'URCNzCriminalStart::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzCriminalStart, SpText_StartQuestion) == 0x0002F0, "Member 'URCNzCriminalStart::SpText_StartQuestion' has a wrong offset!");
static_assert(offsetof(URCNzCriminalStart, StartQuestionFontSize) == 0x000310, "Member 'URCNzCriminalStart::StartQuestionFontSize' has a wrong offset!");

// Class RC.RCNzCriminalSubtitles
// 0x0020 (0x02F8 - 0x02D8)
class URCNzCriminalSubtitles final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      RichTextBlock_Subtitles;                           // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalSubtitles">();
	}
	static class URCNzCriminalSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalSubtitles>();
	}
};
static_assert(alignof(URCNzCriminalSubtitles) == 0x000008, "Wrong alignment on URCNzCriminalSubtitles");
static_assert(sizeof(URCNzCriminalSubtitles) == 0x0002F8, "Wrong size on URCNzCriminalSubtitles");
static_assert(offsetof(URCNzCriminalSubtitles, RichTextBlock_Subtitles) == 0x0002D8, "Member 'URCNzCriminalSubtitles::RichTextBlock_Subtitles' has a wrong offset!");

// Class RC.RCParamBgListL01Data
// 0x0010 (0x0040 - 0x0030)
class URCParamBgListL01Data final : public URCCSVData
{
public:
	TArray<struct FRCParamBgListL01TableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamBgListL01Data">();
	}
	static class URCParamBgListL01Data* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamBgListL01Data>();
	}
};
static_assert(alignof(URCParamBgListL01Data) == 0x000008, "Wrong alignment on URCParamBgListL01Data");
static_assert(sizeof(URCParamBgListL01Data) == 0x000040, "Wrong size on URCParamBgListL01Data");
static_assert(offsetof(URCParamBgListL01Data, Data) == 0x000030, "Member 'URCParamBgListL01Data::Data' has a wrong offset!");

// Class RC.RCNzCriminalSuccess
// 0x0018 (0x02F0 - 0x02D8)
class URCNzCriminalSuccess final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzCriminalSuccess">();
	}
	static class URCNzCriminalSuccess* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzCriminalSuccess>();
	}
};
static_assert(alignof(URCNzCriminalSuccess) == 0x000008, "Wrong alignment on URCNzCriminalSuccess");
static_assert(sizeof(URCNzCriminalSuccess) == 0x0002F0, "Wrong size on URCNzCriminalSuccess");
static_assert(offsetof(URCNzCriminalSuccess, AN_Start) == 0x0002D8, "Member 'URCNzCriminalSuccess::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSuccess, AN_Wait) == 0x0002E0, "Member 'URCNzCriminalSuccess::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzCriminalSuccess, AN_Finish) == 0x0002E8, "Member 'URCNzCriminalSuccess::AN_Finish' has a wrong offset!");

// Class RC.RCUiStaffRollItem_Image
// 0x0018 (0x02F8 - 0x02E0)
class URCUiStaffRollItem_Image final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_Image">();
	}
	static class URCUiStaffRollItem_Image* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_Image>();
	}
};
static_assert(alignof(URCUiStaffRollItem_Image) == 0x000008, "Wrong alignment on URCUiStaffRollItem_Image");
static_assert(sizeof(URCUiStaffRollItem_Image) == 0x0002F8, "Wrong size on URCUiStaffRollItem_Image");

// Class RC.RCNzFinaleCameraActorBase
// 0x0000 (0x07C0 - 0x07C0)
class ARCNzFinaleCameraActorBase final : public ARCCameraActor
{
public:
	void CameraZoomEnd();
	void CameraZoomReturnEnd();
	void CameraZoomReturnStart();
	void CameraZoomStart();
	void ChangeDetectiveMode(EFinaleSceneType nextType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleCameraActorBase">();
	}
	static class ARCNzFinaleCameraActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleCameraActorBase>();
	}
};
static_assert(alignof(ARCNzFinaleCameraActorBase) == 0x000010, "Wrong alignment on ARCNzFinaleCameraActorBase");
static_assert(sizeof(ARCNzFinaleCameraActorBase) == 0x0007C0, "Wrong size on ARCNzFinaleCameraActorBase");

// Class RC.RCNzFinaleEditableManagerBase
// 0x0030 (0x0250 - 0x0220)
class ARCNzFinaleEditableManagerBase final : public AActor
{
public:
	class FName                                   TargetSceneID;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SectionDataTable;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PieceDataTable;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PiecePositionDataTable;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARCNzFinalePieceBase*>           PieceActorList;                                    // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GetAllPieceInfoList(TArray<struct FRCNzFinaleEditableSpawnPieceData>* dataList);
	void GetAllPieceNameList(TArray<class FName>* nameList);
	void GetSpawnPieceInfoList(TArray<struct FRCNzFinaleEditableSpawnPieceData>* dataList);
	void SpawnPieceActorList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleEditableManagerBase">();
	}
	static class ARCNzFinaleEditableManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleEditableManagerBase>();
	}
};
static_assert(alignof(ARCNzFinaleEditableManagerBase) == 0x000008, "Wrong alignment on ARCNzFinaleEditableManagerBase");
static_assert(sizeof(ARCNzFinaleEditableManagerBase) == 0x000250, "Wrong size on ARCNzFinaleEditableManagerBase");
static_assert(offsetof(ARCNzFinaleEditableManagerBase, TargetSceneID) == 0x000220, "Member 'ARCNzFinaleEditableManagerBase::TargetSceneID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleEditableManagerBase, SectionDataTable) == 0x000228, "Member 'ARCNzFinaleEditableManagerBase::SectionDataTable' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleEditableManagerBase, PieceDataTable) == 0x000230, "Member 'ARCNzFinaleEditableManagerBase::PieceDataTable' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleEditableManagerBase, PiecePositionDataTable) == 0x000238, "Member 'ARCNzFinaleEditableManagerBase::PiecePositionDataTable' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleEditableManagerBase, PieceActorList) == 0x000240, "Member 'ARCNzFinaleEditableManagerBase::PieceActorList' has a wrong offset!");

// Class RC.RCParamLipSyncData
// 0x0010 (0x0040 - 0x0030)
class URCParamLipSyncData final : public URCCSVData
{
public:
	TArray<struct FRCParamLipSyncTableRow>        Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamLipSyncData">();
	}
	static class URCParamLipSyncData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamLipSyncData>();
	}
};
static_assert(alignof(URCParamLipSyncData) == 0x000008, "Wrong alignment on URCParamLipSyncData");
static_assert(sizeof(URCParamLipSyncData) == 0x000040, "Wrong size on URCParamLipSyncData");
static_assert(offsetof(URCParamLipSyncData, Data) == 0x000030, "Member 'URCParamLipSyncData::Data' has a wrong offset!");

// Class RC.RCNzFinaleHeadingLineBase
// 0x00D8 (0x02F8 - 0x0220)
class ARCNzFinaleHeadingLineBase final : public AActor
{
public:
	class UBoxComponent*                          BoxComp;                                           // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Extent;                                            // 0x0228(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionID;                                         // 0x0234(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionNameTextID;                                 // 0x023C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SectionNameTextString;                             // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           pieceIDList;                                       // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNzFinalePieceBase*>           PieceActorList;                                    // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       PieceQuestionStateList;                            // 0x0278(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ARCNzFinaleManagerBase*                 FinaleManager;                                     // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARCNzFinalePieceBase>       pieceActorClass;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCParamNzFinalePieceTableRow>  PieceDataList;                                     // 0x02D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCParamNzFinaleDetectiveBackgroundImageTableRow> BackgroundImgDataList;                             // 0x02E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class FString GetDetectiveBackgroundImagePath();
	int32 GetDetectivepointNum();
	TArray<bool> GetDetectivePointState();
	void HiddenPieceActors();
	void HiddenSectionActor();
	void InitializeHeadingLine(class FName SectionID_0, class FName SectionTextID, const TArray<class FName>& pieceIDList_0, class ARCNzFinaleManagerBase* FinaleManager_0);
	void ShowPieceActors();
	void ShowSectionActor();
	void SpawnPieceActors();
	void StartSectionEnter();
	void UpdatePieceQuestionState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleHeadingLineBase">();
	}
	static class ARCNzFinaleHeadingLineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleHeadingLineBase>();
	}
};
static_assert(alignof(ARCNzFinaleHeadingLineBase) == 0x000008, "Wrong alignment on ARCNzFinaleHeadingLineBase");
static_assert(sizeof(ARCNzFinaleHeadingLineBase) == 0x0002F8, "Wrong size on ARCNzFinaleHeadingLineBase");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, BoxComp) == 0x000220, "Member 'ARCNzFinaleHeadingLineBase::BoxComp' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, Extent) == 0x000228, "Member 'ARCNzFinaleHeadingLineBase::Extent' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, SectionID) == 0x000234, "Member 'ARCNzFinaleHeadingLineBase::SectionID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, SectionNameTextID) == 0x00023C, "Member 'ARCNzFinaleHeadingLineBase::SectionNameTextID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, SectionNameTextString) == 0x000248, "Member 'ARCNzFinaleHeadingLineBase::SectionNameTextString' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, pieceIDList) == 0x000258, "Member 'ARCNzFinaleHeadingLineBase::pieceIDList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, PieceActorList) == 0x000268, "Member 'ARCNzFinaleHeadingLineBase::PieceActorList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, PieceQuestionStateList) == 0x000278, "Member 'ARCNzFinaleHeadingLineBase::PieceQuestionStateList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, FinaleManager) == 0x0002C8, "Member 'ARCNzFinaleHeadingLineBase::FinaleManager' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, pieceActorClass) == 0x0002D0, "Member 'ARCNzFinaleHeadingLineBase::pieceActorClass' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, PieceDataList) == 0x0002D8, "Member 'ARCNzFinaleHeadingLineBase::PieceDataList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleHeadingLineBase, BackgroundImgDataList) == 0x0002E8, "Member 'ARCNzFinaleHeadingLineBase::BackgroundImgDataList' has a wrong offset!");

// Class RC.RCParamBgListData
// 0x0010 (0x0040 - 0x0030)
class URCParamBgListData final : public URCCSVData
{
public:
	TArray<struct FRCParamBgListTableRow>         Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamBgListData">();
	}
	static class URCParamBgListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamBgListData>();
	}
};
static_assert(alignof(URCParamBgListData) == 0x000008, "Wrong alignment on URCParamBgListData");
static_assert(sizeof(URCParamBgListData) == 0x000040, "Wrong size on URCParamBgListData");
static_assert(offsetof(URCParamBgListData, Data) == 0x000030, "Member 'URCParamBgListData::Data' has a wrong offset!");

// Class RC.RCNzFinaleManagerBase
// 0x05B8 (0x07D8 - 0x0220)
class ARCNzFinaleManagerBase final : public AActor
{
public:
	float                                         LimitTime;                                         // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitTimeMax;                                      // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GameStartFadeInTime;                               // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitTimeAlertScale;                               // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AlertStartTime;                                    // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SignalStartTime;                                   // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARCNzFinaleHeadingLineBase> SectionLineClass;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           SectionIDList;                                     // 0x0240(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNzFinaleHeadingLineBase*>     SectionLineList;                                   // 0x0250(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ARCNzFinaleHeadingLineBase*             CurrentSection;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SectionNum;                                        // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OneLineSectionNumMax;                              // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         sectionHorizontalDistance;                         // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         sectionVerticalDistance;                           // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartSectionPos;                                   // 0x0278(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartSectionPosZ;                                  // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomCameraDist;                                    // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomCameraTime;                                    // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomCameraReturnTime;                              // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitializePlayerPosDetectiveMode;                  // 0x0294(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitializePlayerPosZDetectiveMode;                 // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SceneID;                                           // 0x02A4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isLoadedData;                                      // 0x02AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFinaleSceneType                              CurrentMode;                                       // 0x02AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AE[0x2];                                      // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiFinaleWidget*                    FinaleMainUI;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexListParentWidget*     FinaleIndexListParentUI;                           // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleIndexListWidget*           FinaleIndexListUI;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleCursorWidget*              FinaleCursorUI;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleQuestionWidget*            QuestionWidget;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PiecePositionDataTable;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCNzFinalePieceObjectInfo>     PieceDataList;                                     // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ARCNzFinalePieceBase*                   CurrentPiece;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isGamePlay;                                        // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCNzFinaleDetectiveBackGround*         DetectiveBackgroundActor;                          // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         cursorMoveSpeed;                                   // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         cursorIndexMoveSpeed;                              // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         cursorLowMoveSpeed;                                // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRCNzFinaleGameIDListData> DetectieveBackgroundImageMap;                      // 0x0318(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FString>              DetectiveBackgroundImageWidgetPath;                // 0x0368(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UUserWidget>> DetectievBackgroundWidgetClassMap;                 // 0x03B8(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, class URCNzUiFinaleDetectiveSceneWidget*> DetectiveBackgroundWidgetMap;                      // 0x0408(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCNzFinaleGameBackgroundData> BackgroundImageMap;                                // 0x0458(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVector2D>           DetectiveBackgroundImgScaleMap;                    // 0x04A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCNzFinaleGameSectionState> SectionStateMap;                                   // 0x04F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRCNzFinaleGameIDListData> SectionPieceListMap;                               // 0x0548(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCParamNzFinaleSectionTableRow> SectionDataList;                                   // 0x0598(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class URCNzUiFinaleInteractIconWidget*        CurrentHoverPiece;                                 // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinalePieceList_PieceBase*       CurrentHoverPieceListItem;                         // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BeforeOpenPieceListL_SelectedPieceIdx;             // 0x05B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isMoveCursor;                                      // 0x05BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentHP;                                         // 0x05C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentMaxHP;                                      // 0x05C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EFinaleSEType, class FString>            FinaleSEIDMap;                                     // 0x05C8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          isUseDetectiveSceneScaleParam;                     // 0x0618(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BgmID;                                             // 0x061C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitDetectivePointNum;                             // 0x0624(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSkip;                                            // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FinaleIntteractIconWidgetPath;                     // 0x0630(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                InteractIconWidgetClass;                           // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DetectiveImageRootPath;                            // 0x0648(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PieceImageRootPath;                                // 0x0658(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentChapterNumStr;                              // 0x0668(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         debug_dpi;                                         // 0x0678(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataTablePath;                                     // 0x0680(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCParamNzFinalePieceData*              pieceDataAsset;                                    // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCParamNzFinaleSectionData*            sectionDataAsset;                                  // 0x0698(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isDebugMode;                                       // 0x06A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x3];                                      // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamagePoint;                                       // 0x06A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OpenPiecceListText;                                // 0x06A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SelectPieceText;                                   // 0x06B8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SelectIndexText;                                   // 0x06C8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CheckDetectPieceText;                              // 0x06D8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MoveNextPageIconText;                              // 0x06E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MovePrevPageIconText;                              // 0x06F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 IndexSectionTitle;                                 // 0x0708(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCNzHUD*                               HUD;                                               // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         startDamageAnim;                                   // 0x0720(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGameOver;                                        // 0x0724(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_725[0x3];                                      // 0x0725(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         inputNoneTimer;                                    // 0x0728(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         inputNoneTimerMax;                                 // 0x072C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              oldCursorPos;                                      // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCInputCursolInfoType                        currentInputType;                                  // 0x0738(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              currentInputMovePos;                               // 0x073C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isLowSpeedMode;                                    // 0x0744(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_745[0x3];                                      // 0x0745(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         lastHeadingIndex;                                  // 0x0748(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   oldFrameHoverPieceID;                              // 0x074C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   lastPlaySEHoverPieceID;                            // 0x0754(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadingColScale;                                   // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTutorial;                                        // 0x0760(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TutorialID;                                        // 0x0764(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BtnGuideIndex;                                     // 0x076C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionText1ID;                                    // 0x0774(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionText2ID;                                    // 0x077C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   lowSpeedBtnGuideTexID;                             // 0x0784(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFinaleAutoPlayInputType                      currentFrameAutoPlayInput;                         // 0x078C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78D[0x3];                                      // 0x078D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              currentFrameAutoPlayAnalogInput;                   // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         pieceListAreaL;                                    // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         pieceListAreaR;                                    // 0x079C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         pieceListAreaU;                                    // 0x07A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         pieceListAreaD;                                    // 0x07A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         pageMoveIconSize;                                  // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BGMFadeOutTime;                                    // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BGMFadeOutFinishVolume;                            // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                HoveredButtonGuide;                                // 0x07B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool isSuccess)> FinishedDetectiveInteractIconAnimDelegate;         // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddDamage(int32 Damage);
	void AddFailedCount();
	void AllReleaseUI();
	int32 CalcDetectivePointNum();
	bool CalcIsHoverCursor(const struct FMargin& Offsets, const struct FVector2D& Size, const struct FVector2D& halfViewportSize, const struct FVector2D& cursorPos, const struct FVector2D& listParentSize, int32 idx, float colScale);
	struct FVector2D CalcUpdateCursorPosition(float deltaSecond, float X, float Y, float MoveSpeed);
	void CancelSelectPieceList();
	void ChangeBackgroundImg(const class UTexture2D* Img, const EFinaleInteractPointType InteractType);
	bool CheckAllDetectiveSectionState();
	bool CheckCurrentFrameInput(EFinaleAutoPlayInputType targetInput);
	bool CheckCurrentMode(EFinaleSceneType isMode);
	bool CheckCursorHoverPageMoveIcon(bool isAutoMove);
	bool CheckCursorHoverPieceListOpenIcon(bool isAutoMove);
	bool CheckDetectiveState();
	void CheckHoverItem(float deltaSecond);
	bool CheckIsLockCurrentSelectedPiece(const struct FRCNzFinalePieceObjectInfo& pieceInfo);
	bool CheckSelectPiece(const struct FRCNzFinalePieceObjectInfo& Info, struct FVector2D* PiecePosition);
	bool CheckTargetDetectiveSectionState(class FName ID);
	void ClearQuestionWidget();
	void DebugAutoPlay(float DeltaTime, bool isClearMode);
	void DebugSelectPiece();
	void EnterPieceObject(class ARCNzFinalePieceBase* piece);
	void EnterSectionActor(class ARCNzFinaleHeadingLineBase* TargetActor);
	void ExitPieceObject(class ARCNzFinalePieceBase* piece);
	void ExitSectionActor(class ARCNzFinaleHeadingLineBase* TargetActor);
	void FiishSuccessAllSectionInteractPointAnimation();
	void FinaleFinishEvent();
	void FinishedFinaleInteractIconWidgetAnim(bool isSuccess);
	void FinishedLightingAAnim();
	void FinishedMainLayoutFinishAnim();
	void FinishedMainLayoutStartAnim();
	void FinishGetPieceAnimation();
	void FinishIndexClearEvent();
	void FinishPieceDetailUnlock();
	void FinishQuestionWidgetStartAnim();
	void FinishSuccessSectionAllInteractPointAnimation();
	void FinishSucessInteractPointAnimation();
	void FinishSwitchDetectiveAssemblyMode();
	void FinishSwitchHeadingMode();
	void GameOverEvent();
	class FString GetBackgroundImgPath(class FName BackgroundImgID);
	float GetCurrentCursorMoveSpeed();
	float GetCurrentDPI();
	EFinaleInteractPointType GetCurrentHoverInteratPointType();
	struct FVector2D GetCurrentHoverPiecePosition();
	class FName GetCurrentSceneID();
	class ARCNzFinaleHeadingLineBase* GetCurrentSection();
	TArray<bool> GetCurrentSectionDetectivePointState();
	class FName GetCurrentSectionID();
	struct FVector2D GetCursorPosViewPortSize();
	void GetCursorScreenPosition(float* PositionX, float* PositionY);
	class FString GetDataTableRootPath();
	class UTexture2D* GetDetectiveBackgroundImageList(const class FString& targetSectionID);
	struct FVector2D GetDetectiveBackgroundImgScale(const class FString& targetSectionID);
	class URCNzUiFinaleDetectiveSceneWidget* GetDetectiveBackgroundWidget(class FName targetSectionID);
	class FString GetDetectiveImageRootPath();
	TSubclassOf<class UUserWidget> GetDetectiveSceneWidgetClass(class FName targetSectionID);
	class FString GetDetectiveSceneWidgetPath(class FName targetSectionID);
	class FString GetFinaleDataTablePath();
	class FString GetFinaleDetectiveBackgroundImageDataTablePath();
	class FString GetFinalePieceDataTablePath();
	class FString GetFinaleSceneDataTablePath();
	class FString GetFinaleSectionDataTablePath();
	bool GetIsUseDetectiveSceneScaleParam();
	void GetPieceCurrentHoverInteractPoint();
	class FString GetPieceImageRootPath(bool isSmall);
	bool GetPieceSuccessTargetPage(const struct FRCNzFinalePieceObjectInfo& pieceInfo, int32 currentIdx, int32* idx, class FName* SectionName, int32* pageMoveDir);
	struct FVector GetSectionActorPosition();
	void GetTargetIdxPageText(int32 targetIdx, class FString* titleTxt, int32* sectionTxt);
	class FName GetTargetIndexSectionID(int32 idx);
	struct FVector GetTargetPiecePosition(class FName TargetID);
	struct FVector2D GetTargetPieceSpawnPosition(int32 idx, const struct FRCParamNzFinaleSectionTableRow& Data);
	TArray<bool> GetTargetSectionDetectivePointState(class FName targetSectionID);
	TArray<struct FRCNzFinaleGamePieceData> GetTargetSectionPieceList(class FName targetSectionID);
	void InCorrectDamage();
	void InitializeRegisterUIEvent();
	bool IsCheckHoverCursorIsPick();
	bool IsCurrentSection();
	bool IsExistNextSection();
	bool IsExistPrevSection();
	bool IsExistTargetSection(int32 TargetSceneIdx);
	bool IsHoverCusor();
	void LoadDataTable();
	class UTexture* LoadTexture(const class FString& Path);
	void MoveMode();
	void MoveModeToHeadingProcess();
	void MoveNextSection();
	void MoveNextSectionProcess();
	void MovePrevSection();
	void MovePrevSectionProcess();
	void MoveSection(int32 idx);
	void MoveSectionProcess(int32 idx);
	void MoveSectionProcess_OnEndAnimFinished();
	bool NextSection(class ARCNzFinaleHeadingLineBase** Section);
	void OnPageGuideClick(int32 PageIndex, const struct FPointerEvent& InMouseEvent);
	void PlayClearAnimation();
	void PlayFinaleMainLayoutFinishSE();
	void PlayFinaleSE(EFinaleSEType targetSE, bool IsLoop);
	void PlayFinaleTimelimitFinishSE();
	void PlayFinishAnimation();
	void PlayGetPieceAnimation();
	void PlayIndexClearSE();
	void PlaySuccessAllSectionInteractPointAnimation();
	void PlaySuccessInteractPointAnimation();
	void PlaySuccessSectionAllInteractPointAnimation();
	void PlayTimeLimitSE();
	void PlayTimeSignalSE();
	bool PrevSection(class ARCNzFinaleHeadingLineBase** Section);
	void SetCursorPosition(const struct FVector2D& Pos);
	void SetCursorVisible(bool IsVisible);
	void SetIsMouseCursor(bool Val);
	void SetIsMouseCursorState(bool IsVisible, bool isStatic);
	void SetSelectedPieceIdx(int32 idx);
	void ShowDirectingUI(bool isSuccess);
	bool ShowPieceLayout();
	void SpawnSectionActorList();
	void StartTutorial();
	void UpdateCursor(float deltaSecond, float X, float Y);
	bool UpdateLimitTime(float deltaSecond);
	void UpdatePageMoveIcon();
	void UpdatePieceData();
	void UpdatePieceDataList(const struct FRCNzFinalePieceObjectInfo& Info);
	void UpdatePieceListData();
	void UpdateSectionPageGuide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinaleManagerBase">();
	}
	static class ARCNzFinaleManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinaleManagerBase>();
	}
};
static_assert(alignof(ARCNzFinaleManagerBase) == 0x000008, "Wrong alignment on ARCNzFinaleManagerBase");
static_assert(sizeof(ARCNzFinaleManagerBase) == 0x0007D8, "Wrong size on ARCNzFinaleManagerBase");
static_assert(offsetof(ARCNzFinaleManagerBase, LimitTime) == 0x000220, "Member 'ARCNzFinaleManagerBase::LimitTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, LimitTimeMax) == 0x000224, "Member 'ARCNzFinaleManagerBase::LimitTimeMax' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, GameStartFadeInTime) == 0x000228, "Member 'ARCNzFinaleManagerBase::GameStartFadeInTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, LimitTimeAlertScale) == 0x00022C, "Member 'ARCNzFinaleManagerBase::LimitTimeAlertScale' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, AlertStartTime) == 0x000230, "Member 'ARCNzFinaleManagerBase::AlertStartTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SignalStartTime) == 0x000234, "Member 'ARCNzFinaleManagerBase::SignalStartTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionLineClass) == 0x000238, "Member 'ARCNzFinaleManagerBase::SectionLineClass' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionIDList) == 0x000240, "Member 'ARCNzFinaleManagerBase::SectionIDList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionLineList) == 0x000250, "Member 'ARCNzFinaleManagerBase::SectionLineList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentSection) == 0x000260, "Member 'ARCNzFinaleManagerBase::CurrentSection' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionNum) == 0x000268, "Member 'ARCNzFinaleManagerBase::SectionNum' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, OneLineSectionNumMax) == 0x00026C, "Member 'ARCNzFinaleManagerBase::OneLineSectionNumMax' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, sectionHorizontalDistance) == 0x000270, "Member 'ARCNzFinaleManagerBase::sectionHorizontalDistance' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, sectionVerticalDistance) == 0x000274, "Member 'ARCNzFinaleManagerBase::sectionVerticalDistance' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, StartSectionPos) == 0x000278, "Member 'ARCNzFinaleManagerBase::StartSectionPos' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, StartSectionPosZ) == 0x000284, "Member 'ARCNzFinaleManagerBase::StartSectionPosZ' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, ZoomCameraDist) == 0x000288, "Member 'ARCNzFinaleManagerBase::ZoomCameraDist' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, ZoomCameraTime) == 0x00028C, "Member 'ARCNzFinaleManagerBase::ZoomCameraTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, ZoomCameraReturnTime) == 0x000290, "Member 'ARCNzFinaleManagerBase::ZoomCameraReturnTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, InitializePlayerPosDetectiveMode) == 0x000294, "Member 'ARCNzFinaleManagerBase::InitializePlayerPosDetectiveMode' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, InitializePlayerPosZDetectiveMode) == 0x0002A0, "Member 'ARCNzFinaleManagerBase::InitializePlayerPosZDetectiveMode' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SceneID) == 0x0002A4, "Member 'ARCNzFinaleManagerBase::SceneID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isLoadedData) == 0x0002AC, "Member 'ARCNzFinaleManagerBase::isLoadedData' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentMode) == 0x0002AD, "Member 'ARCNzFinaleManagerBase::CurrentMode' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleMainUI) == 0x0002B0, "Member 'ARCNzFinaleManagerBase::FinaleMainUI' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleIndexListParentUI) == 0x0002B8, "Member 'ARCNzFinaleManagerBase::FinaleIndexListParentUI' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleIndexListUI) == 0x0002C0, "Member 'ARCNzFinaleManagerBase::FinaleIndexListUI' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleCursorUI) == 0x0002C8, "Member 'ARCNzFinaleManagerBase::FinaleCursorUI' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, QuestionWidget) == 0x0002D0, "Member 'ARCNzFinaleManagerBase::QuestionWidget' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, PiecePositionDataTable) == 0x0002D8, "Member 'ARCNzFinaleManagerBase::PiecePositionDataTable' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, PieceDataList) == 0x0002E0, "Member 'ARCNzFinaleManagerBase::PieceDataList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentPiece) == 0x0002F0, "Member 'ARCNzFinaleManagerBase::CurrentPiece' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isGamePlay) == 0x0002F8, "Member 'ARCNzFinaleManagerBase::isGamePlay' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectiveBackgroundActor) == 0x000300, "Member 'ARCNzFinaleManagerBase::DetectiveBackgroundActor' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, cursorMoveSpeed) == 0x000308, "Member 'ARCNzFinaleManagerBase::cursorMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, cursorIndexMoveSpeed) == 0x00030C, "Member 'ARCNzFinaleManagerBase::cursorIndexMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, cursorLowMoveSpeed) == 0x000310, "Member 'ARCNzFinaleManagerBase::cursorLowMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectieveBackgroundImageMap) == 0x000318, "Member 'ARCNzFinaleManagerBase::DetectieveBackgroundImageMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectiveBackgroundImageWidgetPath) == 0x000368, "Member 'ARCNzFinaleManagerBase::DetectiveBackgroundImageWidgetPath' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectievBackgroundWidgetClassMap) == 0x0003B8, "Member 'ARCNzFinaleManagerBase::DetectievBackgroundWidgetClassMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectiveBackgroundWidgetMap) == 0x000408, "Member 'ARCNzFinaleManagerBase::DetectiveBackgroundWidgetMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BackgroundImageMap) == 0x000458, "Member 'ARCNzFinaleManagerBase::BackgroundImageMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectiveBackgroundImgScaleMap) == 0x0004A8, "Member 'ARCNzFinaleManagerBase::DetectiveBackgroundImgScaleMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionStateMap) == 0x0004F8, "Member 'ARCNzFinaleManagerBase::SectionStateMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionPieceListMap) == 0x000548, "Member 'ARCNzFinaleManagerBase::SectionPieceListMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionDataList) == 0x000598, "Member 'ARCNzFinaleManagerBase::SectionDataList' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentHoverPiece) == 0x0005A8, "Member 'ARCNzFinaleManagerBase::CurrentHoverPiece' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentHoverPieceListItem) == 0x0005B0, "Member 'ARCNzFinaleManagerBase::CurrentHoverPieceListItem' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BeforeOpenPieceListL_SelectedPieceIdx) == 0x0005B8, "Member 'ARCNzFinaleManagerBase::BeforeOpenPieceListL_SelectedPieceIdx' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isMoveCursor) == 0x0005BC, "Member 'ARCNzFinaleManagerBase::isMoveCursor' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentHP) == 0x0005C0, "Member 'ARCNzFinaleManagerBase::CurrentHP' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentMaxHP) == 0x0005C4, "Member 'ARCNzFinaleManagerBase::CurrentMaxHP' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleSEIDMap) == 0x0005C8, "Member 'ARCNzFinaleManagerBase::FinaleSEIDMap' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isUseDetectiveSceneScaleParam) == 0x000618, "Member 'ARCNzFinaleManagerBase::isUseDetectiveSceneScaleParam' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BgmID) == 0x00061C, "Member 'ARCNzFinaleManagerBase::BgmID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, InitDetectivePointNum) == 0x000624, "Member 'ARCNzFinaleManagerBase::InitDetectivePointNum' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, IsSkip) == 0x000628, "Member 'ARCNzFinaleManagerBase::IsSkip' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinaleIntteractIconWidgetPath) == 0x000630, "Member 'ARCNzFinaleManagerBase::FinaleIntteractIconWidgetPath' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, InteractIconWidgetClass) == 0x000640, "Member 'ARCNzFinaleManagerBase::InteractIconWidgetClass' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DetectiveImageRootPath) == 0x000648, "Member 'ARCNzFinaleManagerBase::DetectiveImageRootPath' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, PieceImageRootPath) == 0x000658, "Member 'ARCNzFinaleManagerBase::PieceImageRootPath' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CurrentChapterNumStr) == 0x000668, "Member 'ARCNzFinaleManagerBase::CurrentChapterNumStr' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, debug_dpi) == 0x000678, "Member 'ARCNzFinaleManagerBase::debug_dpi' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DataTablePath) == 0x000680, "Member 'ARCNzFinaleManagerBase::DataTablePath' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pieceDataAsset) == 0x000690, "Member 'ARCNzFinaleManagerBase::pieceDataAsset' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, sectionDataAsset) == 0x000698, "Member 'ARCNzFinaleManagerBase::sectionDataAsset' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isDebugMode) == 0x0006A0, "Member 'ARCNzFinaleManagerBase::isDebugMode' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, DamagePoint) == 0x0006A4, "Member 'ARCNzFinaleManagerBase::DamagePoint' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, OpenPiecceListText) == 0x0006A8, "Member 'ARCNzFinaleManagerBase::OpenPiecceListText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SelectPieceText) == 0x0006B8, "Member 'ARCNzFinaleManagerBase::SelectPieceText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SelectIndexText) == 0x0006C8, "Member 'ARCNzFinaleManagerBase::SelectIndexText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, CheckDetectPieceText) == 0x0006D8, "Member 'ARCNzFinaleManagerBase::CheckDetectPieceText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, MoveNextPageIconText) == 0x0006E8, "Member 'ARCNzFinaleManagerBase::MoveNextPageIconText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, MovePrevPageIconText) == 0x0006F8, "Member 'ARCNzFinaleManagerBase::MovePrevPageIconText' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, IndexSectionTitle) == 0x000708, "Member 'ARCNzFinaleManagerBase::IndexSectionTitle' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, HUD) == 0x000718, "Member 'ARCNzFinaleManagerBase::HUD' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, startDamageAnim) == 0x000720, "Member 'ARCNzFinaleManagerBase::startDamageAnim' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, IsGameOver) == 0x000724, "Member 'ARCNzFinaleManagerBase::IsGameOver' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, inputNoneTimer) == 0x000728, "Member 'ARCNzFinaleManagerBase::inputNoneTimer' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, inputNoneTimerMax) == 0x00072C, "Member 'ARCNzFinaleManagerBase::inputNoneTimerMax' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, oldCursorPos) == 0x000730, "Member 'ARCNzFinaleManagerBase::oldCursorPos' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, currentInputType) == 0x000738, "Member 'ARCNzFinaleManagerBase::currentInputType' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, currentInputMovePos) == 0x00073C, "Member 'ARCNzFinaleManagerBase::currentInputMovePos' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, isLowSpeedMode) == 0x000744, "Member 'ARCNzFinaleManagerBase::isLowSpeedMode' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, lastHeadingIndex) == 0x000748, "Member 'ARCNzFinaleManagerBase::lastHeadingIndex' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, oldFrameHoverPieceID) == 0x00074C, "Member 'ARCNzFinaleManagerBase::oldFrameHoverPieceID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, lastPlaySEHoverPieceID) == 0x000754, "Member 'ARCNzFinaleManagerBase::lastPlaySEHoverPieceID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, HeadingColScale) == 0x00075C, "Member 'ARCNzFinaleManagerBase::HeadingColScale' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, IsTutorial) == 0x000760, "Member 'ARCNzFinaleManagerBase::IsTutorial' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, TutorialID) == 0x000764, "Member 'ARCNzFinaleManagerBase::TutorialID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BtnGuideIndex) == 0x00076C, "Member 'ARCNzFinaleManagerBase::BtnGuideIndex' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionText1ID) == 0x000774, "Member 'ARCNzFinaleManagerBase::SectionText1ID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, SectionText2ID) == 0x00077C, "Member 'ARCNzFinaleManagerBase::SectionText2ID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, lowSpeedBtnGuideTexID) == 0x000784, "Member 'ARCNzFinaleManagerBase::lowSpeedBtnGuideTexID' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, currentFrameAutoPlayInput) == 0x00078C, "Member 'ARCNzFinaleManagerBase::currentFrameAutoPlayInput' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, currentFrameAutoPlayAnalogInput) == 0x000790, "Member 'ARCNzFinaleManagerBase::currentFrameAutoPlayAnalogInput' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pieceListAreaL) == 0x000798, "Member 'ARCNzFinaleManagerBase::pieceListAreaL' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pieceListAreaR) == 0x00079C, "Member 'ARCNzFinaleManagerBase::pieceListAreaR' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pieceListAreaU) == 0x0007A0, "Member 'ARCNzFinaleManagerBase::pieceListAreaU' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pieceListAreaD) == 0x0007A4, "Member 'ARCNzFinaleManagerBase::pieceListAreaD' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, pageMoveIconSize) == 0x0007A8, "Member 'ARCNzFinaleManagerBase::pageMoveIconSize' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BGMFadeOutTime) == 0x0007AC, "Member 'ARCNzFinaleManagerBase::BGMFadeOutTime' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, BGMFadeOutFinishVolume) == 0x0007B0, "Member 'ARCNzFinaleManagerBase::BGMFadeOutFinishVolume' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, HoveredButtonGuide) == 0x0007B8, "Member 'ARCNzFinaleManagerBase::HoveredButtonGuide' has a wrong offset!");
static_assert(offsetof(ARCNzFinaleManagerBase, FinishedDetectiveInteractIconAnimDelegate) == 0x0007C8, "Member 'ARCNzFinaleManagerBase::FinishedDetectiveInteractIconAnimDelegate' has a wrong offset!");

// Class RC.RCNzFinalePieceBase
// 0x0040 (0x0260 - 0x0220)
class ARCNzFinalePieceBase final : public AActor
{
public:
	class FName                                   NameID;                                            // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NameString;                                        // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DetailString;                                      // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   answerID;                                          // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PieceType;                                         // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PieceID;                                           // 0x0254(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isComplete;                                        // 0x025C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckPieceID(class FName TargetID);
	void CompletePiece();
	class FName GetAnswerPieceID();
	void InitializeFinalePiece(const class FString& ImagePath, const int32& Type, const class FName& NameTextID, const class FName& TextID, const class FName& answerID_0, const class FName& PieceID_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinalePieceBase">();
	}
	static class ARCNzFinalePieceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzFinalePieceBase>();
	}
};
static_assert(alignof(ARCNzFinalePieceBase) == 0x000008, "Wrong alignment on ARCNzFinalePieceBase");
static_assert(sizeof(ARCNzFinalePieceBase) == 0x000260, "Wrong size on ARCNzFinalePieceBase");
static_assert(offsetof(ARCNzFinalePieceBase, NameID) == 0x000220, "Member 'ARCNzFinalePieceBase::NameID' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, NameString) == 0x000228, "Member 'ARCNzFinalePieceBase::NameString' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, DetailString) == 0x000238, "Member 'ARCNzFinalePieceBase::DetailString' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, answerID) == 0x000248, "Member 'ARCNzFinalePieceBase::answerID' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, PieceType) == 0x000250, "Member 'ARCNzFinalePieceBase::PieceType' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, PieceID) == 0x000254, "Member 'ARCNzFinalePieceBase::PieceID' has a wrong offset!");
static_assert(offsetof(ARCNzFinalePieceBase, isComplete) == 0x00025C, "Member 'ARCNzFinalePieceBase::isComplete' has a wrong offset!");

// Class RC.RCParamCharacterCategoryListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterCategoryListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterCategoryListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterCategoryListData">();
	}
	static class URCParamCharacterCategoryListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterCategoryListData>();
	}
};
static_assert(alignof(URCParamCharacterCategoryListData) == 0x000008, "Wrong alignment on URCParamCharacterCategoryListData");
static_assert(sizeof(URCParamCharacterCategoryListData) == 0x000040, "Wrong size on URCParamCharacterCategoryListData");
static_assert(offsetof(URCParamCharacterCategoryListData, Data) == 0x000030, "Member 'URCParamCharacterCategoryListData::Data' has a wrong offset!");

// Class RC.RCNzFinalePieceObjectBase
// 0x0058 (0x0080 - 0x0028)
class URCNzFinalePieceObjectBase final : public UObject
{
public:
	struct FRCNzFinalePieceObjectInfo             pieceInfo;                                         // 0x0028(0x0058)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzFinalePieceObjectBase">();
	}
	static class URCNzFinalePieceObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzFinalePieceObjectBase>();
	}
};
static_assert(alignof(URCNzFinalePieceObjectBase) == 0x000008, "Wrong alignment on URCNzFinalePieceObjectBase");
static_assert(sizeof(URCNzFinalePieceObjectBase) == 0x000080, "Wrong size on URCNzFinalePieceObjectBase");
static_assert(offsetof(URCNzFinalePieceObjectBase, pieceInfo) == 0x000028, "Member 'URCNzFinalePieceObjectBase::pieceInfo' has a wrong offset!");

// Class RC.RCUiTipsScreenWidget
// 0x0188 (0x0460 - 0x02D8)
class URCUiTipsScreenWidget : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiTipsScreenProgressBar*             WBP_ProgressBar;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_SimpleLoading;                              // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_Tips;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Tips;                                          // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Text_TipsTitle;                                    // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Text_TipsContent;                                  // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x40];                                     // 0x0338(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UObject*>             ImageList;                                         // 0x0378(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UObject*                                EmblemImage;                                       // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x90];                                     // 0x03D0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiTipsScreenWidget">();
	}
	static class URCUiTipsScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiTipsScreenWidget>();
	}
};
static_assert(alignof(URCUiTipsScreenWidget) == 0x000008, "Wrong alignment on URCUiTipsScreenWidget");
static_assert(sizeof(URCUiTipsScreenWidget) == 0x000460, "Wrong size on URCUiTipsScreenWidget");
static_assert(offsetof(URCUiTipsScreenWidget, AN_Start) == 0x0002F0, "Member 'URCUiTipsScreenWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, AN_Wait) == 0x0002F8, "Member 'URCUiTipsScreenWidget::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, AN_Finish) == 0x000300, "Member 'URCUiTipsScreenWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, WBP_ProgressBar) == 0x000308, "Member 'URCUiTipsScreenWidget::WBP_ProgressBar' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, Canvas_SimpleLoading) == 0x000310, "Member 'URCUiTipsScreenWidget::Canvas_SimpleLoading' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, Canvas_Tips) == 0x000318, "Member 'URCUiTipsScreenWidget::Canvas_Tips' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, Img_Tips) == 0x000320, "Member 'URCUiTipsScreenWidget::Img_Tips' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, Text_TipsTitle) == 0x000328, "Member 'URCUiTipsScreenWidget::Text_TipsTitle' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, Text_TipsContent) == 0x000330, "Member 'URCUiTipsScreenWidget::Text_TipsContent' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, ImageList) == 0x000378, "Member 'URCUiTipsScreenWidget::ImageList' has a wrong offset!");
static_assert(offsetof(URCUiTipsScreenWidget, EmblemImage) == 0x0003C8, "Member 'URCUiTipsScreenWidget::EmblemImage' has a wrong offset!");

// Class RC.RCReHUD
// 0x0060 (0x0938 - 0x08D8)
class ARCReHUD : public ARCAdvHUD
{
public:
	ERCReHUDState                                 HUDState;                                          // 0x08D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCReHUDFreeMoveState                         FreeMoveState;                                     // 0x08D9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetRequest                        FreeMoveRequest;                                   // 0x08DA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreeMoveButtonGuide;                              // 0x08DB(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8DC[0x14];                                     // 0x08DC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMiniMapSmall;                                   // 0x08F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCReHUDState                                 HUDStateAtFinishResearchMode;                      // 0x08F1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F2[0xE];                                      // 0x08F2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCSoundNovelRowData>           SoundNovelDataArray;                               // 0x0900(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         SoundNovelDataCurrentIndex;                        // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SoundNovelTimerHandle;                             // 0x0918(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoundNovelDelayToNext;                            // 0x0920(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoundNovelWaitCmd;                                // 0x0921(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_922[0xA];                                      // 0x0922(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	ERCAdvHUDWidgetState                          SoundNovelWidgetState;                             // 0x092C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCAdvHUDWidgetState                          SoundNovelWidgetOldState;                          // 0x092D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92E[0x2];                                      // 0x092E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiSoundNovel*                        SoundNovelWidget;                                  // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckFreeMoveButtonGuide();
	bool CheckLocationFinished();
	bool CheckLocationRunning();
	bool CheckLocationStarted(bool bInMiniMap, bool bInLocation);
	bool CheckSelectFinished();
	bool CheckSelectStarted();
	bool CheckSelectWindow();
	bool CheckSoundNovelFinished();
	void FinishLocation();
	bool FreeMoveButtonGuideFinish();
	bool FreeMoveButtonGuideStart();
	bool FreeMoveButtonGuideUpdate();
	void FreeMoveFinish();
	void FreeMoveStart();
	class FName GetCurrentLocationDisplayLocationID();
	class FName GetCurrentLocationDisplayTextID();
	class FName GetCurrentLocationID();
	class FName GetCurrentLocationTextID();
	class FName GetCurrentMiniMapLocationID();
	class FName GetCurrentMiniMapTextID();
	ERCReHUDFreeMoveState GetFreeMoveState();
	ERCReHUDState GetHUDState();
	int32 GetSelectedIndex();
	int32 GetSelectIndex();
	ERCAdvHUDWidgetState GetSelectWindowState();
	ERCAdvHUDWidgetState GetTalkWindowState();
	bool LoadLocationDataName(class FName in_LocationID, class FName in_LocationTextID);
	bool SelectFinish();
	bool SelectSetData(int32 in_Index, class FName in_TextID, bool in_bCheckMark);
	bool SelectStart(int32 in_SelectNum, class FName in_QuestionTextID);
	bool SelectStartWithDataArray(const TArray<struct FRCReHUDSelectData>& InSelectDataArray, class FName InQuestionTextID);
	bool SetLocationDisplayLocation(class FName in_LocationID, class FName in_LocationTextID);
	bool SetLocationName(class FName in_LocationID, class FName in_LocationTextID);
	bool SetMiniMapLocation(class FName in_LocationID, class FName in_LocationTextID);
	bool SoundNovelShowBackgroundFade(bool bInShow);
	bool SoundNovelStart(class UDataTable* InSoundNovelDataTable, bool bInShowBackgroundFade);
	bool SoundNovelWidgetStart(bool bInShowBackgroundFade);
	void StartLocation(bool bInMiniMap, bool bInLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReHUD">();
	}
	static class ARCReHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCReHUD>();
	}
};
static_assert(alignof(ARCReHUD) == 0x000008, "Wrong alignment on ARCReHUD");
static_assert(sizeof(ARCReHUD) == 0x000938, "Wrong size on ARCReHUD");
static_assert(offsetof(ARCReHUD, HUDState) == 0x0008D8, "Member 'ARCReHUD::HUDState' has a wrong offset!");
static_assert(offsetof(ARCReHUD, FreeMoveState) == 0x0008D9, "Member 'ARCReHUD::FreeMoveState' has a wrong offset!");
static_assert(offsetof(ARCReHUD, FreeMoveRequest) == 0x0008DA, "Member 'ARCReHUD::FreeMoveRequest' has a wrong offset!");
static_assert(offsetof(ARCReHUD, bFreeMoveButtonGuide) == 0x0008DB, "Member 'ARCReHUD::bFreeMoveButtonGuide' has a wrong offset!");
static_assert(offsetof(ARCReHUD, bIsMiniMapSmall) == 0x0008F0, "Member 'ARCReHUD::bIsMiniMapSmall' has a wrong offset!");
static_assert(offsetof(ARCReHUD, HUDStateAtFinishResearchMode) == 0x0008F1, "Member 'ARCReHUD::HUDStateAtFinishResearchMode' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelDataArray) == 0x000900, "Member 'ARCReHUD::SoundNovelDataArray' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelDataCurrentIndex) == 0x000910, "Member 'ARCReHUD::SoundNovelDataCurrentIndex' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelTimerHandle) == 0x000918, "Member 'ARCReHUD::SoundNovelTimerHandle' has a wrong offset!");
static_assert(offsetof(ARCReHUD, bSoundNovelDelayToNext) == 0x000920, "Member 'ARCReHUD::bSoundNovelDelayToNext' has a wrong offset!");
static_assert(offsetof(ARCReHUD, bSoundNovelWaitCmd) == 0x000921, "Member 'ARCReHUD::bSoundNovelWaitCmd' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelWidgetState) == 0x00092C, "Member 'ARCReHUD::SoundNovelWidgetState' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelWidgetOldState) == 0x00092D, "Member 'ARCReHUD::SoundNovelWidgetOldState' has a wrong offset!");
static_assert(offsetof(ARCReHUD, SoundNovelWidget) == 0x000930, "Member 'ARCReHUD::SoundNovelWidget' has a wrong offset!");

// Class RC.RCParamButtonGuideListData
// 0x0010 (0x0040 - 0x0030)
class URCParamButtonGuideListData final : public URCCSVData
{
public:
	TArray<struct FRCParamButtonGuideListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamButtonGuideListData">();
	}
	static class URCParamButtonGuideListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamButtonGuideListData>();
	}
};
static_assert(alignof(URCParamButtonGuideListData) == 0x000008, "Wrong alignment on URCParamButtonGuideListData");
static_assert(sizeof(URCParamButtonGuideListData) == 0x000040, "Wrong size on URCParamButtonGuideListData");
static_assert(offsetof(URCParamButtonGuideListData, Data) == 0x000030, "Member 'URCParamButtonGuideListData::Data' has a wrong offset!");

// Class RC.RCNzHUD
// 0x00F8 (0x0A30 - 0x0938)
class ARCNzHUD final : public ARCReHUD
{
public:
	uint8                                         Pad_938[0xA8];                                     // 0x0938(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleHPGauge*                   HPGauge;                                           // 0x09E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleHint*                      HintWidget;                                        // 0x09E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleGameOver*                  GameOverWidget;                                    // 0x09F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiSkillInfoList*                   SkillInfoListWidget;                               // 0x09F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A00[0x10];                                     // 0x0A00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiCountdown*                       CountdownWidget;                                   // 0x0A10(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTimer*                               CountdownTimer;                                    // 0x0A18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x10];                                     // 0x0A20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CountdownGetMilliseconds();
	bool CountdownGetProgressAndMilliseconds(int32* OutProgress, int32* OutMilliseconds);
	bool CountdownGetProgressAndSeconds(int32* OutProgress, float* OutSeconds);
	bool CountdownGetProgressAndTime(int32* OutProgress, int32* OutHours, int32* OutMinutes, int32* OutSeconds, int32* OutMilliseconds);
	float CountdownGetSeconds();
	bool CountdownGetTime(int32* OutHours, int32* OutMinutes, int32* OutSeconds, int32* OutMilliseconds);
	bool CountdownInitialize();
	bool CountdownIsInitialized();
	bool CountdownPause();
	bool CountdownRelease();
	bool CountdownResume();
	bool CountdownSetProgressAndTime(int32 InProgress);
	bool CountdownStartMillisecond(int32 InTime, bool bInWidgetOpen);
	bool CountdownStartSecond(float InTime, bool bInWidgetOpen);
	bool CountdownStartTime(int32 InHours, int32 InMinutes, int32 InSeconds, int32 InMilliseconds, bool bInWidgetOpen);
	bool CountdownStop();
	bool CountdownWidgetClose(bool bInTimerPause);
	bool CountdownWidgetIsClosed();
	bool CountdownWidgetIsOpened();
	bool CountdownWidgetOpen();
	int32 GameOverGetSelectedIndex();
	bool GameOverIsFinished();
	bool GameOverStart();
	bool HintIsFinished();
	bool HintStart(class FName HintTextId);
	bool HPGaugeDamage(int32 InDamage, int32* OutResultHP, bool bInSilence);
	bool HPGaugeDamageForScene(int32* OutResultHP, bool bInSilence);
	bool HPGaugeFinish();
	ERCAdvHUDWidgetState HPGaugeGetState();
	bool HPGaugeRecover(int32 InRecover, int32* OutResultHP, bool bInSilence);
	bool HPGaugeRecoverForScene(int32* OutResultHP, bool bInSilence);
	bool HPGaugeStart();
	bool SkillInfoListStart(const TArray<class FName>& skillNameTextIDList);
	bool SkillInfoListStartByType(const TArray<ERCSkillFunctionType>& skillFunctionTypeList);

	bool SkillInfoListIsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzHUD">();
	}
	static class ARCNzHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzHUD>();
	}
};
static_assert(alignof(ARCNzHUD) == 0x000008, "Wrong alignment on ARCNzHUD");
static_assert(sizeof(ARCNzHUD) == 0x000A30, "Wrong size on ARCNzHUD");
static_assert(offsetof(ARCNzHUD, HPGauge) == 0x0009E0, "Member 'ARCNzHUD::HPGauge' has a wrong offset!");
static_assert(offsetof(ARCNzHUD, HintWidget) == 0x0009E8, "Member 'ARCNzHUD::HintWidget' has a wrong offset!");
static_assert(offsetof(ARCNzHUD, GameOverWidget) == 0x0009F0, "Member 'ARCNzHUD::GameOverWidget' has a wrong offset!");
static_assert(offsetof(ARCNzHUD, SkillInfoListWidget) == 0x0009F8, "Member 'ARCNzHUD::SkillInfoListWidget' has a wrong offset!");
static_assert(offsetof(ARCNzHUD, CountdownWidget) == 0x000A10, "Member 'ARCNzHUD::CountdownWidget' has a wrong offset!");
static_assert(offsetof(ARCNzHUD, CountdownTimer) == 0x000A18, "Member 'ARCNzHUD::CountdownTimer' has a wrong offset!");

// Class RC.RCNzHUDBFL
// 0x0000 (0x0028 - 0x0028)
class URCNzHUDBFL final : public UBlueprintFunctionLibrary
{
public:
	static int32 CountdownGetMilliseconds();
	static void CountdownGetProgressAndMilliseconds(bool* bSucceeded, int32* Progress, int32* Milliseconds);
	static void CountdownGetProgressAndSeconds(bool* bSucceeded, int32* Progress, float* Seconds);
	static void CountdownGetProgressAndTime(bool* bSucceeded, int32* Progress, int32* Hours, int32* Minutes, int32* Seconds, int32* Milliseconds);
	static float CountdownGetSeconds();
	static void CountdownGetTime(bool* bSucceeded, int32* Hours, int32* Minutes, int32* Seconds, int32* Milliseconds);
	static void CountdownInitialize(bool* bSucceeded);
	static bool CountdownIsInitialized();
	static void CountdownPause(bool* bSucceeded);
	static void CountdownRelease(bool* bSucceeded);
	static void CountdownResume(bool* bSucceeded);
	static void CountdownSetProgressAndTime(bool* bSucceeded, int32 Progress);
	static void CountdownStartMillisecond(bool* bSucceeded, int32 Time, bool bWidgetOpen);
	static void CountdownStartSecond(bool* bSucceeded, float Time, bool bWidgetOpen);
	static void CountdownStartTime(bool* bSucceeded, int32 Hours, int32 Minutes, int32 Seconds, int32 Milliseconds, bool bWidgetOpen);
	static void CountdownStop(bool* bSucceeded);
	static void CountdownWidgetClose(bool* bSucceeded, bool bTimerPause);
	static bool CountdownWidgetIsClosed();
	static bool CountdownWidgetIsOpened();
	static void CountdownWidgetOpen(bool* bSucceeded);
	static void GetBattleCutinPriority(int32* Priority);
	static class ARCNzHUD* GetNzHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzHUDBFL">();
	}
	static class URCNzHUDBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzHUDBFL>();
	}
};
static_assert(alignof(URCNzHUDBFL) == 0x000008, "Wrong alignment on URCNzHUDBFL");
static_assert(sizeof(URCNzHUDBFL) == 0x000028, "Wrong size on URCNzHUDBFL");

// Class RC.RCParamAttachmentFormListData
// 0x0010 (0x0040 - 0x0030)
class URCParamAttachmentFormListData final : public URCCSVData
{
public:
	TArray<struct FRCParamAttachmentFormListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamAttachmentFormListData">();
	}
	static class URCParamAttachmentFormListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamAttachmentFormListData>();
	}
};
static_assert(alignof(URCParamAttachmentFormListData) == 0x000008, "Wrong alignment on URCParamAttachmentFormListData");
static_assert(sizeof(URCParamAttachmentFormListData) == 0x000040, "Wrong size on URCParamAttachmentFormListData");
static_assert(offsetof(URCParamAttachmentFormListData, Data) == 0x000030, "Member 'URCParamAttachmentFormListData::Data' has a wrong offset!");

// Class RC.RCNzMTB_FortActorBase
// 0x01D8 (0x0480 - 0x02A8)
class ARCNzMTB_FortActorBase final : public ARCCustomEventActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Box;                                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallHP;                                            // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallMeshName;                                      // 0x02BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallMotionName;                                    // 0x02C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallTextID;                                        // 0x02CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallTextVoiceID;                                   // 0x02D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallBreakVoiceID;                                  // 0x02DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallBreakEventID;                                  // 0x02E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IntervalVoiceID;                                   // 0x02EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalVoiceDistance;                             // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiID;                                         // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiMissEventID;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiUITextID;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiUITitleTextID;                              // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideFirstEventID;                                // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideEndEventID;                                  // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideIntervalEvent1ID;                            // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideResumeEvent1ID;                              // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideIntervalEvent2ID;                            // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TorideResumeEvent2ID;                              // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCParamNzMTBWallTableRow              paramData;                                         // 0x0348(0x0120)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	float                                         WallVoiceDistance;                                 // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallShowDistance;                                  // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CanAttackDistance;                                 // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiListID;                                     // 0x0474(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttackFort(bool DamageCheck, bool* Result, int32* HitCount, int32* Hp);
	bool CheckAnswerKaikagiID(class FName InKaiKagiID);
	bool LoadParamData(class FName SceneID);
	void PlayFortTextVoice(class ARCCharacterRender* InChara);
	void PlayTextVoice(class ARCCharacterRender* InChara, class FName VoiceID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzMTB_FortActorBase">();
	}
	static class ARCNzMTB_FortActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzMTB_FortActorBase>();
	}
};
static_assert(alignof(ARCNzMTB_FortActorBase) == 0x000008, "Wrong alignment on ARCNzMTB_FortActorBase");
static_assert(sizeof(ARCNzMTB_FortActorBase) == 0x000480, "Wrong size on ARCNzMTB_FortActorBase");
static_assert(offsetof(ARCNzMTB_FortActorBase, Scene) == 0x0002A8, "Member 'ARCNzMTB_FortActorBase::Scene' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, Box) == 0x0002B0, "Member 'ARCNzMTB_FortActorBase::Box' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallHP) == 0x0002B8, "Member 'ARCNzMTB_FortActorBase::WallHP' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallMeshName) == 0x0002BC, "Member 'ARCNzMTB_FortActorBase::WallMeshName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallMotionName) == 0x0002C4, "Member 'ARCNzMTB_FortActorBase::WallMotionName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallTextID) == 0x0002CC, "Member 'ARCNzMTB_FortActorBase::WallTextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallTextVoiceID) == 0x0002D4, "Member 'ARCNzMTB_FortActorBase::WallTextVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallBreakVoiceID) == 0x0002DC, "Member 'ARCNzMTB_FortActorBase::WallBreakVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallBreakEventID) == 0x0002E4, "Member 'ARCNzMTB_FortActorBase::WallBreakEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, IntervalVoiceID) == 0x0002EC, "Member 'ARCNzMTB_FortActorBase::IntervalVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, IntervalVoiceDistance) == 0x0002F4, "Member 'ARCNzMTB_FortActorBase::IntervalVoiceDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, KaikagiID) == 0x0002F8, "Member 'ARCNzMTB_FortActorBase::KaikagiID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, KaikagiMissEventID) == 0x000300, "Member 'ARCNzMTB_FortActorBase::KaikagiMissEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, KaikagiUITextID) == 0x000308, "Member 'ARCNzMTB_FortActorBase::KaikagiUITextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, KaikagiUITitleTextID) == 0x000310, "Member 'ARCNzMTB_FortActorBase::KaikagiUITitleTextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideFirstEventID) == 0x000318, "Member 'ARCNzMTB_FortActorBase::TorideFirstEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideEndEventID) == 0x000320, "Member 'ARCNzMTB_FortActorBase::TorideEndEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideIntervalEvent1ID) == 0x000328, "Member 'ARCNzMTB_FortActorBase::TorideIntervalEvent1ID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideResumeEvent1ID) == 0x000330, "Member 'ARCNzMTB_FortActorBase::TorideResumeEvent1ID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideIntervalEvent2ID) == 0x000338, "Member 'ARCNzMTB_FortActorBase::TorideIntervalEvent2ID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, TorideResumeEvent2ID) == 0x000340, "Member 'ARCNzMTB_FortActorBase::TorideResumeEvent2ID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, paramData) == 0x000348, "Member 'ARCNzMTB_FortActorBase::paramData' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallVoiceDistance) == 0x000468, "Member 'ARCNzMTB_FortActorBase::WallVoiceDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, WallShowDistance) == 0x00046C, "Member 'ARCNzMTB_FortActorBase::WallShowDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, CanAttackDistance) == 0x000470, "Member 'ARCNzMTB_FortActorBase::CanAttackDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_FortActorBase, KaikagiListID) == 0x000474, "Member 'ARCNzMTB_FortActorBase::KaikagiListID' has a wrong offset!");

// Class RC.RCParamChapterSelectDialogData
// 0x0010 (0x0040 - 0x0030)
class URCParamChapterSelectDialogData final : public URCCSVData
{
public:
	TArray<struct FRCParamChapterSelectDialogTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamChapterSelectDialogData">();
	}
	static class URCParamChapterSelectDialogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamChapterSelectDialogData>();
	}
};
static_assert(alignof(URCParamChapterSelectDialogData) == 0x000008, "Wrong alignment on URCParamChapterSelectDialogData");
static_assert(sizeof(URCParamChapterSelectDialogData) == 0x000040, "Wrong size on URCParamChapterSelectDialogData");
static_assert(offsetof(URCParamChapterSelectDialogData, Data) == 0x000030, "Member 'URCParamChapterSelectDialogData::Data' has a wrong offset!");

// Class RC.RCNzMTB_WallActorBase
// 0x0170 (0x0418 - 0x02A8)
class ARCNzMTB_WallActorBase final : public ARCCustomEventActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Box;                                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          box2;                                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          box3;                                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Name_0;                                            // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextID;                                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallHP;                                            // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWallWeakPointType                            WeakPoint;                                         // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWallType                                     WallType;                                          // 0x02DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFort;                                            // 0x02DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWallAlignmentType                            TextAlignment;                                     // 0x02DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WallMeshName;                                      // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          WallMesh;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WallMotionName;                                    // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WallMotion;                                        // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WallSkMeshNormalName;                              // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WallSkMeshNormal;                                  // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WallSkMeshClackName;                               // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WallSkMeshClack;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WallSkMeshBreakName;                               // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WallSkMeshBreak;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallTextID;                                        // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallTextVoiceID;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallFirstEventID;                                  // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallBreakVoiceID;                                  // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WallBreakEventID;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IntervalVoiceID;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalVoiceDistance;                             // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiID;                                         // 0x038C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DropKaikagiID;                                     // 0x0394(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiMissEventID;                                // 0x039C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiUITextID;                                   // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiUITitleTextID;                              // 0x03AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallVoiceDistance;                                 // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsShowWallText;                                    // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallShowDistance;                                  // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowDistance;                                      // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopDistance;                                      // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CanAttackDistance;                                 // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoopBlockID;                                       // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiLoopVoiceID;                                // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiAttackVoiceID;                              // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiAttackEventID;                              // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiSuccessEventID;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackInputLimitDistance;                          // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KaizinID;                                          // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaizinScale;                                       // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaizinPosDepth;                                    // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaizinPosHeight;                                   // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaizinPosSide;                                     // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaizinAngle;                                       // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KaikagiListID;                                     // 0x040C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttackWall(const EWallWeakPointType Type, bool* Result);
	EWallType GetWallType();
	void InitializeWallActor();
	bool LoadParamData(class FName SceneID, int32 Index_0);
	void PlayTextVoice(class ARCCharacterRender* InChara, class FName VoiceID);
	void PlayWallTextVoice(class ARCCharacterRender* InChara);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzMTB_WallActorBase">();
	}
	static class ARCNzMTB_WallActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzMTB_WallActorBase>();
	}
};
static_assert(alignof(ARCNzMTB_WallActorBase) == 0x000008, "Wrong alignment on ARCNzMTB_WallActorBase");
static_assert(sizeof(ARCNzMTB_WallActorBase) == 0x000418, "Wrong size on ARCNzMTB_WallActorBase");
static_assert(offsetof(ARCNzMTB_WallActorBase, Scene) == 0x0002A8, "Member 'ARCNzMTB_WallActorBase::Scene' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, Box) == 0x0002B0, "Member 'ARCNzMTB_WallActorBase::Box' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, box2) == 0x0002B8, "Member 'ARCNzMTB_WallActorBase::box2' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, box3) == 0x0002C0, "Member 'ARCNzMTB_WallActorBase::box3' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, Name_0) == 0x0002C8, "Member 'ARCNzMTB_WallActorBase::Name_0' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, TextID) == 0x0002D0, "Member 'ARCNzMTB_WallActorBase::TextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallHP) == 0x0002D8, "Member 'ARCNzMTB_WallActorBase::WallHP' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WeakPoint) == 0x0002DC, "Member 'ARCNzMTB_WallActorBase::WeakPoint' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallType) == 0x0002DD, "Member 'ARCNzMTB_WallActorBase::WallType' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, IsFort) == 0x0002DE, "Member 'ARCNzMTB_WallActorBase::IsFort' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, TextAlignment) == 0x0002DF, "Member 'ARCNzMTB_WallActorBase::TextAlignment' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallMeshName) == 0x0002E0, "Member 'ARCNzMTB_WallActorBase::WallMeshName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallMesh) == 0x0002F0, "Member 'ARCNzMTB_WallActorBase::WallMesh' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallMotionName) == 0x0002F8, "Member 'ARCNzMTB_WallActorBase::WallMotionName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallMotion) == 0x000308, "Member 'ARCNzMTB_WallActorBase::WallMotion' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshNormalName) == 0x000310, "Member 'ARCNzMTB_WallActorBase::WallSkMeshNormalName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshNormal) == 0x000320, "Member 'ARCNzMTB_WallActorBase::WallSkMeshNormal' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshClackName) == 0x000328, "Member 'ARCNzMTB_WallActorBase::WallSkMeshClackName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshClack) == 0x000338, "Member 'ARCNzMTB_WallActorBase::WallSkMeshClack' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshBreakName) == 0x000340, "Member 'ARCNzMTB_WallActorBase::WallSkMeshBreakName' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallSkMeshBreak) == 0x000350, "Member 'ARCNzMTB_WallActorBase::WallSkMeshBreak' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallTextID) == 0x000358, "Member 'ARCNzMTB_WallActorBase::WallTextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallTextVoiceID) == 0x000360, "Member 'ARCNzMTB_WallActorBase::WallTextVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallFirstEventID) == 0x000368, "Member 'ARCNzMTB_WallActorBase::WallFirstEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallBreakVoiceID) == 0x000370, "Member 'ARCNzMTB_WallActorBase::WallBreakVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallBreakEventID) == 0x000378, "Member 'ARCNzMTB_WallActorBase::WallBreakEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, IntervalVoiceID) == 0x000380, "Member 'ARCNzMTB_WallActorBase::IntervalVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, IntervalVoiceDistance) == 0x000388, "Member 'ARCNzMTB_WallActorBase::IntervalVoiceDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiID) == 0x00038C, "Member 'ARCNzMTB_WallActorBase::KaikagiID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, DropKaikagiID) == 0x000394, "Member 'ARCNzMTB_WallActorBase::DropKaikagiID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiMissEventID) == 0x00039C, "Member 'ARCNzMTB_WallActorBase::KaikagiMissEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiUITextID) == 0x0003A4, "Member 'ARCNzMTB_WallActorBase::KaikagiUITextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiUITitleTextID) == 0x0003AC, "Member 'ARCNzMTB_WallActorBase::KaikagiUITitleTextID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallVoiceDistance) == 0x0003B4, "Member 'ARCNzMTB_WallActorBase::WallVoiceDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, IsShowWallText) == 0x0003B8, "Member 'ARCNzMTB_WallActorBase::IsShowWallText' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, WallShowDistance) == 0x0003BC, "Member 'ARCNzMTB_WallActorBase::WallShowDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, SlowDistance) == 0x0003C0, "Member 'ARCNzMTB_WallActorBase::SlowDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, LoopDistance) == 0x0003C4, "Member 'ARCNzMTB_WallActorBase::LoopDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, CanAttackDistance) == 0x0003C8, "Member 'ARCNzMTB_WallActorBase::CanAttackDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, LoopBlockID) == 0x0003CC, "Member 'ARCNzMTB_WallActorBase::LoopBlockID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiLoopVoiceID) == 0x0003D0, "Member 'ARCNzMTB_WallActorBase::KaikagiLoopVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiAttackVoiceID) == 0x0003D8, "Member 'ARCNzMTB_WallActorBase::KaikagiAttackVoiceID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiAttackEventID) == 0x0003E0, "Member 'ARCNzMTB_WallActorBase::KaikagiAttackEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiSuccessEventID) == 0x0003E8, "Member 'ARCNzMTB_WallActorBase::KaikagiSuccessEventID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, AttackInputLimitDistance) == 0x0003F0, "Member 'ARCNzMTB_WallActorBase::AttackInputLimitDistance' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinID) == 0x0003F4, "Member 'ARCNzMTB_WallActorBase::KaizinID' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinScale) == 0x0003F8, "Member 'ARCNzMTB_WallActorBase::KaizinScale' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinPosDepth) == 0x0003FC, "Member 'ARCNzMTB_WallActorBase::KaizinPosDepth' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinPosHeight) == 0x000400, "Member 'ARCNzMTB_WallActorBase::KaizinPosHeight' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinPosSide) == 0x000404, "Member 'ARCNzMTB_WallActorBase::KaizinPosSide' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaizinAngle) == 0x000408, "Member 'ARCNzMTB_WallActorBase::KaizinAngle' has a wrong offset!");
static_assert(offsetof(ARCNzMTB_WallActorBase, KaikagiListID) == 0x00040C, "Member 'ARCNzMTB_WallActorBase::KaikagiListID' has a wrong offset!");

// Class RC.RCParamCharacterModelListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterModelListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterModelListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterModelListData">();
	}
	static class URCParamCharacterModelListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterModelListData>();
	}
};
static_assert(alignof(URCParamCharacterModelListData) == 0x000008, "Wrong alignment on URCParamCharacterModelListData");
static_assert(sizeof(URCParamCharacterModelListData) == 0x000040, "Wrong size on URCParamCharacterModelListData");
static_assert(offsetof(URCParamCharacterModelListData, Data) == 0x000030, "Member 'URCParamCharacterModelListData::Data' has a wrong offset!");

// Class RC.RCNzMTBRockActorBase
// 0x0000 (0x0220 - 0x0220)
class ARCNzMTBRockActorBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzMTBRockActorBase">();
	}
	static class ARCNzMTBRockActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzMTBRockActorBase>();
	}
};
static_assert(alignof(ARCNzMTBRockActorBase) == 0x000008, "Wrong alignment on ARCNzMTBRockActorBase");
static_assert(sizeof(ARCNzMTBRockActorBase) == 0x000220, "Wrong size on ARCNzMTBRockActorBase");

// Class RC.RCNzPazzleAnswerSwordBase
// 0x0070 (0x0290 - 0x0220)
class ARCNzPazzleAnswerSwordBase final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             endTransform;                                      // 0x0230(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   answerWordText;                                    // 0x0260(0x0018)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	int32                                         answerWordPos;                                     // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             answerWordTexture;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPazzleAnswerSwordBase">();
	}
	static class ARCNzPazzleAnswerSwordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPazzleAnswerSwordBase>();
	}
};
static_assert(alignof(ARCNzPazzleAnswerSwordBase) == 0x000010, "Wrong alignment on ARCNzPazzleAnswerSwordBase");
static_assert(sizeof(ARCNzPazzleAnswerSwordBase) == 0x000290, "Wrong size on ARCNzPazzleAnswerSwordBase");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, Scene) == 0x000220, "Member 'ARCNzPazzleAnswerSwordBase::Scene' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, Mesh) == 0x000228, "Member 'ARCNzPazzleAnswerSwordBase::Mesh' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, endTransform) == 0x000230, "Member 'ARCNzPazzleAnswerSwordBase::endTransform' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, answerWordText) == 0x000260, "Member 'ARCNzPazzleAnswerSwordBase::answerWordText' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, answerWordPos) == 0x000278, "Member 'ARCNzPazzleAnswerSwordBase::answerWordPos' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleAnswerSwordBase, answerWordTexture) == 0x000280, "Member 'ARCNzPazzleAnswerSwordBase::answerWordTexture' has a wrong offset!");

// Class RC.RCParamCharacterDlcListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterDlcListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterDlcListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterDlcListData">();
	}
	static class URCParamCharacterDlcListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterDlcListData>();
	}
};
static_assert(alignof(URCParamCharacterDlcListData) == 0x000008, "Wrong alignment on URCParamCharacterDlcListData");
static_assert(sizeof(URCParamCharacterDlcListData) == 0x000040, "Wrong size on URCParamCharacterDlcListData");
static_assert(offsetof(URCParamCharacterDlcListData, Data) == 0x000030, "Member 'URCParamCharacterDlcListData::Data' has a wrong offset!");

// Class RC.RCNzPazzleAnswerWordBase
// 0x0010 (0x0230 - 0x0220)
class ARCNzPazzleAnswerWordBase final : public AActor
{
public:
	TArray<int32>                                 AnswerIndexList;                                   // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool AnswerCheck(int32 answerID);
	void LoadAnswerList(class FName SceneWordID, int32 targetBarrelIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPazzleAnswerWordBase">();
	}
	static class ARCNzPazzleAnswerWordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPazzleAnswerWordBase>();
	}
};
static_assert(alignof(ARCNzPazzleAnswerWordBase) == 0x000008, "Wrong alignment on ARCNzPazzleAnswerWordBase");
static_assert(sizeof(ARCNzPazzleAnswerWordBase) == 0x000230, "Wrong size on ARCNzPazzleAnswerWordBase");
static_assert(offsetof(ARCNzPazzleAnswerWordBase, AnswerIndexList) == 0x000220, "Member 'ARCNzPazzleAnswerWordBase::AnswerIndexList' has a wrong offset!");

// Class RC.RCNzPazzleBarrelBase
// 0x00F8 (0x0318 - 0x0220)
class ARCNzPazzleBarrelBase final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        upperAnswerWordRoot;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        lowerAnswerWordRoot;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_1;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_2;                                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_3;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_4;                                         // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_5;                                         // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_6;                                         // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        cameraParent;                                      // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rotateSpeed;                                       // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rotateSpeedScale;                                  // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         minRotateSpeed;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxRotateSpeed;                                    // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         minCamPitchRot;                                    // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxCamPitchRot;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InvertCamPitchRot;                                 // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedCamPitchRot;                                  // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxPointerY;                                       // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         minCamYawRot;                                      // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxCamYawRot;                                      // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InvertCamYawRot;                                   // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedCamYawRot;                                    // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxPointerX;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isRotate;                                          // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                kaikagiSpawnPointList;                             // 0x02B8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNzPazzleKaikagiActorBase*>    kaikagiActorList;                                  // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ARCNzPazzleKaikagiActorBase> kaikagiBaseClass;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShinigamiEatAngle;                                 // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTaikutuWait;                                    // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTaikutuWait;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               BaseCameraRot;                                     // 0x02EC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BarrelWordUpperAngle;                              // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrelWordLowerAngle;                              // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrelWordDepthOffset;                             // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrelWordTextScale;                               // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShinigamiAngleWord8;                               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShinigamiAngleWord12;                              // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShinigamiAngleWord16;                              // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitBarrelAngle;                                   // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddRotateCameraParent(const struct FRotator& addRot);
	void AddZoomCamera(float AddForward);
	void ChangeRotate(bool isRot);
	TArray<class ARCNzPazzleAnswerWordBase*> GetAnswerWordActorList();
	float GetRotateSpeed();
	float GetRotateSpeedScale();
	void InitializeAnswerWord(const TArray<class FText>& UpperTextList, const TArray<int32>& UpperTextPosList, const TArray<class FText>& LowerTextList, const TArray<int32>& LowerTextPosList, const TArray<class UTexture2D*>& UpperTextTextureList, const TArray<class UTexture2D*>& LowerTextTextureList, class FName SceneID);
	void InitializeKaikagiActor(const TArray<class FString>& KaikagiNameList, const TArray<class FString>& KaikagiTextList, const int32& Length);
	void PlayVoice(class ARCCharacterRender* InChara, class FName VoiceID);
	void SetKaikagiListLocation(const int32& Length);
	void SetRotateCameraParent(const struct FRotator& NewRot);
	void SetRotateCameraParentForPointer(const struct FVector2D& pointerPos);
	void SetRotateSpeed(float Speed);
	void SetRotateSpeedScale(float Scale);
	void StartNoMoveWaitTimer();
	bool SwitchIsRotate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPazzleBarrelBase">();
	}
	static class ARCNzPazzleBarrelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPazzleBarrelBase>();
	}
};
static_assert(alignof(ARCNzPazzleBarrelBase) == 0x000008, "Wrong alignment on ARCNzPazzleBarrelBase");
static_assert(sizeof(ARCNzPazzleBarrelBase) == 0x000318, "Wrong size on ARCNzPazzleBarrelBase");
static_assert(offsetof(ARCNzPazzleBarrelBase, Scene) == 0x000220, "Member 'ARCNzPazzleBarrelBase::Scene' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, Mesh) == 0x000228, "Member 'ARCNzPazzleBarrelBase::Mesh' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, upperAnswerWordRoot) == 0x000230, "Member 'ARCNzPazzleBarrelBase::upperAnswerWordRoot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, lowerAnswerWordRoot) == 0x000238, "Member 'ARCNzPazzleBarrelBase::lowerAnswerWordRoot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_1) == 0x000240, "Member 'ARCNzPazzleBarrelBase::kaikagi_1' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_2) == 0x000248, "Member 'ARCNzPazzleBarrelBase::kaikagi_2' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_3) == 0x000250, "Member 'ARCNzPazzleBarrelBase::kaikagi_3' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_4) == 0x000258, "Member 'ARCNzPazzleBarrelBase::kaikagi_4' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_5) == 0x000260, "Member 'ARCNzPazzleBarrelBase::kaikagi_5' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagi_6) == 0x000268, "Member 'ARCNzPazzleBarrelBase::kaikagi_6' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, cameraParent) == 0x000270, "Member 'ARCNzPazzleBarrelBase::cameraParent' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, rotateSpeed) == 0x000278, "Member 'ARCNzPazzleBarrelBase::rotateSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, rotateSpeedScale) == 0x00027C, "Member 'ARCNzPazzleBarrelBase::rotateSpeedScale' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, minRotateSpeed) == 0x000280, "Member 'ARCNzPazzleBarrelBase::minRotateSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, maxRotateSpeed) == 0x000284, "Member 'ARCNzPazzleBarrelBase::maxRotateSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, minCamPitchRot) == 0x000288, "Member 'ARCNzPazzleBarrelBase::minCamPitchRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, maxCamPitchRot) == 0x00028C, "Member 'ARCNzPazzleBarrelBase::maxCamPitchRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, InvertCamPitchRot) == 0x000290, "Member 'ARCNzPazzleBarrelBase::InvertCamPitchRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, SpeedCamPitchRot) == 0x000294, "Member 'ARCNzPazzleBarrelBase::SpeedCamPitchRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, maxPointerY) == 0x000298, "Member 'ARCNzPazzleBarrelBase::maxPointerY' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, minCamYawRot) == 0x00029C, "Member 'ARCNzPazzleBarrelBase::minCamYawRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, maxCamYawRot) == 0x0002A0, "Member 'ARCNzPazzleBarrelBase::maxCamYawRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, InvertCamYawRot) == 0x0002A4, "Member 'ARCNzPazzleBarrelBase::InvertCamYawRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, SpeedCamYawRot) == 0x0002A8, "Member 'ARCNzPazzleBarrelBase::SpeedCamYawRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, maxPointerX) == 0x0002AC, "Member 'ARCNzPazzleBarrelBase::maxPointerX' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, isRotate) == 0x0002B0, "Member 'ARCNzPazzleBarrelBase::isRotate' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagiSpawnPointList) == 0x0002B8, "Member 'ARCNzPazzleBarrelBase::kaikagiSpawnPointList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagiActorList) == 0x0002C8, "Member 'ARCNzPazzleBarrelBase::kaikagiActorList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, kaikagiBaseClass) == 0x0002D8, "Member 'ARCNzPazzleBarrelBase::kaikagiBaseClass' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, ShinigamiEatAngle) == 0x0002E0, "Member 'ARCNzPazzleBarrelBase::ShinigamiEatAngle' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, MinTaikutuWait) == 0x0002E4, "Member 'ARCNzPazzleBarrelBase::MinTaikutuWait' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, MaxTaikutuWait) == 0x0002E8, "Member 'ARCNzPazzleBarrelBase::MaxTaikutuWait' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, BaseCameraRot) == 0x0002EC, "Member 'ARCNzPazzleBarrelBase::BaseCameraRot' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, BarrelWordUpperAngle) == 0x0002F8, "Member 'ARCNzPazzleBarrelBase::BarrelWordUpperAngle' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, BarrelWordLowerAngle) == 0x0002FC, "Member 'ARCNzPazzleBarrelBase::BarrelWordLowerAngle' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, BarrelWordDepthOffset) == 0x000300, "Member 'ARCNzPazzleBarrelBase::BarrelWordDepthOffset' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, BarrelWordTextScale) == 0x000304, "Member 'ARCNzPazzleBarrelBase::BarrelWordTextScale' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, ShinigamiAngleWord8) == 0x000308, "Member 'ARCNzPazzleBarrelBase::ShinigamiAngleWord8' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, ShinigamiAngleWord12) == 0x00030C, "Member 'ARCNzPazzleBarrelBase::ShinigamiAngleWord12' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, ShinigamiAngleWord16) == 0x000310, "Member 'ARCNzPazzleBarrelBase::ShinigamiAngleWord16' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleBarrelBase, InitBarrelAngle) == 0x000314, "Member 'ARCNzPazzleBarrelBase::InitBarrelAngle' has a wrong offset!");

// Class RC.RCParamChapterNameData
// 0x0010 (0x0040 - 0x0030)
class URCParamChapterNameData final : public URCCSVData
{
public:
	TArray<struct FRCParamChapterNameTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamChapterNameData">();
	}
	static class URCParamChapterNameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamChapterNameData>();
	}
};
static_assert(alignof(URCParamChapterNameData) == 0x000008, "Wrong alignment on URCParamChapterNameData");
static_assert(sizeof(URCParamChapterNameData) == 0x000040, "Wrong size on URCParamChapterNameData");
static_assert(offsetof(URCParamChapterNameData, Data) == 0x000030, "Member 'URCParamChapterNameData::Data' has a wrong offset!");

// Class RC.RCNzPazzleKaikagiActorBase
// 0x0070 (0x0290 - 0x0220)
class ARCNzPazzleKaikagiActorBase final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Box;                                               // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 kaikagiName;                                       // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 kaikagiCapText;                                    // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KaikagiNum;                                        // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x0260(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	class FString GetCapText();
	void GetKaikagiTextData(class FString* nameText, class FString* capText);
	class FString GetNameText();
	void HoldMove(const struct FVector& nextLocation);
	void Initialize(const class FString& kaikagiName_0, const class FString& kaikagiCapText_0);
	void KaikagiHold();
	void KaikagiRelease();
	void SetKaikagiTextSize(const int32 Size);
	void SetStartTransform(const struct FTransform& Transform, class AActor* ParentActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPazzleKaikagiActorBase">();
	}
	static class ARCNzPazzleKaikagiActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPazzleKaikagiActorBase>();
	}
};
static_assert(alignof(ARCNzPazzleKaikagiActorBase) == 0x000010, "Wrong alignment on ARCNzPazzleKaikagiActorBase");
static_assert(sizeof(ARCNzPazzleKaikagiActorBase) == 0x000290, "Wrong size on ARCNzPazzleKaikagiActorBase");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, Scene) == 0x000220, "Member 'ARCNzPazzleKaikagiActorBase::Scene' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, Mesh) == 0x000228, "Member 'ARCNzPazzleKaikagiActorBase::Mesh' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, Box) == 0x000230, "Member 'ARCNzPazzleKaikagiActorBase::Box' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, kaikagiName) == 0x000238, "Member 'ARCNzPazzleKaikagiActorBase::kaikagiName' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, kaikagiCapText) == 0x000248, "Member 'ARCNzPazzleKaikagiActorBase::kaikagiCapText' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, KaikagiNum) == 0x000258, "Member 'ARCNzPazzleKaikagiActorBase::KaikagiNum' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleKaikagiActorBase, StartTransform) == 0x000260, "Member 'ARCNzPazzleKaikagiActorBase::StartTransform' has a wrong offset!");

// Class RC.RCNzPazzleManagerBase
// 0x0100 (0x0320 - 0x0220)
class ARCNzPazzleManagerBase final : public AActor
{
public:
	class ARCNzPazzleBarrelBase*                  BarrelActor;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCNzPuzzleCameraActor*                 CameraActor;                                       // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HpMax;                                             // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Hp;                                                // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   pazzleID;                                          // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SceneID;                                           // 0x0244(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BarrelWordCount;                                   // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnswerWordCount;                                   // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QuestionText;                                      // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 AnswerIndexList;                                   // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 BarrelIndexList;                                   // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     TextureList;                                       // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           AnswerWordIDList;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         KaikagiReturnSpeed;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomInMaxDistance;                           // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomOutMaxDistance;                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomSpeed;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissDamage;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrelRotateSpeed;                                 // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitTime;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlertTime;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintDrawTime;                                      // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPuzzleClear;                                      // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NowFocusIndex;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkillNum_KaikagiDown;                              // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkillNum_WordDown;                                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkillNum_Speed;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTutorialScene;                                   // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BgmID;                                             // 0x02E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResultCount_MissAnswer;                            // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResultCount_MissKaikagi;                           // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isBeginplay;                                       // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ChangeSpeedArray;                                  // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ChangeSpeedInterval_Min;                           // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSpeedInterval_Max;                           // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChangeSpeedIndex;                                  // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSpeedLastTimer;                              // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseStartUI;                                        // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPuzzleTimeZoneType                           BGTimeZone;                                        // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetKaikagiData(int32* listLength, TArray<class FString>* kaikagiNameTextList, TArray<class FString>* KaikagiTextList);
	void GetKaikagiNameText(class FName InKaiKagiID, class FString* kaikagiNameText);
	class FName GetSceneIDFName();
	void IncrementResultData_Answer();
	void IncrementResultData_Kaikagi();
	int32 InitFocusIndex();
	int32 InitializeBarrelWord();
	void LoadDataTable();
	int32 NextFocusIndex(bool bAnimation);
	void SendResultData();
	void SkillInfo_Start();
	void StartPuzzleClear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPazzleManagerBase">();
	}
	static class ARCNzPazzleManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPazzleManagerBase>();
	}
};
static_assert(alignof(ARCNzPazzleManagerBase) == 0x000008, "Wrong alignment on ARCNzPazzleManagerBase");
static_assert(sizeof(ARCNzPazzleManagerBase) == 0x000320, "Wrong size on ARCNzPazzleManagerBase");
static_assert(offsetof(ARCNzPazzleManagerBase, BarrelActor) == 0x000220, "Member 'ARCNzPazzleManagerBase::BarrelActor' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, CameraActor) == 0x000228, "Member 'ARCNzPazzleManagerBase::CameraActor' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, Damage) == 0x000230, "Member 'ARCNzPazzleManagerBase::Damage' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, HpMax) == 0x000234, "Member 'ARCNzPazzleManagerBase::HpMax' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, Hp) == 0x000238, "Member 'ARCNzPazzleManagerBase::Hp' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, pazzleID) == 0x00023C, "Member 'ARCNzPazzleManagerBase::pazzleID' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, SceneID) == 0x000244, "Member 'ARCNzPazzleManagerBase::SceneID' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, BarrelWordCount) == 0x00024C, "Member 'ARCNzPazzleManagerBase::BarrelWordCount' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, AnswerWordCount) == 0x000250, "Member 'ARCNzPazzleManagerBase::AnswerWordCount' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, QuestionText) == 0x000258, "Member 'ARCNzPazzleManagerBase::QuestionText' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, AnswerIndexList) == 0x000268, "Member 'ARCNzPazzleManagerBase::AnswerIndexList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, BarrelIndexList) == 0x000278, "Member 'ARCNzPazzleManagerBase::BarrelIndexList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, TextureList) == 0x000288, "Member 'ARCNzPazzleManagerBase::TextureList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, AnswerWordIDList) == 0x000298, "Member 'ARCNzPazzleManagerBase::AnswerWordIDList' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, KaikagiReturnSpeed) == 0x0002A8, "Member 'ARCNzPazzleManagerBase::KaikagiReturnSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, CameraZoomInMaxDistance) == 0x0002AC, "Member 'ARCNzPazzleManagerBase::CameraZoomInMaxDistance' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, CameraZoomOutMaxDistance) == 0x0002B0, "Member 'ARCNzPazzleManagerBase::CameraZoomOutMaxDistance' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, CameraZoomSpeed) == 0x0002B4, "Member 'ARCNzPazzleManagerBase::CameraZoomSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, MissDamage) == 0x0002B8, "Member 'ARCNzPazzleManagerBase::MissDamage' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, BarrelRotateSpeed) == 0x0002BC, "Member 'ARCNzPazzleManagerBase::BarrelRotateSpeed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, LimitTime) == 0x0002C0, "Member 'ARCNzPazzleManagerBase::LimitTime' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, AlertTime) == 0x0002C4, "Member 'ARCNzPazzleManagerBase::AlertTime' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, HintDrawTime) == 0x0002C8, "Member 'ARCNzPazzleManagerBase::HintDrawTime' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, bPuzzleClear) == 0x0002CC, "Member 'ARCNzPazzleManagerBase::bPuzzleClear' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, NowFocusIndex) == 0x0002D0, "Member 'ARCNzPazzleManagerBase::NowFocusIndex' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, SkillNum_KaikagiDown) == 0x0002D4, "Member 'ARCNzPazzleManagerBase::SkillNum_KaikagiDown' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, SkillNum_WordDown) == 0x0002D8, "Member 'ARCNzPazzleManagerBase::SkillNum_WordDown' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, SkillNum_Speed) == 0x0002DC, "Member 'ARCNzPazzleManagerBase::SkillNum_Speed' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, IsTutorialScene) == 0x0002E0, "Member 'ARCNzPazzleManagerBase::IsTutorialScene' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, BgmID) == 0x0002E4, "Member 'ARCNzPazzleManagerBase::BgmID' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ResultCount_MissAnswer) == 0x0002EC, "Member 'ARCNzPazzleManagerBase::ResultCount_MissAnswer' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ResultCount_MissKaikagi) == 0x0002F0, "Member 'ARCNzPazzleManagerBase::ResultCount_MissKaikagi' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, isBeginplay) == 0x0002F4, "Member 'ARCNzPazzleManagerBase::isBeginplay' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ChangeSpeedArray) == 0x0002F8, "Member 'ARCNzPazzleManagerBase::ChangeSpeedArray' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ChangeSpeedInterval_Min) == 0x000308, "Member 'ARCNzPazzleManagerBase::ChangeSpeedInterval_Min' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ChangeSpeedInterval_Max) == 0x00030C, "Member 'ARCNzPazzleManagerBase::ChangeSpeedInterval_Max' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ChangeSpeedIndex) == 0x000310, "Member 'ARCNzPazzleManagerBase::ChangeSpeedIndex' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, ChangeSpeedLastTimer) == 0x000314, "Member 'ARCNzPazzleManagerBase::ChangeSpeedLastTimer' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, UseStartUI) == 0x000318, "Member 'ARCNzPazzleManagerBase::UseStartUI' has a wrong offset!");
static_assert(offsetof(ARCNzPazzleManagerBase, BGTimeZone) == 0x000319, "Member 'ARCNzPazzleManagerBase::BGTimeZone' has a wrong offset!");

// Class RC.RCParamCharacterLookSettingData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterLookSettingData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterLookSettingTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterLookSettingData">();
	}
	static class URCParamCharacterLookSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterLookSettingData>();
	}
};
static_assert(alignof(URCParamCharacterLookSettingData) == 0x000008, "Wrong alignment on URCParamCharacterLookSettingData");
static_assert(sizeof(URCParamCharacterLookSettingData) == 0x000040, "Wrong size on URCParamCharacterLookSettingData");
static_assert(offsetof(URCParamCharacterLookSettingData, Data) == 0x000030, "Member 'URCParamCharacterLookSettingData::Data' has a wrong offset!");

// Class RC.RCNzPuzzle3DText
// 0x0000 (0x0248 - 0x0248)
class ARCNzPuzzle3DText final : public ARCLocalizeText3DActor
{
public:
	bool CheckTextID(class FName ID, class FText* resultText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzle3DText">();
	}
	static class ARCNzPuzzle3DText* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPuzzle3DText>();
	}
};
static_assert(alignof(ARCNzPuzzle3DText) == 0x000008, "Wrong alignment on ARCNzPuzzle3DText");
static_assert(sizeof(ARCNzPuzzle3DText) == 0x000248, "Wrong size on ARCNzPuzzle3DText");

// Class RC.RCParamEnviromentSoundData
// 0x0010 (0x0040 - 0x0030)
class URCParamEnviromentSoundData final : public URCCSVData
{
public:
	TArray<struct FRCParamEnviromentSoundTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEnviromentSoundData">();
	}
	static class URCParamEnviromentSoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEnviromentSoundData>();
	}
};
static_assert(alignof(URCParamEnviromentSoundData) == 0x000008, "Wrong alignment on URCParamEnviromentSoundData");
static_assert(sizeof(URCParamEnviromentSoundData) == 0x000040, "Wrong size on URCParamEnviromentSoundData");
static_assert(offsetof(URCParamEnviromentSoundData, Data) == 0x000030, "Member 'URCParamEnviromentSoundData::Data' has a wrong offset!");

// Class RC.RCNzPuzzleAnswerLayoutBase
// 0x0018 (0x02F0 - 0x02D8)
class URCNzPuzzleAnswerLayoutBase final : public URCUiWidgetBase
{
public:
	class UHorizontalBox*                         answerListHorizontalBox;                           // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URCNzPuzzleAnswerBase*>          WordList;                                          // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void ClearWordList();
	void InitializePuzzleAnswerLayout();
	void SetAnswer(int32 wordPos, class FName wordText, class UTexture2D* wordTexture);
	void SetWordList(int32 Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleAnswerLayoutBase">();
	}
	static class URCNzPuzzleAnswerLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleAnswerLayoutBase>();
	}
};
static_assert(alignof(URCNzPuzzleAnswerLayoutBase) == 0x000008, "Wrong alignment on URCNzPuzzleAnswerLayoutBase");
static_assert(sizeof(URCNzPuzzleAnswerLayoutBase) == 0x0002F0, "Wrong size on URCNzPuzzleAnswerLayoutBase");
static_assert(offsetof(URCNzPuzzleAnswerLayoutBase, answerListHorizontalBox) == 0x0002D8, "Member 'URCNzPuzzleAnswerLayoutBase::answerListHorizontalBox' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleAnswerLayoutBase, WordList) == 0x0002E0, "Member 'URCNzPuzzleAnswerLayoutBase::WordList' has a wrong offset!");

// Class RC.RCNzPuzzleCameraActor
// 0x0068 (0x0288 - 0x0220)
class ARCNzPuzzleCameraActor final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_1;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_2;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_3;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_4;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_5;                                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        kaikagi_6;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                kaikagiSpawnPointList;                             // 0x0258(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ARCNzPazzleKaikagiActorBase*>    kaikagiActorList;                                  // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ARCNzPazzleKaikagiActorBase> kaikagiBaseClass;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KaikagiDepthPos;                                   // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcKaikagiSpawnLocationList(const TArray<struct FVector>& locList, const TArray<struct FVector>& dirList, const TArray<struct FVector>& HintDirList);
	float GetKaikagiDistance();
	void InitializeKaikagiActor(const TArray<class FString>& KaikagiNameList, const TArray<class FString>& KaikagiTextList, const int32& Length, const int32 WordSize);
	void SetKaikagiListLocation(const int32& Length);
	void SetZoomLength(float Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleCameraActor">();
	}
	static class ARCNzPuzzleCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCNzPuzzleCameraActor>();
	}
};
static_assert(alignof(ARCNzPuzzleCameraActor) == 0x000008, "Wrong alignment on ARCNzPuzzleCameraActor");
static_assert(sizeof(ARCNzPuzzleCameraActor) == 0x000288, "Wrong size on ARCNzPuzzleCameraActor");
static_assert(offsetof(ARCNzPuzzleCameraActor, Root) == 0x000220, "Member 'ARCNzPuzzleCameraActor::Root' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_1) == 0x000228, "Member 'ARCNzPuzzleCameraActor::kaikagi_1' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_2) == 0x000230, "Member 'ARCNzPuzzleCameraActor::kaikagi_2' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_3) == 0x000238, "Member 'ARCNzPuzzleCameraActor::kaikagi_3' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_4) == 0x000240, "Member 'ARCNzPuzzleCameraActor::kaikagi_4' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_5) == 0x000248, "Member 'ARCNzPuzzleCameraActor::kaikagi_5' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagi_6) == 0x000250, "Member 'ARCNzPuzzleCameraActor::kaikagi_6' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagiSpawnPointList) == 0x000258, "Member 'ARCNzPuzzleCameraActor::kaikagiSpawnPointList' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagiActorList) == 0x000268, "Member 'ARCNzPuzzleCameraActor::kaikagiActorList' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, kaikagiBaseClass) == 0x000278, "Member 'ARCNzPuzzleCameraActor::kaikagiBaseClass' has a wrong offset!");
static_assert(offsetof(ARCNzPuzzleCameraActor, KaikagiDepthPos) == 0x000280, "Member 'ARCNzPuzzleCameraActor::KaikagiDepthPos' has a wrong offset!");

// Class RC.RCParamCharacterSelectPageSettingData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterSelectPageSettingData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterSelectPageSettingTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterSelectPageSettingData">();
	}
	static class URCParamCharacterSelectPageSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterSelectPageSettingData>();
	}
};
static_assert(alignof(URCParamCharacterSelectPageSettingData) == 0x000008, "Wrong alignment on URCParamCharacterSelectPageSettingData");
static_assert(sizeof(URCParamCharacterSelectPageSettingData) == 0x000040, "Wrong size on URCParamCharacterSelectPageSettingData");
static_assert(offsetof(URCParamCharacterSelectPageSettingData, Data) == 0x000030, "Member 'URCParamCharacterSelectPageSettingData::Data' has a wrong offset!");

// Class RC.RCNzPuzzleHintBalloonBase
// 0x0030 (0x0308 - 0x02D8)
class URCNzPuzzleHintBalloonBase final : public URCUiWidgetBase
{
public:
	class URCNzPuzzleHintBalloonTextBase*         HintText;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 decoImg;                                           // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VoiceID;                                           // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              widgetPosition;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                decoImgMargin;                                     // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckCursorHover(const struct FVector2D& cursorPos);
	void InitializePuzzleHintBalloon();
	void PlayHint();
	void SetWidgetPosition(const struct FVector2D& NewPosition);
	void ShowHint(const class FText& Text, const class FName VoiceID_0);
	void ShowHintAfterEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleHintBalloonBase">();
	}
	static class URCNzPuzzleHintBalloonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleHintBalloonBase>();
	}
};
static_assert(alignof(URCNzPuzzleHintBalloonBase) == 0x000008, "Wrong alignment on URCNzPuzzleHintBalloonBase");
static_assert(sizeof(URCNzPuzzleHintBalloonBase) == 0x000308, "Wrong size on URCNzPuzzleHintBalloonBase");
static_assert(offsetof(URCNzPuzzleHintBalloonBase, HintText) == 0x0002D8, "Member 'URCNzPuzzleHintBalloonBase::HintText' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleHintBalloonBase, decoImg) == 0x0002E0, "Member 'URCNzPuzzleHintBalloonBase::decoImg' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleHintBalloonBase, VoiceID) == 0x0002E8, "Member 'URCNzPuzzleHintBalloonBase::VoiceID' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleHintBalloonBase, widgetPosition) == 0x0002F0, "Member 'URCNzPuzzleHintBalloonBase::widgetPosition' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleHintBalloonBase, decoImgMargin) == 0x0002F8, "Member 'URCNzPuzzleHintBalloonBase::decoImgMargin' has a wrong offset!");

// Class RC.RCNzPuzzleHintBalloonTextBase
// 0x0008 (0x02E0 - 0x02D8)
class URCNzPuzzleHintBalloonTextBase final : public URCUiWidgetBase
{
public:
	class USpTextBlock*                           TextBlock;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetHintText();
	void InitializePuzzleHintBalloonText();
	void SetHintText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleHintBalloonTextBase">();
	}
	static class URCNzPuzzleHintBalloonTextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleHintBalloonTextBase>();
	}
};
static_assert(alignof(URCNzPuzzleHintBalloonTextBase) == 0x000008, "Wrong alignment on URCNzPuzzleHintBalloonTextBase");
static_assert(sizeof(URCNzPuzzleHintBalloonTextBase) == 0x0002E0, "Wrong size on URCNzPuzzleHintBalloonTextBase");
static_assert(offsetof(URCNzPuzzleHintBalloonTextBase, TextBlock) == 0x0002D8, "Member 'URCNzPuzzleHintBalloonTextBase::TextBlock' has a wrong offset!");

// Class RC.RCParamCharacterFacialTempleteData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterFacialTempleteData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterFacialTempleteTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterFacialTempleteData">();
	}
	static class URCParamCharacterFacialTempleteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterFacialTempleteData>();
	}
};
static_assert(alignof(URCParamCharacterFacialTempleteData) == 0x000008, "Wrong alignment on URCParamCharacterFacialTempleteData");
static_assert(sizeof(URCParamCharacterFacialTempleteData) == 0x000040, "Wrong size on URCParamCharacterFacialTempleteData");
static_assert(offsetof(URCParamCharacterFacialTempleteData, Data) == 0x000030, "Member 'URCParamCharacterFacialTempleteData::Data' has a wrong offset!");

// Class RC.RCNzPuzzleMainLayout
// 0x0000 (0x0270 - 0x0270)
class URCNzPuzzleMainLayout final : public URCUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleMainLayout">();
	}
	static class URCNzPuzzleMainLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleMainLayout>();
	}
};
static_assert(alignof(URCNzPuzzleMainLayout) == 0x000008, "Wrong alignment on URCNzPuzzleMainLayout");
static_assert(sizeof(URCNzPuzzleMainLayout) == 0x000270, "Wrong size on URCNzPuzzleMainLayout");

// Class RC.RCVariableLog
// 0x0020 (0x0048 - 0x0028)
class URCVariableLog final : public UObject
{
public:
	struct FRCVariableLogList                     BacklogInfo;                                       // 0x0028(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bBacklogAdd;                                       // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableLog">();
	}
	static class URCVariableLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableLog>();
	}
};
static_assert(alignof(URCVariableLog) == 0x000008, "Wrong alignment on URCVariableLog");
static_assert(sizeof(URCVariableLog) == 0x000048, "Wrong size on URCVariableLog");
static_assert(offsetof(URCVariableLog, BacklogInfo) == 0x000028, "Member 'URCVariableLog::BacklogInfo' has a wrong offset!");
static_assert(offsetof(URCVariableLog, bBacklogAdd) == 0x000040, "Member 'URCVariableLog::bBacklogAdd' has a wrong offset!");

// Class RC.RCNzPuzzleMainLayoutBase
// 0x00A0 (0x0378 - 0x02D8)
class URCNzPuzzleMainLayoutBase final : public URCUiWidgetBase
{
public:
	class URCNzPuzzleHintBalloonBase*             HintBalloonR;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleHintBalloonBase*             HintBalloonL;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleHintBalloonBase*             currentHoverHintBalloon;                           // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzlePointerBase*                 Pointer;                                           // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleAnswerLayoutBase*            AnswerLayout;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleQuestionBase*                question;                                          // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzPuzzleTimelimitAlertBase*          TimelimitAlert;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleTimeLimitWidget*           TimeLimit;                                         // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSpeed;                                         // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzCriminalButtonGuideList*           ButtonGuideWidget;                                 // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PrePointerLocation;                                // 0x0340(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCNzPuzzleHintBalloonBase*>     HintBalloonList;                                   // 0x0350(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              PreScreenPos;                                      // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Debug_AutoMoveTargetPos;                           // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CalcIsHoverCursor(const struct FMargin& Offsets, const struct FVector2D& Size, const struct FVector2D& halfViewportSize, const struct FVector2D& cursorPos, bool isLeft);
	void CheckIsHoverCursorToHintBalloon();
	bool CheckPointerHoverType(EPuzzlePointerHoverType Type);
	TArray<struct FVector2D> GetHintBalloonBox(class URCNzPuzzleHintBalloonBase* Widget, bool isLeft);
	void GetPointerLocation(struct FVector* Location, struct FVector* Direction);
	struct FVector GetPointerMoveDistance();
	void GetPointerScreenPosition(float* PositionX, float* PositionY);
	void GetPointerScreenPositionAlpha(float* PositionX, float* PositionY);
	void GetWidget3DLocAndDir(const class UWidget* Widget, struct FVector* Location, struct FVector* Direction);
	void HideButtonGuide();
	void InitializePuzzleMainLayout();
	void PlayHint();
	bool PointerMove(float DeltaTime, float Aspect);
	void SetAnswer(int32 wordPos, class FName wordText, class UTexture2D* wordTexture);
	void SetHoverPointer(EPuzzlePointerHoverType Type);
	void SetQuestion(const class FText& wordText);
	void SetTimeLimit(float Time);
	void SetWordListNum(int32 Length);
	void ShowButtonGuide();
	void ShowHint(const int32 KaikagiNum, const class FText& HintText, const class FName hintVoiceID);
	void StartAlert();
	void StartUI();
	void SynchronizeToInputPlatform(ERCInputPlatform InputPlatform);
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleMainLayoutBase">();
	}
	static class URCNzPuzzleMainLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleMainLayoutBase>();
	}
};
static_assert(alignof(URCNzPuzzleMainLayoutBase) == 0x000008, "Wrong alignment on URCNzPuzzleMainLayoutBase");
static_assert(sizeof(URCNzPuzzleMainLayoutBase) == 0x000378, "Wrong size on URCNzPuzzleMainLayoutBase");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, HintBalloonR) == 0x0002D8, "Member 'URCNzPuzzleMainLayoutBase::HintBalloonR' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, HintBalloonL) == 0x0002E0, "Member 'URCNzPuzzleMainLayoutBase::HintBalloonL' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, currentHoverHintBalloon) == 0x0002E8, "Member 'URCNzPuzzleMainLayoutBase::currentHoverHintBalloon' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, Pointer) == 0x0002F0, "Member 'URCNzPuzzleMainLayoutBase::Pointer' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, AnswerLayout) == 0x0002F8, "Member 'URCNzPuzzleMainLayoutBase::AnswerLayout' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, question) == 0x000300, "Member 'URCNzPuzzleMainLayoutBase::question' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, TimelimitAlert) == 0x000308, "Member 'URCNzPuzzleMainLayoutBase::TimelimitAlert' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, TimeLimit) == 0x000310, "Member 'URCNzPuzzleMainLayoutBase::TimeLimit' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, AN_Start) == 0x000318, "Member 'URCNzPuzzleMainLayoutBase::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, AN_Wait) == 0x000320, "Member 'URCNzPuzzleMainLayoutBase::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, AN_Finish) == 0x000328, "Member 'URCNzPuzzleMainLayoutBase::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, MoveSpeed) == 0x000330, "Member 'URCNzPuzzleMainLayoutBase::MoveSpeed' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, ButtonGuideWidget) == 0x000338, "Member 'URCNzPuzzleMainLayoutBase::ButtonGuideWidget' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, PrePointerLocation) == 0x000340, "Member 'URCNzPuzzleMainLayoutBase::PrePointerLocation' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, HintBalloonList) == 0x000350, "Member 'URCNzPuzzleMainLayoutBase::HintBalloonList' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, PreScreenPos) == 0x000360, "Member 'URCNzPuzzleMainLayoutBase::PreScreenPos' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleMainLayoutBase, Debug_AutoMoveTargetPos) == 0x000368, "Member 'URCNzPuzzleMainLayoutBase::Debug_AutoMoveTargetPos' has a wrong offset!");

// Class RC.RCNzPuzzleMainResultLayoutBase
// 0x0000 (0x02D8 - 0x02D8)
class URCNzPuzzleMainResultLayoutBase final : public URCUiWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleMainResultLayoutBase">();
	}
	static class URCNzPuzzleMainResultLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleMainResultLayoutBase>();
	}
};
static_assert(alignof(URCNzPuzzleMainResultLayoutBase) == 0x000008, "Wrong alignment on URCNzPuzzleMainResultLayoutBase");
static_assert(sizeof(URCNzPuzzleMainResultLayoutBase) == 0x0002D8, "Wrong size on URCNzPuzzleMainResultLayoutBase");

// Class RC.RCNzPuzzlePointerBase
// 0x0038 (0x0310 - 0x02D8)
class URCNzPuzzlePointerBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_UnSelect;                                       // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Select;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Select_Kaikagi;                                 // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Drag_Kaikagi;                                   // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Select_Hint;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Block;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pointerSize;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isKaikagiSelected;                                 // 0x030C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPuzzlePointerHoverType                       currentType;                                       // 0x030D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30E[0x2];                                      // 0x030E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckHoverType(EPuzzlePointerHoverType Type);
	void InitializePuzzlePointer();
	void SetHover(EPuzzlePointerHoverType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzlePointerBase">();
	}
	static class URCNzPuzzlePointerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzlePointerBase>();
	}
};
static_assert(alignof(URCNzPuzzlePointerBase) == 0x000008, "Wrong alignment on URCNzPuzzlePointerBase");
static_assert(sizeof(URCNzPuzzlePointerBase) == 0x000310, "Wrong size on URCNzPuzzlePointerBase");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_UnSelect) == 0x0002D8, "Member 'URCNzPuzzlePointerBase::AN_UnSelect' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_Select) == 0x0002E0, "Member 'URCNzPuzzlePointerBase::AN_Select' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_Select_Kaikagi) == 0x0002E8, "Member 'URCNzPuzzlePointerBase::AN_Select_Kaikagi' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_Drag_Kaikagi) == 0x0002F0, "Member 'URCNzPuzzlePointerBase::AN_Drag_Kaikagi' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_Select_Hint) == 0x0002F8, "Member 'URCNzPuzzlePointerBase::AN_Select_Hint' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, AN_Block) == 0x000300, "Member 'URCNzPuzzlePointerBase::AN_Block' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, pointerSize) == 0x000308, "Member 'URCNzPuzzlePointerBase::pointerSize' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, isKaikagiSelected) == 0x00030C, "Member 'URCNzPuzzlePointerBase::isKaikagiSelected' has a wrong offset!");
static_assert(offsetof(URCNzPuzzlePointerBase, currentType) == 0x00030D, "Member 'URCNzPuzzlePointerBase::currentType' has a wrong offset!");

// Class RC.RCVariableNazoResult
// 0x0050 (0x0078 - 0x0028)
class URCVariableNazoResult final : public UObject
{
public:
	TArray<struct FRCVariableNazoResultList>      ResultAllInfo;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FRCVariableNazoResultList              ResultCurrentInfo;                                 // 0x0038(0x0038)(NativeAccessSpecifierPrivate)
	class FName                                   NowMinigameID;                                     // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableNazoResult">();
	}
	static class URCVariableNazoResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableNazoResult>();
	}
};
static_assert(alignof(URCVariableNazoResult) == 0x000008, "Wrong alignment on URCVariableNazoResult");
static_assert(sizeof(URCVariableNazoResult) == 0x000078, "Wrong size on URCVariableNazoResult");
static_assert(offsetof(URCVariableNazoResult, ResultAllInfo) == 0x000028, "Member 'URCVariableNazoResult::ResultAllInfo' has a wrong offset!");
static_assert(offsetof(URCVariableNazoResult, ResultCurrentInfo) == 0x000038, "Member 'URCVariableNazoResult::ResultCurrentInfo' has a wrong offset!");
static_assert(offsetof(URCVariableNazoResult, NowMinigameID) == 0x000070, "Member 'URCVariableNazoResult::NowMinigameID' has a wrong offset!");

// Class RC.RCNzPuzzleTimelimitAlertBase
// 0x0038 (0x0310 - 0x02D8)
class URCNzPuzzleTimelimitAlertBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_OffAlert;                                       // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isStartAlert;                                      // 0x02F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             StartAnimFinishedDelegate;                         // 0x02FC(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AN_StartFinished();
	void InitializePuzzleTimelimitAleart();
	void StartAlert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzPuzzleTimelimitAlertBase">();
	}
	static class URCNzPuzzleTimelimitAlertBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzPuzzleTimelimitAlertBase>();
	}
};
static_assert(alignof(URCNzPuzzleTimelimitAlertBase) == 0x000008, "Wrong alignment on URCNzPuzzleTimelimitAlertBase");
static_assert(sizeof(URCNzPuzzleTimelimitAlertBase) == 0x000310, "Wrong size on URCNzPuzzleTimelimitAlertBase");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, AN_OffAlert) == 0x0002D8, "Member 'URCNzPuzzleTimelimitAlertBase::AN_OffAlert' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, AN_Start) == 0x0002E0, "Member 'URCNzPuzzleTimelimitAlertBase::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, AN_Wait) == 0x0002E8, "Member 'URCNzPuzzleTimelimitAlertBase::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, AN_Finish) == 0x0002F0, "Member 'URCNzPuzzleTimelimitAlertBase::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, isStartAlert) == 0x0002F8, "Member 'URCNzPuzzleTimelimitAlertBase::isStartAlert' has a wrong offset!");
static_assert(offsetof(URCNzPuzzleTimelimitAlertBase, StartAnimFinishedDelegate) == 0x0002FC, "Member 'URCNzPuzzleTimelimitAlertBase::StartAnimFinishedDelegate' has a wrong offset!");

// Class RC.RCNzResultRank
// 0x0010 (0x02E8 - 0x02D8)
class URCNzResultRank : public URCUiWidgetBase
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher_Rank;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzResultRank">();
	}
	static class URCNzResultRank* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzResultRank>();
	}
};
static_assert(alignof(URCNzResultRank) == 0x000008, "Wrong alignment on URCNzResultRank");
static_assert(sizeof(URCNzResultRank) == 0x0002E8, "Wrong size on URCNzResultRank");
static_assert(offsetof(URCNzResultRank, WidgetSwitcher_Rank) == 0x0002D8, "Member 'URCNzResultRank::WidgetSwitcher_Rank' has a wrong offset!");

// Class RC.RCNzResultRankCalculator
// 0x00B8 (0x00E0 - 0x0028)
class URCNzResultRankCalculator final : public UObject
{
public:
	uint8                                         Pad_28[0x2C];                                      // 0x0028(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChapterNumber;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x53];                                      // 0x0058(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          HitPointRank;                                      // 0x00AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          ResultRank;                                        // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TanteiPoint;                                       // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ContinueCount;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzResultRankCalculator">();
	}
	static class URCNzResultRankCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzResultRankCalculator>();
	}
};
static_assert(alignof(URCNzResultRankCalculator) == 0x000008, "Wrong alignment on URCNzResultRankCalculator");
static_assert(sizeof(URCNzResultRankCalculator) == 0x0000E0, "Wrong size on URCNzResultRankCalculator");
static_assert(offsetof(URCNzResultRankCalculator, ChapterNumber) == 0x000054, "Member 'URCNzResultRankCalculator::ChapterNumber' has a wrong offset!");
static_assert(offsetof(URCNzResultRankCalculator, HitPointRank) == 0x0000AB, "Member 'URCNzResultRankCalculator::HitPointRank' has a wrong offset!");
static_assert(offsetof(URCNzResultRankCalculator, ResultRank) == 0x0000AC, "Member 'URCNzResultRankCalculator::ResultRank' has a wrong offset!");
static_assert(offsetof(URCNzResultRankCalculator, TanteiPoint) == 0x0000B0, "Member 'URCNzResultRankCalculator::TanteiPoint' has a wrong offset!");
static_assert(offsetof(URCNzResultRankCalculator, ContinueCount) == 0x0000B4, "Member 'URCNzResultRankCalculator::ContinueCount' has a wrong offset!");

// Class RC.RCVehicleActor
// 0x0000 (0x0288 - 0x0288)
class ARCVehicleActor final : public ARCActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleActor">();
	}
	static class ARCVehicleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCVehicleActor>();
	}
};
static_assert(alignof(ARCVehicleActor) == 0x000008, "Wrong alignment on ARCVehicleActor");
static_assert(sizeof(ARCVehicleActor) == 0x000288, "Wrong size on ARCVehicleActor");

// Class RC.RCNzResultScoreDetails
// 0x0030 (0x0308 - 0x02D8)
class URCNzResultScoreDetails : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzResultScoreDetails">();
	}
	static class URCNzResultScoreDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzResultScoreDetails>();
	}
};
static_assert(alignof(URCNzResultScoreDetails) == 0x000008, "Wrong alignment on URCNzResultScoreDetails");
static_assert(sizeof(URCNzResultScoreDetails) == 0x000308, "Wrong size on URCNzResultScoreDetails");

// Class RC.RCParamEventMapConnectInfoData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventMapConnectInfoData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventMapConnectInfoTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventMapConnectInfoData">();
	}
	static class URCParamEventMapConnectInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventMapConnectInfoData>();
	}
};
static_assert(alignof(URCParamEventMapConnectInfoData) == 0x000008, "Wrong alignment on URCParamEventMapConnectInfoData");
static_assert(sizeof(URCParamEventMapConnectInfoData) == 0x000040, "Wrong size on URCParamEventMapConnectInfoData");
static_assert(offsetof(URCParamEventMapConnectInfoData, Data) == 0x000030, "Member 'URCParamEventMapConnectInfoData::Data' has a wrong offset!");

// Class RC.RCNzResultScoreDetailsContent
// 0x0048 (0x0320 - 0x02D8)
class URCNzResultScoreDetailsContent : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      SpText_Number;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      SpText_EvaluationItem_Name;                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x20];                                     // 0x0300(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzResultScoreDetailsContent">();
	}
	static class URCNzResultScoreDetailsContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzResultScoreDetailsContent>();
	}
};
static_assert(alignof(URCNzResultScoreDetailsContent) == 0x000008, "Wrong alignment on URCNzResultScoreDetailsContent");
static_assert(sizeof(URCNzResultScoreDetailsContent) == 0x000320, "Wrong size on URCNzResultScoreDetailsContent");
static_assert(offsetof(URCNzResultScoreDetailsContent, SpText_Number) == 0x0002D8, "Member 'URCNzResultScoreDetailsContent::SpText_Number' has a wrong offset!");
static_assert(offsetof(URCNzResultScoreDetailsContent, SpText_EvaluationItem_Name) == 0x0002F8, "Member 'URCNzResultScoreDetailsContent::SpText_EvaluationItem_Name' has a wrong offset!");

// Class RC.RCNzSceneChangeLoadingScreen
// 0x0030 (0x0058 - 0x0028)
class URCNzSceneChangeLoadingScreen final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzSceneChangeLoadingWidget*          FadeWidget;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzSceneChangeLoadingScreen">();
	}
	static class URCNzSceneChangeLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzSceneChangeLoadingScreen>();
	}
};
static_assert(alignof(URCNzSceneChangeLoadingScreen) == 0x000008, "Wrong alignment on URCNzSceneChangeLoadingScreen");
static_assert(sizeof(URCNzSceneChangeLoadingScreen) == 0x000058, "Wrong size on URCNzSceneChangeLoadingScreen");
static_assert(offsetof(URCNzSceneChangeLoadingScreen, FadeWidget) == 0x000048, "Member 'URCNzSceneChangeLoadingScreen::FadeWidget' has a wrong offset!");

// Class RC.RCVehicleControllerBFL
// 0x0000 (0x0028 - 0x0028)
class URCVehicleControllerBFL final : public URCBlueprintFunctionLibrary
{
public:
	static void SetVisible(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleControllerBFL">();
	}
	static class URCVehicleControllerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVehicleControllerBFL>();
	}
};
static_assert(alignof(URCVehicleControllerBFL) == 0x000008, "Wrong alignment on URCVehicleControllerBFL");
static_assert(sizeof(URCVehicleControllerBFL) == 0x000028, "Wrong size on URCVehicleControllerBFL");

// Class RC.RCNzUiBattleAssist
// 0x0070 (0x0348 - 0x02D8)
class URCNzUiBattleAssist final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_AssistBarMax;                                   // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_AssistBarNormal;                                // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_AssistFace;                                    // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AssistBar_Mask;                                    // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadingImage;                                     // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FaceImagePath;                                     // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	ERCNzUiBattleAssistStatus GetBattleCutinStatus();
	void InitializeBattleAssist(const struct FSoftObjectPath& InFaceImagePath);
	void Open();
	void SetAssistGauge(float InAssistGauge, float InAssistGaugeMax);
	void UninitializeBattleAssist();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleAssist">();
	}
	static class URCNzUiBattleAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleAssist>();
	}
};
static_assert(alignof(URCNzUiBattleAssist) == 0x000008, "Wrong alignment on URCNzUiBattleAssist");
static_assert(sizeof(URCNzUiBattleAssist) == 0x000348, "Wrong size on URCNzUiBattleAssist");
static_assert(offsetof(URCNzUiBattleAssist, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleAssist::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, AN_Finish) == 0x0002E8, "Member 'URCNzUiBattleAssist::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, AN_AssistBarMax) == 0x0002F0, "Member 'URCNzUiBattleAssist::AN_AssistBarMax' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, AN_AssistBarNormal) == 0x0002F8, "Member 'URCNzUiBattleAssist::AN_AssistBarNormal' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, Img_AssistFace) == 0x000300, "Member 'URCNzUiBattleAssist::Img_AssistFace' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, AssistBar_Mask) == 0x000308, "Member 'URCNzUiBattleAssist::AssistBar_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, WBP_ButtonGuide) == 0x000310, "Member 'URCNzUiBattleAssist::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, bLoadingImage) == 0x000318, "Member 'URCNzUiBattleAssist::bLoadingImage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleAssist, FaceImagePath) == 0x000320, "Member 'URCNzUiBattleAssist::FaceImagePath' has a wrong offset!");

// Class RC.RCNzUiBattleDodge
// 0x0028 (0x0300 - 0x02D8)
class URCNzUiBattleDodge final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            DodgeBTN;                                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	ERCNzUiBattleDodgeStatus GetBattleDodgeStatus();
	void InitializeBattleDodge();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleDodge">();
	}
	static class URCNzUiBattleDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleDodge>();
	}
};
static_assert(alignof(URCNzUiBattleDodge) == 0x000008, "Wrong alignment on URCNzUiBattleDodge");
static_assert(sizeof(URCNzUiBattleDodge) == 0x000300, "Wrong size on URCNzUiBattleDodge");
static_assert(offsetof(URCNzUiBattleDodge, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleDodge::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleDodge, AN_Wait) == 0x0002E8, "Member 'URCNzUiBattleDodge::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleDodge, AN_Finish) == 0x0002F0, "Member 'URCNzUiBattleDodge::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleDodge, DodgeBTN) == 0x0002F8, "Member 'URCNzUiBattleDodge::DodgeBTN' has a wrong offset!");

// Class RC.RCParamEventListData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventListData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventListTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventListData">();
	}
	static class URCParamEventListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventListData>();
	}
};
static_assert(alignof(URCParamEventListData) == 0x000008, "Wrong alignment on URCParamEventListData");
static_assert(sizeof(URCParamEventListData) == 0x000040, "Wrong size on URCParamEventListData");
static_assert(offsetof(URCParamEventListData, Data) == 0x000030, "Member 'URCParamEventListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleGameOver
// 0x0048 (0x0340 - 0x02F8)
class URCNzUiBattleGameOver final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectIndex;                                       // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void Decide();
	ERCNzUiBattleGameOverStatus GetBattleGameOverStatus();
	int32 GetSelectIndex();
	void InitializeBattleGameOver();
	void Open();
	bool Select(int32 InSelectIndex);
	bool SelectStart(int32 InSelectIndex);
	class UWidget* UpAndDown(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleGameOver">();
	}
	static class URCNzUiBattleGameOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleGameOver>();
	}
};
static_assert(alignof(URCNzUiBattleGameOver) == 0x000008, "Wrong alignment on URCNzUiBattleGameOver");
static_assert(sizeof(URCNzUiBattleGameOver) == 0x000340, "Wrong size on URCNzUiBattleGameOver");
static_assert(offsetof(URCNzUiBattleGameOver, AN_Start) == 0x000300, "Member 'URCNzUiBattleGameOver::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOver, AN_Wait) == 0x000308, "Member 'URCNzUiBattleGameOver::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOver, AN_Finish) == 0x000310, "Member 'URCNzUiBattleGameOver::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOver, SelectIndex) == 0x000338, "Member 'URCNzUiBattleGameOver::SelectIndex' has a wrong offset!");

// Class RC.RCUiOptionKeyList
// 0x0410 (0x06E8 - 0x02D8)
class URCUiOptionKeyList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x410];                                    // 0x02D8(0x0410)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitializeButtonClick();
	bool OnPagerSetClickEvent(int32 ind, const struct FPointerEvent& InMouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKeyList">();
	}
	static class URCUiOptionKeyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKeyList>();
	}
};
static_assert(alignof(URCUiOptionKeyList) == 0x000008, "Wrong alignment on URCUiOptionKeyList");
static_assert(sizeof(URCUiOptionKeyList) == 0x0006E8, "Wrong size on URCUiOptionKeyList");

// Class RC.RCNzUiBattleGameOverSelectBar
// 0x0028 (0x0348 - 0x0320)
class URCNzUiBattleGameOverSelectBar final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OffCursor;                                      // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_000;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void Decide();
	void InitializeBattleKaiKagiSelectBar();
	void Select();
	void SetText(class FName InTextID);
	void SetVisible(bool bInVisibility);
	void Unselect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleGameOverSelectBar">();
	}
	static class URCNzUiBattleGameOverSelectBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleGameOverSelectBar>();
	}
};
static_assert(alignof(URCNzUiBattleGameOverSelectBar) == 0x000008, "Wrong alignment on URCNzUiBattleGameOverSelectBar");
static_assert(sizeof(URCNzUiBattleGameOverSelectBar) == 0x000348, "Wrong size on URCNzUiBattleGameOverSelectBar");
static_assert(offsetof(URCNzUiBattleGameOverSelectBar, AN_OnCursor) == 0x000320, "Member 'URCNzUiBattleGameOverSelectBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOverSelectBar, AN_Push) == 0x000328, "Member 'URCNzUiBattleGameOverSelectBar::AN_Push' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOverSelectBar, AN_OffCursor) == 0x000330, "Member 'URCNzUiBattleGameOverSelectBar::AN_OffCursor' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleGameOverSelectBar, Text_000) == 0x000338, "Member 'URCNzUiBattleGameOverSelectBar::Text_000' has a wrong offset!");

// Class RC.RCParamFinaleTest
// 0x0000 (0x0030 - 0x0030)
class URCParamFinaleTest final : public URCCSVData
{
public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFinaleTest">();
	}
	static class URCParamFinaleTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFinaleTest>();
	}
};
static_assert(alignof(URCParamFinaleTest) == 0x000008, "Wrong alignment on URCParamFinaleTest");
static_assert(sizeof(URCParamFinaleTest) == 0x000030, "Wrong size on URCParamFinaleTest");

// Class RC.RCNzUiBattleHint
// 0x0028 (0x0300 - 0x02D8)
class URCNzUiBattleHint final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RTxt_HintText;                                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	ERCNzUiBattleHintStatus GetBattleHintStatus();
	void InitializeBattleHint();
	void Open();
	void SetText(class FName InTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleHint">();
	}
	static class URCNzUiBattleHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleHint>();
	}
};
static_assert(alignof(URCNzUiBattleHint) == 0x000008, "Wrong alignment on URCNzUiBattleHint");
static_assert(sizeof(URCNzUiBattleHint) == 0x000300, "Wrong size on URCNzUiBattleHint");
static_assert(offsetof(URCNzUiBattleHint, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleHint::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHint, AN_Wait) == 0x0002E8, "Member 'URCNzUiBattleHint::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHint, AN_Finish) == 0x0002F0, "Member 'URCNzUiBattleHint::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHint, RTxt_HintText) == 0x0002F8, "Member 'URCNzUiBattleHint::RTxt_HintText' has a wrong offset!");

// Class RC.RCNzUiBattleHPBar
// 0x00A8 (0x0380 - 0x02D8)
class URCNzUiBattleHPBar final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Current;                                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Attenuation;                                    // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Damage;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Recover;                                        // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           DamageDelayBar_Mask;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_DamageDelayBar_01;                             // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AttenuationBar_Mask;                               // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_AttenuationBar_01;                             // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CurrentHPBar_Mask;                                 // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_CurrentHPBar;                                  // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           DamageEffect_Mask;                                 // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_DamageEffect_01;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RecoverEffect_Mask;                                // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_RecoverEffect_01;                              // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Base;                                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Dropshadow;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DamageAnim();
	ERCNzUiBattleHPBarStatus GetBattleHPBarStatus();
	void InitializeBattleHPBar();
	void RecoverAnim();
	void ResetHP(int32 InHP, int32 InMaxHP);
	void SetDelayHP(int32 InDelayHP);
	void SetHP(int32 InHP, int32 InMaxHP, bool bInApplyDelayHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleHPBar">();
	}
	static class URCNzUiBattleHPBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleHPBar>();
	}
};
static_assert(alignof(URCNzUiBattleHPBar) == 0x000008, "Wrong alignment on URCNzUiBattleHPBar");
static_assert(sizeof(URCNzUiBattleHPBar) == 0x000380, "Wrong size on URCNzUiBattleHPBar");
static_assert(offsetof(URCNzUiBattleHPBar, AN_Current) == 0x0002E0, "Member 'URCNzUiBattleHPBar::AN_Current' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, AN_Attenuation) == 0x0002E8, "Member 'URCNzUiBattleHPBar::AN_Attenuation' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, AN_Damage) == 0x0002F0, "Member 'URCNzUiBattleHPBar::AN_Damage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, AN_Recover) == 0x0002F8, "Member 'URCNzUiBattleHPBar::AN_Recover' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, DamageDelayBar_Mask) == 0x000300, "Member 'URCNzUiBattleHPBar::DamageDelayBar_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_DamageDelayBar_01) == 0x000308, "Member 'URCNzUiBattleHPBar::Img_DamageDelayBar_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, AttenuationBar_Mask) == 0x000310, "Member 'URCNzUiBattleHPBar::AttenuationBar_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_AttenuationBar_01) == 0x000318, "Member 'URCNzUiBattleHPBar::Img_AttenuationBar_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, CurrentHPBar_Mask) == 0x000320, "Member 'URCNzUiBattleHPBar::CurrentHPBar_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_CurrentHPBar) == 0x000328, "Member 'URCNzUiBattleHPBar::Img_CurrentHPBar' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, DamageEffect_Mask) == 0x000330, "Member 'URCNzUiBattleHPBar::DamageEffect_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_DamageEffect_01) == 0x000338, "Member 'URCNzUiBattleHPBar::Img_DamageEffect_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, RecoverEffect_Mask) == 0x000340, "Member 'URCNzUiBattleHPBar::RecoverEffect_Mask' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_RecoverEffect_01) == 0x000348, "Member 'URCNzUiBattleHPBar::Img_RecoverEffect_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_Base) == 0x000350, "Member 'URCNzUiBattleHPBar::Img_Base' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPBar, Img_Dropshadow) == 0x000358, "Member 'URCNzUiBattleHPBar::Img_Dropshadow' has a wrong offset!");

// Class RC.RCParamInputKeyData
// 0x0010 (0x0040 - 0x0030)
class URCParamInputKeyData final : public URCCSVData
{
public:
	TArray<struct FRCParamInputKeyTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamInputKeyData">();
	}
	static class URCParamInputKeyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamInputKeyData>();
	}
};
static_assert(alignof(URCParamInputKeyData) == 0x000008, "Wrong alignment on URCParamInputKeyData");
static_assert(sizeof(URCParamInputKeyData) == 0x000040, "Wrong size on URCParamInputKeyData");
static_assert(offsetof(URCParamInputKeyData, Data) == 0x000030, "Member 'URCParamInputKeyData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleHPGauge
// 0x00E0 (0x03B8 - 0x02D8)
class URCNzUiBattleHPGauge final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Damage;                                         // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleHPBar*                     HPBar;                                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Face;                                          // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x24];                                     // 0x0310(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageWaitTime;                                    // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageTimeFlag;                                   // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageTime;                                        // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageValuePerS;                                   // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayDamageWaitTime;                               // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDelayDamageTimeFlag;                              // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayDamageTime;                                   // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayDamageValuePerS;                              // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamagePhase;                                       // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x4];                                      // 0x0358(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRecoverTimeFlag;                                  // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverTime;                                       // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverValuePerS;                                  // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        VigorFaceImagePath;                                // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        NormalFaceImagePath;                               // 0x0388(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        PinchFaceImagePath;                                // 0x03A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyHP(bool bInReset);
	bool AutoDamage(int32 InNewHP, int32 InHP, int32 InMaxHP, bool bInSilence);
	bool AutoDamage2(int32 InDamage, int32 InHP, int32 InMaxHP, bool bInSilence);
	bool AutoRecover(int32 InNewHP, int32 InHP, int32 InMaxHP, bool bInSilence);
	bool AutoRecover2(int32 InRecover, int32 InHP, int32 InMaxHP, bool bInSilence);
	void Close();
	void Damage(int32 InHP, bool bInSilence);
	void Damage2(int32 InDamage, bool bInSilence);
	ERCNzUiBattleHPGaugeStatus GetBattleHPGaugeStatus();
	void InitializeBattleHPGauge();
	void Open();
	void Recover(int32 InHP, bool bInSilence);
	void Recover2(int32 InRecover, bool bInSilence);
	void SetHP(int32 InHP, int32 InMaxHP);
	void UninitializeBattleHPGauge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleHPGauge">();
	}
	static class URCNzUiBattleHPGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleHPGauge>();
	}
};
static_assert(alignof(URCNzUiBattleHPGauge) == 0x000008, "Wrong alignment on URCNzUiBattleHPGauge");
static_assert(sizeof(URCNzUiBattleHPGauge) == 0x0003B8, "Wrong size on URCNzUiBattleHPGauge");
static_assert(offsetof(URCNzUiBattleHPGauge, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleHPGauge::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, AN_Wait) == 0x0002E8, "Member 'URCNzUiBattleHPGauge::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, AN_Finish) == 0x0002F0, "Member 'URCNzUiBattleHPGauge::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, AN_Damage) == 0x0002F8, "Member 'URCNzUiBattleHPGauge::AN_Damage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, HPBar) == 0x000300, "Member 'URCNzUiBattleHPGauge::HPBar' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, Img_Face) == 0x000308, "Member 'URCNzUiBattleHPGauge::Img_Face' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DamageWaitTime) == 0x000334, "Member 'URCNzUiBattleHPGauge::DamageWaitTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, bDamageTimeFlag) == 0x000338, "Member 'URCNzUiBattleHPGauge::bDamageTimeFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DamageTime) == 0x00033C, "Member 'URCNzUiBattleHPGauge::DamageTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DamageValuePerS) == 0x000340, "Member 'URCNzUiBattleHPGauge::DamageValuePerS' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DelayDamageWaitTime) == 0x000344, "Member 'URCNzUiBattleHPGauge::DelayDamageWaitTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, bDelayDamageTimeFlag) == 0x000348, "Member 'URCNzUiBattleHPGauge::bDelayDamageTimeFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DelayDamageTime) == 0x00034C, "Member 'URCNzUiBattleHPGauge::DelayDamageTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DelayDamageValuePerS) == 0x000350, "Member 'URCNzUiBattleHPGauge::DelayDamageValuePerS' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, DamagePhase) == 0x000354, "Member 'URCNzUiBattleHPGauge::DamagePhase' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, bRecoverTimeFlag) == 0x00035C, "Member 'URCNzUiBattleHPGauge::bRecoverTimeFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, RecoverTime) == 0x000360, "Member 'URCNzUiBattleHPGauge::RecoverTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, RecoverValuePerS) == 0x000364, "Member 'URCNzUiBattleHPGauge::RecoverValuePerS' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, VigorFaceImagePath) == 0x000370, "Member 'URCNzUiBattleHPGauge::VigorFaceImagePath' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, NormalFaceImagePath) == 0x000388, "Member 'URCNzUiBattleHPGauge::NormalFaceImagePath' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPGauge, PinchFaceImagePath) == 0x0003A0, "Member 'URCNzUiBattleHPGauge::PinchFaceImagePath' has a wrong offset!");

// Class RC.RCUiOptionPager
// 0x0088 (0x0360 - 0x02D8)
class URCUiOptionPager final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x88];                                     // 0x02D8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonGuideClickEvent(ERCInputKeyType Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionPager">();
	}
	static class URCUiOptionPager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionPager>();
	}
};
static_assert(alignof(URCUiOptionPager) == 0x000008, "Wrong alignment on URCUiOptionPager");
static_assert(sizeof(URCUiOptionPager) == 0x000360, "Wrong size on URCUiOptionPager");

// Class RC.RCNzUiBattleHPValue
// 0x0030 (0x0308 - 0x02D8)
class URCNzUiBattleHPValue final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Damage;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Recover;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Text_CurrentHP;                                    // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Text_MaxHP;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DamageAnim();
	ERCNzUiBattleHPValueStatus GetBattleHPValueStatus();
	void InitializeBattleHPValue();
	void RecoverAnim();
	void SetHP(int32 InHP, int32 InMaxHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleHPValue">();
	}
	static class URCNzUiBattleHPValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleHPValue>();
	}
};
static_assert(alignof(URCNzUiBattleHPValue) == 0x000008, "Wrong alignment on URCNzUiBattleHPValue");
static_assert(sizeof(URCNzUiBattleHPValue) == 0x000308, "Wrong size on URCNzUiBattleHPValue");
static_assert(offsetof(URCNzUiBattleHPValue, AN_Damage) == 0x0002E0, "Member 'URCNzUiBattleHPValue::AN_Damage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPValue, AN_Recover) == 0x0002E8, "Member 'URCNzUiBattleHPValue::AN_Recover' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPValue, Text_CurrentHP) == 0x0002F0, "Member 'URCNzUiBattleHPValue::Text_CurrentHP' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleHPValue, Text_MaxHP) == 0x0002F8, "Member 'URCNzUiBattleHPValue::Text_MaxHP' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiButton
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiBattleKaiKagiButton final : public URCUiWidgetBase
{
public:
	class URichTextBlock*                         Text_KaikagiName;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeBattleKaiKagiButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiButton">();
	}
	static class URCNzUiBattleKaiKagiButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiButton>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiButton) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiButton");
static_assert(sizeof(URCNzUiBattleKaiKagiButton) == 0x0002E0, "Wrong size on URCNzUiBattleKaiKagiButton");
static_assert(offsetof(URCNzUiBattleKaiKagiButton, Text_KaikagiName) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiButton::Text_KaikagiName' has a wrong offset!");

// Class RC.RCParamFigureData
// 0x0010 (0x0040 - 0x0030)
class URCParamFigureData final : public URCCSVData
{
public:
	TArray<struct FRCParamFigureTableRow>         Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFigureData">();
	}
	static class URCParamFigureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFigureData>();
	}
};
static_assert(alignof(URCParamFigureData) == 0x000008, "Wrong alignment on URCParamFigureData");
static_assert(sizeof(URCParamFigureData) == 0x000040, "Wrong size on URCParamFigureData");
static_assert(offsetof(URCParamFigureData, Data) == 0x000030, "Member 'URCParamFigureData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiList
// 0x0060 (0x0338 - 0x02D8)
class URCNzUiBattleKaiKagiList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCNzUiBattleKaiKagiListBar*>    KaiKagiListBarArray;                               // 0x02E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x4];                                      // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KaiKagiListFinishTime;                             // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x1C];                                     // 0x0300(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KaiKagiListBarWaitTime;                            // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnClosed;                                          // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	ERCNzUiBattleKaiKagiListStatus GetBattleKaiKagiListStatus();
	void InitializeBattleKaiKagiList();
	void Open(const TArray<class FName>& InKaiKagiNameIDArray);
	void UninitializeBattleKaiKagiList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiList">();
	}
	static class URCNzUiBattleKaiKagiList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiList>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiList) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiList");
static_assert(sizeof(URCNzUiBattleKaiKagiList) == 0x000338, "Wrong size on URCNzUiBattleKaiKagiList");
static_assert(offsetof(URCNzUiBattleKaiKagiList, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiList::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiList, KaiKagiListBarArray) == 0x0002E8, "Member 'URCNzUiBattleKaiKagiList::KaiKagiListBarArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiList, KaiKagiListFinishTime) == 0x0002FC, "Member 'URCNzUiBattleKaiKagiList::KaiKagiListFinishTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiList, KaiKagiListBarWaitTime) == 0x00031C, "Member 'URCNzUiBattleKaiKagiList::KaiKagiListBarWaitTime' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiList, OnClosed) == 0x000328, "Member 'URCNzUiBattleKaiKagiList::OnClosed' has a wrong offset!");

// Class RC.RCParamGlossaryListData
// 0x0010 (0x0040 - 0x0030)
class URCParamGlossaryListData final : public URCCSVData
{
public:
	TArray<struct FRCParamGlossaryListTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamGlossaryListData">();
	}
	static class URCParamGlossaryListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamGlossaryListData>();
	}
};
static_assert(alignof(URCParamGlossaryListData) == 0x000008, "Wrong alignment on URCParamGlossaryListData");
static_assert(sizeof(URCParamGlossaryListData) == 0x000040, "Wrong size on URCParamGlossaryListData");
static_assert(offsetof(URCParamGlossaryListData, Data) == 0x000030, "Member 'URCParamGlossaryListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiName
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiBattleKaiKagiName final : public URCUiWidgetBase
{
public:
	class UTextBlock*                             TextBlock_kaikagiName;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeBattleKaiKagiName();
	void SetKaiKagiName(class FName InTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiName">();
	}
	static class URCNzUiBattleKaiKagiName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiName>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiName) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiName");
static_assert(sizeof(URCNzUiBattleKaiKagiName) == 0x0002E0, "Wrong size on URCNzUiBattleKaiKagiName");
static_assert(offsetof(URCNzUiBattleKaiKagiName, TextBlock_kaikagiName) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiName::TextBlock_kaikagiName' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelect
// 0x01E0 (0x04D8 - 0x02F8)
class URCNzUiBattleKaiKagiSelect final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Next;                                           // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Prev;                                           // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKaiKagiSelectBar2;                                // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCNzUiBattleKaiKagiSelectBar*>  KaiKagiBarArray;                                   // 0x0330(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCNzUiBattleKaiKagiSelectBar2*> KaiKagiBar2Array;                                  // 0x0340(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCNzUiBattleKaiKagiSelectParts*> KaiKagiArray;                                      // 0x0350(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagiSelectDecide*       WBP_NzKaikagi_BTNGuideDecision;                    // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagiSelectDetail*       WBP_NzKaikagiDetail;                               // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReverseInput;                                     // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReverseNextAndPrev;                               // 0x0371(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x2];                                      // 0x0372(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChoiceNum;                                         // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 PriorityUseChoiceNoArray;                          // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 PriorityTextChoiceNoArray;                         // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 UseChoiceNoArray;                                  // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectChoiceNo;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TextChoiceNoArray;                                 // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectChoiceIndexInTextChoiceNoArray;              // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        KaiKagiDataTablePath;                              // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKaiKagiDataLoading;                               // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRCParamKaikagiListTableRow> KaiKagiDataMap;                                    // 0x03E8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OriginalKaiKagiIDList;                             // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           KaikagiIDList;                                     // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FSoftObjectPath>     LoadImagePathMap;                                  // 0x0460(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bLoadingImage;                                     // 0x04B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMenuEnableAtStart;                                // 0x04B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopEnable;                                       // 0x04B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPauseEnable;                                      // 0x04B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 SelectIndex)> OnDecide;                                          // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 SelectIndex)> OnClosed;                                          // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Close();
	void Decide();
	ERCNzUiBattleKaiKagiSelectStatus GetBattleKaiKagiSelectStatus();
	int32 GetSelectIndex();
	void InitializeBattleKaiKagiSelect();
	bool KaiKagiSelectStart(const TArray<class FName>& InKaiKagiIDArray, int32 InSelectIndex);
	bool KaiKagiSelectStart2(const TArray<class FName>& InKaiKagiIDArray, const TArray<class FName>& InDeleteKaiKagiIDArray, int32 InSelectIndex);
	void Open();
	void SelectDeteil();
	bool SelectKaiKagi(int32 InSelectIndex, bool bStart);
	void UninitializeBattleKaiKagiSelect();
	class UWidget* UpAndDown(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelect">();
	}
	static class URCNzUiBattleKaiKagiSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelect>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelect) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelect");
static_assert(sizeof(URCNzUiBattleKaiKagiSelect) == 0x0004D8, "Wrong size on URCNzUiBattleKaiKagiSelect");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, AN_Start) == 0x000300, "Member 'URCNzUiBattleKaiKagiSelect::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, AN_Wait) == 0x000308, "Member 'URCNzUiBattleKaiKagiSelect::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, AN_Finish) == 0x000310, "Member 'URCNzUiBattleKaiKagiSelect::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, AN_Next) == 0x000318, "Member 'URCNzUiBattleKaiKagiSelect::AN_Next' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, AN_Prev) == 0x000320, "Member 'URCNzUiBattleKaiKagiSelect::AN_Prev' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bKaiKagiSelectBar2) == 0x000328, "Member 'URCNzUiBattleKaiKagiSelect::bKaiKagiSelectBar2' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaiKagiBarArray) == 0x000330, "Member 'URCNzUiBattleKaiKagiSelect::KaiKagiBarArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaiKagiBar2Array) == 0x000340, "Member 'URCNzUiBattleKaiKagiSelect::KaiKagiBar2Array' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaiKagiArray) == 0x000350, "Member 'URCNzUiBattleKaiKagiSelect::KaiKagiArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, WBP_NzKaikagi_BTNGuideDecision) == 0x000360, "Member 'URCNzUiBattleKaiKagiSelect::WBP_NzKaikagi_BTNGuideDecision' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, WBP_NzKaikagiDetail) == 0x000368, "Member 'URCNzUiBattleKaiKagiSelect::WBP_NzKaikagiDetail' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bReverseInput) == 0x000370, "Member 'URCNzUiBattleKaiKagiSelect::bReverseInput' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bReverseNextAndPrev) == 0x000371, "Member 'URCNzUiBattleKaiKagiSelect::bReverseNextAndPrev' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, ChoiceNum) == 0x000374, "Member 'URCNzUiBattleKaiKagiSelect::ChoiceNum' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, PriorityUseChoiceNoArray) == 0x000378, "Member 'URCNzUiBattleKaiKagiSelect::PriorityUseChoiceNoArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, PriorityTextChoiceNoArray) == 0x000388, "Member 'URCNzUiBattleKaiKagiSelect::PriorityTextChoiceNoArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, UseChoiceNoArray) == 0x000398, "Member 'URCNzUiBattleKaiKagiSelect::UseChoiceNoArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, SelectChoiceNo) == 0x0003A8, "Member 'URCNzUiBattleKaiKagiSelect::SelectChoiceNo' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, TextChoiceNoArray) == 0x0003B0, "Member 'URCNzUiBattleKaiKagiSelect::TextChoiceNoArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, SelectChoiceIndexInTextChoiceNoArray) == 0x0003C0, "Member 'URCNzUiBattleKaiKagiSelect::SelectChoiceIndexInTextChoiceNoArray' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaiKagiDataTablePath) == 0x0003C8, "Member 'URCNzUiBattleKaiKagiSelect::KaiKagiDataTablePath' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bKaiKagiDataLoading) == 0x0003E0, "Member 'URCNzUiBattleKaiKagiSelect::bKaiKagiDataLoading' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaiKagiDataMap) == 0x0003E8, "Member 'URCNzUiBattleKaiKagiSelect::KaiKagiDataMap' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, SelectIndex) == 0x000438, "Member 'URCNzUiBattleKaiKagiSelect::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, OriginalKaiKagiIDList) == 0x000440, "Member 'URCNzUiBattleKaiKagiSelect::OriginalKaiKagiIDList' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, KaikagiIDList) == 0x000450, "Member 'URCNzUiBattleKaiKagiSelect::KaikagiIDList' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, LoadImagePathMap) == 0x000460, "Member 'URCNzUiBattleKaiKagiSelect::LoadImagePathMap' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bLoadingImage) == 0x0004B0, "Member 'URCNzUiBattleKaiKagiSelect::bLoadingImage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bMenuEnableAtStart) == 0x0004B1, "Member 'URCNzUiBattleKaiKagiSelect::bMenuEnableAtStart' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bLoopEnable) == 0x0004B2, "Member 'URCNzUiBattleKaiKagiSelect::bLoopEnable' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, bPauseEnable) == 0x0004B3, "Member 'URCNzUiBattleKaiKagiSelect::bPauseEnable' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, OnDecide) == 0x0004B8, "Member 'URCNzUiBattleKaiKagiSelect::OnDecide' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelect, OnClosed) == 0x0004C8, "Member 'URCNzUiBattleKaiKagiSelect::OnClosed' has a wrong offset!");

// Class RC.RCParamMenuAreaMapListData
// 0x0010 (0x0040 - 0x0030)
class URCParamMenuAreaMapListData final : public URCCSVData
{
public:
	TArray<struct FRCParamMenuAreaMapListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMenuAreaMapListData">();
	}
	static class URCParamMenuAreaMapListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMenuAreaMapListData>();
	}
};
static_assert(alignof(URCParamMenuAreaMapListData) == 0x000008, "Wrong alignment on URCParamMenuAreaMapListData");
static_assert(sizeof(URCParamMenuAreaMapListData) == 0x000040, "Wrong size on URCParamMenuAreaMapListData");
static_assert(offsetof(URCParamMenuAreaMapListData, Data) == 0x000030, "Member 'URCParamMenuAreaMapListData::Data' has a wrong offset!");

// Class RC.RCUiShortLoadingIcon
// 0x0028 (0x0300 - 0x02D8)
class URCUiShortLoadingIcon : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndLoad();
	void StartLoad();

	bool IsLoading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiShortLoadingIcon">();
	}
	static class URCUiShortLoadingIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiShortLoadingIcon>();
	}
};
static_assert(alignof(URCUiShortLoadingIcon) == 0x000008, "Wrong alignment on URCUiShortLoadingIcon");
static_assert(sizeof(URCUiShortLoadingIcon) == 0x000300, "Wrong size on URCUiShortLoadingIcon");
static_assert(offsetof(URCUiShortLoadingIcon, AN_Start) == 0x0002D8, "Member 'URCUiShortLoadingIcon::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiShortLoadingIcon, AN_Wait) == 0x0002E0, "Member 'URCUiShortLoadingIcon::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiShortLoadingIcon, AN_Finish) == 0x0002E8, "Member 'URCUiShortLoadingIcon::AN_Finish' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectBar2
// 0x0028 (0x0348 - 0x0320)
class URCNzUiBattleKaiKagiSelectBar2 final : public URCMenuButton
{
public:
	class UTextBlock*                             Text_KaikagiName;                                  // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagiSelectEquip*        WBP_NzKaikagiSel_Equipment;                        // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select;                                         // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_UnSelect;                                       // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeBattleKaiKagiSelectBar();
	bool IsSelect();
	void Select(bool bInStart);
	void SetKaiKagiName(class FName InTextID);
	void SetVisible(bool bInVisibility);
	void Unselect(bool bInStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectBar2">();
	}
	static class URCNzUiBattleKaiKagiSelectBar2* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectBar2>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectBar2) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectBar2");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectBar2) == 0x000348, "Wrong size on URCNzUiBattleKaiKagiSelectBar2");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar2, Text_KaikagiName) == 0x000320, "Member 'URCNzUiBattleKaiKagiSelectBar2::Text_KaikagiName' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar2, WBP_NzKaikagiSel_Equipment) == 0x000328, "Member 'URCNzUiBattleKaiKagiSelectBar2::WBP_NzKaikagiSel_Equipment' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar2, AN_Select) == 0x000330, "Member 'URCNzUiBattleKaiKagiSelectBar2::AN_Select' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectBar2, AN_UnSelect) == 0x000338, "Member 'URCNzUiBattleKaiKagiSelectBar2::AN_UnSelect' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectDecide
// 0x0040 (0x0318 - 0x02D8)
class URCNzUiBattleKaiKagiSelectDecide final : public URCUiWidgetBase
{
public:
	class UTextBlock*                             Text_ButtonGuideText_2;                            // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ClickebleButton;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Btn_On;                                         // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Btn_Off;                                        // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               AnimArray;                                         // 0x0308(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void InitializeBattleKaiKagiSelectDecide();
	void OnMouseClickEvent();
	void OnMouseHoverdEvent();
	void OnMouseUnhoverdEvent();
	void SetInputFromButtonGuide(ERCInputKeyType InType);
	void SetMouseButtonDisable();
	void SetMouseButtonEnable();
	void UninitializeBattleKaiKagiSelectDecide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectDecide">();
	}
	static class URCNzUiBattleKaiKagiSelectDecide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectDecide>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectDecide) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectDecide");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectDecide) == 0x000318, "Wrong size on URCNzUiBattleKaiKagiSelectDecide");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, Text_ButtonGuideText_2) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiSelectDecide::Text_ButtonGuideText_2' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, WBP_ButtonGuide) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiSelectDecide::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, ClickebleButton) == 0x0002E8, "Member 'URCNzUiBattleKaiKagiSelectDecide::ClickebleButton' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, AN_Btn_On) == 0x0002F8, "Member 'URCNzUiBattleKaiKagiSelectDecide::AN_Btn_On' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, AN_Btn_Off) == 0x000300, "Member 'URCNzUiBattleKaiKagiSelectDecide::AN_Btn_Off' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDecide, AnimArray) == 0x000308, "Member 'URCNzUiBattleKaiKagiSelectDecide::AnimArray' has a wrong offset!");

// Class RC.RCParamGalleryMovieListData
// 0x0010 (0x0040 - 0x0030)
class URCParamGalleryMovieListData final : public URCCSVData
{
public:
	TArray<struct FRCParamGalleryMovieListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamGalleryMovieListData">();
	}
	static class URCParamGalleryMovieListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamGalleryMovieListData>();
	}
};
static_assert(alignof(URCParamGalleryMovieListData) == 0x000008, "Wrong alignment on URCParamGalleryMovieListData");
static_assert(sizeof(URCParamGalleryMovieListData) == 0x000040, "Wrong size on URCParamGalleryMovieListData");
static_assert(offsetof(URCParamGalleryMovieListData, Data) == 0x000030, "Member 'URCParamGalleryMovieListData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectDetail
// 0x00B8 (0x0390 - 0x02D8)
class URCNzUiBattleKaiKagiSelectDetail final : public URCUiWidgetBase
{
public:
	class UTextBlock*                             Text_KaikagiDetail_01;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiDetail_02;                             // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiDetail_03;                             // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiDetail_04;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiDetail_05;                             // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_KaikagiDetail_06;                             // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Img_KaikagiImage;                                  // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ButtonGuideText;                              // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ClickebleButton;                                   // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Next;                                           // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Prev;                                           // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Btn_On;                                         // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Btn_Off;                                        // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidgetAnimation*>               AnimArray;                                         // 0x0378(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeBattleKaiKagiSelectDetail();
	void OnMouseClickEvent();
	void OnMouseHoverdEvent();
	void OnMouseUnhoverdEvent();
	void PlayAnim(ERCNzUiBattleKaiKagiSelectPartsAnimType AnimType);
	void SetDetailTextID(class FName DetailTextID);
	void SetImageTexture(class UTexture2D* ImageTexture);
	void SetInputFromButtonGuide(ERCInputKeyType InType);
	void SetMouseButtonDisable();
	void SetMouseButtonEnable();
	void UninitializeBattleKaiKagiSelectDetail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectDetail">();
	}
	static class URCNzUiBattleKaiKagiSelectDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectDetail>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectDetail) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectDetail");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectDetail) == 0x000390, "Wrong size on URCNzUiBattleKaiKagiSelectDetail");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_01) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_01' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_02) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_02' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_03) == 0x0002E8, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_03' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_04) == 0x0002F0, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_04' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_05) == 0x0002F8, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_05' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_KaikagiDetail_06) == 0x000300, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_KaikagiDetail_06' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Img_KaikagiImage) == 0x000318, "Member 'URCNzUiBattleKaiKagiSelectDetail::Img_KaikagiImage' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, Text_ButtonGuideText) == 0x000320, "Member 'URCNzUiBattleKaiKagiSelectDetail::Text_ButtonGuideText' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, WBP_ButtonGuide) == 0x000328, "Member 'URCNzUiBattleKaiKagiSelectDetail::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, ClickebleButton) == 0x000330, "Member 'URCNzUiBattleKaiKagiSelectDetail::ClickebleButton' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Start) == 0x000340, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Wait) == 0x000348, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Finish) == 0x000350, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Next) == 0x000358, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Next' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Prev) == 0x000360, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Prev' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Btn_On) == 0x000368, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Btn_On' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AN_Btn_Off) == 0x000370, "Member 'URCNzUiBattleKaiKagiSelectDetail::AN_Btn_Off' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectDetail, AnimArray) == 0x000378, "Member 'URCNzUiBattleKaiKagiSelectDetail::AnimArray' has a wrong offset!");

// Class RC.RCNzUiBattleKaiKagiSelectEquip
// 0x0010 (0x02E8 - 0x02D8)
class URCNzUiBattleKaiKagiSelectEquip final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeBattleKaiKagiSelectEquip();
	void Off();
	void On();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleKaiKagiSelectEquip">();
	}
	static class URCNzUiBattleKaiKagiSelectEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleKaiKagiSelectEquip>();
	}
};
static_assert(alignof(URCNzUiBattleKaiKagiSelectEquip) == 0x000008, "Wrong alignment on URCNzUiBattleKaiKagiSelectEquip");
static_assert(sizeof(URCNzUiBattleKaiKagiSelectEquip) == 0x0002E8, "Wrong size on URCNzUiBattleKaiKagiSelectEquip");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectEquip, AN_On) == 0x0002D8, "Member 'URCNzUiBattleKaiKagiSelectEquip::AN_On' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleKaiKagiSelectEquip, AN_Off) == 0x0002E0, "Member 'URCNzUiBattleKaiKagiSelectEquip::AN_Off' has a wrong offset!");

// Class RC.RCParamNzCriminalCameraSettingData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzCriminalCameraSettingData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzCriminalCameraSettingTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzCriminalCameraSettingData">();
	}
	static class URCParamNzCriminalCameraSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzCriminalCameraSettingData>();
	}
};
static_assert(alignof(URCParamNzCriminalCameraSettingData) == 0x000008, "Wrong alignment on URCParamNzCriminalCameraSettingData");
static_assert(sizeof(URCParamNzCriminalCameraSettingData) == 0x000040, "Wrong size on URCParamNzCriminalCameraSettingData");
static_assert(offsetof(URCParamNzCriminalCameraSettingData, Data) == 0x000030, "Member 'URCParamNzCriminalCameraSettingData::Data' has a wrong offset!");

// Class RC.RCNzUiBattleStart
// 0x0010 (0x02E8 - 0x02D8)
class URCNzUiBattleStart final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ERCNzUiBattleStartStatus GetBattleStartStatus();
	void InitializeBattleStart();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleStart">();
	}
	static class URCNzUiBattleStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleStart>();
	}
};
static_assert(alignof(URCNzUiBattleStart) == 0x000008, "Wrong alignment on URCNzUiBattleStart");
static_assert(sizeof(URCNzUiBattleStart) == 0x0002E8, "Wrong size on URCNzUiBattleStart");
static_assert(offsetof(URCNzUiBattleStart, AN_Start) == 0x0002E0, "Member 'URCNzUiBattleStart::AN_Start' has a wrong offset!");

// Class RC.RCNzUiBattleUi
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiBattleUi final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiBattleKaiKagi*                   kaikagi;                                           // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleAssist*                    Assist;                                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssistEnable;                                     // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzCriminalButtonGuideList*           ButtonGuideWidget;                                 // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bButtonGuideSet;                                   // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinalBattle;                                      // 0x0301(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRebuttalSlash;                                    // 0x0302(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisturbSlashEnable;                               // 0x0303(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                TimelimitWidget;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BattleUiFinish();
	void BattleUiStart(bool bOpenKaiKagi, bool bInAssistEnable);
	void ChangeKaiKagi(class FName InTextID);
	void Close();
	ERCNzUiBattleUiStatus GetBattleUiStatus();
	void InitializeBattleUi(struct FRCNzUiBattleUiAssetData* InAssetData);
	void Open();
	void RebuttalFinish();
	void RebuttalStart();
	void SetAssistGauge(float InAssistGauge, float InAssistGaugeMax);
	void SetButtonGuide(bool bInFinalBattle, bool bInRebuttalSlash, bool bInDisturbSlashEnable);
	void SetElapsedTime(float ElapsedTime, float LimitTime);
	void SetKaiKagiName(class FName InTextID);
	void SetTime(float Time, float LimitTime);
	void UninitializeBattleUi();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiBattleUi">();
	}
	static class URCNzUiBattleUi* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiBattleUi>();
	}
};
static_assert(alignof(URCNzUiBattleUi) == 0x000008, "Wrong alignment on URCNzUiBattleUi");
static_assert(sizeof(URCNzUiBattleUi) == 0x000310, "Wrong size on URCNzUiBattleUi");
static_assert(offsetof(URCNzUiBattleUi, kaikagi) == 0x0002E0, "Member 'URCNzUiBattleUi::kaikagi' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, Assist) == 0x0002E8, "Member 'URCNzUiBattleUi::Assist' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, bAssistEnable) == 0x0002F0, "Member 'URCNzUiBattleUi::bAssistEnable' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, ButtonGuideWidget) == 0x0002F8, "Member 'URCNzUiBattleUi::ButtonGuideWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, bButtonGuideSet) == 0x000300, "Member 'URCNzUiBattleUi::bButtonGuideSet' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, bFinalBattle) == 0x000301, "Member 'URCNzUiBattleUi::bFinalBattle' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, bRebuttalSlash) == 0x000302, "Member 'URCNzUiBattleUi::bRebuttalSlash' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, bDisturbSlashEnable) == 0x000303, "Member 'URCNzUiBattleUi::bDisturbSlashEnable' has a wrong offset!");
static_assert(offsetof(URCNzUiBattleUi, TimelimitWidget) == 0x000308, "Member 'URCNzUiBattleUi::TimelimitWidget' has a wrong offset!");

// Class RC.RCNzUiChousaStart
// 0x0018 (0x02F0 - 0x02D8)
class URCNzUiChousaStart final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static int32 GetNzChousaStartPriority();

	void CloseChousaStart();
	bool IsFinished();
	void OpenChousaStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiChousaStart">();
	}
	static class URCNzUiChousaStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiChousaStart>();
	}
};
static_assert(alignof(URCNzUiChousaStart) == 0x000008, "Wrong alignment on URCNzUiChousaStart");
static_assert(sizeof(URCNzUiChousaStart) == 0x0002F0, "Wrong size on URCNzUiChousaStart");
static_assert(offsetof(URCNzUiChousaStart, AN_Start) == 0x0002D8, "Member 'URCNzUiChousaStart::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiChousaStart, AN_Finish) == 0x0002E0, "Member 'URCNzUiChousaStart::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiChousaStart, AN_Wait) == 0x0002E8, "Member 'URCNzUiChousaStart::AN_Wait' has a wrong offset!");

// Class RC.RCParamMovieDataData
// 0x0050 (0x0080 - 0x0030)
class URCParamMovieDataData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamMovieDataTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMovieDataData">();
	}
	static class URCParamMovieDataData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMovieDataData>();
	}
};
static_assert(alignof(URCParamMovieDataData) == 0x000008, "Wrong alignment on URCParamMovieDataData");
static_assert(sizeof(URCParamMovieDataData) == 0x000080, "Wrong size on URCParamMovieDataData");
static_assert(offsetof(URCParamMovieDataData, Data) == 0x000030, "Member 'URCParamMovieDataData::Data' has a wrong offset!");

// Class RC.RCNzUiCountdownNum
// 0x0040 (0x0318 - 0x02D8)
class URCNzUiCountdownNum final : public URCUiWidgetBase
{
public:
	class UImage*                                 NumImage_0;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_1;                                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_2;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_3;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_4;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_5;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_6;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NumImage_7;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiCountdownNum">();
	}
	static class URCNzUiCountdownNum* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiCountdownNum>();
	}
};
static_assert(alignof(URCNzUiCountdownNum) == 0x000008, "Wrong alignment on URCNzUiCountdownNum");
static_assert(sizeof(URCNzUiCountdownNum) == 0x000318, "Wrong size on URCNzUiCountdownNum");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_0) == 0x0002D8, "Member 'URCNzUiCountdownNum::NumImage_0' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_1) == 0x0002E0, "Member 'URCNzUiCountdownNum::NumImage_1' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_2) == 0x0002E8, "Member 'URCNzUiCountdownNum::NumImage_2' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_3) == 0x0002F0, "Member 'URCNzUiCountdownNum::NumImage_3' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_4) == 0x0002F8, "Member 'URCNzUiCountdownNum::NumImage_4' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_5) == 0x000300, "Member 'URCNzUiCountdownNum::NumImage_5' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_6) == 0x000308, "Member 'URCNzUiCountdownNum::NumImage_6' has a wrong offset!");
static_assert(offsetof(URCNzUiCountdownNum, NumImage_7) == 0x000310, "Member 'URCNzUiCountdownNum::NumImage_7' has a wrong offset!");

// Class RC.RCParamNzMTBChData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzMTBChData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzMTBChTableRow>        Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzMTBChData">();
	}
	static class URCParamNzMTBChData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzMTBChData>();
	}
};
static_assert(alignof(URCParamNzMTBChData) == 0x000008, "Wrong alignment on URCParamNzMTBChData");
static_assert(sizeof(URCParamNzMTBChData) == 0x000040, "Wrong size on URCParamNzMTBChData");
static_assert(offsetof(URCParamNzMTBChData, Data) == 0x000030, "Member 'URCParamNzMTBChData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleCursorBtnGuideWidget
// 0x0020 (0x02F8 - 0x02D8)
class URCNzUiFinaleCursorBtnGuideWidget final : public URCUiWidgetBase
{
public:
	class URCUiButtonGuideParts*                  BtnGuideParts;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Btn_On;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Btn_Off;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isVisibleState;                                    // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFinaleCursorBtnGuide();
	void UpdateBtnGuide(ERCInputKeyType Key, const class FString& GuideStr, bool visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleCursorBtnGuideWidget">();
	}
	static class URCNzUiFinaleCursorBtnGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleCursorBtnGuideWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleCursorBtnGuideWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleCursorBtnGuideWidget");
static_assert(sizeof(URCNzUiFinaleCursorBtnGuideWidget) == 0x0002F8, "Wrong size on URCNzUiFinaleCursorBtnGuideWidget");
static_assert(offsetof(URCNzUiFinaleCursorBtnGuideWidget, BtnGuideParts) == 0x0002D8, "Member 'URCNzUiFinaleCursorBtnGuideWidget::BtnGuideParts' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorBtnGuideWidget, AN_Btn_On) == 0x0002E0, "Member 'URCNzUiFinaleCursorBtnGuideWidget::AN_Btn_On' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorBtnGuideWidget, AN_Btn_Off) == 0x0002E8, "Member 'URCNzUiFinaleCursorBtnGuideWidget::AN_Btn_Off' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorBtnGuideWidget, isVisibleState) == 0x0002F0, "Member 'URCNzUiFinaleCursorBtnGuideWidget::isVisibleState' has a wrong offset!");

// Class RC.RCNzUiFinaleCursorWidget
// 0x0028 (0x0300 - 0x02D8)
class URCNzUiFinaleCursorWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           topCanvasPanel;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStart;                                           // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CursorSize;                                        // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCNzUiFinaleCursorBtnGuideWidget*      BtnGuideParts;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CursorFinish();
	void CursorStart();
	void InitializeFinaleCursorWidget();
	void PlaySelectAnimation();
	void PlayUnSelectAnimation();
	void UpdateCursorBtnGuide(ERCInputKeyType Key, bool IsVisible_0, const class FString& GuideStr);
	void UpdateCursorVisibleState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleCursorWidget">();
	}
	static class URCNzUiFinaleCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleCursorWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleCursorWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleCursorWidget");
static_assert(sizeof(URCNzUiFinaleCursorWidget) == 0x000300, "Wrong size on URCNzUiFinaleCursorWidget");
static_assert(offsetof(URCNzUiFinaleCursorWidget, AN_Start) == 0x0002D8, "Member 'URCNzUiFinaleCursorWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorWidget, AN_Finish) == 0x0002E0, "Member 'URCNzUiFinaleCursorWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorWidget, topCanvasPanel) == 0x0002E8, "Member 'URCNzUiFinaleCursorWidget::topCanvasPanel' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorWidget, IsStart) == 0x0002F0, "Member 'URCNzUiFinaleCursorWidget::IsStart' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorWidget, CursorSize) == 0x0002F4, "Member 'URCNzUiFinaleCursorWidget::CursorSize' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleCursorWidget, BtnGuideParts) == 0x0002F8, "Member 'URCNzUiFinaleCursorWidget::BtnGuideParts' has a wrong offset!");

// Class RC.RCParamNzFinaleData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzFinaleData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzFinaleTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzFinaleData">();
	}
	static class URCParamNzFinaleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzFinaleData>();
	}
};
static_assert(alignof(URCParamNzFinaleData) == 0x000008, "Wrong alignment on URCParamNzFinaleData");
static_assert(sizeof(URCParamNzFinaleData) == 0x000040, "Wrong size on URCParamNzFinaleData");
static_assert(offsetof(URCParamNzFinaleData, Data) == 0x000030, "Member 'URCParamNzFinaleData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleDetectiveImageText
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiFinaleDetectiveImageText final : public URCUiWidgetBase
{
public:
	class FName                                   TextID;                                            // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeText();
	void UpdateText(const class FString& str);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleDetectiveImageText">();
	}
	static class URCNzUiFinaleDetectiveImageText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleDetectiveImageText>();
	}
};
static_assert(alignof(URCNzUiFinaleDetectiveImageText) == 0x000008, "Wrong alignment on URCNzUiFinaleDetectiveImageText");
static_assert(sizeof(URCNzUiFinaleDetectiveImageText) == 0x0002E0, "Wrong size on URCNzUiFinaleDetectiveImageText");
static_assert(offsetof(URCNzUiFinaleDetectiveImageText, TextID) == 0x0002D8, "Member 'URCNzUiFinaleDetectiveImageText::TextID' has a wrong offset!");

// Class RC.RCParamMinimapListData
// 0x0010 (0x0040 - 0x0030)
class URCParamMinimapListData final : public URCCSVData
{
public:
	TArray<struct FRCParamMinimapListTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMinimapListData">();
	}
	static class URCParamMinimapListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMinimapListData>();
	}
};
static_assert(alignof(URCParamMinimapListData) == 0x000008, "Wrong alignment on URCParamMinimapListData");
static_assert(sizeof(URCParamMinimapListData) == 0x000040, "Wrong size on URCParamMinimapListData");
static_assert(offsetof(URCParamMinimapListData, Data) == 0x000030, "Member 'URCParamMinimapListData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleDetectiveSceneWidget
// 0x0060 (0x0338 - 0x02D8)
class URCNzUiFinaleDetectiveSceneWidget final : public URCUiWidgetBase
{
public:
	float                                         backgroundImgScaleX;                               // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         backgroundImgScaleY;                               // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCNzUiFinaleInteractIconWidget*> InteractIconList;                                  // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCNzUiFinaleInteractIconWidget*> InOutAnimPlayInteractIconList;                     // 0x02F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           initAnimTimerHandle;                               // 0x0300(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         initAnimIdx;                                       // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InOutAnimPlayListCount;                            // 0x030C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isUseInOutAnimFlag;                                // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInitialized;                                     // 0x0311(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              AllStartAnimFinished;                              // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              AllEndAnimFinished;                                // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void AddImage(const class UTexture2D* Img);
	void ClearAddImageList();
	struct FVector2D GetBackgroundImgScale();
	class URCNzUiFinaleInteractIconWidget* GetCurrentDetectiveSceneInteractPointPos(bool* Result);
	TArray<class URCNzUiFinaleInteractIconWidget*> GetInteractIconList();
	int32 GetInteractIconNum();
	TArray<class FName> GetInteractIDList();
	TArray<struct FRCNzFinaleGamePieceData> GetInteractPieceDataList();
	TArray<struct FRCNzUiFinaleInteractImgInfo> GetPieceImgInfoList();
	TMap<class FName, class UTexture2D*> GetPieceImgList();
	void HiddenDetectiveScene();
	void InitializeDetectiveScene();
	void InteractEndFinished();
	void InteractStartFinished();
	bool IsUseInOutAnim();
	bool PlayEndAnim();
	void PlayInitPieceList();
	bool PlayStartAnim();
	void SetBackgroundImgScale(float ScaleX, float ScaleY);
	void SetVisibleDetectiveScene(const bool IsVisible_0);
	void ShowDetectiveScene(const class UTexture2D* Img);
	void UpdateDetectiveScene(const class UTexture2D* Img);
	void UpdatePieceData(const TArray<struct FRCNzFinaleGamePieceData>& pieceList);
	void UpdatePieceImg(const TMap<class FName, class UTexture2D*>& PieceImgList);
	void UpdatePieceImgInfo(const TArray<struct FRCNzUiFinaleInteractImgInfo>& PieceImgInfoList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleDetectiveSceneWidget">();
	}
	static class URCNzUiFinaleDetectiveSceneWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleDetectiveSceneWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleDetectiveSceneWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleDetectiveSceneWidget");
static_assert(sizeof(URCNzUiFinaleDetectiveSceneWidget) == 0x000338, "Wrong size on URCNzUiFinaleDetectiveSceneWidget");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, backgroundImgScaleX) == 0x0002D8, "Member 'URCNzUiFinaleDetectiveSceneWidget::backgroundImgScaleX' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, backgroundImgScaleY) == 0x0002DC, "Member 'URCNzUiFinaleDetectiveSceneWidget::backgroundImgScaleY' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, InteractIconList) == 0x0002E0, "Member 'URCNzUiFinaleDetectiveSceneWidget::InteractIconList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, InOutAnimPlayInteractIconList) == 0x0002F0, "Member 'URCNzUiFinaleDetectiveSceneWidget::InOutAnimPlayInteractIconList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, initAnimTimerHandle) == 0x000300, "Member 'URCNzUiFinaleDetectiveSceneWidget::initAnimTimerHandle' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, initAnimIdx) == 0x000308, "Member 'URCNzUiFinaleDetectiveSceneWidget::initAnimIdx' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, InOutAnimPlayListCount) == 0x00030C, "Member 'URCNzUiFinaleDetectiveSceneWidget::InOutAnimPlayListCount' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, isUseInOutAnimFlag) == 0x000310, "Member 'URCNzUiFinaleDetectiveSceneWidget::isUseInOutAnimFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, IsInitialized) == 0x000311, "Member 'URCNzUiFinaleDetectiveSceneWidget::IsInitialized' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, AllStartAnimFinished) == 0x000318, "Member 'URCNzUiFinaleDetectiveSceneWidget::AllStartAnimFinished' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleDetectiveSceneWidget, AllEndAnimFinished) == 0x000328, "Member 'URCNzUiFinaleDetectiveSceneWidget::AllEndAnimFinished' has a wrong offset!");

// Class RC.RCParamNzFinaleSectionData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzFinaleSectionData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzFinaleSectionTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzFinaleSectionData">();
	}
	static class URCParamNzFinaleSectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzFinaleSectionData>();
	}
};
static_assert(alignof(URCParamNzFinaleSectionData) == 0x000008, "Wrong alignment on URCParamNzFinaleSectionData");
static_assert(sizeof(URCParamNzFinaleSectionData) == 0x000040, "Wrong size on URCParamNzFinaleSectionData");
static_assert(offsetof(URCParamNzFinaleSectionData, Data) == 0x000030, "Member 'URCParamNzFinaleSectionData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleHeadingClearWidget
// 0x0030 (0x0308 - 0x02D8)
class URCNzUiFinaleHeadingClearWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x02E8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         showTime;                                          // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x14];                                     // 0x02F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayHeadingClearHiddenAnim();
	void PlayHeadingClearShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleHeadingClearWidget">();
	}
	static class URCNzUiFinaleHeadingClearWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleHeadingClearWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleHeadingClearWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleHeadingClearWidget");
static_assert(sizeof(URCNzUiFinaleHeadingClearWidget) == 0x000308, "Wrong size on URCNzUiFinaleHeadingClearWidget");
static_assert(offsetof(URCNzUiFinaleHeadingClearWidget, AN_Start) == 0x0002D8, "Member 'URCNzUiFinaleHeadingClearWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingClearWidget, AN_Finish) == 0x0002E0, "Member 'URCNzUiFinaleHeadingClearWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingClearWidget, TimerHandle) == 0x0002E8, "Member 'URCNzUiFinaleHeadingClearWidget::TimerHandle' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleHeadingClearWidget, showTime) == 0x0002F0, "Member 'URCNzUiFinaleHeadingClearWidget::showTime' has a wrong offset!");

// Class RC.RCSpiritMiniGameCheckPoint
// 0x0010 (0x0310 - 0x0300)
class ARCSpiritMiniGameCheckPoint final : public ARCEventTrigger
{
public:
	ERCSpiritMiniGameCheckPointType               CheckPointType;                                    // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCSpiritMiniGameManager*               SpiritMiniGameManager;                             // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSpiritMiniGameCheckPoint">();
	}
	static class ARCSpiritMiniGameCheckPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSpiritMiniGameCheckPoint>();
	}
};
static_assert(alignof(ARCSpiritMiniGameCheckPoint) == 0x000008, "Wrong alignment on ARCSpiritMiniGameCheckPoint");
static_assert(sizeof(ARCSpiritMiniGameCheckPoint) == 0x000310, "Wrong size on ARCSpiritMiniGameCheckPoint");
static_assert(offsetof(ARCSpiritMiniGameCheckPoint, CheckPointType) == 0x000300, "Member 'ARCSpiritMiniGameCheckPoint::CheckPointType' has a wrong offset!");
static_assert(offsetof(ARCSpiritMiniGameCheckPoint, SpiritMiniGameManager) == 0x000308, "Member 'ARCSpiritMiniGameCheckPoint::SpiritMiniGameManager' has a wrong offset!");

// Class RC.RCParamNzResultChapterSettingData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultChapterSettingData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultChapterSettingTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultChapterSettingData">();
	}
	static class URCParamNzResultChapterSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultChapterSettingData>();
	}
};
static_assert(alignof(URCParamNzResultChapterSettingData) == 0x000008, "Wrong alignment on URCParamNzResultChapterSettingData");
static_assert(sizeof(URCParamNzResultChapterSettingData) == 0x000040, "Wrong size on URCParamNzResultChapterSettingData");
static_assert(offsetof(URCParamNzResultChapterSettingData, Data) == 0x000030, "Member 'URCParamNzResultChapterSettingData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleIndexBTNGuideWidget
// 0x0018 (0x02F0 - 0x02D8)
class URCNzUiFinaleIndexBTNGuideWidget final : public URCUiWidgetBase
{
public:
	class URCUiButtonGuideParts*                  ButtonGuideParts;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BtnGuideText;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BaseImage;                                         // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BTNGuideCloseEvent();
	void BTNGuideOpenEvent();
	bool InitializeButtonGuide(ERCInputKeyType InKeyType, const class FString& str);
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleIndexBTNGuideWidget">();
	}
	static class URCNzUiFinaleIndexBTNGuideWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleIndexBTNGuideWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleIndexBTNGuideWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleIndexBTNGuideWidget");
static_assert(sizeof(URCNzUiFinaleIndexBTNGuideWidget) == 0x0002F0, "Wrong size on URCNzUiFinaleIndexBTNGuideWidget");
static_assert(offsetof(URCNzUiFinaleIndexBTNGuideWidget, ButtonGuideParts) == 0x0002D8, "Member 'URCNzUiFinaleIndexBTNGuideWidget::ButtonGuideParts' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexBTNGuideWidget, BtnGuideText) == 0x0002E0, "Member 'URCNzUiFinaleIndexBTNGuideWidget::BtnGuideText' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleIndexBTNGuideWidget, BaseImage) == 0x0002E8, "Member 'URCNzUiFinaleIndexBTNGuideWidget::BaseImage' has a wrong offset!");

// Class RC.RCParamNzMTBWallMeshData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzMTBWallMeshData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzMTBWallMeshTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzMTBWallMeshData">();
	}
	static class URCParamNzMTBWallMeshData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzMTBWallMeshData>();
	}
};
static_assert(alignof(URCParamNzMTBWallMeshData) == 0x000008, "Wrong alignment on URCParamNzMTBWallMeshData");
static_assert(sizeof(URCParamNzMTBWallMeshData) == 0x000040, "Wrong size on URCParamNzMTBWallMeshData");
static_assert(offsetof(URCParamNzMTBWallMeshData, Data) == 0x000030, "Member 'URCParamNzMTBWallMeshData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleIndexListParentWidget
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiFinaleIndexListParentWidget final : public URCUiWidgetBase
{
public:
	class URCNzUiFinaleIndexListWidget*           IndexListUI;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class URCNzUiFinaleIndexListWidget* GetIndexListUI();
	void InitializeIndexList(const class FString& chNumStr);
	void UpdateIndexList(const struct FRCParamNzFinaleSectionTableRow& Section, int32 idx, class ARCNzFinaleManagerBase* FinaleManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleIndexListParentWidget">();
	}
	static class URCNzUiFinaleIndexListParentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleIndexListParentWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleIndexListParentWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleIndexListParentWidget");
static_assert(sizeof(URCNzUiFinaleIndexListParentWidget) == 0x0002E0, "Wrong size on URCNzUiFinaleIndexListParentWidget");
static_assert(offsetof(URCNzUiFinaleIndexListParentWidget, IndexListUI) == 0x0002D8, "Member 'URCNzUiFinaleIndexListParentWidget::IndexListUI' has a wrong offset!");

// Class RC.RCParamNzFinalePieceData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzFinalePieceData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzFinalePieceTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzFinalePieceData">();
	}
	static class URCParamNzFinalePieceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzFinalePieceData>();
	}
};
static_assert(alignof(URCParamNzFinalePieceData) == 0x000008, "Wrong alignment on URCParamNzFinalePieceData");
static_assert(sizeof(URCParamNzFinalePieceData) == 0x000040, "Wrong size on URCParamNzFinalePieceData");
static_assert(offsetof(URCParamNzFinalePieceData, Data) == 0x000030, "Member 'URCParamNzFinalePieceData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleInteractIconQBase
// 0x0000 (0x02D8 - 0x02D8)
class URCNzUiFinaleInteractIconQBase final : public URCUiWidgetBase
{
public:
	void PlayCorrect();
	void PlayFinish();
	void PlayHide();
	void PlayInCorrect();
	void PlayStart();
	void PlayWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleInteractIconQBase">();
	}
	static class URCNzUiFinaleInteractIconQBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleInteractIconQBase>();
	}
};
static_assert(alignof(URCNzUiFinaleInteractIconQBase) == 0x000008, "Wrong alignment on URCNzUiFinaleInteractIconQBase");
static_assert(sizeof(URCNzUiFinaleInteractIconQBase) == 0x0002D8, "Wrong size on URCNzUiFinaleInteractIconQBase");

// Class RC.RCParamNzPuzzleSceneData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzPuzzleSceneData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzPuzzleSceneTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzPuzzleSceneData">();
	}
	static class URCParamNzPuzzleSceneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzPuzzleSceneData>();
	}
};
static_assert(alignof(URCParamNzPuzzleSceneData) == 0x000008, "Wrong alignment on URCParamNzPuzzleSceneData");
static_assert(sizeof(URCParamNzPuzzleSceneData) == 0x000040, "Wrong size on URCParamNzPuzzleSceneData");
static_assert(offsetof(URCParamNzPuzzleSceneData, Data) == 0x000030, "Member 'URCParamNzPuzzleSceneData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleLowSpeedBTNGuide
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiFinaleLowSpeedBTNGuide final : public URCUiWidgetBase
{
public:
	class URCUiButtonGuideParts*                  ButtonGuideParts;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool InitializeButtonGuide(ERCInputKeyType InKeyType, const class FString& str);
	void PlayOffAnim();
	void PlayOnAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleLowSpeedBTNGuide">();
	}
	static class URCNzUiFinaleLowSpeedBTNGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleLowSpeedBTNGuide>();
	}
};
static_assert(alignof(URCNzUiFinaleLowSpeedBTNGuide) == 0x000008, "Wrong alignment on URCNzUiFinaleLowSpeedBTNGuide");
static_assert(sizeof(URCNzUiFinaleLowSpeedBTNGuide) == 0x0002E0, "Wrong size on URCNzUiFinaleLowSpeedBTNGuide");
static_assert(offsetof(URCNzUiFinaleLowSpeedBTNGuide, ButtonGuideParts) == 0x0002D8, "Member 'URCNzUiFinaleLowSpeedBTNGuide::ButtonGuideParts' has a wrong offset!");

// Class RC.RCStartupCaution
// 0x0018 (0x02D8 - 0x02C0)
class URCStartupCaution final : public URCStartupWidget
{
public:
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCStartupCaution">();
	}
	static class URCStartupCaution* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCStartupCaution>();
	}
};
static_assert(alignof(URCStartupCaution) == 0x000008, "Wrong alignment on URCStartupCaution");
static_assert(sizeof(URCStartupCaution) == 0x0002D8, "Wrong size on URCStartupCaution");

// Class RC.RCParamNzResultRankPointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultRankPointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultRankPointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultRankPointData">();
	}
	static class URCParamNzResultRankPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultRankPointData>();
	}
};
static_assert(alignof(URCParamNzResultRankPointData) == 0x000008, "Wrong alignment on URCParamNzResultRankPointData");
static_assert(sizeof(URCParamNzResultRankPointData) == 0x000040, "Wrong size on URCParamNzResultRankPointData");
static_assert(offsetof(URCParamNzResultRankPointData, Data) == 0x000030, "Member 'URCParamNzResultRankPointData::Data' has a wrong offset!");

// Class RC.RCNzUiFinalePageMoveLayoutWidget
// 0x0020 (0x02F8 - 0x02D8)
class URCNzUiFinalePageMoveLayoutWidget final : public URCUiWidgetBase
{
public:
	class USizeBox*                               SizeBox_2;                                         // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_VisibleLR;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_VisibleL;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_VisibleR;                                       // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeVisiblePageMoveIcons(EPageMoveVisibleDirection dir);
	void GetPageMoveIconLocationAndSize(struct FVector2D* Location, struct FVector2D* Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePageMoveLayoutWidget">();
	}
	static class URCNzUiFinalePageMoveLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePageMoveLayoutWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePageMoveLayoutWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePageMoveLayoutWidget");
static_assert(sizeof(URCNzUiFinalePageMoveLayoutWidget) == 0x0002F8, "Wrong size on URCNzUiFinalePageMoveLayoutWidget");
static_assert(offsetof(URCNzUiFinalePageMoveLayoutWidget, SizeBox_2) == 0x0002D8, "Member 'URCNzUiFinalePageMoveLayoutWidget::SizeBox_2' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePageMoveLayoutWidget, AN_VisibleLR) == 0x0002E0, "Member 'URCNzUiFinalePageMoveLayoutWidget::AN_VisibleLR' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePageMoveLayoutWidget, AN_VisibleL) == 0x0002E8, "Member 'URCNzUiFinalePageMoveLayoutWidget::AN_VisibleL' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePageMoveLayoutWidget, AN_VisibleR) == 0x0002F0, "Member 'URCNzUiFinalePageMoveLayoutWidget::AN_VisibleR' has a wrong offset!");

// Class RC.RCParamNzResultMinigameListData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultMinigameListData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultMinigameListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultMinigameListData">();
	}
	static class URCParamNzResultMinigameListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultMinigameListData>();
	}
};
static_assert(alignof(URCParamNzResultMinigameListData) == 0x000008, "Wrong alignment on URCParamNzResultMinigameListData");
static_assert(sizeof(URCParamNzResultMinigameListData) == 0x000040, "Wrong size on URCParamNzResultMinigameListData");
static_assert(offsetof(URCParamNzResultMinigameListData, Data) == 0x000030, "Member 'URCParamNzResultMinigameListData::Data' has a wrong offset!");

// Class RC.RCNzUiFinalePieceCorrectWidget
// 0x0040 (0x0318 - 0x02D8)
class URCNzUiFinalePieceCorrectWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Correct;                                        // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Incorrect;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x02E8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         showTime;                                          // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPlayAnimForward;                                 // 0x02F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              FinishCorrectAnimDelegate;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishIncorrectAnimDelegate;                       // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void PlayCorrectPieceHiddenAnim();
	void PlayCorrectPieceShowAnim();
	void PlayInCorrectPieceShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceCorrectWidget">();
	}
	static class URCNzUiFinalePieceCorrectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceCorrectWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePieceCorrectWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePieceCorrectWidget");
static_assert(sizeof(URCNzUiFinalePieceCorrectWidget) == 0x000318, "Wrong size on URCNzUiFinalePieceCorrectWidget");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, AN_Correct) == 0x0002D8, "Member 'URCNzUiFinalePieceCorrectWidget::AN_Correct' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, AN_Incorrect) == 0x0002E0, "Member 'URCNzUiFinalePieceCorrectWidget::AN_Incorrect' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, TimerHandle) == 0x0002E8, "Member 'URCNzUiFinalePieceCorrectWidget::TimerHandle' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, showTime) == 0x0002F0, "Member 'URCNzUiFinalePieceCorrectWidget::showTime' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, isPlayAnimForward) == 0x0002F4, "Member 'URCNzUiFinalePieceCorrectWidget::isPlayAnimForward' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, FinishCorrectAnimDelegate) == 0x0002F8, "Member 'URCNzUiFinalePieceCorrectWidget::FinishCorrectAnimDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceCorrectWidget, FinishIncorrectAnimDelegate) == 0x000308, "Member 'URCNzUiFinalePieceCorrectWidget::FinishIncorrectAnimDelegate' has a wrong offset!");

// Class RC.RCNzUiFinalePieceDetailWidget
// 0x0070 (0x0348 - 0x02D8)
class URCNzUiFinalePieceDetailWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_ApplyStart;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_ApplyFinish;                                    // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_ApplyBlock_Lock;                                // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_ApplyBlock_Done;                                // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              FinishApplyStart;                                  // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishApplyFinish;                                 // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishApplyBlock_Lock;                             // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishApplyBlock_Done;                             // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishUnlock;                                      // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void PlayApplyBlock_Done();
	void PlayApplyBlock_Lock();
	void PlayApplyFinish();
	void PlayApplyStart();
	void PlayDone();
	void StartFinish();
	void StartOpen();
	void UpdateDetailInfo(const class FString& titile, const class UTexture2D* PieceImg, const class UTexture2D* lockNum, const bool isLock, const bool isUsed, const bool isUnlockAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceDetailWidget">();
	}
	static class URCNzUiFinalePieceDetailWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceDetailWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePieceDetailWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePieceDetailWidget");
static_assert(sizeof(URCNzUiFinalePieceDetailWidget) == 0x000348, "Wrong size on URCNzUiFinalePieceDetailWidget");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, AN_ApplyStart) == 0x0002D8, "Member 'URCNzUiFinalePieceDetailWidget::AN_ApplyStart' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, AN_ApplyFinish) == 0x0002E0, "Member 'URCNzUiFinalePieceDetailWidget::AN_ApplyFinish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, AN_ApplyBlock_Lock) == 0x0002E8, "Member 'URCNzUiFinalePieceDetailWidget::AN_ApplyBlock_Lock' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, AN_ApplyBlock_Done) == 0x0002F0, "Member 'URCNzUiFinalePieceDetailWidget::AN_ApplyBlock_Done' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, FinishApplyStart) == 0x0002F8, "Member 'URCNzUiFinalePieceDetailWidget::FinishApplyStart' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, FinishApplyFinish) == 0x000308, "Member 'URCNzUiFinalePieceDetailWidget::FinishApplyFinish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, FinishApplyBlock_Lock) == 0x000318, "Member 'URCNzUiFinalePieceDetailWidget::FinishApplyBlock_Lock' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, FinishApplyBlock_Done) == 0x000328, "Member 'URCNzUiFinalePieceDetailWidget::FinishApplyBlock_Done' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceDetailWidget, FinishUnlock) == 0x000338, "Member 'URCNzUiFinalePieceDetailWidget::FinishUnlock' has a wrong offset!");

// Class RC.RCSingletonObject
// 0x0020 (0x0048 - 0x0028)
class URCSingletonObject : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiShortLoadingIcon*                  ShortLoadingIcon;                                  // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCUiTipsScreenWidget*                  TipScreenWidget;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ReceiveTick(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSingletonObject">();
	}
	static class URCSingletonObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSingletonObject>();
	}
};
static_assert(alignof(URCSingletonObject) == 0x000008, "Wrong alignment on URCSingletonObject");
static_assert(sizeof(URCSingletonObject) == 0x000048, "Wrong size on URCSingletonObject");
static_assert(offsetof(URCSingletonObject, ShortLoadingIcon) == 0x000038, "Member 'URCSingletonObject::ShortLoadingIcon' has a wrong offset!");
static_assert(offsetof(URCSingletonObject, TipScreenWidget) == 0x000040, "Member 'URCSingletonObject::TipScreenWidget' has a wrong offset!");

// Class RC.RCParamNzPuzzleBarrelWordData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzPuzzleBarrelWordData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzPuzzleBarrelWordTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzPuzzleBarrelWordData">();
	}
	static class URCParamNzPuzzleBarrelWordData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzPuzzleBarrelWordData>();
	}
};
static_assert(alignof(URCParamNzPuzzleBarrelWordData) == 0x000008, "Wrong alignment on URCParamNzPuzzleBarrelWordData");
static_assert(sizeof(URCParamNzPuzzleBarrelWordData) == 0x000040, "Wrong size on URCParamNzPuzzleBarrelWordData");
static_assert(offsetof(URCParamNzPuzzleBarrelWordData, Data) == 0x000030, "Member 'URCParamNzPuzzleBarrelWordData::Data' has a wrong offset!");

// Class RC.RCNzUiFinalePieceGetWidget
// 0x0048 (0x0320 - 0x02D8)
class URCNzUiFinalePieceGetWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         showTime;                                          // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x1C];                                     // 0x02F4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              HiddenFinishDelegate;                              // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallHiddenFinishedDelegate();
	void PlayGetPieceHiddenAnim();
	void PlayGetPieceShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceGetWidget">();
	}
	static class URCNzUiFinalePieceGetWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceGetWidget>();
	}
};
static_assert(alignof(URCNzUiFinalePieceGetWidget) == 0x000008, "Wrong alignment on URCNzUiFinalePieceGetWidget");
static_assert(sizeof(URCNzUiFinalePieceGetWidget) == 0x000320, "Wrong size on URCNzUiFinalePieceGetWidget");
static_assert(offsetof(URCNzUiFinalePieceGetWidget, AN_Start) == 0x0002D8, "Member 'URCNzUiFinalePieceGetWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceGetWidget, AN_Wait) == 0x0002E0, "Member 'URCNzUiFinalePieceGetWidget::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceGetWidget, AN_Finish) == 0x0002E8, "Member 'URCNzUiFinalePieceGetWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceGetWidget, showTime) == 0x0002F0, "Member 'URCNzUiFinalePieceGetWidget::showTime' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceGetWidget, HiddenFinishDelegate) == 0x000310, "Member 'URCNzUiFinalePieceGetWidget::HiddenFinishDelegate' has a wrong offset!");

// Class RC.RCParamCollectionMenuData
// 0x0010 (0x0040 - 0x0030)
class URCParamCollectionMenuData final : public URCCSVData
{
public:
	TArray<struct FRCParamCollectionMenuTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCollectionMenuData">();
	}
	static class URCParamCollectionMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCollectionMenuData>();
	}
};
static_assert(alignof(URCParamCollectionMenuData) == 0x000008, "Wrong alignment on URCParamCollectionMenuData");
static_assert(sizeof(URCParamCollectionMenuData) == 0x000040, "Wrong size on URCParamCollectionMenuData");
static_assert(offsetof(URCParamCollectionMenuData, Data) == 0x000030, "Member 'URCParamCollectionMenuData::Data' has a wrong offset!");

// Class RC.RCNzUiFinalePieceList_PieceBase
// 0x00A0 (0x0378 - 0x02D8)
class URCNzUiFinalePieceList_PieceBase final : public URCUiWidgetBase
{
public:
	bool                                          isDone;                                            // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFinalePieceState                             CurrentPieceState;                                 // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCNzFinalePieceObjectInfo             PieceObjectInfo;                                   // 0x02E0(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          isUnlock;                                          // 0x0338(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCNzUiFinalePieceLayoutWidget*         ownerLayout;                                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0348(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x034C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              PieceUnlockFinishedDelegate;                       // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PiecePickFinishedDelegate;                         // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	bool CheckCurrentPieceState(EFinalePieceState targetState);
	EFinalePieceState GetCurrentPieceState();
	float GetPieceDegree();
	float GetPieceImgAngle();
	struct FVector2D GetPieceImgSize();
	struct FVector2D GetPieceWBPScale();
	struct FVector2D GetPieceWBPSize();
	void InitializePiece(const struct FRCNzFinalePieceObjectInfo& Info, class URCNzUiFinalePieceLayoutWidget* Owner);
	void PlayDone();
	void PlayPickAnim();
	void PlaySelect();
	void PlayUnLockAnim();
	void PlayUnSelect();
	void SetPieceImage(class UTexture2D* tex);
	void SetPieceState(bool IsSelect);
	void UpdatePiece(const struct FRCNzFinalePieceObjectInfo& Info);
	void UpdateRockState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceList_PieceBase">();
	}
	static class URCNzUiFinalePieceList_PieceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceList_PieceBase>();
	}
};
static_assert(alignof(URCNzUiFinalePieceList_PieceBase) == 0x000008, "Wrong alignment on URCNzUiFinalePieceList_PieceBase");
static_assert(sizeof(URCNzUiFinalePieceList_PieceBase) == 0x000378, "Wrong size on URCNzUiFinalePieceList_PieceBase");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, isDone) == 0x0002D8, "Member 'URCNzUiFinalePieceList_PieceBase::isDone' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, CurrentPieceState) == 0x0002D9, "Member 'URCNzUiFinalePieceList_PieceBase::CurrentPieceState' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, PieceObjectInfo) == 0x0002E0, "Member 'URCNzUiFinalePieceList_PieceBase::PieceObjectInfo' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, isUnlock) == 0x000338, "Member 'URCNzUiFinalePieceList_PieceBase::isUnlock' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, ownerLayout) == 0x000340, "Member 'URCNzUiFinalePieceList_PieceBase::ownerLayout' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, Angle) == 0x000348, "Member 'URCNzUiFinalePieceList_PieceBase::Angle' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, Size) == 0x00034C, "Member 'URCNzUiFinalePieceList_PieceBase::Size' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, PieceUnlockFinishedDelegate) == 0x000358, "Member 'URCNzUiFinalePieceList_PieceBase::PieceUnlockFinishedDelegate' has a wrong offset!");
static_assert(offsetof(URCNzUiFinalePieceList_PieceBase, PiecePickFinishedDelegate) == 0x000368, "Member 'URCNzUiFinalePieceList_PieceBase::PiecePickFinishedDelegate' has a wrong offset!");

// Class RC.RCNzUiFinalePieceQuestionBase
// 0x0008 (0x02E0 - 0x02D8)
class URCNzUiFinalePieceQuestionBase final : public URCUiWidgetBase
{
public:
	class UMaterialInstance*                      WindowMat;                                         // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishPieceQuestion();
	void InitializePieceQuestion();
	void SetQuestionTextPosition(const struct FVector2D& Position, const bool isLeft);
	void UpdateQuestion(const bool IsVisible_0, const class FString& QuestionText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinalePieceQuestionBase">();
	}
	static class URCNzUiFinalePieceQuestionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinalePieceQuestionBase>();
	}
};
static_assert(alignof(URCNzUiFinalePieceQuestionBase) == 0x000008, "Wrong alignment on URCNzUiFinalePieceQuestionBase");
static_assert(sizeof(URCNzUiFinalePieceQuestionBase) == 0x0002E0, "Wrong size on URCNzUiFinalePieceQuestionBase");
static_assert(offsetof(URCNzUiFinalePieceQuestionBase, WindowMat) == 0x0002D8, "Member 'URCNzUiFinalePieceQuestionBase::WindowMat' has a wrong offset!");

// Class RC.RCNzUiFinaleQuestionIconWidget
// 0x0010 (0x02E8 - 0x02D8)
class URCNzUiFinaleQuestionIconWidget final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Check;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_UnCheck;                                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleQuestionIconWidget">();
	}
	static class URCNzUiFinaleQuestionIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleQuestionIconWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleQuestionIconWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleQuestionIconWidget");
static_assert(sizeof(URCNzUiFinaleQuestionIconWidget) == 0x0002E8, "Wrong size on URCNzUiFinaleQuestionIconWidget");
static_assert(offsetof(URCNzUiFinaleQuestionIconWidget, AN_Check) == 0x0002D8, "Member 'URCNzUiFinaleQuestionIconWidget::AN_Check' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionIconWidget, AN_UnCheck) == 0x0002E0, "Member 'URCNzUiFinaleQuestionIconWidget::AN_UnCheck' has a wrong offset!");

// Class RC.RCParamEventCheckReloadSubLevelData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventCheckReloadSubLevelData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventCheckReloadSubLevelTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventCheckReloadSubLevelData">();
	}
	static class URCParamEventCheckReloadSubLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventCheckReloadSubLevelData>();
	}
};
static_assert(alignof(URCParamEventCheckReloadSubLevelData) == 0x000008, "Wrong alignment on URCParamEventCheckReloadSubLevelData");
static_assert(sizeof(URCParamEventCheckReloadSubLevelData) == 0x000040, "Wrong size on URCParamEventCheckReloadSubLevelData");
static_assert(offsetof(URCParamEventCheckReloadSubLevelData, Data) == 0x000030, "Member 'URCParamEventCheckReloadSubLevelData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleQuestionLayoutWidget
// 0x0010 (0x02E8 - 0x02D8)
class URCNzUiFinaleQuestionLayoutWidget final : public URCUiWidgetBase
{
public:
	TArray<class URCNzUiFinaleQuestionIconWidget*> IconWidgetList;                                    // 0x02D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void HiddenAllQuestionIcon();
	void InitializeQuestionLayoutWidget();
	void UpdateAllQuestionIcon(const TArray<bool>& isCheckList);
	void UpdateAtQuestionIcon(int32 Index_0, bool isCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleQuestionLayoutWidget">();
	}
	static class URCNzUiFinaleQuestionLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleQuestionLayoutWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleQuestionLayoutWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleQuestionLayoutWidget");
static_assert(sizeof(URCNzUiFinaleQuestionLayoutWidget) == 0x0002E8, "Wrong size on URCNzUiFinaleQuestionLayoutWidget");
static_assert(offsetof(URCNzUiFinaleQuestionLayoutWidget, IconWidgetList) == 0x0002D8, "Member 'URCNzUiFinaleQuestionLayoutWidget::IconWidgetList' has a wrong offset!");

// Class RC.RCNzUiFinaleQuestionRestWidget
// 0x0040 (0x0318 - 0x02D8)
class URCNzUiFinaleQuestionRestWidget final : public URCUiWidgetBase
{
public:
	class UTextBlock*                             RestNumberText;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RestNumImg_01;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RestNumImg_02;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     NumTextureList;                                    // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FString                                 RestNumTexPath;                                    // 0x0300(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_PieceCorrect;                                   // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeFinaleQuestionRestWidget();
	void PlayPieeCorrectAnim();
	void SetQuestionNum(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleQuestionRestWidget">();
	}
	static class URCNzUiFinaleQuestionRestWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleQuestionRestWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleQuestionRestWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleQuestionRestWidget");
static_assert(sizeof(URCNzUiFinaleQuestionRestWidget) == 0x000318, "Wrong size on URCNzUiFinaleQuestionRestWidget");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, RestNumberText) == 0x0002D8, "Member 'URCNzUiFinaleQuestionRestWidget::RestNumberText' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, RestNumImg_01) == 0x0002E0, "Member 'URCNzUiFinaleQuestionRestWidget::RestNumImg_01' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, RestNumImg_02) == 0x0002E8, "Member 'URCNzUiFinaleQuestionRestWidget::RestNumImg_02' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, NumTextureList) == 0x0002F0, "Member 'URCNzUiFinaleQuestionRestWidget::NumTextureList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, RestNumTexPath) == 0x000300, "Member 'URCNzUiFinaleQuestionRestWidget::RestNumTexPath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionRestWidget, AN_PieceCorrect) == 0x000310, "Member 'URCNzUiFinaleQuestionRestWidget::AN_PieceCorrect' has a wrong offset!");

// Class RC.RCParamCharacterTagListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterTagListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterTagListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterTagListData">();
	}
	static class URCParamCharacterTagListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterTagListData>();
	}
};
static_assert(alignof(URCParamCharacterTagListData) == 0x000008, "Wrong alignment on URCParamCharacterTagListData");
static_assert(sizeof(URCParamCharacterTagListData) == 0x000040, "Wrong size on URCParamCharacterTagListData");
static_assert(offsetof(URCParamCharacterTagListData, Data) == 0x000030, "Member 'URCParamCharacterTagListData::Data' has a wrong offset!");

// Class RC.RCNzUiFinaleQuestionWidget
// 0x0068 (0x0340 - 0x02D8)
class URCNzUiFinaleQuestionWidget final : public URCUiWidgetBase
{
public:
	TArray<class URCNzUiFinaleInteractIconWidget*> InteractIconList;                                  // 0x02D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCNzUiFinaleDetectiveSceneWidget*> DetectiveSceneList;                                // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas;                                            // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiFinaleDetectiveImageWidget*      DetectiveImageWidget;                              // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URCNzUiFinaleInteractIconWidget> PieceIconWidgetClass;                              // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URCNzUiFinaleInteractIconWidget> DetectiveIconWidgetClass;                          // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentShowDetectiveSceneIdx;                      // 0x0318(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 backImageWidget;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DetectiveImageWidgetPath;                          // 0x0328(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         tmpTargetSectionNum;                               // 0x0338(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBackgroundImg(class UTexture2D* tex);
	void AddInteractIconWidget(class URCNzUiFinaleInteractIconWidget* Widget, const struct FVector2D& Position, bool isSuccess);
	void CleanPiece();
	void FinishedInteractIconStartAnim();
	void FinishedToLeftAnim();
	void FinishedToRightAnim();
	class URCNzUiFinaleDetectiveSceneWidget* GetCurrentDetectiveScene();
	int32 GetCurrentShowDetectiveSceneIdx();
	TArray<class URCNzUiFinaleInteractIconWidget*> GetPieceList();
	void InitializeFinaleQuestion();
	void PlayIconListInitAnim();
	void SetIsPickPiece(class FName targetPieceID, bool isPick);
	void SetVisiblePiece(class FName targetPieceID, bool visible);
	void SetVisibleQuestionWidget(bool IsVisible_0);
	bool StartPlayPageMoveAnim(const int32 targetSectionNum, const EFinalePageMoveDirection dir);
	bool UpdateBackgroundImg(const int32 targetSectionNum);
	void UpdatePiece(const TArray<struct FRCNzFinaleGamePieceData>& pieceList);
	void UpdateTexture(const class UTexture2D* backImg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleQuestionWidget">();
	}
	static class URCNzUiFinaleQuestionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleQuestionWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleQuestionWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleQuestionWidget");
static_assert(sizeof(URCNzUiFinaleQuestionWidget) == 0x000340, "Wrong size on URCNzUiFinaleQuestionWidget");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, InteractIconList) == 0x0002D8, "Member 'URCNzUiFinaleQuestionWidget::InteractIconList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, DetectiveSceneList) == 0x0002E8, "Member 'URCNzUiFinaleQuestionWidget::DetectiveSceneList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, Canvas) == 0x0002F8, "Member 'URCNzUiFinaleQuestionWidget::Canvas' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, DetectiveImageWidget) == 0x000300, "Member 'URCNzUiFinaleQuestionWidget::DetectiveImageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, PieceIconWidgetClass) == 0x000308, "Member 'URCNzUiFinaleQuestionWidget::PieceIconWidgetClass' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, DetectiveIconWidgetClass) == 0x000310, "Member 'URCNzUiFinaleQuestionWidget::DetectiveIconWidgetClass' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, CurrentShowDetectiveSceneIdx) == 0x000318, "Member 'URCNzUiFinaleQuestionWidget::CurrentShowDetectiveSceneIdx' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, backImageWidget) == 0x000320, "Member 'URCNzUiFinaleQuestionWidget::backImageWidget' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, DetectiveImageWidgetPath) == 0x000328, "Member 'URCNzUiFinaleQuestionWidget::DetectiveImageWidgetPath' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleQuestionWidget, tmpTargetSectionNum) == 0x000338, "Member 'URCNzUiFinaleQuestionWidget::tmpTargetSectionNum' has a wrong offset!");

// Class RC.RCNzUiFinaleTimeLimitWidget
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiFinaleTimeLimitWidget final : public URCUiWidgetBase
{
public:
	TArray<class UImage*>                         TimerImageList;                                    // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     NumTextureList;                                    // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoftObjectPath>                NumHighTexturePathList;                            // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFinaleTimeLimitWidget();
	void SetTime(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiFinaleTimeLimitWidget">();
	}
	static class URCNzUiFinaleTimeLimitWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiFinaleTimeLimitWidget>();
	}
};
static_assert(alignof(URCNzUiFinaleTimeLimitWidget) == 0x000008, "Wrong alignment on URCNzUiFinaleTimeLimitWidget");
static_assert(sizeof(URCNzUiFinaleTimeLimitWidget) == 0x000310, "Wrong size on URCNzUiFinaleTimeLimitWidget");
static_assert(offsetof(URCNzUiFinaleTimeLimitWidget, TimerImageList) == 0x0002D8, "Member 'URCNzUiFinaleTimeLimitWidget::TimerImageList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitWidget, NumTextureList) == 0x0002E8, "Member 'URCNzUiFinaleTimeLimitWidget::NumTextureList' has a wrong offset!");
static_assert(offsetof(URCNzUiFinaleTimeLimitWidget, NumHighTexturePathList) == 0x0002F8, "Member 'URCNzUiFinaleTimeLimitWidget::NumHighTexturePathList' has a wrong offset!");

// Class RC.RCNzUiKagiChoiceQuestion
// 0x0038 (0x0310 - 0x02D8)
class URCNzUiKagiChoiceQuestion final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      SpText_Question;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void Open();
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiKagiChoiceQuestion">();
	}
	static class URCNzUiKagiChoiceQuestion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiKagiChoiceQuestion>();
	}
};
static_assert(alignof(URCNzUiKagiChoiceQuestion) == 0x000008, "Wrong alignment on URCNzUiKagiChoiceQuestion");
static_assert(sizeof(URCNzUiKagiChoiceQuestion) == 0x000310, "Wrong size on URCNzUiKagiChoiceQuestion");
static_assert(offsetof(URCNzUiKagiChoiceQuestion, AN_Start) == 0x0002D8, "Member 'URCNzUiKagiChoiceQuestion::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiKagiChoiceQuestion, AN_Wait) == 0x0002E0, "Member 'URCNzUiKagiChoiceQuestion::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiKagiChoiceQuestion, AN_Finish) == 0x0002E8, "Member 'URCNzUiKagiChoiceQuestion::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiKagiChoiceQuestion, SpText_Question) == 0x0002F0, "Member 'URCNzUiKagiChoiceQuestion::SpText_Question' has a wrong offset!");

// Class RC.RCNzUiReproduceClosedRoomTelop
// 0x0028 (0x0300 - 0x02D8)
class URCNzUiReproduceClosedRoomTelop final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReproduceCloseRoomUIDataAsset*       UIDataAsset;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetReproduceClosedRoomTelopPriority();

	void FinishTelop();
	bool IsFinished();
	void StartTelop(class URCReproduceCloseRoomUIDataAsset* DataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiReproduceClosedRoomTelop">();
	}
	static class URCNzUiReproduceClosedRoomTelop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiReproduceClosedRoomTelop>();
	}
};
static_assert(alignof(URCNzUiReproduceClosedRoomTelop) == 0x000008, "Wrong alignment on URCNzUiReproduceClosedRoomTelop");
static_assert(sizeof(URCNzUiReproduceClosedRoomTelop) == 0x000300, "Wrong size on URCNzUiReproduceClosedRoomTelop");
static_assert(offsetof(URCNzUiReproduceClosedRoomTelop, AN_Start) == 0x0002D8, "Member 'URCNzUiReproduceClosedRoomTelop::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiReproduceClosedRoomTelop, AN_Wait) == 0x0002E0, "Member 'URCNzUiReproduceClosedRoomTelop::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiReproduceClosedRoomTelop, AN_Finish) == 0x0002E8, "Member 'URCNzUiReproduceClosedRoomTelop::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzUiReproduceClosedRoomTelop, UIDataAsset) == 0x0002F0, "Member 'URCNzUiReproduceClosedRoomTelop::UIDataAsset' has a wrong offset!");

// Class RC.RCNzUiSkillInfo
// 0x0030 (0x0308 - 0x02D8)
class URCNzUiSkillInfo final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWaitTime(float sec);
	void StartSkillInfo(class FName ID, float StartOffsetTime, float InFinishWaitTime, bool bInFinishSE);

	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiSkillInfo">();
	}
	static class URCNzUiSkillInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiSkillInfo>();
	}
};
static_assert(alignof(URCNzUiSkillInfo) == 0x000008, "Wrong alignment on URCNzUiSkillInfo");
static_assert(sizeof(URCNzUiSkillInfo) == 0x000308, "Wrong size on URCNzUiSkillInfo");
static_assert(offsetof(URCNzUiSkillInfo, AN_Start) == 0x0002D8, "Member 'URCNzUiSkillInfo::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzUiSkillInfo, AN_Wait) == 0x0002E0, "Member 'URCNzUiSkillInfo::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzUiSkillInfo, AN_Finish) == 0x0002E8, "Member 'URCNzUiSkillInfo::AN_Finish' has a wrong offset!");

// Class RC.RCNzUiSkillInfoList
// 0x0028 (0x0300 - 0x02D8)
class URCNzUiSkillInfoList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x14];                                     // 0x02D8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartOffsetTime;                                   // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllFinishFlag;                                    // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinishWaitTime;                                    // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishSkilInfoList();
	bool StartShowSkillInfoList(const TArray<class FName>& IdList);

	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzUiSkillInfoList">();
	}
	static class URCNzUiSkillInfoList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzUiSkillInfoList>();
	}
};
static_assert(alignof(URCNzUiSkillInfoList) == 0x000008, "Wrong alignment on URCNzUiSkillInfoList");
static_assert(sizeof(URCNzUiSkillInfoList) == 0x000300, "Wrong size on URCNzUiSkillInfoList");
static_assert(offsetof(URCNzUiSkillInfoList, StartOffsetTime) == 0x0002EC, "Member 'URCNzUiSkillInfoList::StartOffsetTime' has a wrong offset!");
static_assert(offsetof(URCNzUiSkillInfoList, bAllFinishFlag) == 0x0002F0, "Member 'URCNzUiSkillInfoList::bAllFinishFlag' has a wrong offset!");
static_assert(offsetof(URCNzUiSkillInfoList, FinishWaitTime) == 0x0002F4, "Member 'URCNzUiSkillInfoList::FinishWaitTime' has a wrong offset!");

// Class RC.RCNzWaruagaki_LayoutBase
// 0x0038 (0x02A8 - 0x0270)
class URCNzWaruagaki_LayoutBase final : public URCUserWidget
{
public:
	class URCNzWaruagaki_LogoBase*                Logo;                                              // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleKaiKagi*                   KaikagiSelect;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzCriminalButtonGuideList*           ButtonGuideWidget;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                InformationWidget;                                 // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzUiBattleHPGauge*                   HPGauge;                                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              WaruagakiLogoHiddenFinished;                       // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HideButtonGuide();
	void InitializeKaikagiQuestionAndInfoUI(const class FString& Heading, const class FString& question);
	void InitializeWaruagakiUI();
	void PlayWaruagakiLogoShowAnim();
	void ReleaseWaruagakiLayout();
	void SetHP(int32 OldHP, int32 NewHP, bool PlayDamageAnimation);
	void SetKaiKagiName(class FName InTextID);
	void ShowButtonGuide(bool IsNormalMode);
	void ShowStartLogoAnimFinishedEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzWaruagaki_LayoutBase">();
	}
	static class URCNzWaruagaki_LayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzWaruagaki_LayoutBase>();
	}
};
static_assert(alignof(URCNzWaruagaki_LayoutBase) == 0x000008, "Wrong alignment on URCNzWaruagaki_LayoutBase");
static_assert(sizeof(URCNzWaruagaki_LayoutBase) == 0x0002A8, "Wrong size on URCNzWaruagaki_LayoutBase");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, Logo) == 0x000270, "Member 'URCNzWaruagaki_LayoutBase::Logo' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, KaikagiSelect) == 0x000278, "Member 'URCNzWaruagaki_LayoutBase::KaikagiSelect' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, ButtonGuideWidget) == 0x000280, "Member 'URCNzWaruagaki_LayoutBase::ButtonGuideWidget' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, InformationWidget) == 0x000288, "Member 'URCNzWaruagaki_LayoutBase::InformationWidget' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, HPGauge) == 0x000290, "Member 'URCNzWaruagaki_LayoutBase::HPGauge' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LayoutBase, WaruagakiLogoHiddenFinished) == 0x000298, "Member 'URCNzWaruagaki_LayoutBase::WaruagakiLogoHiddenFinished' has a wrong offset!");

// Class RC.RCNzWaruagaki_LogoBase
// 0x0018 (0x02F0 - 0x02D8)
class URCNzWaruagaki_LogoBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              WaruagakiLogoHiddenFinishDelegate;                 // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void PlayWaruagakiLogoShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzWaruagaki_LogoBase">();
	}
	static class URCNzWaruagaki_LogoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzWaruagaki_LogoBase>();
	}
};
static_assert(alignof(URCNzWaruagaki_LogoBase) == 0x000008, "Wrong alignment on URCNzWaruagaki_LogoBase");
static_assert(sizeof(URCNzWaruagaki_LogoBase) == 0x0002F0, "Wrong size on URCNzWaruagaki_LogoBase");
static_assert(offsetof(URCNzWaruagaki_LogoBase, AN_Start) == 0x0002D8, "Member 'URCNzWaruagaki_LogoBase::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_LogoBase, WaruagakiLogoHiddenFinishDelegate) == 0x0002E0, "Member 'URCNzWaruagaki_LogoBase::WaruagakiLogoHiddenFinishDelegate' has a wrong offset!");

// Class RC.RCNzWaruagaki_Question
// 0x0028 (0x0300 - 0x02D8)
class URCNzWaruagaki_Question final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              WaruagakiQuestionShowFinishDelegate;               // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void InitializeQuestionText(const class FString& Heading, const class FString& question);
	void PlayWaruagakiQuestionFinishAnim();
	void PlayWaruagakiQuestionShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNzWaruagaki_Question">();
	}
	static class URCNzWaruagaki_Question* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNzWaruagaki_Question>();
	}
};
static_assert(alignof(URCNzWaruagaki_Question) == 0x000008, "Wrong alignment on URCNzWaruagaki_Question");
static_assert(sizeof(URCNzWaruagaki_Question) == 0x000300, "Wrong size on URCNzWaruagaki_Question");
static_assert(offsetof(URCNzWaruagaki_Question, AN_Start) == 0x0002D8, "Member 'URCNzWaruagaki_Question::AN_Start' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Question, AN_Wait) == 0x0002E0, "Member 'URCNzWaruagaki_Question::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Question, AN_Finish) == 0x0002E8, "Member 'URCNzWaruagaki_Question::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCNzWaruagaki_Question, WaruagakiQuestionShowFinishDelegate) == 0x0002F0, "Member 'URCNzWaruagaki_Question::WaruagakiQuestionShowFinishDelegate' has a wrong offset!");

// Class RC.RCOnlineStoreInterface
// 0x0000 (0x0028 - 0x0028)
class URCOnlineStoreInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOnlineStoreInterface">();
	}
	static class URCOnlineStoreInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOnlineStoreInterface>();
	}
};
static_assert(alignof(URCOnlineStoreInterface) == 0x000008, "Wrong alignment on URCOnlineStoreInterface");
static_assert(sizeof(URCOnlineStoreInterface) == 0x000028, "Wrong size on URCOnlineStoreInterface");

// Class RC.RCOnlineStoreManager
// 0x0018 (0x0040 - 0x0028)
class URCOnlineStoreManager final : public UObject
{
public:
	class URCOnlineStoreInterface*                OnlineStore;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOnlineStoreManager">();
	}
	static class URCOnlineStoreManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOnlineStoreManager>();
	}
};
static_assert(alignof(URCOnlineStoreManager) == 0x000008, "Wrong alignment on URCOnlineStoreManager");
static_assert(sizeof(URCOnlineStoreManager) == 0x000040, "Wrong size on URCOnlineStoreManager");
static_assert(offsetof(URCOnlineStoreManager, OnlineStore) == 0x000028, "Member 'URCOnlineStoreManager::OnlineStore' has a wrong offset!");

// Class RC.RCOnlineStoreSwitch
// 0x0000 (0x0028 - 0x0028)
class URCOnlineStoreSwitch final : public URCOnlineStoreInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOnlineStoreSwitch">();
	}
	static class URCOnlineStoreSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOnlineStoreSwitch>();
	}
};
static_assert(alignof(URCOnlineStoreSwitch) == 0x000008, "Wrong alignment on URCOnlineStoreSwitch");
static_assert(sizeof(URCOnlineStoreSwitch) == 0x000028, "Wrong size on URCOnlineStoreSwitch");

// Class RC.RCOnlineSubsystemHelper
// 0x0000 (0x0028 - 0x0028)
class URCOnlineSubsystemHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOnlineSubsystemHelper">();
	}
	static class URCOnlineSubsystemHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOnlineSubsystemHelper>();
	}
};
static_assert(alignof(URCOnlineSubsystemHelper) == 0x000008, "Wrong alignment on URCOnlineSubsystemHelper");
static_assert(sizeof(URCOnlineSubsystemHelper) == 0x000028, "Wrong size on URCOnlineSubsystemHelper");

// Class RC.RCOptionSetting
// 0x00C8 (0x00F0 - 0x0028)
class URCOptionSetting final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOption                                Option;                                            // 0x0030(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsApplyGraphicsOption;                            // 0x0098(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsApplyScreenSize;                                // 0x0099(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsApplyWindowPosition;                            // 0x009A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9B[0x55];                                      // 0x009B(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOptionSetting">();
	}
	static class URCOptionSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCOptionSetting>();
	}
};
static_assert(alignof(URCOptionSetting) == 0x000008, "Wrong alignment on URCOptionSetting");
static_assert(sizeof(URCOptionSetting) == 0x0000F0, "Wrong size on URCOptionSetting");
static_assert(offsetof(URCOptionSetting, Option) == 0x000030, "Member 'URCOptionSetting::Option' has a wrong offset!");
static_assert(offsetof(URCOptionSetting, bIsApplyGraphicsOption) == 0x000098, "Member 'URCOptionSetting::bIsApplyGraphicsOption' has a wrong offset!");
static_assert(offsetof(URCOptionSetting, bIsApplyScreenSize) == 0x000099, "Member 'URCOptionSetting::bIsApplyScreenSize' has a wrong offset!");
static_assert(offsetof(URCOptionSetting, bIsApplyWindowPosition) == 0x00009A, "Member 'URCOptionSetting::bIsApplyWindowPosition' has a wrong offset!");

// Class RC.RCOptionUIWrap
// 0x0018 (0x0238 - 0x0220)
class ARCOptionUIWrap final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCOptionUIWrap">();
	}
	static class ARCOptionUIWrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCOptionUIWrap>();
	}
};
static_assert(alignof(ARCOptionUIWrap) == 0x000008, "Wrong alignment on ARCOptionUIWrap");
static_assert(sizeof(ARCOptionUIWrap) == 0x000238, "Wrong size on ARCOptionUIWrap");

// Class RC.RCParamAttachmentColorPaletteData
// 0x0050 (0x0080 - 0x0030)
class URCParamAttachmentColorPaletteData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamAttachmentColorPaletteTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamAttachmentColorPaletteData">();
	}
	static class URCParamAttachmentColorPaletteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamAttachmentColorPaletteData>();
	}
};
static_assert(alignof(URCParamAttachmentColorPaletteData) == 0x000008, "Wrong alignment on URCParamAttachmentColorPaletteData");
static_assert(sizeof(URCParamAttachmentColorPaletteData) == 0x000080, "Wrong size on URCParamAttachmentColorPaletteData");
static_assert(offsetof(URCParamAttachmentColorPaletteData, Data) == 0x000030, "Member 'URCParamAttachmentColorPaletteData::Data' has a wrong offset!");

// Class RC.RCUiMenuContentsButton
// 0x0068 (0x0388 - 0x0320)
class URCUiMenuContentsButton final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect;                                      // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off_OnCursor;                                   // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off_OutCursor;                                  // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect_OnCursor;                             // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect_OutCursor;                            // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuContentsButton">();
	}
	static class URCUiMenuContentsButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuContentsButton>();
	}
};
static_assert(alignof(URCUiMenuContentsButton) == 0x000008, "Wrong alignment on URCUiMenuContentsButton");
static_assert(sizeof(URCUiMenuContentsButton) == 0x000388, "Wrong size on URCUiMenuContentsButton");
static_assert(offsetof(URCUiMenuContentsButton, AN_Def) == 0x000320, "Member 'URCUiMenuContentsButton::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_OnCursor) == 0x000328, "Member 'URCUiMenuContentsButton::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_OutCursor) == 0x000330, "Member 'URCUiMenuContentsButton::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_Push) == 0x000338, "Member 'URCUiMenuContentsButton::AN_Push' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_NotSelect) == 0x000340, "Member 'URCUiMenuContentsButton::AN_NotSelect' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_Off) == 0x000348, "Member 'URCUiMenuContentsButton::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_Off_OnCursor) == 0x000350, "Member 'URCUiMenuContentsButton::AN_Off_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_Off_OutCursor) == 0x000358, "Member 'URCUiMenuContentsButton::AN_Off_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_NotSelect_OnCursor) == 0x000360, "Member 'URCUiMenuContentsButton::AN_NotSelect_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuContentsButton, AN_NotSelect_OutCursor) == 0x000368, "Member 'URCUiMenuContentsButton::AN_NotSelect_OutCursor' has a wrong offset!");

// Class RC.RCParamBgFileListData
// 0x0010 (0x0040 - 0x0030)
class URCParamBgFileListData final : public URCCSVData
{
public:
	TArray<struct FRCParamBgFileListTableRow>     Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamBgFileListData">();
	}
	static class URCParamBgFileListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamBgFileListData>();
	}
};
static_assert(alignof(URCParamBgFileListData) == 0x000008, "Wrong alignment on URCParamBgFileListData");
static_assert(sizeof(URCParamBgFileListData) == 0x000040, "Wrong size on URCParamBgFileListData");
static_assert(offsetof(URCParamBgFileListData, Data) == 0x000030, "Member 'URCParamBgFileListData::Data' has a wrong offset!");

// Class RC.RCParamBgListL00Data
// 0x0010 (0x0040 - 0x0030)
class URCParamBgListL00Data final : public URCCSVData
{
public:
	TArray<struct FRCParamBgListL00TableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamBgListL00Data">();
	}
	static class URCParamBgListL00Data* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamBgListL00Data>();
	}
};
static_assert(alignof(URCParamBgListL00Data) == 0x000008, "Wrong alignment on URCParamBgListL00Data");
static_assert(sizeof(URCParamBgListL00Data) == 0x000040, "Wrong size on URCParamBgListL00Data");
static_assert(offsetof(URCParamBgListL00Data, Data) == 0x000030, "Member 'URCParamBgListL00Data::Data' has a wrong offset!");

// Class RC.RCUiMenuGlossary
// 0x0038 (0x0310 - 0x02D8)
class URCUiMenuGlossary final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_In;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_Out;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossary">();
	}
	static class URCUiMenuGlossary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossary>();
	}
};
static_assert(alignof(URCUiMenuGlossary) == 0x000008, "Wrong alignment on URCUiMenuGlossary");
static_assert(sizeof(URCUiMenuGlossary) == 0x000310, "Wrong size on URCUiMenuGlossary");
static_assert(offsetof(URCUiMenuGlossary, AN_On) == 0x0002D8, "Member 'URCUiMenuGlossary::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossary, AN_Off) == 0x0002E0, "Member 'URCUiMenuGlossary::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossary, AN_Flame_In) == 0x0002E8, "Member 'URCUiMenuGlossary::AN_Flame_In' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossary, AN_Flame_Out) == 0x0002F0, "Member 'URCUiMenuGlossary::AN_Flame_Out' has a wrong offset!");

// Class RC.RCParamBombReleaseData
// 0x0010 (0x0040 - 0x0030)
class URCParamBombReleaseData final : public URCCSVData
{
public:
	TArray<struct FRCParamBombReleaseTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamBombReleaseData">();
	}
	static class URCParamBombReleaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamBombReleaseData>();
	}
};
static_assert(alignof(URCParamBombReleaseData) == 0x000008, "Wrong alignment on URCParamBombReleaseData");
static_assert(sizeof(URCParamBombReleaseData) == 0x000040, "Wrong size on URCParamBombReleaseData");
static_assert(offsetof(URCParamBombReleaseData, Data) == 0x000030, "Member 'URCParamBombReleaseData::Data' has a wrong offset!");

// Class RC.RCParamChapterListData
// 0x0010 (0x0040 - 0x0030)
class URCParamChapterListData final : public URCCSVData
{
public:
	TArray<struct FRCParamChapterListTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamChapterListData">();
	}
	static class URCParamChapterListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamChapterListData>();
	}
};
static_assert(alignof(URCParamChapterListData) == 0x000008, "Wrong alignment on URCParamChapterListData");
static_assert(sizeof(URCParamChapterListData) == 0x000040, "Wrong size on URCParamChapterListData");
static_assert(offsetof(URCParamChapterListData, Data) == 0x000030, "Member 'URCParamChapterListData::Data' has a wrong offset!");

// Class RC.RCUiMenuGlossaryListBar
// 0x0050 (0x0370 - 0x0320)
class URCUiMenuGlossaryListBar final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x28];                                     // 0x0348(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossaryListBar">();
	}
	static class URCUiMenuGlossaryListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossaryListBar>();
	}
};
static_assert(alignof(URCUiMenuGlossaryListBar) == 0x000008, "Wrong alignment on URCUiMenuGlossaryListBar");
static_assert(sizeof(URCUiMenuGlossaryListBar) == 0x000370, "Wrong size on URCUiMenuGlossaryListBar");
static_assert(offsetof(URCUiMenuGlossaryListBar, AN_Default) == 0x000320, "Member 'URCUiMenuGlossaryListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryListBar, AN_OnCursor) == 0x000328, "Member 'URCUiMenuGlossaryListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryListBar, AN_OnCursor_Wait) == 0x000330, "Member 'URCUiMenuGlossaryListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryListBar, AN_OutCursor) == 0x000338, "Member 'URCUiMenuGlossaryListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryListBar, Text_ListName) == 0x000340, "Member 'URCUiMenuGlossaryListBar::Text_ListName' has a wrong offset!");

// Class RC.RCParamChapterSelectDataData
// 0x0010 (0x0040 - 0x0030)
class URCParamChapterSelectDataData final : public URCCSVData
{
public:
	TArray<struct FRCParamChapterSelectDataTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamChapterSelectDataData">();
	}
	static class URCParamChapterSelectDataData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamChapterSelectDataData>();
	}
};
static_assert(alignof(URCParamChapterSelectDataData) == 0x000008, "Wrong alignment on URCParamChapterSelectDataData");
static_assert(sizeof(URCParamChapterSelectDataData) == 0x000040, "Wrong size on URCParamChapterSelectDataData");
static_assert(offsetof(URCParamChapterSelectDataData, Data) == 0x000030, "Member 'URCParamChapterSelectDataData::Data' has a wrong offset!");

// Class RC.RCParamCharacterBallonPositionData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterBallonPositionData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterBallonPositionTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterBallonPositionData">();
	}
	static class URCParamCharacterBallonPositionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterBallonPositionData>();
	}
};
static_assert(alignof(URCParamCharacterBallonPositionData) == 0x000008, "Wrong alignment on URCParamCharacterBallonPositionData");
static_assert(sizeof(URCParamCharacterBallonPositionData) == 0x000040, "Wrong size on URCParamCharacterBallonPositionData");
static_assert(offsetof(URCParamCharacterBallonPositionData, Data) == 0x000030, "Member 'URCParamCharacterBallonPositionData::Data' has a wrong offset!");

// Class RC.RCUiMenuKagi
// 0x0068 (0x0340 - 0x02D8)
class URCUiMenuKagi final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_ScaleUp;                                        // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_ScaleDown;                                      // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_Question;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x38];                                     // 0x0308(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeKagiScale();
	void Close();
	void InitializeMenuKagi(bool bInKagiSelect);
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuKagi">();
	}
	static class URCUiMenuKagi* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuKagi>();
	}
};
static_assert(alignof(URCUiMenuKagi) == 0x000008, "Wrong alignment on URCUiMenuKagi");
static_assert(sizeof(URCUiMenuKagi) == 0x000340, "Wrong size on URCUiMenuKagi");
static_assert(offsetof(URCUiMenuKagi, AN_Start) == 0x0002D8, "Member 'URCUiMenuKagi::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagi, AN_Wait) == 0x0002E0, "Member 'URCUiMenuKagi::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagi, AN_Finish) == 0x0002E8, "Member 'URCUiMenuKagi::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagi, AN_ScaleUp) == 0x0002F0, "Member 'URCUiMenuKagi::AN_ScaleUp' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagi, AN_ScaleDown) == 0x0002F8, "Member 'URCUiMenuKagi::AN_ScaleDown' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagi, Txt_Question) == 0x000300, "Member 'URCUiMenuKagi::Txt_Question' has a wrong offset!");

// Class RC.RCParamCharacterColorPaletteData
// 0x0050 (0x0080 - 0x0030)
class URCParamCharacterColorPaletteData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamCharacterColorPaletteTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterColorPaletteData">();
	}
	static class URCParamCharacterColorPaletteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterColorPaletteData>();
	}
};
static_assert(alignof(URCParamCharacterColorPaletteData) == 0x000008, "Wrong alignment on URCParamCharacterColorPaletteData");
static_assert(sizeof(URCParamCharacterColorPaletteData) == 0x000080, "Wrong size on URCParamCharacterColorPaletteData");
static_assert(offsetof(URCParamCharacterColorPaletteData, Data) == 0x000030, "Member 'URCParamCharacterColorPaletteData::Data' has a wrong offset!");

// Class RC.RCParamCharacterFacial2D3DListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterFacial2D3DListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterFacial2D3DListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterFacial2D3DListData">();
	}
	static class URCParamCharacterFacial2D3DListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterFacial2D3DListData>();
	}
};
static_assert(alignof(URCParamCharacterFacial2D3DListData) == 0x000008, "Wrong alignment on URCParamCharacterFacial2D3DListData");
static_assert(sizeof(URCParamCharacterFacial2D3DListData) == 0x000040, "Wrong size on URCParamCharacterFacial2D3DListData");
static_assert(offsetof(URCParamCharacterFacial2D3DListData, Data) == 0x000030, "Member 'URCParamCharacterFacial2D3DListData::Data' has a wrong offset!");

// Class RC.RCUiIntArea
// 0x0008 (0x0300 - 0x02F8)
class URCUiIntArea final : public URCUiInteractIcon
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiIntArea">();
	}
	static class URCUiIntArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiIntArea>();
	}
};
static_assert(alignof(URCUiIntArea) == 0x000008, "Wrong alignment on URCUiIntArea");
static_assert(sizeof(URCUiIntArea) == 0x000300, "Wrong size on URCUiIntArea");

// Class RC.RCParamCharacterInfoListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterInfoListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterInfoListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterInfoListData">();
	}
	static class URCParamCharacterInfoListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterInfoListData>();
	}
};
static_assert(alignof(URCParamCharacterInfoListData) == 0x000008, "Wrong alignment on URCParamCharacterInfoListData");
static_assert(sizeof(URCParamCharacterInfoListData) == 0x000040, "Wrong size on URCParamCharacterInfoListData");
static_assert(offsetof(URCParamCharacterInfoListData, Data) == 0x000030, "Member 'URCParamCharacterInfoListData::Data' has a wrong offset!");

// Class RC.RCParamCharacterMaterialListData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterMaterialListData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterMaterialListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterMaterialListData">();
	}
	static class URCParamCharacterMaterialListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterMaterialListData>();
	}
};
static_assert(alignof(URCParamCharacterMaterialListData) == 0x000008, "Wrong alignment on URCParamCharacterMaterialListData");
static_assert(sizeof(URCParamCharacterMaterialListData) == 0x000040, "Wrong size on URCParamCharacterMaterialListData");
static_assert(offsetof(URCParamCharacterMaterialListData, Data) == 0x000030, "Member 'URCParamCharacterMaterialListData::Data' has a wrong offset!");

// Class RC.RCUiInteractIconParts
// 0x0038 (0x0310 - 0x02D8)
class URCUiInteractIconParts : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x38];                                     // 0x02D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractIconParts">();
	}
	static class URCUiInteractIconParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractIconParts>();
	}
};
static_assert(alignof(URCUiInteractIconParts) == 0x000008, "Wrong alignment on URCUiInteractIconParts");
static_assert(sizeof(URCUiInteractIconParts) == 0x000310, "Wrong size on URCUiInteractIconParts");

// Class RC.RCParamCharacterMotionTemplateData
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterMotionTemplateData final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterMotionTemplateTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterMotionTemplateData">();
	}
	static class URCParamCharacterMotionTemplateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterMotionTemplateData>();
	}
};
static_assert(alignof(URCParamCharacterMotionTemplateData) == 0x000008, "Wrong alignment on URCParamCharacterMotionTemplateData");
static_assert(sizeof(URCParamCharacterMotionTemplateData) == 0x000040, "Wrong size on URCParamCharacterMotionTemplateData");
static_assert(offsetof(URCParamCharacterMotionTemplateData, Data) == 0x000030, "Member 'URCParamCharacterMotionTemplateData::Data' has a wrong offset!");

// Class RC.RCParamCharacterSettingDataAsset
// 0x0010 (0x0040 - 0x0030)
class URCParamCharacterSettingDataAsset final : public URCCSVData
{
public:
	TArray<struct FRCParamCharacterSettingDataAssetRecord> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCharacterSettingDataAsset">();
	}
	static class URCParamCharacterSettingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCharacterSettingDataAsset>();
	}
};
static_assert(alignof(URCParamCharacterSettingDataAsset) == 0x000008, "Wrong alignment on URCParamCharacterSettingDataAsset");
static_assert(sizeof(URCParamCharacterSettingDataAsset) == 0x000040, "Wrong size on URCParamCharacterSettingDataAsset");
static_assert(offsetof(URCParamCharacterSettingDataAsset, Data) == 0x000030, "Member 'URCParamCharacterSettingDataAsset::Data' has a wrong offset!");

// Class RC.RCUiInteractOn
// 0x0030 (0x0308 - 0x02D8)
class URCUiInteractOn final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractOn">();
	}
	static class URCUiInteractOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractOn>();
	}
};
static_assert(alignof(URCUiInteractOn) == 0x000008, "Wrong alignment on URCUiInteractOn");
static_assert(sizeof(URCUiInteractOn) == 0x000308, "Wrong size on URCUiInteractOn");

// Class RC.RCParamCollectionDialogData
// 0x0010 (0x0040 - 0x0030)
class URCParamCollectionDialogData final : public URCCSVData
{
public:
	TArray<struct FRCParamCollectionDialogTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamCollectionDialogData">();
	}
	static class URCParamCollectionDialogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamCollectionDialogData>();
	}
};
static_assert(alignof(URCParamCollectionDialogData) == 0x000008, "Wrong alignment on URCParamCollectionDialogData");
static_assert(sizeof(URCParamCollectionDialogData) == 0x000040, "Wrong size on URCParamCollectionDialogData");
static_assert(offsetof(URCParamCollectionDialogData, Data) == 0x000030, "Member 'URCParamCollectionDialogData::Data' has a wrong offset!");

// Class RC.RCParamDLCSoundSheetListData
// 0x0010 (0x0040 - 0x0030)
class URCParamDLCSoundSheetListData final : public URCCSVData
{
public:
	TArray<struct FRCParamDLCSoundSheetListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamDLCSoundSheetListData">();
	}
	static class URCParamDLCSoundSheetListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamDLCSoundSheetListData>();
	}
};
static_assert(alignof(URCParamDLCSoundSheetListData) == 0x000008, "Wrong alignment on URCParamDLCSoundSheetListData");
static_assert(sizeof(URCParamDLCSoundSheetListData) == 0x000040, "Wrong size on URCParamDLCSoundSheetListData");
static_assert(offsetof(URCParamDLCSoundSheetListData, Data) == 0x000030, "Member 'URCParamDLCSoundSheetListData::Data' has a wrong offset!");

// Class RC.RCUiInteractTalkOn
// 0x0000 (0x0310 - 0x0310)
class URCUiInteractTalkOn final : public URCUiInteractIconParts
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTalkOn">();
	}
	static class URCUiInteractTalkOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTalkOn>();
	}
};
static_assert(alignof(URCUiInteractTalkOn) == 0x000008, "Wrong alignment on URCUiInteractTalkOn");
static_assert(sizeof(URCUiInteractTalkOn) == 0x000310, "Wrong size on URCUiInteractTalkOn");

// Class RC.RCParamEventCharacterFacialColorData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventCharacterFacialColorData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventCharacterFacialColorTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventCharacterFacialColorData">();
	}
	static class URCParamEventCharacterFacialColorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventCharacterFacialColorData>();
	}
};
static_assert(alignof(URCParamEventCharacterFacialColorData) == 0x000008, "Wrong alignment on URCParamEventCharacterFacialColorData");
static_assert(sizeof(URCParamEventCharacterFacialColorData) == 0x000040, "Wrong size on URCParamEventCharacterFacialColorData");
static_assert(offsetof(URCParamEventCharacterFacialColorData, Data) == 0x000030, "Member 'URCParamEventCharacterFacialColorData::Data' has a wrong offset!");

// Class RC.RCParamEventCheckSubQuestSubLevelData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventCheckSubQuestSubLevelData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventCheckSubQuestSubLevelTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventCheckSubQuestSubLevelData">();
	}
	static class URCParamEventCheckSubQuestSubLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventCheckSubQuestSubLevelData>();
	}
};
static_assert(alignof(URCParamEventCheckSubQuestSubLevelData) == 0x000008, "Wrong alignment on URCParamEventCheckSubQuestSubLevelData");
static_assert(sizeof(URCParamEventCheckSubQuestSubLevelData) == 0x000040, "Wrong size on URCParamEventCheckSubQuestSubLevelData");
static_assert(offsetof(URCParamEventCheckSubQuestSubLevelData, Data) == 0x000030, "Member 'URCParamEventCheckSubQuestSubLevelData::Data' has a wrong offset!");

// Class RC.RCTitleLanguage
// 0x0038 (0x0310 - 0x02D8)
class URCTitleLanguage : public URCUiWidgetBase
{
public:
	class URCTitleLanguageWindow*                 langWindow;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleHelp*                           titleHelp;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCUiButtonGuide*                       Title_BTNGuide;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETitleLanguageState                           State;                                             // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCheckFinish;                                     // 0x0309(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isRestart;                                         // 0x030A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleLanguage">();
	}
	static class URCTitleLanguage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleLanguage>();
	}
};
static_assert(alignof(URCTitleLanguage) == 0x000008, "Wrong alignment on URCTitleLanguage");
static_assert(sizeof(URCTitleLanguage) == 0x000310, "Wrong size on URCTitleLanguage");
static_assert(offsetof(URCTitleLanguage, langWindow) == 0x0002D8, "Member 'URCTitleLanguage::langWindow' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, titleHelp) == 0x0002E0, "Member 'URCTitleLanguage::titleHelp' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, Title_BTNGuide) == 0x0002E8, "Member 'URCTitleLanguage::Title_BTNGuide' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, AN_Start) == 0x0002F0, "Member 'URCTitleLanguage::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, AN_Wait) == 0x0002F8, "Member 'URCTitleLanguage::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, AN_Finish) == 0x000300, "Member 'URCTitleLanguage::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, State) == 0x000308, "Member 'URCTitleLanguage::State' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, IsCheckFinish) == 0x000309, "Member 'URCTitleLanguage::IsCheckFinish' has a wrong offset!");
static_assert(offsetof(URCTitleLanguage, isRestart) == 0x00030A, "Member 'URCTitleLanguage::isRestart' has a wrong offset!");

// Class RC.RCParamEventMapBusStopInfoData
// 0x0010 (0x0040 - 0x0030)
class URCParamEventMapBusStopInfoData final : public URCCSVData
{
public:
	TArray<struct FRCParamEventMapBusStopInfoTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamEventMapBusStopInfoData">();
	}
	static class URCParamEventMapBusStopInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamEventMapBusStopInfoData>();
	}
};
static_assert(alignof(URCParamEventMapBusStopInfoData) == 0x000008, "Wrong alignment on URCParamEventMapBusStopInfoData");
static_assert(sizeof(URCParamEventMapBusStopInfoData) == 0x000040, "Wrong size on URCParamEventMapBusStopInfoData");
static_assert(offsetof(URCParamEventMapBusStopInfoData, Data) == 0x000030, "Member 'URCParamEventMapBusStopInfoData::Data' has a wrong offset!");

// Class RC.RCParamFaceGradationListData
// 0x0010 (0x0040 - 0x0030)
class URCParamFaceGradationListData final : public URCCSVData
{
public:
	TArray<struct FRCParamFaceGradationListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFaceGradationListData">();
	}
	static class URCParamFaceGradationListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFaceGradationListData>();
	}
};
static_assert(alignof(URCParamFaceGradationListData) == 0x000008, "Wrong alignment on URCParamFaceGradationListData");
static_assert(sizeof(URCParamFaceGradationListData) == 0x000040, "Wrong size on URCParamFaceGradationListData");
static_assert(offsetof(URCParamFaceGradationListData, Data) == 0x000030, "Member 'URCParamFaceGradationListData::Data' has a wrong offset!");

// Class RC.RCTitleMenuList
// 0x0040 (0x0338 - 0x02F8)
class URCTitleMenuList : public URCMenuManager
{
public:
	TArray<class URCTitleMenuListItem*>           listItemArray;                                     // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URCTitleMenuListItem*>           enableListItemArray;                               // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bListLoop;                                         // 0x031C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           helpTextArray;                                     // 0x0320(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSelectButton;                                     // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isPushDecide;                                      // 0x0331(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* TitleListSelectNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleMenuList">();
	}
	static class URCTitleMenuList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleMenuList>();
	}
};
static_assert(alignof(URCTitleMenuList) == 0x000008, "Wrong alignment on URCTitleMenuList");
static_assert(sizeof(URCTitleMenuList) == 0x000338, "Wrong size on URCTitleMenuList");
static_assert(offsetof(URCTitleMenuList, listItemArray) == 0x0002F8, "Member 'URCTitleMenuList::listItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, enableListItemArray) == 0x000308, "Member 'URCTitleMenuList::enableListItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, SelectIndex) == 0x000318, "Member 'URCTitleMenuList::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, bListLoop) == 0x00031C, "Member 'URCTitleMenuList::bListLoop' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, helpTextArray) == 0x000320, "Member 'URCTitleMenuList::helpTextArray' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, bSelectButton) == 0x000330, "Member 'URCTitleMenuList::bSelectButton' has a wrong offset!");
static_assert(offsetof(URCTitleMenuList, isPushDecide) == 0x000331, "Member 'URCTitleMenuList::isPushDecide' has a wrong offset!");

// Class RC.RCParamFigureInformationData
// 0x0010 (0x0040 - 0x0030)
class URCParamFigureInformationData final : public URCCSVData
{
public:
	TArray<struct FRCParamFigureInformationTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFigureInformationData">();
	}
	static class URCParamFigureInformationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFigureInformationData>();
	}
};
static_assert(alignof(URCParamFigureInformationData) == 0x000008, "Wrong alignment on URCParamFigureInformationData");
static_assert(sizeof(URCParamFigureInformationData) == 0x000040, "Wrong size on URCParamFigureInformationData");
static_assert(offsetof(URCParamFigureInformationData, Data) == 0x000030, "Member 'URCParamFigureInformationData::Data' has a wrong offset!");

// Class RC.RCParamFloorTypeData
// 0x0010 (0x0040 - 0x0030)
class URCParamFloorTypeData final : public URCCSVData
{
public:
	TArray<struct FRCParamFloorTypeTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamFloorTypeData">();
	}
	static class URCParamFloorTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamFloorTypeData>();
	}
};
static_assert(alignof(URCParamFloorTypeData) == 0x000008, "Wrong alignment on URCParamFloorTypeData");
static_assert(sizeof(URCParamFloorTypeData) == 0x000040, "Wrong size on URCParamFloorTypeData");
static_assert(offsetof(URCParamFloorTypeData, Data) == 0x000030, "Member 'URCParamFloorTypeData::Data' has a wrong offset!");

// Class RC.RCParamGalleryBgmListData
// 0x0010 (0x0040 - 0x0030)
class URCParamGalleryBgmListData final : public URCCSVData
{
public:
	TArray<struct FRCParamGalleryBgmListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamGalleryBgmListData">();
	}
	static class URCParamGalleryBgmListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamGalleryBgmListData>();
	}
};
static_assert(alignof(URCParamGalleryBgmListData) == 0x000008, "Wrong alignment on URCParamGalleryBgmListData");
static_assert(sizeof(URCParamGalleryBgmListData) == 0x000040, "Wrong size on URCParamGalleryBgmListData");
static_assert(offsetof(URCParamGalleryBgmListData, Data) == 0x000030, "Member 'URCParamGalleryBgmListData::Data' has a wrong offset!");

// Class RC.RCUiMenuCharacterFace
// 0x00F0 (0x0410 - 0x0320)
class URCUiMenuCharacterFace final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Alive_Def;                                      // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Alive_OnCursor;                                 // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Alive_OnCursor_Wait;                            // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Alive_OutCursor;                                // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Alive_Push;                                     // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Alive_Off;                                      // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_Start;                                     // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_Def;                                       // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_OnCursor;                                  // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_OnCursor_Wait;                             // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_OutCursor;                                 // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_Push;                                      // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Dead_Off;                                       // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_CharaName_00;                                 // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x18];                                     // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_CharaName_01;                                 // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	ERCUiMenuCharacterAliveType                   CurrentAliveType;                                  // 0x03D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCUiMenuCharacterTransType                   CurrentTransType;                                  // 0x03D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 CharacterFace;                                     // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterFaceTexPath;                              // 0x03E0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x20];                                     // 0x03F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void mPush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterFace">();
	}
	static class URCUiMenuCharacterFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterFace>();
	}
};
static_assert(alignof(URCUiMenuCharacterFace) == 0x000008, "Wrong alignment on URCUiMenuCharacterFace");
static_assert(sizeof(URCUiMenuCharacterFace) == 0x000410, "Wrong size on URCUiMenuCharacterFace");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_Def) == 0x000320, "Member 'URCUiMenuCharacterFace::AN_Alive_Def' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_OnCursor) == 0x000328, "Member 'URCUiMenuCharacterFace::AN_Alive_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_OnCursor_Wait) == 0x000330, "Member 'URCUiMenuCharacterFace::AN_Alive_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_OutCursor) == 0x000338, "Member 'URCUiMenuCharacterFace::AN_Alive_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_Push) == 0x000340, "Member 'URCUiMenuCharacterFace::AN_Alive_Push' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Alive_Off) == 0x000348, "Member 'URCUiMenuCharacterFace::AN_Alive_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_Start) == 0x000350, "Member 'URCUiMenuCharacterFace::AN_Dead_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_Def) == 0x000358, "Member 'URCUiMenuCharacterFace::AN_Dead_Def' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_OnCursor) == 0x000360, "Member 'URCUiMenuCharacterFace::AN_Dead_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_OnCursor_Wait) == 0x000368, "Member 'URCUiMenuCharacterFace::AN_Dead_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_OutCursor) == 0x000370, "Member 'URCUiMenuCharacterFace::AN_Dead_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_Push) == 0x000378, "Member 'URCUiMenuCharacterFace::AN_Dead_Push' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, AN_Dead_Off) == 0x000380, "Member 'URCUiMenuCharacterFace::AN_Dead_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, Text_CharaName_00) == 0x000388, "Member 'URCUiMenuCharacterFace::Text_CharaName_00' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, Text_CharaName_01) == 0x0003A8, "Member 'URCUiMenuCharacterFace::Text_CharaName_01' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, CurrentAliveType) == 0x0003D0, "Member 'URCUiMenuCharacterFace::CurrentAliveType' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, CurrentTransType) == 0x0003D1, "Member 'URCUiMenuCharacterFace::CurrentTransType' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, CharacterFace) == 0x0003D8, "Member 'URCUiMenuCharacterFace::CharacterFace' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterFace, CharacterFaceTexPath) == 0x0003E0, "Member 'URCUiMenuCharacterFace::CharacterFaceTexPath' has a wrong offset!");

// Class RC.RCParamGlossaryCategoryListData
// 0x0010 (0x0040 - 0x0030)
class URCParamGlossaryCategoryListData final : public URCCSVData
{
public:
	TArray<struct FRCParamGlossaryCategoryListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamGlossaryCategoryListData">();
	}
	static class URCParamGlossaryCategoryListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamGlossaryCategoryListData>();
	}
};
static_assert(alignof(URCParamGlossaryCategoryListData) == 0x000008, "Wrong alignment on URCParamGlossaryCategoryListData");
static_assert(sizeof(URCParamGlossaryCategoryListData) == 0x000040, "Wrong size on URCParamGlossaryCategoryListData");
static_assert(offsetof(URCParamGlossaryCategoryListData, Data) == 0x000030, "Member 'URCParamGlossaryCategoryListData::Data' has a wrong offset!");

// Class RC.RCParamInputIDData
// 0x0010 (0x0040 - 0x0030)
class URCParamInputIDData final : public URCCSVData
{
public:
	TArray<struct FRCParamInputIDTableRow>        Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamInputIDData">();
	}
	static class URCParamInputIDData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamInputIDData>();
	}
};
static_assert(alignof(URCParamInputIDData) == 0x000008, "Wrong alignment on URCParamInputIDData");
static_assert(sizeof(URCParamInputIDData) == 0x000040, "Wrong size on URCParamInputIDData");
static_assert(offsetof(URCParamInputIDData, Data) == 0x000030, "Member 'URCParamInputIDData::Data' has a wrong offset!");

// Class RC.RCParamLevelListData
// 0x0010 (0x0040 - 0x0030)
class URCParamLevelListData final : public URCCSVData
{
public:
	TArray<struct FRCParamLevelListTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamLevelListData">();
	}
	static class URCParamLevelListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamLevelListData>();
	}
};
static_assert(alignof(URCParamLevelListData) == 0x000008, "Wrong alignment on URCParamLevelListData");
static_assert(sizeof(URCParamLevelListData) == 0x000040, "Wrong size on URCParamLevelListData");
static_assert(offsetof(URCParamLevelListData, Data) == 0x000030, "Member 'URCParamLevelListData::Data' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewerName
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuCharacterViewerName final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_CharaName;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerName">();
	}
	static class URCUiMenuCharacterViewerName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerName>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerName) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerName");
static_assert(sizeof(URCUiMenuCharacterViewerName) == 0x0002F8, "Wrong size on URCUiMenuCharacterViewerName");
static_assert(offsetof(URCUiMenuCharacterViewerName, Text_CharaName) == 0x0002D8, "Member 'URCUiMenuCharacterViewerName::Text_CharaName' has a wrong offset!");

// Class RC.RCParamLipSyncCharaIDListData
// 0x0050 (0x0080 - 0x0030)
class URCParamLipSyncCharaIDListData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamLipSyncCharaIDListTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamLipSyncCharaIDListData">();
	}
	static class URCParamLipSyncCharaIDListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamLipSyncCharaIDListData>();
	}
};
static_assert(alignof(URCParamLipSyncCharaIDListData) == 0x000008, "Wrong alignment on URCParamLipSyncCharaIDListData");
static_assert(sizeof(URCParamLipSyncCharaIDListData) == 0x000080, "Wrong size on URCParamLipSyncCharaIDListData");
static_assert(offsetof(URCParamLipSyncCharaIDListData, Data) == 0x000030, "Member 'URCParamLipSyncCharaIDListData::Data' has a wrong offset!");

// Class RC.RCParamLipSyncForTextIDData
// 0x0050 (0x0080 - 0x0030)
class URCParamLipSyncForTextIDData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamLipSyncForTextIDTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamLipSyncForTextIDData">();
	}
	static class URCParamLipSyncForTextIDData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamLipSyncForTextIDData>();
	}
};
static_assert(alignof(URCParamLipSyncForTextIDData) == 0x000008, "Wrong alignment on URCParamLipSyncForTextIDData");
static_assert(sizeof(URCParamLipSyncForTextIDData) == 0x000080, "Wrong size on URCParamLipSyncForTextIDData");
static_assert(offsetof(URCParamLipSyncForTextIDData, Data) == 0x000030, "Member 'URCParamLipSyncForTextIDData::Data' has a wrong offset!");

// Class RC.RCParamMenuWorldMapListData
// 0x0010 (0x0040 - 0x0030)
class URCParamMenuWorldMapListData final : public URCCSVData
{
public:
	TArray<struct FRCParamMenuWorldMapListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMenuWorldMapListData">();
	}
	static class URCParamMenuWorldMapListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMenuWorldMapListData>();
	}
};
static_assert(alignof(URCParamMenuWorldMapListData) == 0x000008, "Wrong alignment on URCParamMenuWorldMapListData");
static_assert(sizeof(URCParamMenuWorldMapListData) == 0x000040, "Wrong size on URCParamMenuWorldMapListData");
static_assert(offsetof(URCParamMenuWorldMapListData, Data) == 0x000030, "Member 'URCParamMenuWorldMapListData::Data' has a wrong offset!");

// Class RC.RCUiOptionBar
// 0x0068 (0x0340 - 0x02D8)
class URCUiOptionBar : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Cursor;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x50];                                     // 0x02F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBar">();
	}
	static class URCUiOptionBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBar>();
	}
};
static_assert(alignof(URCUiOptionBar) == 0x000008, "Wrong alignment on URCUiOptionBar");
static_assert(sizeof(URCUiOptionBar) == 0x000340, "Wrong size on URCUiOptionBar");
static_assert(offsetof(URCUiOptionBar, AN_Def) == 0x0002D8, "Member 'URCUiOptionBar::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiOptionBar, AN_On_Cursor) == 0x0002E0, "Member 'URCUiOptionBar::AN_On_Cursor' has a wrong offset!");
static_assert(offsetof(URCUiOptionBar, AN_Off) == 0x0002E8, "Member 'URCUiOptionBar::AN_Off' has a wrong offset!");

// Class RC.RCParamMobListData
// 0x0010 (0x0040 - 0x0030)
class URCParamMobListData final : public URCCSVData
{
public:
	TArray<struct FRCParamMobListTableRow>        Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamMobListData">();
	}
	static class URCParamMobListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamMobListData>();
	}
};
static_assert(alignof(URCParamMobListData) == 0x000008, "Wrong alignment on URCParamMobListData");
static_assert(sizeof(URCParamMobListData) == 0x000040, "Wrong size on URCParamMobListData");
static_assert(offsetof(URCParamMobListData, Data) == 0x000030, "Member 'URCParamMobListData::Data' has a wrong offset!");

// Class RC.RCParamNzCriminalData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzCriminalData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzCriminalTableRow>     Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzCriminalData">();
	}
	static class URCParamNzCriminalData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzCriminalData>();
	}
};
static_assert(alignof(URCParamNzCriminalData) == 0x000008, "Wrong alignment on URCParamNzCriminalData");
static_assert(sizeof(URCParamNzCriminalData) == 0x000040, "Wrong size on URCParamNzCriminalData");
static_assert(offsetof(URCParamNzCriminalData, Data) == 0x000030, "Member 'URCParamNzCriminalData::Data' has a wrong offset!");

// Class RC.RCUiOptionBarArrow
// 0x0038 (0x0310 - 0x02D8)
class URCUiOptionBarArrow final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarArrow">();
	}
	static class URCUiOptionBarArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarArrow>();
	}
};
static_assert(alignof(URCUiOptionBarArrow) == 0x000008, "Wrong alignment on URCUiOptionBarArrow");
static_assert(sizeof(URCUiOptionBarArrow) == 0x000310, "Wrong size on URCUiOptionBarArrow");
static_assert(offsetof(URCUiOptionBarArrow, AN_Def) == 0x0002D8, "Member 'URCUiOptionBarArrow::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarArrow, AN_Push) == 0x0002E0, "Member 'URCUiOptionBarArrow::AN_Push' has a wrong offset!");

// Class RC.RCParamNzCriminalSceneData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzCriminalSceneData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzCriminalSceneTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzCriminalSceneData">();
	}
	static class URCParamNzCriminalSceneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzCriminalSceneData>();
	}
};
static_assert(alignof(URCParamNzCriminalSceneData) == 0x000008, "Wrong alignment on URCParamNzCriminalSceneData");
static_assert(sizeof(URCParamNzCriminalSceneData) == 0x000040, "Wrong size on URCParamNzCriminalSceneData");
static_assert(offsetof(URCParamNzCriminalSceneData, Data) == 0x000030, "Member 'URCParamNzCriminalSceneData::Data' has a wrong offset!");

// Class RC.RCParamNzFinaleDetectiveBackgroundImageData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzFinaleDetectiveBackgroundImageData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzFinaleDetectiveBackgroundImageTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzFinaleDetectiveBackgroundImageData">();
	}
	static class URCParamNzFinaleDetectiveBackgroundImageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzFinaleDetectiveBackgroundImageData>();
	}
};
static_assert(alignof(URCParamNzFinaleDetectiveBackgroundImageData) == 0x000008, "Wrong alignment on URCParamNzFinaleDetectiveBackgroundImageData");
static_assert(sizeof(URCParamNzFinaleDetectiveBackgroundImageData) == 0x000040, "Wrong size on URCParamNzFinaleDetectiveBackgroundImageData");
static_assert(offsetof(URCParamNzFinaleDetectiveBackgroundImageData, Data) == 0x000030, "Member 'URCParamNzFinaleDetectiveBackgroundImageData::Data' has a wrong offset!");

// Class RC.RCUiOptionBarText
// 0x0020 (0x02F8 - 0x02D8)
class URCUiOptionBarText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Not;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarText">();
	}
	static class URCUiOptionBarText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarText>();
	}
};
static_assert(alignof(URCUiOptionBarText) == 0x000008, "Wrong alignment on URCUiOptionBarText");
static_assert(sizeof(URCUiOptionBarText) == 0x0002F8, "Wrong size on URCUiOptionBarText");
static_assert(offsetof(URCUiOptionBarText, AN_Def) == 0x0002D8, "Member 'URCUiOptionBarText::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarText, AN_Not) == 0x0002E0, "Member 'URCUiOptionBarText::AN_Not' has a wrong offset!");

// Class RC.RCParamNzFinaleSceneData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzFinaleSceneData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzFinaleSceneTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzFinaleSceneData">();
	}
	static class URCParamNzFinaleSceneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzFinaleSceneData>();
	}
};
static_assert(alignof(URCParamNzFinaleSceneData) == 0x000008, "Wrong alignment on URCParamNzFinaleSceneData");
static_assert(sizeof(URCParamNzFinaleSceneData) == 0x000040, "Wrong size on URCParamNzFinaleSceneData");
static_assert(offsetof(URCParamNzFinaleSceneData, Data) == 0x000030, "Member 'URCParamNzFinaleSceneData::Data' has a wrong offset!");

// Class RC.RCParamNzMTBData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzMTBData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzMTBTableRow>          Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzMTBData">();
	}
	static class URCParamNzMTBData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzMTBData>();
	}
};
static_assert(alignof(URCParamNzMTBData) == 0x000008, "Wrong alignment on URCParamNzMTBData");
static_assert(sizeof(URCParamNzMTBData) == 0x000040, "Wrong size on URCParamNzMTBData");
static_assert(offsetof(URCParamNzMTBData, Data) == 0x000030, "Member 'URCParamNzMTBData::Data' has a wrong offset!");

// Class RC.RCUiOptionControllerList
// 0x0098 (0x0370 - 0x02D8)
class URCUiOptionControllerList final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x78];                                     // 0x02F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionControllerList">();
	}
	static class URCUiOptionControllerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionControllerList>();
	}
};
static_assert(alignof(URCUiOptionControllerList) == 0x000008, "Wrong alignment on URCUiOptionControllerList");
static_assert(sizeof(URCUiOptionControllerList) == 0x000370, "Wrong size on URCUiOptionControllerList");
static_assert(offsetof(URCUiOptionControllerList, AN_Start) == 0x0002D8, "Member 'URCUiOptionControllerList::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiOptionControllerList, AN_Wait) == 0x0002E0, "Member 'URCUiOptionControllerList::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiOptionControllerList, AN_Finish) == 0x0002E8, "Member 'URCUiOptionControllerList::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiOptionControllerList, AN_Off) == 0x0002F0, "Member 'URCUiOptionControllerList::AN_Off' has a wrong offset!");

// Class RC.RCParamNzMTBWallData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzMTBWallData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzMTBWallTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzMTBWallData">();
	}
	static class URCParamNzMTBWallData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzMTBWallData>();
	}
};
static_assert(alignof(URCParamNzMTBWallData) == 0x000008, "Wrong alignment on URCParamNzMTBWallData");
static_assert(sizeof(URCParamNzMTBWallData) == 0x000040, "Wrong size on URCParamNzMTBWallData");
static_assert(offsetof(URCParamNzMTBWallData, Data) == 0x000030, "Member 'URCParamNzMTBWallData::Data' has a wrong offset!");

// Class RC.RCParamNzPuzzleData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzPuzzleData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzPuzzleTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzPuzzleData">();
	}
	static class URCParamNzPuzzleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzPuzzleData>();
	}
};
static_assert(alignof(URCParamNzPuzzleData) == 0x000008, "Wrong alignment on URCParamNzPuzzleData");
static_assert(sizeof(URCParamNzPuzzleData) == 0x000040, "Wrong size on URCParamNzPuzzleData");
static_assert(offsetof(URCParamNzPuzzleData, Data) == 0x000030, "Member 'URCParamNzPuzzleData::Data' has a wrong offset!");

// Class RC.RCUiMenuKagiListBar
// 0x0078 (0x0398 - 0x0320)
class URCUiMenuKagiListBar final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListNumber;                                   // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x48];                                     // 0x0350(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuKagiListBar">();
	}
	static class URCUiMenuKagiListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuKagiListBar>();
	}
};
static_assert(alignof(URCUiMenuKagiListBar) == 0x000008, "Wrong alignment on URCUiMenuKagiListBar");
static_assert(sizeof(URCUiMenuKagiListBar) == 0x000398, "Wrong size on URCUiMenuKagiListBar");
static_assert(offsetof(URCUiMenuKagiListBar, AN_Default) == 0x000320, "Member 'URCUiMenuKagiListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagiListBar, AN_OnCursor) == 0x000328, "Member 'URCUiMenuKagiListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagiListBar, AN_OnCursor_Wait) == 0x000330, "Member 'URCUiMenuKagiListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagiListBar, AN_OutCursor) == 0x000338, "Member 'URCUiMenuKagiListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagiListBar, Text_ListNumber) == 0x000340, "Member 'URCUiMenuKagiListBar::Text_ListNumber' has a wrong offset!");
static_assert(offsetof(URCUiMenuKagiListBar, Text_ListName) == 0x000348, "Member 'URCUiMenuKagiListBar::Text_ListName' has a wrong offset!");

// Class RC.RCParamNzPuzzleLangData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzPuzzleLangData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzPuzzleLangTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzPuzzleLangData">();
	}
	static class URCParamNzPuzzleLangData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzPuzzleLangData>();
	}
};
static_assert(alignof(URCParamNzPuzzleLangData) == 0x000008, "Wrong alignment on URCParamNzPuzzleLangData");
static_assert(sizeof(URCParamNzPuzzleLangData) == 0x000040, "Wrong size on URCParamNzPuzzleLangData");
static_assert(offsetof(URCParamNzPuzzleLangData, Data) == 0x000030, "Member 'URCParamNzPuzzleLangData::Data' has a wrong offset!");

// Class RC.RCParamNzPuzzleSpeedData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzPuzzleSpeedData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzPuzzleSpeedTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzPuzzleSpeedData">();
	}
	static class URCParamNzPuzzleSpeedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzPuzzleSpeedData>();
	}
};
static_assert(alignof(URCParamNzPuzzleSpeedData) == 0x000008, "Wrong alignment on URCParamNzPuzzleSpeedData");
static_assert(sizeof(URCParamNzPuzzleSpeedData) == 0x000040, "Wrong size on URCParamNzPuzzleSpeedData");
static_assert(offsetof(URCParamNzPuzzleSpeedData, Data) == 0x000030, "Member 'URCParamNzPuzzleSpeedData::Data' has a wrong offset!");

// Class RC.RCUiMenuMainQuestDetail
// 0x0008 (0x02F0 - 0x02E8)
class URCUiMenuMainQuestDetail final : public URCUiMenuQuestDetail
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuMainQuestDetail">();
	}
	static class URCUiMenuMainQuestDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuMainQuestDetail>();
	}
};
static_assert(alignof(URCUiMenuMainQuestDetail) == 0x000008, "Wrong alignment on URCUiMenuMainQuestDetail");
static_assert(sizeof(URCUiMenuMainQuestDetail) == 0x0002F0, "Wrong size on URCUiMenuMainQuestDetail");

// Class RC.RCParamNzResultHitPointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultHitPointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultHitPointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultHitPointData">();
	}
	static class URCParamNzResultHitPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultHitPointData>();
	}
};
static_assert(alignof(URCParamNzResultHitPointData) == 0x000008, "Wrong alignment on URCParamNzResultHitPointData");
static_assert(sizeof(URCParamNzResultHitPointData) == 0x000040, "Wrong size on URCParamNzResultHitPointData");
static_assert(offsetof(URCParamNzResultHitPointData, Data) == 0x000030, "Member 'URCParamNzResultHitPointData::Data' has a wrong offset!");

// Class RC.RCParamNzResultMinigamePointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultMinigamePointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultMinigamePointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultMinigamePointData">();
	}
	static class URCParamNzResultMinigamePointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultMinigamePointData>();
	}
};
static_assert(alignof(URCParamNzResultMinigamePointData) == 0x000008, "Wrong alignment on URCParamNzResultMinigamePointData");
static_assert(sizeof(URCParamNzResultMinigamePointData) == 0x000040, "Wrong size on URCParamNzResultMinigamePointData");
static_assert(offsetof(URCParamNzResultMinigamePointData, Data) == 0x000030, "Member 'URCParamNzResultMinigamePointData::Data' has a wrong offset!");

// Class RC.RCStaffRollDataAsset
// 0x0030 (0x0060 - 0x0030)
class URCStaffRollDataAsset final : public UDataAsset
{
public:
	float                                         MovieStartTime;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpaceSize;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetX;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Music;                                             // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicStartTime;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicFadeoutTime;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishTime;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCStaffRollRegion                            DispRegion;                                        // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCStaffRollPlatform                          DispPlatform;                                      // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCStaffRollDataAsset">();
	}
	static class URCStaffRollDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCStaffRollDataAsset>();
	}
};
static_assert(alignof(URCStaffRollDataAsset) == 0x000008, "Wrong alignment on URCStaffRollDataAsset");
static_assert(sizeof(URCStaffRollDataAsset) == 0x000060, "Wrong size on URCStaffRollDataAsset");
static_assert(offsetof(URCStaffRollDataAsset, MovieStartTime) == 0x000030, "Member 'URCStaffRollDataAsset::MovieStartTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, StartTime) == 0x000034, "Member 'URCStaffRollDataAsset::StartTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, EndTime) == 0x000038, "Member 'URCStaffRollDataAsset::EndTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, SpaceSize) == 0x00003C, "Member 'URCStaffRollDataAsset::SpaceSize' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, OffsetX) == 0x000040, "Member 'URCStaffRollDataAsset::OffsetX' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, Music) == 0x000044, "Member 'URCStaffRollDataAsset::Music' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, MusicStartTime) == 0x00004C, "Member 'URCStaffRollDataAsset::MusicStartTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, MusicFadeoutTime) == 0x000050, "Member 'URCStaffRollDataAsset::MusicFadeoutTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, FinishTime) == 0x000054, "Member 'URCStaffRollDataAsset::FinishTime' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, DispRegion) == 0x000058, "Member 'URCStaffRollDataAsset::DispRegion' has a wrong offset!");
static_assert(offsetof(URCStaffRollDataAsset, DispPlatform) == 0x000059, "Member 'URCStaffRollDataAsset::DispPlatform' has a wrong offset!");

// Class RC.RCParamNzResultMinigameTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultMinigameTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultMinigameTextTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultMinigameTextData">();
	}
	static class URCParamNzResultMinigameTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultMinigameTextData>();
	}
};
static_assert(alignof(URCParamNzResultMinigameTextData) == 0x000008, "Wrong alignment on URCParamNzResultMinigameTextData");
static_assert(sizeof(URCParamNzResultMinigameTextData) == 0x000040, "Wrong size on URCParamNzResultMinigameTextData");
static_assert(offsetof(URCParamNzResultMinigameTextData, Data) == 0x000030, "Member 'URCParamNzResultMinigameTextData::Data' has a wrong offset!");

// Class RC.RCUiMenuQuestList
// 0x00E0 (0x03D8 - 0x02F8)
class URCUiMenuQuestList final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0xA8];                                     // 0x02F8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x34];                                     // 0x03A4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void QuestMenuCustomNavigation(EUINavigation InNavigation, class APlayerController* InPlayerController);
	class UWidget* QuestNavigation(EUINavigation InNavigation);
	void SelectQuestListBar();
	void SelectQuestListBarWrap(ERCInputKeyType InKeyType);
	void SetQuestButtonGuide(class URCUiMenuQuestListGrp* InListGrp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestList">();
	}
	static class URCUiMenuQuestList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestList>();
	}
};
static_assert(alignof(URCUiMenuQuestList) == 0x000008, "Wrong alignment on URCUiMenuQuestList");
static_assert(sizeof(URCUiMenuQuestList) == 0x0003D8, "Wrong size on URCUiMenuQuestList");
static_assert(offsetof(URCUiMenuQuestList, MaxBarOfPage) == 0x0003A0, "Member 'URCUiMenuQuestList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCParamNzResultMinigameTypeData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultMinigameTypeData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultMinigameTypeTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultMinigameTypeData">();
	}
	static class URCParamNzResultMinigameTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultMinigameTypeData>();
	}
};
static_assert(alignof(URCParamNzResultMinigameTypeData) == 0x000008, "Wrong alignment on URCParamNzResultMinigameTypeData");
static_assert(sizeof(URCParamNzResultMinigameTypeData) == 0x000040, "Wrong size on URCParamNzResultMinigameTypeData");
static_assert(offsetof(URCParamNzResultMinigameTypeData, Data) == 0x000030, "Member 'URCParamNzResultMinigameTypeData::Data' has a wrong offset!");

// Class RC.RCParamNzResultRankData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultRankData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultRankTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultRankData">();
	}
	static class URCParamNzResultRankData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultRankData>();
	}
};
static_assert(alignof(URCParamNzResultRankData) == 0x000008, "Wrong alignment on URCParamNzResultRankData");
static_assert(sizeof(URCParamNzResultRankData) == 0x000040, "Wrong size on URCParamNzResultRankData");
static_assert(offsetof(URCParamNzResultRankData, Data) == 0x000030, "Member 'URCParamNzResultRankData::Data' has a wrong offset!");

// Class RC.RCParamNzResultRankItemToTanteiPointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultRankItemToTanteiPointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultRankItemToTanteiPointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultRankItemToTanteiPointData">();
	}
	static class URCParamNzResultRankItemToTanteiPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultRankItemToTanteiPointData>();
	}
};
static_assert(alignof(URCParamNzResultRankItemToTanteiPointData) == 0x000008, "Wrong alignment on URCParamNzResultRankItemToTanteiPointData");
static_assert(sizeof(URCParamNzResultRankItemToTanteiPointData) == 0x000040, "Wrong size on URCParamNzResultRankItemToTanteiPointData");
static_assert(offsetof(URCParamNzResultRankItemToTanteiPointData, Data) == 0x000030, "Member 'URCParamNzResultRankItemToTanteiPointData::Data' has a wrong offset!");

// Class RC.RCUiMenuSkillSelect
// 0x0038 (0x0330 - 0x02F8)
class URCUiMenuSkillSelect final : public URCMenuManager
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyCloseEventWrap(ERCInputKeyType InKeyType);
	void NotifyOpenEventWrap(ERCInputKeyType InKeyType);
	class UWidget* SkillSelectNavigation(EUINavigation InNavigation);
	void StartPush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillSelect">();
	}
	static class URCUiMenuSkillSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillSelect>();
	}
};
static_assert(alignof(URCUiMenuSkillSelect) == 0x000008, "Wrong alignment on URCUiMenuSkillSelect");
static_assert(sizeof(URCUiMenuSkillSelect) == 0x000330, "Wrong size on URCUiMenuSkillSelect");
static_assert(offsetof(URCUiMenuSkillSelect, AN_Start) == 0x0002F8, "Member 'URCUiMenuSkillSelect::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelect, AN_Wait) == 0x000300, "Member 'URCUiMenuSkillSelect::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillSelect, AN_Finish) == 0x000308, "Member 'URCUiMenuSkillSelect::AN_Finish' has a wrong offset!");

// Class RC.RCParamNzResultRankToTanteiPointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultRankToTanteiPointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultRankToTanteiPointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultRankToTanteiPointData">();
	}
	static class URCParamNzResultRankToTanteiPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultRankToTanteiPointData>();
	}
};
static_assert(alignof(URCParamNzResultRankToTanteiPointData) == 0x000008, "Wrong alignment on URCParamNzResultRankToTanteiPointData");
static_assert(sizeof(URCParamNzResultRankToTanteiPointData) == 0x000040, "Wrong size on URCParamNzResultRankToTanteiPointData");
static_assert(offsetof(URCParamNzResultRankToTanteiPointData, Data) == 0x000030, "Member 'URCParamNzResultRankToTanteiPointData::Data' has a wrong offset!");

// Class RC.RCParamNzResultReasoningPointData
// 0x0010 (0x0040 - 0x0030)
class URCParamNzResultReasoningPointData final : public URCCSVData
{
public:
	TArray<struct FRCParamNzResultReasoningPointTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamNzResultReasoningPointData">();
	}
	static class URCParamNzResultReasoningPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamNzResultReasoningPointData>();
	}
};
static_assert(alignof(URCParamNzResultReasoningPointData) == 0x000008, "Wrong alignment on URCParamNzResultReasoningPointData");
static_assert(sizeof(URCParamNzResultReasoningPointData) == 0x000040, "Wrong size on URCParamNzResultReasoningPointData");
static_assert(offsetof(URCParamNzResultReasoningPointData, Data) == 0x000030, "Member 'URCParamNzResultReasoningPointData::Data' has a wrong offset!");

// Class RC.RCParamOptionData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionTableRow>         Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionData">();
	}
	static class URCParamOptionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionData>();
	}
};
static_assert(alignof(URCParamOptionData) == 0x000008, "Wrong alignment on URCParamOptionData");
static_assert(sizeof(URCParamOptionData) == 0x000040, "Wrong size on URCParamOptionData");
static_assert(offsetof(URCParamOptionData, Data) == 0x000030, "Member 'URCParamOptionData::Data' has a wrong offset!");

// Class RC.RCParamOption_ItemListData
// 0x0010 (0x0040 - 0x0030)
class URCParamOption_ItemListData final : public URCCSVData
{
public:
	TArray<struct FRCParamOption_ItemListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOption_ItemListData">();
	}
	static class URCParamOption_ItemListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOption_ItemListData>();
	}
};
static_assert(alignof(URCParamOption_ItemListData) == 0x000008, "Wrong alignment on URCParamOption_ItemListData");
static_assert(sizeof(URCParamOption_ItemListData) == 0x000040, "Wrong size on URCParamOption_ItemListData");
static_assert(offsetof(URCParamOption_ItemListData, Data) == 0x000030, "Member 'URCParamOption_ItemListData::Data' has a wrong offset!");

// Class RC.RCUiInteractText
// 0x0040 (0x0318 - 0x02D8)
class URCUiInteractText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On_Start;                                       // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Wait;                                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Finish;                                      // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_TargetName;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeTextPl();
	void Off();
	void Open();
	void SetTargetName(const class FString& InName);
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractText">();
	}
	static class URCUiInteractText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractText>();
	}
};
static_assert(alignof(URCUiInteractText) == 0x000008, "Wrong alignment on URCUiInteractText");
static_assert(sizeof(URCUiInteractText) == 0x000318, "Wrong size on URCUiInteractText");
static_assert(offsetof(URCUiInteractText, AN_On_Start) == 0x0002D8, "Member 'URCUiInteractText::AN_On_Start' has a wrong offset!");
static_assert(offsetof(URCUiInteractText, AN_On_Wait) == 0x0002E0, "Member 'URCUiInteractText::AN_On_Wait' has a wrong offset!");
static_assert(offsetof(URCUiInteractText, AN_On_Finish) == 0x0002E8, "Member 'URCUiInteractText::AN_On_Finish' has a wrong offset!");
static_assert(offsetof(URCUiInteractText, AN_Off) == 0x0002F0, "Member 'URCUiInteractText::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiInteractText, Text_TargetName) == 0x0002F8, "Member 'URCUiInteractText::Text_TargetName' has a wrong offset!");

// Class RC.RCParamOptionCommonData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionCommonData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionCommonTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionCommonData">();
	}
	static class URCParamOptionCommonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionCommonData>();
	}
};
static_assert(alignof(URCParamOptionCommonData) == 0x000008, "Wrong alignment on URCParamOptionCommonData");
static_assert(sizeof(URCParamOptionCommonData) == 0x000040, "Wrong size on URCParamOptionCommonData");
static_assert(offsetof(URCParamOptionCommonData, Data) == 0x000030, "Member 'URCParamOptionCommonData::Data' has a wrong offset!");

// Class RC.RCParamOptionControllerData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionControllerData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionControllerTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionControllerData">();
	}
	static class URCParamOptionControllerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionControllerData>();
	}
};
static_assert(alignof(URCParamOptionControllerData) == 0x000008, "Wrong alignment on URCParamOptionControllerData");
static_assert(sizeof(URCParamOptionControllerData) == 0x000040, "Wrong size on URCParamOptionControllerData");
static_assert(offsetof(URCParamOptionControllerData, Data) == 0x000030, "Member 'URCParamOptionControllerData::Data' has a wrong offset!");

// Class RC.RCParamOptionGraphicsData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionGraphicsData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionGraphicsTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionGraphicsData">();
	}
	static class URCParamOptionGraphicsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionGraphicsData>();
	}
};
static_assert(alignof(URCParamOptionGraphicsData) == 0x000008, "Wrong alignment on URCParamOptionGraphicsData");
static_assert(sizeof(URCParamOptionGraphicsData) == 0x000040, "Wrong size on URCParamOptionGraphicsData");
static_assert(offsetof(URCParamOptionGraphicsData, Data) == 0x000030, "Member 'URCParamOptionGraphicsData::Data' has a wrong offset!");

// Class RC.RCParamOptionKeyData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionKeyData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionKeyTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionKeyData">();
	}
	static class URCParamOptionKeyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionKeyData>();
	}
};
static_assert(alignof(URCParamOptionKeyData) == 0x000008, "Wrong alignment on URCParamOptionKeyData");
static_assert(sizeof(URCParamOptionKeyData) == 0x000040, "Wrong size on URCParamOptionKeyData");
static_assert(offsetof(URCParamOptionKeyData, Data) == 0x000030, "Member 'URCParamOptionKeyData::Data' has a wrong offset!");

// Class RC.RCUiIntTarget
// 0x0008 (0x0300 - 0x02F8)
class URCUiIntTarget final : public URCUiInteractIcon
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetImg(bool bInIsNzWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiIntTarget">();
	}
	static class URCUiIntTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiIntTarget>();
	}
};
static_assert(alignof(URCUiIntTarget) == 0x000008, "Wrong alignment on URCUiIntTarget");
static_assert(sizeof(URCUiIntTarget) == 0x000300, "Wrong size on URCUiIntTarget");

// Class RC.RCParamOptionKeyDuplicateData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionKeyDuplicateData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionKeyDuplicateTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionKeyDuplicateData">();
	}
	static class URCParamOptionKeyDuplicateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionKeyDuplicateData>();
	}
};
static_assert(alignof(URCParamOptionKeyDuplicateData) == 0x000008, "Wrong alignment on URCParamOptionKeyDuplicateData");
static_assert(sizeof(URCParamOptionKeyDuplicateData) == 0x000040, "Wrong size on URCParamOptionKeyDuplicateData");
static_assert(offsetof(URCParamOptionKeyDuplicateData, Data) == 0x000030, "Member 'URCParamOptionKeyDuplicateData::Data' has a wrong offset!");

// Class RC.RCParamOptionSoundData
// 0x0010 (0x0040 - 0x0030)
class URCParamOptionSoundData final : public URCCSVData
{
public:
	TArray<struct FRCParamOptionSoundTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamOptionSoundData">();
	}
	static class URCParamOptionSoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamOptionSoundData>();
	}
};
static_assert(alignof(URCParamOptionSoundData) == 0x000008, "Wrong alignment on URCParamOptionSoundData");
static_assert(sizeof(URCParamOptionSoundData) == 0x000040, "Wrong size on URCParamOptionSoundData");
static_assert(offsetof(URCParamOptionSoundData, Data) == 0x000030, "Member 'URCParamOptionSoundData::Data' has a wrong offset!");

// Class RC.RCParamQuestCategoryListData
// 0x0010 (0x0040 - 0x0030)
class URCParamQuestCategoryListData final : public URCCSVData
{
public:
	TArray<struct FRCParamQuestCategoryListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamQuestCategoryListData">();
	}
	static class URCParamQuestCategoryListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamQuestCategoryListData>();
	}
};
static_assert(alignof(URCParamQuestCategoryListData) == 0x000008, "Wrong alignment on URCParamQuestCategoryListData");
static_assert(sizeof(URCParamQuestCategoryListData) == 0x000040, "Wrong size on URCParamQuestCategoryListData");
static_assert(offsetof(URCParamQuestCategoryListData, Data) == 0x000030, "Member 'URCParamQuestCategoryListData::Data' has a wrong offset!");

// Class RC.RCParamQuestListData
// 0x0010 (0x0040 - 0x0030)
class URCParamQuestListData final : public URCCSVData
{
public:
	TArray<struct FRCParamQuestListTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamQuestListData">();
	}
	static class URCParamQuestListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamQuestListData>();
	}
};
static_assert(alignof(URCParamQuestListData) == 0x000008, "Wrong alignment on URCParamQuestListData");
static_assert(sizeof(URCParamQuestListData) == 0x000040, "Wrong size on URCParamQuestListData");
static_assert(offsetof(URCParamQuestListData, Data) == 0x000030, "Member 'URCParamQuestListData::Data' has a wrong offset!");

// Class RC.RCUiMenuAreaMapIconGoal
// 0x0000 (0x02E0 - 0x02E0)
class URCUiMenuAreaMapIconGoal final : public URCUiMenuAreaMapIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapIconGoal">();
	}
	static class URCUiMenuAreaMapIconGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapIconGoal>();
	}
};
static_assert(alignof(URCUiMenuAreaMapIconGoal) == 0x000008, "Wrong alignment on URCUiMenuAreaMapIconGoal");
static_assert(sizeof(URCUiMenuAreaMapIconGoal) == 0x0002E0, "Wrong size on URCUiMenuAreaMapIconGoal");

// Class RC.RCParamRainEffectListData
// 0x0010 (0x0040 - 0x0030)
class URCParamRainEffectListData final : public URCCSVData
{
public:
	TArray<struct FRCParamRainEffectListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamRainEffectListData">();
	}
	static class URCParamRainEffectListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamRainEffectListData>();
	}
};
static_assert(alignof(URCParamRainEffectListData) == 0x000008, "Wrong alignment on URCParamRainEffectListData");
static_assert(sizeof(URCParamRainEffectListData) == 0x000040, "Wrong size on URCParamRainEffectListData");
static_assert(offsetof(URCParamRainEffectListData, Data) == 0x000030, "Member 'URCParamRainEffectListData::Data' has a wrong offset!");

// Class RC.RCParamRealEventSettingDataAsset
// 0x0020 (0x0050 - 0x0030)
class URCParamRealEventSettingDataAsset final : public URCCSVData
{
public:
	TArray<struct FRCParamRealEventSettingDataAssetRecord> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   MapID;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Filename;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamRealEventSettingDataAsset">();
	}
	static class URCParamRealEventSettingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamRealEventSettingDataAsset>();
	}
};
static_assert(alignof(URCParamRealEventSettingDataAsset) == 0x000008, "Wrong alignment on URCParamRealEventSettingDataAsset");
static_assert(sizeof(URCParamRealEventSettingDataAsset) == 0x000050, "Wrong size on URCParamRealEventSettingDataAsset");
static_assert(offsetof(URCParamRealEventSettingDataAsset, Data) == 0x000030, "Member 'URCParamRealEventSettingDataAsset::Data' has a wrong offset!");
static_assert(offsetof(URCParamRealEventSettingDataAsset, MapID) == 0x000040, "Member 'URCParamRealEventSettingDataAsset::MapID' has a wrong offset!");
static_assert(offsetof(URCParamRealEventSettingDataAsset, Filename) == 0x000048, "Member 'URCParamRealEventSettingDataAsset::Filename' has a wrong offset!");

// Class RC.RCParamSaveLoadDialogData
// 0x0010 (0x0040 - 0x0030)
class URCParamSaveLoadDialogData final : public URCCSVData
{
public:
	TArray<struct FRCParamSaveLoadDialogTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSaveLoadDialogData">();
	}
	static class URCParamSaveLoadDialogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSaveLoadDialogData>();
	}
};
static_assert(alignof(URCParamSaveLoadDialogData) == 0x000008, "Wrong alignment on URCParamSaveLoadDialogData");
static_assert(sizeof(URCParamSaveLoadDialogData) == 0x000040, "Wrong size on URCParamSaveLoadDialogData");
static_assert(offsetof(URCParamSaveLoadDialogData, Data) == 0x000030, "Member 'URCParamSaveLoadDialogData::Data' has a wrong offset!");

// Class RC.RCParamSaveLoadErrorData
// 0x0010 (0x0040 - 0x0030)
class URCParamSaveLoadErrorData final : public URCCSVData
{
public:
	TArray<struct FRCParamSaveLoadErrorTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSaveLoadErrorData">();
	}
	static class URCParamSaveLoadErrorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSaveLoadErrorData>();
	}
};
static_assert(alignof(URCParamSaveLoadErrorData) == 0x000008, "Wrong alignment on URCParamSaveLoadErrorData");
static_assert(sizeof(URCParamSaveLoadErrorData) == 0x000040, "Wrong size on URCParamSaveLoadErrorData");
static_assert(offsetof(URCParamSaveLoadErrorData, Data) == 0x000030, "Member 'URCParamSaveLoadErrorData::Data' has a wrong offset!");

// Class RC.RCUiMenuAreaMapPointer
// 0x0040 (0x0318 - 0x02D8)
class URCUiMenuAreaMapPointer final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Idle;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Point;                                          // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_PlaceName;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Pointer;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishCursor();
	void FinishDefault();
	void FinishOverlap();
	float GetWidgetRadius();
	void InitializeMapPointer();
	void OffMark();
	void OnMark();
	void SetIconText(class FName InTextID);
	void StartDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapPointer">();
	}
	static class URCUiMenuAreaMapPointer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapPointer>();
	}
};
static_assert(alignof(URCUiMenuAreaMapPointer) == 0x000008, "Wrong alignment on URCUiMenuAreaMapPointer");
static_assert(sizeof(URCUiMenuAreaMapPointer) == 0x000318, "Wrong size on URCUiMenuAreaMapPointer");
static_assert(offsetof(URCUiMenuAreaMapPointer, AN_Idle) == 0x0002E0, "Member 'URCUiMenuAreaMapPointer::AN_Idle' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapPointer, AN_Point) == 0x0002E8, "Member 'URCUiMenuAreaMapPointer::AN_Point' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapPointer, Txt_PlaceName) == 0x0002F0, "Member 'URCUiMenuAreaMapPointer::Txt_PlaceName' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMapPointer, Img_Pointer) == 0x0002F8, "Member 'URCUiMenuAreaMapPointer::Img_Pointer' has a wrong offset!");

// Class RC.RCParamSaveLoadIconData
// 0x0010 (0x0040 - 0x0030)
class URCParamSaveLoadIconData final : public URCCSVData
{
public:
	TArray<struct FRCParamSaveLoadIconTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSaveLoadIconData">();
	}
	static class URCParamSaveLoadIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSaveLoadIconData>();
	}
};
static_assert(alignof(URCParamSaveLoadIconData) == 0x000008, "Wrong alignment on URCParamSaveLoadIconData");
static_assert(sizeof(URCParamSaveLoadIconData) == 0x000040, "Wrong size on URCParamSaveLoadIconData");
static_assert(offsetof(URCParamSaveLoadIconData, Data) == 0x000030, "Member 'URCParamSaveLoadIconData::Data' has a wrong offset!");

// Class RC.RCParamSaveLoadTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamSaveLoadTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamSaveLoadTextTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSaveLoadTextData">();
	}
	static class URCParamSaveLoadTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSaveLoadTextData>();
	}
};
static_assert(alignof(URCParamSaveLoadTextData) == 0x000008, "Wrong alignment on URCParamSaveLoadTextData");
static_assert(sizeof(URCParamSaveLoadTextData) == 0x000040, "Wrong size on URCParamSaveLoadTextData");
static_assert(offsetof(URCParamSaveLoadTextData, Data) == 0x000030, "Member 'URCParamSaveLoadTextData::Data' has a wrong offset!");

// Class RC.RCParamSequencerSoundTemplateData
// 0x0010 (0x0040 - 0x0030)
class URCParamSequencerSoundTemplateData final : public URCCSVData
{
public:
	TArray<struct FRCParamSequencerSoundTemplateTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSequencerSoundTemplateData">();
	}
	static class URCParamSequencerSoundTemplateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSequencerSoundTemplateData>();
	}
};
static_assert(alignof(URCParamSequencerSoundTemplateData) == 0x000008, "Wrong alignment on URCParamSequencerSoundTemplateData");
static_assert(sizeof(URCParamSequencerSoundTemplateData) == 0x000040, "Wrong size on URCParamSequencerSoundTemplateData");
static_assert(offsetof(URCParamSequencerSoundTemplateData, Data) == 0x000030, "Member 'URCParamSequencerSoundTemplateData::Data' has a wrong offset!");

// Class RC.RCParamShinigamiExIdleData
// 0x0010 (0x0040 - 0x0030)
class URCParamShinigamiExIdleData final : public URCCSVData
{
public:
	TArray<struct FRCParamShinigamiExIdleTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamShinigamiExIdleData">();
	}
	static class URCParamShinigamiExIdleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamShinigamiExIdleData>();
	}
};
static_assert(alignof(URCParamShinigamiExIdleData) == 0x000008, "Wrong alignment on URCParamShinigamiExIdleData");
static_assert(sizeof(URCParamShinigamiExIdleData) == 0x000040, "Wrong size on URCParamShinigamiExIdleData");
static_assert(offsetof(URCParamShinigamiExIdleData, Data) == 0x000030, "Member 'URCParamShinigamiExIdleData::Data' has a wrong offset!");

// Class RC.RCUiMenuTutorialList
// 0x0098 (0x0390 - 0x02F8)
class URCUiMenuTutorialList final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x70];                                     // 0x02F8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x24];                                     // 0x036C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectTutorial();
	class UWidget* TutorialNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuTutorialList">();
	}
	static class URCUiMenuTutorialList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuTutorialList>();
	}
};
static_assert(alignof(URCUiMenuTutorialList) == 0x000008, "Wrong alignment on URCUiMenuTutorialList");
static_assert(sizeof(URCUiMenuTutorialList) == 0x000390, "Wrong size on URCUiMenuTutorialList");
static_assert(offsetof(URCUiMenuTutorialList, MaxBarOfPage) == 0x000368, "Member 'URCUiMenuTutorialList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCParamShinigamiFacialTempleteData
// 0x0010 (0x0040 - 0x0030)
class URCParamShinigamiFacialTempleteData final : public URCCSVData
{
public:
	TArray<struct FRCParamShinigamiFacialTempleteTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamShinigamiFacialTempleteData">();
	}
	static class URCParamShinigamiFacialTempleteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamShinigamiFacialTempleteData>();
	}
};
static_assert(alignof(URCParamShinigamiFacialTempleteData) == 0x000008, "Wrong alignment on URCParamShinigamiFacialTempleteData");
static_assert(sizeof(URCParamShinigamiFacialTempleteData) == 0x000040, "Wrong size on URCParamShinigamiFacialTempleteData");
static_assert(offsetof(URCParamShinigamiFacialTempleteData, Data) == 0x000030, "Member 'URCParamShinigamiFacialTempleteData::Data' has a wrong offset!");

// Class RC.RCParamSkillEquipmentListData
// 0x0010 (0x0040 - 0x0030)
class URCParamSkillEquipmentListData final : public URCCSVData
{
public:
	TArray<struct FRCParamSkillEquipmentListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSkillEquipmentListData">();
	}
	static class URCParamSkillEquipmentListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSkillEquipmentListData>();
	}
};
static_assert(alignof(URCParamSkillEquipmentListData) == 0x000008, "Wrong alignment on URCParamSkillEquipmentListData");
static_assert(sizeof(URCParamSkillEquipmentListData) == 0x000040, "Wrong size on URCParamSkillEquipmentListData");
static_assert(offsetof(URCParamSkillEquipmentListData, Data) == 0x000030, "Member 'URCParamSkillEquipmentListData::Data' has a wrong offset!");

// Class RC.RCParamSkillListData
// 0x0010 (0x0040 - 0x0030)
class URCParamSkillListData final : public URCCSVData
{
public:
	TArray<struct FRCParamSkillListTableRow>      Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSkillListData">();
	}
	static class URCParamSkillListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSkillListData>();
	}
};
static_assert(alignof(URCParamSkillListData) == 0x000008, "Wrong alignment on URCParamSkillListData");
static_assert(sizeof(URCParamSkillListData) == 0x000040, "Wrong size on URCParamSkillListData");
static_assert(offsetof(URCParamSkillListData, Data) == 0x000030, "Member 'URCParamSkillListData::Data' has a wrong offset!");

// Class RC.RCParamSocketListData
// 0x0010 (0x0040 - 0x0030)
class URCParamSocketListData final : public URCCSVData
{
public:
	TArray<struct FRCParamSocketListTableRow>     Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSocketListData">();
	}
	static class URCParamSocketListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSocketListData>();
	}
};
static_assert(alignof(URCParamSocketListData) == 0x000008, "Wrong alignment on URCParamSocketListData");
static_assert(sizeof(URCParamSocketListData) == 0x000040, "Wrong size on URCParamSocketListData");
static_assert(offsetof(URCParamSocketListData, Data) == 0x000030, "Member 'URCParamSocketListData::Data' has a wrong offset!");

// Class RC.RCUiMenuWorldMapBusIcon
// 0x0038 (0x0320 - 0x02E8)
class URCUiMenuWorldMapBusIcon final : public URCUiMenuCommonIcon
{
public:
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Close;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_MouseEnter;                                     // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_MouseLeave;                                     // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_MouseHover;                                     // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Click;                                          // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinishClickAnim();
	void OnFinishMouseEnterAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapBusIcon">();
	}
	static class URCUiMenuWorldMapBusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapBusIcon>();
	}
};
static_assert(alignof(URCUiMenuWorldMapBusIcon) == 0x000008, "Wrong alignment on URCUiMenuWorldMapBusIcon");
static_assert(sizeof(URCUiMenuWorldMapBusIcon) == 0x000320, "Wrong size on URCUiMenuWorldMapBusIcon");
static_assert(offsetof(URCUiMenuWorldMapBusIcon, AN_Close) == 0x0002F8, "Member 'URCUiMenuWorldMapBusIcon::AN_Close' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapBusIcon, AN_MouseEnter) == 0x000300, "Member 'URCUiMenuWorldMapBusIcon::AN_MouseEnter' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapBusIcon, AN_MouseLeave) == 0x000308, "Member 'URCUiMenuWorldMapBusIcon::AN_MouseLeave' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapBusIcon, AN_MouseHover) == 0x000310, "Member 'URCUiMenuWorldMapBusIcon::AN_MouseHover' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapBusIcon, AN_Click) == 0x000318, "Member 'URCUiMenuWorldMapBusIcon::AN_Click' has a wrong offset!");

// Class RC.RCParamSoundFormatData
// 0x0010 (0x0040 - 0x0030)
class URCParamSoundFormatData final : public URCCSVData
{
public:
	TArray<struct FRCParamSoundFormatTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSoundFormatData">();
	}
	static class URCParamSoundFormatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSoundFormatData>();
	}
};
static_assert(alignof(URCParamSoundFormatData) == 0x000008, "Wrong alignment on URCParamSoundFormatData");
static_assert(sizeof(URCParamSoundFormatData) == 0x000040, "Wrong size on URCParamSoundFormatData");
static_assert(offsetof(URCParamSoundFormatData, Data) == 0x000030, "Member 'URCParamSoundFormatData::Data' has a wrong offset!");

// Class RC.RCParamSoundIdListTemplateData
// 0x0010 (0x0040 - 0x0030)
class URCParamSoundIdListTemplateData final : public URCCSVData
{
public:
	TArray<struct FRCParamSoundIdListTemplateTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSoundIdListTemplateData">();
	}
	static class URCParamSoundIdListTemplateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSoundIdListTemplateData>();
	}
};
static_assert(alignof(URCParamSoundIdListTemplateData) == 0x000008, "Wrong alignment on URCParamSoundIdListTemplateData");
static_assert(sizeof(URCParamSoundIdListTemplateData) == 0x000040, "Wrong size on URCParamSoundIdListTemplateData");
static_assert(offsetof(URCParamSoundIdListTemplateData, Data) == 0x000030, "Member 'URCParamSoundIdListTemplateData::Data' has a wrong offset!");

// Class RC.RCParamSoundNonResidentListData
// 0x0010 (0x0040 - 0x0030)
class URCParamSoundNonResidentListData final : public URCCSVData
{
public:
	TArray<struct FRCParamSoundNonResidentListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSoundNonResidentListData">();
	}
	static class URCParamSoundNonResidentListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSoundNonResidentListData>();
	}
};
static_assert(alignof(URCParamSoundNonResidentListData) == 0x000008, "Wrong alignment on URCParamSoundNonResidentListData");
static_assert(sizeof(URCParamSoundNonResidentListData) == 0x000040, "Wrong size on URCParamSoundNonResidentListData");
static_assert(offsetof(URCParamSoundNonResidentListData, Data) == 0x000030, "Member 'URCParamSoundNonResidentListData::Data' has a wrong offset!");

// Class RC.RCParamSoundResidentListData
// 0x0010 (0x0040 - 0x0030)
class URCParamSoundResidentListData final : public URCCSVData
{
public:
	TArray<struct FRCParamSoundResidentListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSoundResidentListData">();
	}
	static class URCParamSoundResidentListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSoundResidentListData>();
	}
};
static_assert(alignof(URCParamSoundResidentListData) == 0x000008, "Wrong alignment on URCParamSoundResidentListData");
static_assert(sizeof(URCParamSoundResidentListData) == 0x000040, "Wrong size on URCParamSoundResidentListData");
static_assert(offsetof(URCParamSoundResidentListData, Data) == 0x000030, "Member 'URCParamSoundResidentListData::Data' has a wrong offset!");

// Class RC.RCUiMenuWorldMapLostArea
// 0x0030 (0x0308 - 0x02D8)
class URCUiMenuWorldMapLostArea final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapLostArea">();
	}
	static class URCUiMenuWorldMapLostArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapLostArea>();
	}
};
static_assert(alignof(URCUiMenuWorldMapLostArea) == 0x000008, "Wrong alignment on URCUiMenuWorldMapLostArea");
static_assert(sizeof(URCUiMenuWorldMapLostArea) == 0x000308, "Wrong size on URCUiMenuWorldMapLostArea");

// Class RC.RCParamStaffRollListData
// 0x0010 (0x0040 - 0x0030)
class URCParamStaffRollListData final : public URCCSVData
{
public:
	TArray<struct FRCParamStaffRollListTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamStaffRollListData">();
	}
	static class URCParamStaffRollListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamStaffRollListData>();
	}
};
static_assert(alignof(URCParamStaffRollListData) == 0x000008, "Wrong alignment on URCParamStaffRollListData");
static_assert(sizeof(URCParamStaffRollListData) == 0x000040, "Wrong size on URCParamStaffRollListData");
static_assert(offsetof(URCParamStaffRollListData, Data) == 0x000030, "Member 'URCParamStaffRollListData::Data' has a wrong offset!");

// Class RC.RCParamStaffRollList_PS5Data
// 0x0010 (0x0040 - 0x0030)
class URCParamStaffRollList_PS5Data final : public URCCSVData
{
public:
	TArray<struct FRCParamStaffRollList_PS5TableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamStaffRollList_PS5Data">();
	}
	static class URCParamStaffRollList_PS5Data* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamStaffRollList_PS5Data>();
	}
};
static_assert(alignof(URCParamStaffRollList_PS5Data) == 0x000008, "Wrong alignment on URCParamStaffRollList_PS5Data");
static_assert(sizeof(URCParamStaffRollList_PS5Data) == 0x000040, "Wrong size on URCParamStaffRollList_PS5Data");
static_assert(offsetof(URCParamStaffRollList_PS5Data, Data) == 0x000030, "Member 'URCParamStaffRollList_PS5Data::Data' has a wrong offset!");

// Class RC.RCParamStaffRollList_SwitchData
// 0x0010 (0x0040 - 0x0030)
class URCParamStaffRollList_SwitchData final : public URCCSVData
{
public:
	TArray<struct FRCParamStaffRollList_SwitchTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamStaffRollList_SwitchData">();
	}
	static class URCParamStaffRollList_SwitchData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamStaffRollList_SwitchData>();
	}
};
static_assert(alignof(URCParamStaffRollList_SwitchData) == 0x000008, "Wrong alignment on URCParamStaffRollList_SwitchData");
static_assert(sizeof(URCParamStaffRollList_SwitchData) == 0x000040, "Wrong size on URCParamStaffRollList_SwitchData");
static_assert(offsetof(URCParamStaffRollList_SwitchData, Data) == 0x000030, "Member 'URCParamStaffRollList_SwitchData::Data' has a wrong offset!");

// Class RC.RCParamStaffRollList_XboxData
// 0x0010 (0x0040 - 0x0030)
class URCParamStaffRollList_XboxData final : public URCCSVData
{
public:
	TArray<struct FRCParamStaffRollList_XboxTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamStaffRollList_XboxData">();
	}
	static class URCParamStaffRollList_XboxData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamStaffRollList_XboxData>();
	}
};
static_assert(alignof(URCParamStaffRollList_XboxData) == 0x000008, "Wrong alignment on URCParamStaffRollList_XboxData");
static_assert(sizeof(URCParamStaffRollList_XboxData) == 0x000040, "Wrong size on URCParamStaffRollList_XboxData");
static_assert(offsetof(URCParamStaffRollList_XboxData, Data) == 0x000030, "Member 'URCParamStaffRollList_XboxData::Data' has a wrong offset!");

// Class RC.RCUiSceneChange
// 0x0038 (0x0310 - 0x02D8)
class URCUiSceneChange : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiSceneChange">();
	}
	static class URCUiSceneChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiSceneChange>();
	}
};
static_assert(alignof(URCUiSceneChange) == 0x000008, "Wrong alignment on URCUiSceneChange");
static_assert(sizeof(URCUiSceneChange) == 0x000310, "Wrong size on URCUiSceneChange");
static_assert(offsetof(URCUiSceneChange, AN_Start) == 0x0002F8, "Member 'URCUiSceneChange::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiSceneChange, AN_Wait) == 0x000300, "Member 'URCUiSceneChange::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiSceneChange, AN_Finish) == 0x000308, "Member 'URCUiSceneChange::AN_Finish' has a wrong offset!");

// Class RC.RCParamStartupTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamStartupTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamStartupTextTableRow>    Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamStartupTextData">();
	}
	static class URCParamStartupTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamStartupTextData>();
	}
};
static_assert(alignof(URCParamStartupTextData) == 0x000008, "Wrong alignment on URCParamStartupTextData");
static_assert(sizeof(URCParamStartupTextData) == 0x000040, "Wrong size on URCParamStartupTextData");
static_assert(offsetof(URCParamStartupTextData, Data) == 0x000030, "Member 'URCParamStartupTextData::Data' has a wrong offset!");

// Class RC.RCParamSubQuestTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamSubQuestTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamSubQuestTextTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSubQuestTextData">();
	}
	static class URCParamSubQuestTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSubQuestTextData>();
	}
};
static_assert(alignof(URCParamSubQuestTextData) == 0x000008, "Wrong alignment on URCParamSubQuestTextData");
static_assert(sizeof(URCParamSubQuestTextData) == 0x000040, "Wrong size on URCParamSubQuestTextData");
static_assert(offsetof(URCParamSubQuestTextData, Data) == 0x000030, "Member 'URCParamSubQuestTextData::Data' has a wrong offset!");

// Class RC.RCParamSystemData
// 0x0010 (0x0040 - 0x0030)
class URCParamSystemData final : public URCCSVData
{
public:
	TArray<struct FRCParamSystemTableRow>         Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSystemData">();
	}
	static class URCParamSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSystemData>();
	}
};
static_assert(alignof(URCParamSystemData) == 0x000008, "Wrong alignment on URCParamSystemData");
static_assert(sizeof(URCParamSystemData) == 0x000040, "Wrong size on URCParamSystemData");
static_assert(offsetof(URCParamSystemData, Data) == 0x000030, "Member 'URCParamSystemData::Data' has a wrong offset!");

// Class RC.RCShinigamiAICommandTrigger
// 0x00C8 (0x0350 - 0x0288)
class ARCShinigamiAICommandTrigger final : public ARCActor
{
public:
	ERCShinigamiAiCommandTriggerType              AreaType;                                          // 0x0288(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        CollisionComponent;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiAIType                            AIType;                                            // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiEmotionType                       EmotionType;                                       // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveAreaName;                                      // 0x029C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TargetPointNameList;                               // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bOnActorEndOverlap;                                // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOncePlay;                                         // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextIntervalTime;                                  // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ExecPercent;                                       // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FARCVariableInfo                       CheckVariableInfo;                                 // 0x02C4(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   PlayVoiceID;                                       // 0x02D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlaySEID;                                          // 0x02DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlaySoundWorldPosition;                           // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetPlayVoiceID;                                 // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetPlaySEID;                                    // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTargetPlaySoundWorldPosition;                     // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetMoveSpeedMagnification;                      // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiWarpType                          TargetMoveWarpType;                                // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlaySequencerName;                                 // 0x0304(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlaySequencerLoopNum;                              // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayFollow;                                       // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TalkDataTable;                                     // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartTalkID;                                       // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTalkDelayAtEnd;                               // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTalkDelayToNext;                              // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayTalkID;                                        // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayTalkDelayAtEnd;                                // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayTalkDelayToNext;                               // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayed;                                           // 0x0341(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_342[0x2];                                      // 0x0342(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayCount;                                         // 0x0344(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayTime;                                          // 0x0348(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapScriptEntry(class AActor* OverlappedActor, class AActor* OtherActor);
	void ResetStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAICommandTrigger">();
	}
	static class ARCShinigamiAICommandTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCShinigamiAICommandTrigger>();
	}
};
static_assert(alignof(ARCShinigamiAICommandTrigger) == 0x000008, "Wrong alignment on ARCShinigamiAICommandTrigger");
static_assert(sizeof(ARCShinigamiAICommandTrigger) == 0x000350, "Wrong size on ARCShinigamiAICommandTrigger");
static_assert(offsetof(ARCShinigamiAICommandTrigger, AreaType) == 0x000288, "Member 'ARCShinigamiAICommandTrigger::AreaType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, CollisionComponent) == 0x000290, "Member 'ARCShinigamiAICommandTrigger::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, AIType) == 0x000298, "Member 'ARCShinigamiAICommandTrigger::AIType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, EmotionType) == 0x000299, "Member 'ARCShinigamiAICommandTrigger::EmotionType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, MoveAreaName) == 0x00029C, "Member 'ARCShinigamiAICommandTrigger::MoveAreaName' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TargetPointNameList) == 0x0002A8, "Member 'ARCShinigamiAICommandTrigger::TargetPointNameList' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bOnActorEndOverlap) == 0x0002B8, "Member 'ARCShinigamiAICommandTrigger::bOnActorEndOverlap' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bOncePlay) == 0x0002B9, "Member 'ARCShinigamiAICommandTrigger::bOncePlay' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, NextIntervalTime) == 0x0002BC, "Member 'ARCShinigamiAICommandTrigger::NextIntervalTime' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, ExecPercent) == 0x0002C0, "Member 'ARCShinigamiAICommandTrigger::ExecPercent' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, CheckVariableInfo) == 0x0002C4, "Member 'ARCShinigamiAICommandTrigger::CheckVariableInfo' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayVoiceID) == 0x0002D4, "Member 'ARCShinigamiAICommandTrigger::PlayVoiceID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlaySEID) == 0x0002DC, "Member 'ARCShinigamiAICommandTrigger::PlaySEID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bPlaySoundWorldPosition) == 0x0002E4, "Member 'ARCShinigamiAICommandTrigger::bPlaySoundWorldPosition' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TargetPlayVoiceID) == 0x0002E8, "Member 'ARCShinigamiAICommandTrigger::TargetPlayVoiceID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TargetPlaySEID) == 0x0002F0, "Member 'ARCShinigamiAICommandTrigger::TargetPlaySEID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bTargetPlaySoundWorldPosition) == 0x0002F8, "Member 'ARCShinigamiAICommandTrigger::bTargetPlaySoundWorldPosition' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TargetMoveSpeedMagnification) == 0x0002FC, "Member 'ARCShinigamiAICommandTrigger::TargetMoveSpeedMagnification' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TargetMoveWarpType) == 0x000300, "Member 'ARCShinigamiAICommandTrigger::TargetMoveWarpType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlaySequencerName) == 0x000304, "Member 'ARCShinigamiAICommandTrigger::PlaySequencerName' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlaySequencerLoopNum) == 0x00030C, "Member 'ARCShinigamiAICommandTrigger::PlaySequencerLoopNum' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bPlayFollow) == 0x000310, "Member 'ARCShinigamiAICommandTrigger::bPlayFollow' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, TalkDataTable) == 0x000318, "Member 'ARCShinigamiAICommandTrigger::TalkDataTable' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, StartTalkID) == 0x000320, "Member 'ARCShinigamiAICommandTrigger::StartTalkID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, StartTalkDelayAtEnd) == 0x000328, "Member 'ARCShinigamiAICommandTrigger::StartTalkDelayAtEnd' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, StartTalkDelayToNext) == 0x00032C, "Member 'ARCShinigamiAICommandTrigger::StartTalkDelayToNext' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayTalkID) == 0x000330, "Member 'ARCShinigamiAICommandTrigger::PlayTalkID' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayTalkDelayAtEnd) == 0x000338, "Member 'ARCShinigamiAICommandTrigger::PlayTalkDelayAtEnd' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayTalkDelayToNext) == 0x00033C, "Member 'ARCShinigamiAICommandTrigger::PlayTalkDelayToNext' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bDebugDraw) == 0x000340, "Member 'ARCShinigamiAICommandTrigger::bDebugDraw' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, bPlayed) == 0x000341, "Member 'ARCShinigamiAICommandTrigger::bPlayed' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayCount) == 0x000344, "Member 'ARCShinigamiAICommandTrigger::PlayCount' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAICommandTrigger, PlayTime) == 0x000348, "Member 'ARCShinigamiAICommandTrigger::PlayTime' has a wrong offset!");

// Class RC.RCParamSystemPlatformData
// 0x0010 (0x0040 - 0x0030)
class URCParamSystemPlatformData final : public URCCSVData
{
public:
	TArray<struct FRCParamSystemPlatformTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamSystemPlatformData">();
	}
	static class URCParamSystemPlatformData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamSystemPlatformData>();
	}
};
static_assert(alignof(URCParamSystemPlatformData) == 0x000008, "Wrong alignment on URCParamSystemPlatformData");
static_assert(sizeof(URCParamSystemPlatformData) == 0x000040, "Wrong size on URCParamSystemPlatformData");
static_assert(offsetof(URCParamSystemPlatformData, Data) == 0x000030, "Member 'URCParamSystemPlatformData::Data' has a wrong offset!");

// Class RC.RCParamTalkTextTagListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTalkTextTagListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTalkTextTagListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTalkTextTagListData">();
	}
	static class URCParamTalkTextTagListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTalkTextTagListData>();
	}
};
static_assert(alignof(URCParamTalkTextTagListData) == 0x000008, "Wrong alignment on URCParamTalkTextTagListData");
static_assert(sizeof(URCParamTalkTextTagListData) == 0x000040, "Wrong size on URCParamTalkTextTagListData");
static_assert(offsetof(URCParamTalkTextTagListData, Data) == 0x000030, "Member 'URCParamTalkTextTagListData::Data' has a wrong offset!");

// Class RC.RCParamTanteiPointListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTanteiPointListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTanteiPointListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTanteiPointListData">();
	}
	static class URCParamTanteiPointListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTanteiPointListData>();
	}
};
static_assert(alignof(URCParamTanteiPointListData) == 0x000008, "Wrong alignment on URCParamTanteiPointListData");
static_assert(sizeof(URCParamTanteiPointListData) == 0x000040, "Wrong size on URCParamTanteiPointListData");
static_assert(offsetof(URCParamTanteiPointListData, Data) == 0x000030, "Member 'URCParamTanteiPointListData::Data' has a wrong offset!");

// Class RC.RCParamTanteiRankListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTanteiRankListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTanteiRankListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTanteiRankListData">();
	}
	static class URCParamTanteiRankListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTanteiRankListData>();
	}
};
static_assert(alignof(URCParamTanteiRankListData) == 0x000008, "Wrong alignment on URCParamTanteiRankListData");
static_assert(sizeof(URCParamTanteiRankListData) == 0x000040, "Wrong size on URCParamTanteiRankListData");
static_assert(offsetof(URCParamTanteiRankListData, Data) == 0x000030, "Member 'URCParamTanteiRankListData::Data' has a wrong offset!");

// Class RC.RCShinigamiAIMoveArea
// 0x0018 (0x02A0 - 0x0288)
class ARCShinigamiAIMoveArea final : public ARCActor
{
public:
	ERCShinigamiAiMoveAreaType                    AreaType;                                          // 0x0288(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        CollisionComponent;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIMoveArea">();
	}
	static class ARCShinigamiAIMoveArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCShinigamiAIMoveArea>();
	}
};
static_assert(alignof(ARCShinigamiAIMoveArea) == 0x000008, "Wrong alignment on ARCShinigamiAIMoveArea");
static_assert(sizeof(ARCShinigamiAIMoveArea) == 0x0002A0, "Wrong size on ARCShinigamiAIMoveArea");
static_assert(offsetof(ARCShinigamiAIMoveArea, AreaType) == 0x000288, "Member 'ARCShinigamiAIMoveArea::AreaType' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAIMoveArea, CollisionComponent) == 0x000290, "Member 'ARCShinigamiAIMoveArea::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAIMoveArea, bDebugDraw) == 0x000298, "Member 'ARCShinigamiAIMoveArea::bDebugDraw' has a wrong offset!");

// Class RC.RCParamTextListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTextListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTextListTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTextListData">();
	}
	static class URCParamTextListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTextListData>();
	}
};
static_assert(alignof(URCParamTextListData) == 0x000008, "Wrong alignment on URCParamTextListData");
static_assert(sizeof(URCParamTextListData) == 0x000040, "Wrong size on URCParamTextListData");
static_assert(offsetof(URCParamTextListData, Data) == 0x000030, "Member 'URCParamTextListData::Data' has a wrong offset!");

// Class RC.RCParamTipsBlackSceneListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTipsBlackSceneListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTipsBlackSceneListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTipsBlackSceneListData">();
	}
	static class URCParamTipsBlackSceneListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTipsBlackSceneListData>();
	}
};
static_assert(alignof(URCParamTipsBlackSceneListData) == 0x000008, "Wrong alignment on URCParamTipsBlackSceneListData");
static_assert(sizeof(URCParamTipsBlackSceneListData) == 0x000040, "Wrong size on URCParamTipsBlackSceneListData");
static_assert(offsetof(URCParamTipsBlackSceneListData, Data) == 0x000030, "Member 'URCParamTipsBlackSceneListData::Data' has a wrong offset!");

// Class RC.RCParamTipsListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTipsListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTipsListTableRow>       Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTipsListData">();
	}
	static class URCParamTipsListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTipsListData>();
	}
};
static_assert(alignof(URCParamTipsListData) == 0x000008, "Wrong alignment on URCParamTipsListData");
static_assert(sizeof(URCParamTipsListData) == 0x000040, "Wrong size on URCParamTipsListData");
static_assert(offsetof(URCParamTipsListData, Data) == 0x000030, "Member 'URCParamTipsListData::Data' has a wrong offset!");

// Class RC.RCParamTitleDialogTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleDialogTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleDialogTextTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleDialogTextData">();
	}
	static class URCParamTitleDialogTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleDialogTextData>();
	}
};
static_assert(alignof(URCParamTitleDialogTextData) == 0x000008, "Wrong alignment on URCParamTitleDialogTextData");
static_assert(sizeof(URCParamTitleDialogTextData) == 0x000040, "Wrong size on URCParamTitleDialogTextData");
static_assert(offsetof(URCParamTitleDialogTextData, Data) == 0x000030, "Member 'URCParamTitleDialogTextData::Data' has a wrong offset!");

// Class RC.RCShinigamiAITargetPoint
// 0x0018 (0x0268 - 0x0250)
class ARCShinigamiAITargetPoint final : public ARCTargetPoint
{
public:
	uint8                                         Pad_250[0x4];                                      // 0x0250(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ERCShinigamiAITargetPointType                 Type;                                              // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetLength;                                      // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShinigamiLength;                                   // 0x025C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MoveRank;                                          // 0x0260(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAITargetPoint">();
	}
	static class ARCShinigamiAITargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCShinigamiAITargetPoint>();
	}
};
static_assert(alignof(ARCShinigamiAITargetPoint) == 0x000008, "Wrong alignment on ARCShinigamiAITargetPoint");
static_assert(sizeof(ARCShinigamiAITargetPoint) == 0x000268, "Wrong size on ARCShinigamiAITargetPoint");
static_assert(offsetof(ARCShinigamiAITargetPoint, Type) == 0x000254, "Member 'ARCShinigamiAITargetPoint::Type' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAITargetPoint, TargetLength) == 0x000258, "Member 'ARCShinigamiAITargetPoint::TargetLength' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAITargetPoint, ShinigamiLength) == 0x00025C, "Member 'ARCShinigamiAITargetPoint::ShinigamiLength' has a wrong offset!");
static_assert(offsetof(ARCShinigamiAITargetPoint, MoveRank) == 0x000260, "Member 'ARCShinigamiAITargetPoint::MoveRank' has a wrong offset!");

// Class RC.RCParamTitleHelpTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleHelpTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleHelpTextTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleHelpTextData">();
	}
	static class URCParamTitleHelpTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleHelpTextData>();
	}
};
static_assert(alignof(URCParamTitleHelpTextData) == 0x000008, "Wrong alignment on URCParamTitleHelpTextData");
static_assert(sizeof(URCParamTitleHelpTextData) == 0x000040, "Wrong size on URCParamTitleHelpTextData");
static_assert(offsetof(URCParamTitleHelpTextData, Data) == 0x000030, "Member 'URCParamTitleHelpTextData::Data' has a wrong offset!");

// Class RC.RCParamTitleLanguageTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleLanguageTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleLanguageTextTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleLanguageTextData">();
	}
	static class URCParamTitleLanguageTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleLanguageTextData>();
	}
};
static_assert(alignof(URCParamTitleLanguageTextData) == 0x000008, "Wrong alignment on URCParamTitleLanguageTextData");
static_assert(sizeof(URCParamTitleLanguageTextData) == 0x000040, "Wrong size on URCParamTitleLanguageTextData");
static_assert(offsetof(URCParamTitleLanguageTextData, Data) == 0x000030, "Member 'URCParamTitleLanguageTextData::Data' has a wrong offset!");

// Class RC.RCParamTitleMenuListData
// 0x0050 (0x0080 - 0x0030)
class URCParamTitleMenuListData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamTitleMenuListTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleMenuListData">();
	}
	static class URCParamTitleMenuListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleMenuListData>();
	}
};
static_assert(alignof(URCParamTitleMenuListData) == 0x000008, "Wrong alignment on URCParamTitleMenuListData");
static_assert(sizeof(URCParamTitleMenuListData) == 0x000080, "Wrong size on URCParamTitleMenuListData");
static_assert(offsetof(URCParamTitleMenuListData, Data) == 0x000030, "Member 'URCParamTitleMenuListData::Data' has a wrong offset!");

// Class RC.RCParamTitleSubStoryData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleSubStoryData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleSubStoryTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleSubStoryData">();
	}
	static class URCParamTitleSubStoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleSubStoryData>();
	}
};
static_assert(alignof(URCParamTitleSubStoryData) == 0x000008, "Wrong alignment on URCParamTitleSubStoryData");
static_assert(sizeof(URCParamTitleSubStoryData) == 0x000040, "Wrong size on URCParamTitleSubStoryData");
static_assert(offsetof(URCParamTitleSubStoryData, Data) == 0x000030, "Member 'URCParamTitleSubStoryData::Data' has a wrong offset!");

// Class RC.RCShinigamiFacialCtrl
// 0x0058 (0x02B8 - 0x0260)
class URCShinigamiFacialCtrl final : public URCCharacterFacialCtrl
{
public:
	class URCMorphBlender*                        BodyMorphBlend;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        HandMorphBlend;                                    // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        EyeBackOffMorphBlend;                              // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        EyebrowBackOffMorphBlend;                          // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        MouthBackOffMorphBlend;                            // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        BodyBackOffMorphBlend;                             // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCMorphBlender*                        HandBackOffMorphBlend;                             // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentDisplacementTextureName;                    // 0x0298(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentDisplacementMaskTextureName;                // 0x02A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiFacialCtrl">();
	}
	static class URCShinigamiFacialCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiFacialCtrl>();
	}
};
static_assert(alignof(URCShinigamiFacialCtrl) == 0x000008, "Wrong alignment on URCShinigamiFacialCtrl");
static_assert(sizeof(URCShinigamiFacialCtrl) == 0x0002B8, "Wrong size on URCShinigamiFacialCtrl");
static_assert(offsetof(URCShinigamiFacialCtrl, BodyMorphBlend) == 0x000260, "Member 'URCShinigamiFacialCtrl::BodyMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, HandMorphBlend) == 0x000268, "Member 'URCShinigamiFacialCtrl::HandMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, EyeBackOffMorphBlend) == 0x000270, "Member 'URCShinigamiFacialCtrl::EyeBackOffMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, EyebrowBackOffMorphBlend) == 0x000278, "Member 'URCShinigamiFacialCtrl::EyebrowBackOffMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, MouthBackOffMorphBlend) == 0x000280, "Member 'URCShinigamiFacialCtrl::MouthBackOffMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, BodyBackOffMorphBlend) == 0x000288, "Member 'URCShinigamiFacialCtrl::BodyBackOffMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, HandBackOffMorphBlend) == 0x000290, "Member 'URCShinigamiFacialCtrl::HandBackOffMorphBlend' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, CurrentDisplacementTextureName) == 0x000298, "Member 'URCShinigamiFacialCtrl::CurrentDisplacementTextureName' has a wrong offset!");
static_assert(offsetof(URCShinigamiFacialCtrl, CurrentDisplacementMaskTextureName) == 0x0002A8, "Member 'URCShinigamiFacialCtrl::CurrentDisplacementMaskTextureName' has a wrong offset!");

// Class RC.RCParamTitleSubStoryDialogTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleSubStoryDialogTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleSubStoryDialogTextTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleSubStoryDialogTextData">();
	}
	static class URCParamTitleSubStoryDialogTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleSubStoryDialogTextData>();
	}
};
static_assert(alignof(URCParamTitleSubStoryDialogTextData) == 0x000008, "Wrong alignment on URCParamTitleSubStoryDialogTextData");
static_assert(sizeof(URCParamTitleSubStoryDialogTextData) == 0x000040, "Wrong size on URCParamTitleSubStoryDialogTextData");
static_assert(offsetof(URCParamTitleSubStoryDialogTextData, Data) == 0x000030, "Member 'URCParamTitleSubStoryDialogTextData::Data' has a wrong offset!");

// Class RC.RCParamTitleSubStoryWindowTextData
// 0x0010 (0x0040 - 0x0030)
class URCParamTitleSubStoryWindowTextData final : public URCCSVData
{
public:
	TArray<struct FRCParamTitleSubStoryWindowTextTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTitleSubStoryWindowTextData">();
	}
	static class URCParamTitleSubStoryWindowTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTitleSubStoryWindowTextData>();
	}
};
static_assert(alignof(URCParamTitleSubStoryWindowTextData) == 0x000008, "Wrong alignment on URCParamTitleSubStoryWindowTextData");
static_assert(sizeof(URCParamTitleSubStoryWindowTextData) == 0x000040, "Wrong size on URCParamTitleSubStoryWindowTextData");
static_assert(offsetof(URCParamTitleSubStoryWindowTextData, Data) == 0x000030, "Member 'URCParamTitleSubStoryWindowTextData::Data' has a wrong offset!");

// Class RC.RCParamTutorialButtonGuideListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTutorialButtonGuideListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTutorialButtonGuideListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTutorialButtonGuideListData">();
	}
	static class URCParamTutorialButtonGuideListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTutorialButtonGuideListData>();
	}
};
static_assert(alignof(URCParamTutorialButtonGuideListData) == 0x000008, "Wrong alignment on URCParamTutorialButtonGuideListData");
static_assert(sizeof(URCParamTutorialButtonGuideListData) == 0x000040, "Wrong size on URCParamTutorialButtonGuideListData");
static_assert(offsetof(URCParamTutorialButtonGuideListData, Data) == 0x000030, "Member 'URCParamTutorialButtonGuideListData::Data' has a wrong offset!");

// Class RC.RCParamTutorialListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTutorialListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTutorialListTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTutorialListData">();
	}
	static class URCParamTutorialListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTutorialListData>();
	}
};
static_assert(alignof(URCParamTutorialListData) == 0x000008, "Wrong alignment on URCParamTutorialListData");
static_assert(sizeof(URCParamTutorialListData) == 0x000040, "Wrong size on URCParamTutorialListData");
static_assert(offsetof(URCParamTutorialListData, Data) == 0x000030, "Member 'URCParamTutorialListData::Data' has a wrong offset!");

// Class RC.RCTitleSaveCheckConnectWindow
// 0x0038 (0x0330 - 0x02F8)
class URCTitleSaveCheckConnectWindow : public URCMenuManager
{
public:
	TArray<class URCTitleSaveCheckConnectWindowTxt*> windowItemArray;                                   // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x032C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* WindowListSelectNavigation(EUINavigation InNavigation);
	class UWidget* WindowListSelectNavigationSolo(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSaveCheckConnectWindow">();
	}
	static class URCTitleSaveCheckConnectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSaveCheckConnectWindow>();
	}
};
static_assert(alignof(URCTitleSaveCheckConnectWindow) == 0x000008, "Wrong alignment on URCTitleSaveCheckConnectWindow");
static_assert(sizeof(URCTitleSaveCheckConnectWindow) == 0x000330, "Wrong size on URCTitleSaveCheckConnectWindow");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, windowItemArray) == 0x0002F8, "Member 'URCTitleSaveCheckConnectWindow::windowItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, AN_Start) == 0x000308, "Member 'URCTitleSaveCheckConnectWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, AN_Wait) == 0x000310, "Member 'URCTitleSaveCheckConnectWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, AN_Finish) == 0x000318, "Member 'URCTitleSaveCheckConnectWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, AN_Off) == 0x000320, "Member 'URCTitleSaveCheckConnectWindow::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, SelectIndex) == 0x000328, "Member 'URCTitleSaveCheckConnectWindow::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheckConnectWindow, bListLoop) == 0x00032C, "Member 'URCTitleSaveCheckConnectWindow::bListLoop' has a wrong offset!");

// Class RC.RCParamTutorialPageListData
// 0x0010 (0x0040 - 0x0030)
class URCParamTutorialPageListData final : public URCCSVData
{
public:
	TArray<struct FRCParamTutorialPageListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamTutorialPageListData">();
	}
	static class URCParamTutorialPageListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamTutorialPageListData>();
	}
};
static_assert(alignof(URCParamTutorialPageListData) == 0x000008, "Wrong alignment on URCParamTutorialPageListData");
static_assert(sizeof(URCParamTutorialPageListData) == 0x000040, "Wrong size on URCParamTutorialPageListData");
static_assert(offsetof(URCParamTutorialPageListData, Data) == 0x000030, "Member 'URCParamTutorialPageListData::Data' has a wrong offset!");

// Class RC.RCParamVariableChapterData
// 0x0010 (0x0040 - 0x0030)
class URCParamVariableChapterData final : public URCCSVData
{
public:
	TArray<struct FRCParamVariableChapterTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVariableChapterData">();
	}
	static class URCParamVariableChapterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVariableChapterData>();
	}
};
static_assert(alignof(URCParamVariableChapterData) == 0x000008, "Wrong alignment on URCParamVariableChapterData");
static_assert(sizeof(URCParamVariableChapterData) == 0x000040, "Wrong size on URCParamVariableChapterData");
static_assert(offsetof(URCParamVariableChapterData, Data) == 0x000030, "Member 'URCParamVariableChapterData::Data' has a wrong offset!");

// Class RC.RCParamVariableGameData
// 0x0010 (0x0040 - 0x0030)
class URCParamVariableGameData final : public URCCSVData
{
public:
	TArray<struct FRCParamVariableGameTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVariableGameData">();
	}
	static class URCParamVariableGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVariableGameData>();
	}
};
static_assert(alignof(URCParamVariableGameData) == 0x000008, "Wrong alignment on URCParamVariableGameData");
static_assert(sizeof(URCParamVariableGameData) == 0x000040, "Wrong size on URCParamVariableGameData");
static_assert(offsetof(URCParamVariableGameData, Data) == 0x000030, "Member 'URCParamVariableGameData::Data' has a wrong offset!");

// Class RC.RCParamVariableSceneData
// 0x0010 (0x0040 - 0x0030)
class URCParamVariableSceneData final : public URCCSVData
{
public:
	TArray<struct FRCParamVariableSceneTableRow>  Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVariableSceneData">();
	}
	static class URCParamVariableSceneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVariableSceneData>();
	}
};
static_assert(alignof(URCParamVariableSceneData) == 0x000008, "Wrong alignment on URCParamVariableSceneData");
static_assert(sizeof(URCParamVariableSceneData) == 0x000040, "Wrong size on URCParamVariableSceneData");
static_assert(offsetof(URCParamVariableSceneData, Data) == 0x000030, "Member 'URCParamVariableSceneData::Data' has a wrong offset!");

// Class RC.RCTitleSubStoryImage
// 0x0008 (0x0300 - 0x02F8)
class URCTitleSubStoryImage : public URCUiMenuQuestImage
{
public:
	int32                                         SubStoryChapterID;                                 // 0x02F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryImage">();
	}
	static class URCTitleSubStoryImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryImage>();
	}
};
static_assert(alignof(URCTitleSubStoryImage) == 0x000008, "Wrong alignment on URCTitleSubStoryImage");
static_assert(sizeof(URCTitleSubStoryImage) == 0x000300, "Wrong size on URCTitleSubStoryImage");
static_assert(offsetof(URCTitleSubStoryImage, SubStoryChapterID) == 0x0002F8, "Member 'URCTitleSubStoryImage::SubStoryChapterID' has a wrong offset!");

// Class RC.RCParamVehicleData
// 0x0010 (0x0040 - 0x0030)
class URCParamVehicleData final : public URCCSVData
{
public:
	TArray<struct FRCParamVehicleTableRow>        Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVehicleData">();
	}
	static class URCParamVehicleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVehicleData>();
	}
};
static_assert(alignof(URCParamVehicleData) == 0x000008, "Wrong alignment on URCParamVehicleData");
static_assert(sizeof(URCParamVehicleData) == 0x000040, "Wrong size on URCParamVehicleData");
static_assert(offsetof(URCParamVehicleData, Data) == 0x000030, "Member 'URCParamVehicleData::Data' has a wrong offset!");

// Class RC.RCParamVoiceDataPathListData
// 0x0050 (0x0080 - 0x0030)
class URCParamVoiceDataPathListData final : public URCCSVData
{
public:
	TMap<class FName, struct FRCParamVoiceDataPathListTableRow> Data;                                              // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVoiceDataPathListData">();
	}
	static class URCParamVoiceDataPathListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVoiceDataPathListData>();
	}
};
static_assert(alignof(URCParamVoiceDataPathListData) == 0x000008, "Wrong alignment on URCParamVoiceDataPathListData");
static_assert(sizeof(URCParamVoiceDataPathListData) == 0x000080, "Wrong size on URCParamVoiceDataPathListData");
static_assert(offsetof(URCParamVoiceDataPathListData, Data) == 0x000030, "Member 'URCParamVoiceDataPathListData::Data' has a wrong offset!");

// Class RC.RCParamVoiceSheetNameListData
// 0x0010 (0x0040 - 0x0030)
class URCParamVoiceSheetNameListData final : public URCCSVData
{
public:
	TArray<struct FRCParamVoiceSheetNameListTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamVoiceSheetNameListData">();
	}
	static class URCParamVoiceSheetNameListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamVoiceSheetNameListData>();
	}
};
static_assert(alignof(URCParamVoiceSheetNameListData) == 0x000008, "Wrong alignment on URCParamVoiceSheetNameListData");
static_assert(sizeof(URCParamVoiceSheetNameListData) == 0x000040, "Wrong size on URCParamVoiceSheetNameListData");
static_assert(offsetof(URCParamVoiceSheetNameListData, Data) == 0x000030, "Member 'URCParamVoiceSheetNameListData::Data' has a wrong offset!");

// Class RC.RCParamWanderingSpiritSpeedData
// 0x0010 (0x0040 - 0x0030)
class URCParamWanderingSpiritSpeedData final : public URCCSVData
{
public:
	TArray<struct FRCParamWanderingSpiritSpeedTableRow> Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamWanderingSpiritSpeedData">();
	}
	static class URCParamWanderingSpiritSpeedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamWanderingSpiritSpeedData>();
	}
};
static_assert(alignof(URCParamWanderingSpiritSpeedData) == 0x000008, "Wrong alignment on URCParamWanderingSpiritSpeedData");
static_assert(sizeof(URCParamWanderingSpiritSpeedData) == 0x000040, "Wrong size on URCParamWanderingSpiritSpeedData");
static_assert(offsetof(URCParamWanderingSpiritSpeedData, Data) == 0x000030, "Member 'URCParamWanderingSpiritSpeedData::Data' has a wrong offset!");

// Class RC.RCTitleSubStoryListItemSwitch
// 0x0028 (0x0348 - 0x0320)
class URCTitleSubStoryListItemSwitch : public URCMenuButton
{
public:
	class URCTitleSubStoryListItemFinish*         itemFinish;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleSubStoryListItemUnFinish*       itemUnFinish;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        listItemSwitcher;                                  // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        iconSwitcher;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDL;                                              // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentMouseSelect;                              // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentPressDecide;                              // 0x0342(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_343[0x5];                                      // 0x0343(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryListItemSwitch">();
	}
	static class URCTitleSubStoryListItemSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryListItemSwitch>();
	}
};
static_assert(alignof(URCTitleSubStoryListItemSwitch) == 0x000008, "Wrong alignment on URCTitleSubStoryListItemSwitch");
static_assert(sizeof(URCTitleSubStoryListItemSwitch) == 0x000348, "Wrong size on URCTitleSubStoryListItemSwitch");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, itemFinish) == 0x000320, "Member 'URCTitleSubStoryListItemSwitch::itemFinish' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, itemUnFinish) == 0x000328, "Member 'URCTitleSubStoryListItemSwitch::itemUnFinish' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, listItemSwitcher) == 0x000330, "Member 'URCTitleSubStoryListItemSwitch::listItemSwitcher' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, iconSwitcher) == 0x000338, "Member 'URCTitleSubStoryListItemSwitch::iconSwitcher' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, isDL) == 0x000340, "Member 'URCTitleSubStoryListItemSwitch::isDL' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, isCurrentMouseSelect) == 0x000341, "Member 'URCTitleSubStoryListItemSwitch::isCurrentMouseSelect' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryListItemSwitch, isCurrentPressDecide) == 0x000342, "Member 'URCTitleSubStoryListItemSwitch::isCurrentPressDecide' has a wrong offset!");

// Class RC.RCParamWarldMapListData
// 0x0010 (0x0040 - 0x0030)
class URCParamWarldMapListData final : public URCCSVData
{
public:
	TArray<struct FRCParamWarldMapListTableRow>   Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCParamWarldMapListData">();
	}
	static class URCParamWarldMapListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCParamWarldMapListData>();
	}
};
static_assert(alignof(URCParamWarldMapListData) == 0x000008, "Wrong alignment on URCParamWarldMapListData");
static_assert(sizeof(URCParamWarldMapListData) == 0x000040, "Wrong size on URCParamWarldMapListData");
static_assert(offsetof(URCParamWarldMapListData, Data) == 0x000030, "Member 'URCParamWarldMapListData::Data' has a wrong offset!");

// Class RC.RCPassengerAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class URCPassengerAnimInstance final : public URCAnimInstance
{
public:
	bool                                          TurnLeft;                                          // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnRight;                                         // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Crashed;                                           // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPassengerAnimInstance">();
	}
	static class URCPassengerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPassengerAnimInstance>();
	}
};
static_assert(alignof(URCPassengerAnimInstance) == 0x000010, "Wrong alignment on URCPassengerAnimInstance");
static_assert(sizeof(URCPassengerAnimInstance) == 0x0002C0, "Wrong size on URCPassengerAnimInstance");
static_assert(offsetof(URCPassengerAnimInstance, TurnLeft) == 0x0002B8, "Member 'URCPassengerAnimInstance::TurnLeft' has a wrong offset!");
static_assert(offsetof(URCPassengerAnimInstance, TurnRight) == 0x0002B9, "Member 'URCPassengerAnimInstance::TurnRight' has a wrong offset!");
static_assert(offsetof(URCPassengerAnimInstance, Crashed) == 0x0002BA, "Member 'URCPassengerAnimInstance::Crashed' has a wrong offset!");

// Class RC.RCPlatformUserGeneric
// 0x0048 (0x0070 - 0x0028)
class URCPlatformUserGeneric final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserGeneric">();
	}
	static class URCPlatformUserGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlatformUserGeneric>();
	}
};
static_assert(alignof(URCPlatformUserGeneric) == 0x000008, "Wrong alignment on URCPlatformUserGeneric");
static_assert(sizeof(URCPlatformUserGeneric) == 0x000070, "Wrong size on URCPlatformUserGeneric");

// Class RC.RCPlatformUserInterface
// 0x0000 (0x0028 - 0x0028)
class IRCPlatformUserInterface final : public IInterface
{
public:
	ERCLoginStatus GetLoginStatus();
	class FName GetPlatformUserName();
	void RequestGetUserPrivilege(const TDelegate<void(ERCUserPrivileges UserPrivileges)>& callbackFunc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserInterface">();
	}
	static class IRCPlatformUserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRCPlatformUserInterface>();
	}
};
static_assert(alignof(IRCPlatformUserInterface) == 0x000008, "Wrong alignment on IRCPlatformUserInterface");
static_assert(sizeof(IRCPlatformUserInterface) == 0x000028, "Wrong size on IRCPlatformUserInterface");

// Class RC.RCPlatformUserNone
// 0x0008 (0x0030 - 0x0028)
class URCPlatformUserNone final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserNone">();
	}
	static class URCPlatformUserNone* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlatformUserNone>();
	}
};
static_assert(alignof(URCPlatformUserNone) == 0x000008, "Wrong alignment on URCPlatformUserNone");
static_assert(sizeof(URCPlatformUserNone) == 0x000030, "Wrong size on URCPlatformUserNone");

// Class RC.RCPlatformUserReactProcess
// 0x0008 (0x0030 - 0x0028)
class URCPlatformUserReactProcess final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishSignOutGenericWindow(bool bResult);
	void OnSignOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserReactProcess">();
	}
	static class URCPlatformUserReactProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlatformUserReactProcess>();
	}
};
static_assert(alignof(URCPlatformUserReactProcess) == 0x000008, "Wrong alignment on URCPlatformUserReactProcess");
static_assert(sizeof(URCPlatformUserReactProcess) == 0x000030, "Wrong size on URCPlatformUserReactProcess");

// Class RC.RCPlatformUserReactProcessInterface
// 0x0000 (0x0028 - 0x0028)
class IRCPlatformUserReactProcessInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserReactProcessInterface">();
	}
	static class IRCPlatformUserReactProcessInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRCPlatformUserReactProcessInterface>();
	}
};
static_assert(alignof(IRCPlatformUserReactProcessInterface) == 0x000008, "Wrong alignment on IRCPlatformUserReactProcessInterface");
static_assert(sizeof(IRCPlatformUserReactProcessInterface) == 0x000028, "Wrong size on IRCPlatformUserReactProcessInterface");

// Class RC.RCPlatformUserReactProcessNone
// 0x0008 (0x0030 - 0x0028)
class URCPlatformUserReactProcessNone final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlatformUserReactProcessNone">();
	}
	static class URCPlatformUserReactProcessNone* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlatformUserReactProcessNone>();
	}
};
static_assert(alignof(URCPlatformUserReactProcessNone) == 0x000008, "Wrong alignment on URCPlatformUserReactProcessNone");
static_assert(sizeof(URCPlatformUserReactProcessNone) == 0x000030, "Wrong size on URCPlatformUserReactProcessNone");

// Class RC.RCUiMenuSkillTreeIcon
// 0x0040 (0x0360 - 0x0320)
class URCUiMenuSkillTreeIcon final : public URCMenuButton
{
public:
	uint8                                         Pad_320[0x40];                                     // 0x0320(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTreeIcon">();
	}
	static class URCUiMenuSkillTreeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTreeIcon>();
	}
};
static_assert(alignof(URCUiMenuSkillTreeIcon) == 0x000008, "Wrong alignment on URCUiMenuSkillTreeIcon");
static_assert(sizeof(URCUiMenuSkillTreeIcon) == 0x000360, "Wrong size on URCUiMenuSkillTreeIcon");

// Class RC.RCPlayerCameraManager
// 0x0010 (0x2820 - 0x2810)
class ARCPlayerCameraManager final : public APlayerCameraManager
{
public:
	uint8                                         Pad_2810[0x10];                                    // 0x2810(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReloadCameras();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlayerCameraManager">();
	}
	static class ARCPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCPlayerCameraManager>();
	}
};
static_assert(alignof(ARCPlayerCameraManager) == 0x000010, "Wrong alignment on ARCPlayerCameraManager");
static_assert(sizeof(ARCPlayerCameraManager) == 0x002820, "Wrong size on ARCPlayerCameraManager");

// Class RC.RCPlayerControllerBFL
// 0x0000 (0x0028 - 0x0028)
class URCPlayerControllerBFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlayerControllerBFL">();
	}
	static class URCPlayerControllerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlayerControllerBFL>();
	}
};
static_assert(alignof(URCPlayerControllerBFL) == 0x000008, "Wrong alignment on URCPlayerControllerBFL");
static_assert(sizeof(URCPlayerControllerBFL) == 0x000028, "Wrong size on URCPlayerControllerBFL");

// Class RC.RCPlayerSaveSetting
// 0x0048 (0x0070 - 0x0028)
class URCPlayerSaveSetting final : public UObject
{
public:
	struct FRCPlayerSave                          PlayerSave;                                        // 0x0028(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPlayerSaveSetting">();
	}
	static class URCPlayerSaveSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPlayerSaveSetting>();
	}
};
static_assert(alignof(URCPlayerSaveSetting) == 0x000008, "Wrong alignment on URCPlayerSaveSetting");
static_assert(sizeof(URCPlayerSaveSetting) == 0x000070, "Wrong size on URCPlayerSaveSetting");
static_assert(offsetof(URCPlayerSaveSetting, PlayerSave) == 0x000028, "Member 'URCPlayerSaveSetting::PlayerSave' has a wrong offset!");

// Class RC.RCUiMenuSkillWindow
// 0x0150 (0x0428 - 0x02D8)
class URCUiMenuSkillWindow final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x38];                                     // 0x02F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Txt_SkillName;                                     // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_SkillPoint_Current;                            // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_SkillPoint_After;                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_UsedPoint_Current;                             // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_MaxPoint_Current;                              // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_UsedPoint_After;                               // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_MaxPoint_After;                                // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_SystemMessage;                                 // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0xC0];                                     // 0x0368(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeSkillWindow();
	bool IsFinishSkillWindow();
	bool IsGetButtonResult();
	void Open();
	void SetSkillWindowText(class FName InSkillMode, class FName InSkillID);
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillWindow">();
	}
	static class URCUiMenuSkillWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillWindow>();
	}
};
static_assert(alignof(URCUiMenuSkillWindow) == 0x000008, "Wrong alignment on URCUiMenuSkillWindow");
static_assert(sizeof(URCUiMenuSkillWindow) == 0x000428, "Wrong size on URCUiMenuSkillWindow");
static_assert(offsetof(URCUiMenuSkillWindow, AN_Start) == 0x0002D8, "Member 'URCUiMenuSkillWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, AN_Wait) == 0x0002E0, "Member 'URCUiMenuSkillWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, AN_Finish) == 0x0002E8, "Member 'URCUiMenuSkillWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_SkillName) == 0x000328, "Member 'URCUiMenuSkillWindow::Txt_SkillName' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_SkillPoint_Current) == 0x000330, "Member 'URCUiMenuSkillWindow::Txt_SkillPoint_Current' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_SkillPoint_After) == 0x000338, "Member 'URCUiMenuSkillWindow::Txt_SkillPoint_After' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_UsedPoint_Current) == 0x000340, "Member 'URCUiMenuSkillWindow::Txt_UsedPoint_Current' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_MaxPoint_Current) == 0x000348, "Member 'URCUiMenuSkillWindow::Txt_MaxPoint_Current' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_UsedPoint_After) == 0x000350, "Member 'URCUiMenuSkillWindow::Txt_UsedPoint_After' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_MaxPoint_After) == 0x000358, "Member 'URCUiMenuSkillWindow::Txt_MaxPoint_After' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillWindow, Txt_SystemMessage) == 0x000360, "Member 'URCUiMenuSkillWindow::Txt_SystemMessage' has a wrong offset!");

// Class RC.RCPrimaryAssetLabelBase
// 0x0038 (0x0068 - 0x0030)
class URCPrimaryAssetLabelBase : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetRules                     Rules;                                             // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bLabelAssetsInMyDirectory : 1;                     // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRuntimeLabel : 1;                               // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UObject>>         ExplicitAssets;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ExplicitBlueprints;                                // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FCollectionReference                   AssetCollection;                                   // 0x0060(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPrimaryAssetLabelBase">();
	}
	static class URCPrimaryAssetLabelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPrimaryAssetLabelBase>();
	}
};
static_assert(alignof(URCPrimaryAssetLabelBase) == 0x000008, "Wrong alignment on URCPrimaryAssetLabelBase");
static_assert(sizeof(URCPrimaryAssetLabelBase) == 0x000068, "Wrong size on URCPrimaryAssetLabelBase");
static_assert(offsetof(URCPrimaryAssetLabelBase, Rules) == 0x000030, "Member 'URCPrimaryAssetLabelBase::Rules' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelBase, ExplicitAssets) == 0x000040, "Member 'URCPrimaryAssetLabelBase::ExplicitAssets' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelBase, ExplicitBlueprints) == 0x000050, "Member 'URCPrimaryAssetLabelBase::ExplicitBlueprints' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelBase, AssetCollection) == 0x000060, "Member 'URCPrimaryAssetLabelBase::AssetCollection' has a wrong offset!");

// Class RC.RCPrimaryAssetLabel
// 0x0000 (0x0068 - 0x0068)
class URCPrimaryAssetLabel final : public URCPrimaryAssetLabelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPrimaryAssetLabel">();
	}
	static class URCPrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPrimaryAssetLabel>();
	}
};
static_assert(alignof(URCPrimaryAssetLabel) == 0x000008, "Wrong alignment on URCPrimaryAssetLabel");
static_assert(sizeof(URCPrimaryAssetLabel) == 0x000068, "Wrong size on URCPrimaryAssetLabel");

// Class RC.RCPrimaryAssetLabelRoot
// 0x0000 (0x0068 - 0x0068)
class URCPrimaryAssetLabelRoot final : public URCPrimaryAssetLabelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPrimaryAssetLabelRoot">();
	}
	static class URCPrimaryAssetLabelRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPrimaryAssetLabelRoot>();
	}
};
static_assert(alignof(URCPrimaryAssetLabelRoot) == 0x000008, "Wrong alignment on URCPrimaryAssetLabelRoot");
static_assert(sizeof(URCPrimaryAssetLabelRoot) == 0x000068, "Wrong size on URCPrimaryAssetLabelRoot");

// Class RC.RCTipsScreen
// 0x0018 (0x0040 - 0x0028)
class URCTipsScreen final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTipsScreen">();
	}
	static class URCTipsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTipsScreen>();
	}
};
static_assert(alignof(URCTipsScreen) == 0x000008, "Wrong alignment on URCTipsScreen");
static_assert(sizeof(URCTipsScreen) == 0x000040, "Wrong size on URCTipsScreen");

// Class RC.RCNeverCookPrimaryAssetLabel
// 0x00F0 (0x0120 - 0x0030)
class URCNeverCookPrimaryAssetLabel final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UObject>>         NeverCookAssets_Switch;                            // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         NeverCookAssets_PS5;                               // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         NeverCookAssets_XSX;                               // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         NeverCookAssets_Windows;                           // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         NeverCookAssetRegularExpressionPaths_Switch;       // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         NeverCookAssetRegularExpressionPaths_PS5;          // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         NeverCookAssetRegularExpressionPaths_XSX;          // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         NeverCookAssetRegularExpressionPaths_Windows;      // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ERCPALPlatform, struct FRCPALData>       NeverCookAssetData;                                // 0x00B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bIsRuntimeLabel : 1;                               // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x1F];                                     // 0x0101(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCNeverCookPrimaryAssetLabel">();
	}
	static class URCNeverCookPrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCNeverCookPrimaryAssetLabel>();
	}
};
static_assert(alignof(URCNeverCookPrimaryAssetLabel) == 0x000008, "Wrong alignment on URCNeverCookPrimaryAssetLabel");
static_assert(sizeof(URCNeverCookPrimaryAssetLabel) == 0x000120, "Wrong size on URCNeverCookPrimaryAssetLabel");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssets_Switch) == 0x000030, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssets_Switch' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssets_PS5) == 0x000040, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssets_PS5' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssets_XSX) == 0x000050, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssets_XSX' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssets_Windows) == 0x000060, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssets_Windows' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssetRegularExpressionPaths_Switch) == 0x000070, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssetRegularExpressionPaths_Switch' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssetRegularExpressionPaths_PS5) == 0x000080, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssetRegularExpressionPaths_PS5' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssetRegularExpressionPaths_XSX) == 0x000090, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssetRegularExpressionPaths_XSX' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssetRegularExpressionPaths_Windows) == 0x0000A0, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssetRegularExpressionPaths_Windows' has a wrong offset!");
static_assert(offsetof(URCNeverCookPrimaryAssetLabel, NeverCookAssetData) == 0x0000B0, "Member 'URCNeverCookPrimaryAssetLabel::NeverCookAssetData' has a wrong offset!");

// Class RC.RCUiMenuStatusListBar
// 0x0060 (0x0338 - 0x02D8)
class URCUiMenuStatusListBar final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_ActiveSkill_000;                              // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ActiveSkill_001;                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ActiveSkill_002;                              // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuStatusListBar">();
	}
	static class URCUiMenuStatusListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuStatusListBar>();
	}
};
static_assert(alignof(URCUiMenuStatusListBar) == 0x000008, "Wrong alignment on URCUiMenuStatusListBar");
static_assert(sizeof(URCUiMenuStatusListBar) == 0x000338, "Wrong size on URCUiMenuStatusListBar");
static_assert(offsetof(URCUiMenuStatusListBar, Text_ActiveSkill_000) == 0x0002D8, "Member 'URCUiMenuStatusListBar::Text_ActiveSkill_000' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatusListBar, Text_ActiveSkill_001) == 0x0002E0, "Member 'URCUiMenuStatusListBar::Text_ActiveSkill_001' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatusListBar, Text_ActiveSkill_002) == 0x0002E8, "Member 'URCUiMenuStatusListBar::Text_ActiveSkill_002' has a wrong offset!");

// Class RC.RCMoveChunkPrimaryAssetLabel
// 0x0018 (0x0048 - 0x0030)
class URCMoveChunkPrimaryAssetLabel final : public UPrimaryDataAsset
{
public:
	TArray<struct FSoftObjectPath>                AssetPaths;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ChunkId;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCMoveChunkPrimaryAssetLabel">();
	}
	static class URCMoveChunkPrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCMoveChunkPrimaryAssetLabel>();
	}
};
static_assert(alignof(URCMoveChunkPrimaryAssetLabel) == 0x000008, "Wrong alignment on URCMoveChunkPrimaryAssetLabel");
static_assert(sizeof(URCMoveChunkPrimaryAssetLabel) == 0x000048, "Wrong size on URCMoveChunkPrimaryAssetLabel");
static_assert(offsetof(URCMoveChunkPrimaryAssetLabel, AssetPaths) == 0x000030, "Member 'URCMoveChunkPrimaryAssetLabel::AssetPaths' has a wrong offset!");
static_assert(offsetof(URCMoveChunkPrimaryAssetLabel, ChunkId) == 0x000040, "Member 'URCMoveChunkPrimaryAssetLabel::ChunkId' has a wrong offset!");

// Class RC.RCPrimaryAssetLabelDLC
// 0x0038 (0x0068 - 0x0030)
class URCPrimaryAssetLabelDLC final : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetRules                     Rules;                                             // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bLabelAssetsInMyDirectory : 1;                     // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRuntimeLabel : 1;                               // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UObject>>         ExplicitAssets;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ExplicitBlueprints;                                // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FCollectionReference                   AssetCollection;                                   // 0x0060(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPrimaryAssetLabelDLC">();
	}
	static class URCPrimaryAssetLabelDLC* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPrimaryAssetLabelDLC>();
	}
};
static_assert(alignof(URCPrimaryAssetLabelDLC) == 0x000008, "Wrong alignment on URCPrimaryAssetLabelDLC");
static_assert(sizeof(URCPrimaryAssetLabelDLC) == 0x000068, "Wrong size on URCPrimaryAssetLabelDLC");
static_assert(offsetof(URCPrimaryAssetLabelDLC, Rules) == 0x000030, "Member 'URCPrimaryAssetLabelDLC::Rules' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelDLC, ExplicitAssets) == 0x000040, "Member 'URCPrimaryAssetLabelDLC::ExplicitAssets' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelDLC, ExplicitBlueprints) == 0x000050, "Member 'URCPrimaryAssetLabelDLC::ExplicitBlueprints' has a wrong offset!");
static_assert(offsetof(URCPrimaryAssetLabelDLC, AssetCollection) == 0x000060, "Member 'URCPrimaryAssetLabelDLC::AssetCollection' has a wrong offset!");

// Class RC.RCPseudoAttachNiagaraComponent
// 0x0070 (0x0270 - 0x0200)
class URCPseudoAttachNiagaraComponent final : public USceneComponent
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0214(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0220(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x3C];                                     // 0x0234(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEffectFinished(class UNiagaraComponent* InParticleComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPseudoAttachNiagaraComponent">();
	}
	static class URCPseudoAttachNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPseudoAttachNiagaraComponent>();
	}
};
static_assert(alignof(URCPseudoAttachNiagaraComponent) == 0x000010, "Wrong alignment on URCPseudoAttachNiagaraComponent");
static_assert(sizeof(URCPseudoAttachNiagaraComponent) == 0x000270, "Wrong size on URCPseudoAttachNiagaraComponent");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, NiagaraComponent) == 0x0001F8, "Member 'URCPseudoAttachNiagaraComponent::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, RootSocketName) == 0x000200, "Member 'URCPseudoAttachNiagaraComponent::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, SocketName) == 0x000208, "Member 'URCPseudoAttachNiagaraComponent::SocketName' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, bIgnoreSocketRotation) == 0x000210, "Member 'URCPseudoAttachNiagaraComponent::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, LocationOffset) == 0x000214, "Member 'URCPseudoAttachNiagaraComponent::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, RotationOffset) == 0x000220, "Member 'URCPseudoAttachNiagaraComponent::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, bKeepAttaching) == 0x00022C, "Member 'URCPseudoAttachNiagaraComponent::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachNiagaraComponent, KeepAttachingTime) == 0x000230, "Member 'URCPseudoAttachNiagaraComponent::KeepAttachingTime' has a wrong offset!");

// Class RC.RCTitleChapterSelectListItem
// 0x0038 (0x0358 - 0x0320)
class URCTitleChapterSelectListItem : public URCMenuButton
{
public:
	class UTextBlock*                             line_00;                                           // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             line_01;                                           // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Def;                                            // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentMouseSelect;                              // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentPressDecide;                              // 0x0351(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_352[0x2];                                      // 0x0352(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChapterNum;                                        // 0x0354(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectListItem">();
	}
	static class URCTitleChapterSelectListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectListItem>();
	}
};
static_assert(alignof(URCTitleChapterSelectListItem) == 0x000008, "Wrong alignment on URCTitleChapterSelectListItem");
static_assert(sizeof(URCTitleChapterSelectListItem) == 0x000358, "Wrong size on URCTitleChapterSelectListItem");
static_assert(offsetof(URCTitleChapterSelectListItem, line_00) == 0x000320, "Member 'URCTitleChapterSelectListItem::line_00' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, line_01) == 0x000328, "Member 'URCTitleChapterSelectListItem::line_01' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, AN_Def) == 0x000330, "Member 'URCTitleChapterSelectListItem::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, AN_Off) == 0x000338, "Member 'URCTitleChapterSelectListItem::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, AN_Cursor_On) == 0x000340, "Member 'URCTitleChapterSelectListItem::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, AN_Cursor_Out) == 0x000348, "Member 'URCTitleChapterSelectListItem::AN_Cursor_Out' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, isCurrentMouseSelect) == 0x000350, "Member 'URCTitleChapterSelectListItem::isCurrentMouseSelect' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, isCurrentPressDecide) == 0x000351, "Member 'URCTitleChapterSelectListItem::isCurrentPressDecide' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectListItem, ChapterNum) == 0x000354, "Member 'URCTitleChapterSelectListItem::ChapterNum' has a wrong offset!");

// Class RC.RCPseudoAttachParticleComponent
// 0x0070 (0x0270 - 0x0200)
class URCPseudoAttachParticleComponent final : public USceneComponent
{
public:
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSocketRotation;                             // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0214(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0220(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bKeepAttaching;                                    // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAttachingTime;                                 // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x3C];                                     // 0x0234(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEffectFinished(class UParticleSystemComponent* InParticleComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCPseudoAttachParticleComponent">();
	}
	static class URCPseudoAttachParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCPseudoAttachParticleComponent>();
	}
};
static_assert(alignof(URCPseudoAttachParticleComponent) == 0x000010, "Wrong alignment on URCPseudoAttachParticleComponent");
static_assert(sizeof(URCPseudoAttachParticleComponent) == 0x000270, "Wrong size on URCPseudoAttachParticleComponent");
static_assert(offsetof(URCPseudoAttachParticleComponent, ParticleComponent) == 0x0001F8, "Member 'URCPseudoAttachParticleComponent::ParticleComponent' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, RootSocketName) == 0x000200, "Member 'URCPseudoAttachParticleComponent::RootSocketName' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, SocketName) == 0x000208, "Member 'URCPseudoAttachParticleComponent::SocketName' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, bIgnoreSocketRotation) == 0x000210, "Member 'URCPseudoAttachParticleComponent::bIgnoreSocketRotation' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, LocationOffset) == 0x000214, "Member 'URCPseudoAttachParticleComponent::LocationOffset' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, RotationOffset) == 0x000220, "Member 'URCPseudoAttachParticleComponent::RotationOffset' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, bKeepAttaching) == 0x00022C, "Member 'URCPseudoAttachParticleComponent::bKeepAttaching' has a wrong offset!");
static_assert(offsetof(URCPseudoAttachParticleComponent, KeepAttachingTime) == 0x000230, "Member 'URCPseudoAttachParticleComponent::KeepAttachingTime' has a wrong offset!");

// Class RC.RCUiMenuSubQuestImage
// 0x0000 (0x02F8 - 0x02F8)
class URCUiMenuSubQuestImage : public URCUiMenuQuestImage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSubQuestImage">();
	}
	static class URCUiMenuSubQuestImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSubQuestImage>();
	}
};
static_assert(alignof(URCUiMenuSubQuestImage) == 0x000008, "Wrong alignment on URCUiMenuSubQuestImage");
static_assert(sizeof(URCUiMenuSubQuestImage) == 0x0002F8, "Wrong size on URCUiMenuSubQuestImage");

// Class RC.RCRailCameraActor
// 0x0000 (0x07C0 - 0x07C0)
class ARCRailCameraActor final : public ARCCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRailCameraActor">();
	}
	static class ARCRailCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRailCameraActor>();
	}
};
static_assert(alignof(ARCRailCameraActor) == 0x000010, "Wrong alignment on ARCRailCameraActor");
static_assert(sizeof(ARCRailCameraActor) == 0x0007C0, "Wrong size on ARCRailCameraActor");

// Class RC.RCRainActor
// 0x0008 (0x0290 - 0x0288)
class ARCRainActor final : public ARCActor
{
public:
	float                                         offsetHeight;                                      // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRainActor">();
	}
	static class ARCRainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRainActor>();
	}
};
static_assert(alignof(ARCRainActor) == 0x000008, "Wrong alignment on ARCRainActor");
static_assert(sizeof(ARCRainActor) == 0x000290, "Wrong size on ARCRainActor");
static_assert(offsetof(ARCRainActor, offsetHeight) == 0x000288, "Member 'ARCRainActor::offsetHeight' has a wrong offset!");

// Class RC.RCRainActorManager
// 0x0018 (0x0040 - 0x0028)
class URCRainActorManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRainActorManager">();
	}
	static class URCRainActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRainActorManager>();
	}
};
static_assert(alignof(URCRainActorManager) == 0x000008, "Wrong alignment on URCRainActorManager");
static_assert(sizeof(URCRainActorManager) == 0x000040, "Wrong size on URCRainActorManager");

// Class RC.SCScriptDefineCommandDataAsset
// 0x0010 (0x0040 - 0x0030)
class USCScriptDefineCommandDataAsset final : public URCCSVData
{
public:
	TArray<struct FSCScriptDefineCommand>         Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCScriptDefineCommandDataAsset">();
	}
	static class USCScriptDefineCommandDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCScriptDefineCommandDataAsset>();
	}
};
static_assert(alignof(USCScriptDefineCommandDataAsset) == 0x000008, "Wrong alignment on USCScriptDefineCommandDataAsset");
static_assert(sizeof(USCScriptDefineCommandDataAsset) == 0x000040, "Wrong size on USCScriptDefineCommandDataAsset");
static_assert(offsetof(USCScriptDefineCommandDataAsset, Data) == 0x000030, "Member 'USCScriptDefineCommandDataAsset::Data' has a wrong offset!");

// Class RC.RCRainMaker
// 0x0168 (0x0388 - 0x0220)
class ARCRainMaker final : public AActor
{
public:
	float                                         offsetDropRain;                                    // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x164];                                    // 0x0224(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetCascadeRainColor(class FName Map, class FName Param);
	bool SetCascadeRainColorDirect(class FName Map, class FName Param, class FName aname, const struct FVector& col, float A, class FName Tag);
	void SetHiddenOutRain(bool isHidden);
	void SetHiddenRain(bool isHidden);
	bool SetRainColor(class FName Name_0);
	bool SetRainColorDirect(class FName Name_0, class FName aname, const struct FVector4& col);
	void SetRainForce(int32 paw);
	bool SetRainLinearColorDirect(class FName Name_0, const struct FLinearColor& col);
	void SetRainRotate(const struct FRotator& Rot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRainMaker">();
	}
	static class ARCRainMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRainMaker>();
	}
};
static_assert(alignof(ARCRainMaker) == 0x000008, "Wrong alignment on ARCRainMaker");
static_assert(sizeof(ARCRainMaker) == 0x000388, "Wrong size on ARCRainMaker");
static_assert(offsetof(ARCRainMaker, offsetDropRain) == 0x000220, "Member 'ARCRainMaker::offsetDropRain' has a wrong offset!");

// Class RC.RCRainSplashEffectComponent
// 0x00B8 (0x0190 - 0x00D8)
class URCRainSplashEffectComponent final : public URCEffectComponent
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0xC];                                       // 0x00E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComponentNo;                                       // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachPointHead;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachPointSpine;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 RainSplashEffectData_Head;                         // 0x0108(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 RainSplashEffectData_Spine;                        // 0x0124(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x50];                                     // 0x0140(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EffectSpawn(struct FRCEffectComponentData& InEffectData, class FName InAttachPointName, class UStaticMesh* InEmitterMesh, float InOffset, float InSpawnRate);
	bool EffectStart(struct FRCEffectComponentData& InEffectData, class FName InAttachPointName, class UStaticMesh* InEmitterMesh, float InOffset, float InSpawnRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRainSplashEffectComponent">();
	}
	static class URCRainSplashEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRainSplashEffectComponent>();
	}
};
static_assert(alignof(URCRainSplashEffectComponent) == 0x000008, "Wrong alignment on URCRainSplashEffectComponent");
static_assert(sizeof(URCRainSplashEffectComponent) == 0x000190, "Wrong size on URCRainSplashEffectComponent");
static_assert(offsetof(URCRainSplashEffectComponent, OwnerCharacter) == 0x0000D8, "Member 'URCRainSplashEffectComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, OwnerMesh) == 0x0000E0, "Member 'URCRainSplashEffectComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, ComponentNo) == 0x0000F4, "Member 'URCRainSplashEffectComponent::ComponentNo' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, AttachPointHead) == 0x0000F8, "Member 'URCRainSplashEffectComponent::AttachPointHead' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, AttachPointSpine) == 0x000100, "Member 'URCRainSplashEffectComponent::AttachPointSpine' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, RainSplashEffectData_Head) == 0x000108, "Member 'URCRainSplashEffectComponent::RainSplashEffectData_Head' has a wrong offset!");
static_assert(offsetof(URCRainSplashEffectComponent, RainSplashEffectData_Spine) == 0x000124, "Member 'URCRainSplashEffectComponent::RainSplashEffectData_Spine' has a wrong offset!");

// Class RC.RCRealEventBFL
// 0x0000 (0x0028 - 0x0028)
class URCRealEventBFL final : public UBlueprintFunctionLibrary
{
public:
	static ERCGameMode GetGameMode(int32 InChapter, class FName InScene);
	static bool IsBusStopEnable(class FName InMapID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventBFL">();
	}
	static class URCRealEventBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealEventBFL>();
	}
};
static_assert(alignof(URCRealEventBFL) == 0x000008, "Wrong alignment on URCRealEventBFL");
static_assert(sizeof(URCRealEventBFL) == 0x000028, "Wrong size on URCRealEventBFL");

// Class RC.RCRealEventSubLevelScriptActor
// 0x0028 (0x0250 - 0x0228)
class ARCRealEventSubLevelScriptActor : public ALevelScriptActor
{
public:
	int32                                         SelectCursolIndex;                                 // 0x0228(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRelease;                                          // 0x022C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventLoadEnd;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventSelectCursol;                               // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetSelectCursolIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventSubLevelScriptActor">();
	}
	static class ARCRealEventSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventSubLevelScriptActor");
static_assert(sizeof(ARCRealEventSubLevelScriptActor) == 0x000250, "Wrong size on ARCRealEventSubLevelScriptActor");
static_assert(offsetof(ARCRealEventSubLevelScriptActor, SelectCursolIndex) == 0x000228, "Member 'ARCRealEventSubLevelScriptActor::SelectCursolIndex' has a wrong offset!");
static_assert(offsetof(ARCRealEventSubLevelScriptActor, bRelease) == 0x00022C, "Member 'ARCRealEventSubLevelScriptActor::bRelease' has a wrong offset!");
static_assert(offsetof(ARCRealEventSubLevelScriptActor, OnEventLoadEnd) == 0x000230, "Member 'ARCRealEventSubLevelScriptActor::OnEventLoadEnd' has a wrong offset!");
static_assert(offsetof(ARCRealEventSubLevelScriptActor, OnEventSelectCursol) == 0x000240, "Member 'ARCRealEventSubLevelScriptActor::OnEventSelectCursol' has a wrong offset!");

// Class RC.RCScreenshotManager
// 0x0008 (0x0030 - 0x0028)
class URCScreenshotManager final : public UObject
{
public:
	bool                                          bEnable;                                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCScreenshotManager">();
	}
	static class URCScreenshotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCScreenshotManager>();
	}
};
static_assert(alignof(URCScreenshotManager) == 0x000008, "Wrong alignment on URCScreenshotManager");
static_assert(sizeof(URCScreenshotManager) == 0x000030, "Wrong size on URCScreenshotManager");
static_assert(offsetof(URCScreenshotManager, bEnable) == 0x000028, "Member 'URCScreenshotManager::bEnable' has a wrong offset!");

// Class RC.RCRealEventBusstopEventSubLevelScriptActor
// 0x0028 (0x0278 - 0x0250)
class ARCRealEventBusstopEventSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	bool                                          bIsEvent;                                          // 0x0250(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventBusIn;                                      // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventBusOut;                                     // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetEndEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventBusstopEventSubLevelScriptActor">();
	}
	static class ARCRealEventBusstopEventSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventBusstopEventSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventBusstopEventSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventBusstopEventSubLevelScriptActor");
static_assert(sizeof(ARCRealEventBusstopEventSubLevelScriptActor) == 0x000278, "Wrong size on ARCRealEventBusstopEventSubLevelScriptActor");
static_assert(offsetof(ARCRealEventBusstopEventSubLevelScriptActor, bIsEvent) == 0x000250, "Member 'ARCRealEventBusstopEventSubLevelScriptActor::bIsEvent' has a wrong offset!");
static_assert(offsetof(ARCRealEventBusstopEventSubLevelScriptActor, OnEventBusIn) == 0x000258, "Member 'ARCRealEventBusstopEventSubLevelScriptActor::OnEventBusIn' has a wrong offset!");
static_assert(offsetof(ARCRealEventBusstopEventSubLevelScriptActor, OnEventBusOut) == 0x000268, "Member 'ARCRealEventBusstopEventSubLevelScriptActor::OnEventBusOut' has a wrong offset!");

// Class RC.RCRealEventBusstopSubLevelScriptActor
// 0x0028 (0x0278 - 0x0250)
class ARCRealEventBusstopSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	bool                                          bEventThrough;                                     // 0x0250(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventBusstop;                                    // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventBusstopDisable;                             // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventBusstopSubLevelScriptActor">();
	}
	static class ARCRealEventBusstopSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventBusstopSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventBusstopSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventBusstopSubLevelScriptActor");
static_assert(sizeof(ARCRealEventBusstopSubLevelScriptActor) == 0x000278, "Wrong size on ARCRealEventBusstopSubLevelScriptActor");
static_assert(offsetof(ARCRealEventBusstopSubLevelScriptActor, bEventThrough) == 0x000250, "Member 'ARCRealEventBusstopSubLevelScriptActor::bEventThrough' has a wrong offset!");
static_assert(offsetof(ARCRealEventBusstopSubLevelScriptActor, OnEventBusstop) == 0x000258, "Member 'ARCRealEventBusstopSubLevelScriptActor::OnEventBusstop' has a wrong offset!");
static_assert(offsetof(ARCRealEventBusstopSubLevelScriptActor, OnEventBusstopDisable) == 0x000268, "Member 'ARCRealEventBusstopSubLevelScriptActor::OnEventBusstopDisable' has a wrong offset!");

// Class RC.RCRealEventCheckSubLevelScriptActor
// 0x0020 (0x0270 - 0x0250)
class ARCRealEventCheckSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	class FName                                   CheckActorName;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEventThrough;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventCheck;                                      // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClearEventThrough();
	class FName GetCheckActorName();
	bool IsEventThrough();
	void SetEventThrough();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventCheckSubLevelScriptActor">();
	}
	static class ARCRealEventCheckSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventCheckSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventCheckSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventCheckSubLevelScriptActor");
static_assert(sizeof(ARCRealEventCheckSubLevelScriptActor) == 0x000270, "Wrong size on ARCRealEventCheckSubLevelScriptActor");
static_assert(offsetof(ARCRealEventCheckSubLevelScriptActor, CheckActorName) == 0x000250, "Member 'ARCRealEventCheckSubLevelScriptActor::CheckActorName' has a wrong offset!");
static_assert(offsetof(ARCRealEventCheckSubLevelScriptActor, bEventThrough) == 0x000258, "Member 'ARCRealEventCheckSubLevelScriptActor::bEventThrough' has a wrong offset!");
static_assert(offsetof(ARCRealEventCheckSubLevelScriptActor, OnEventCheck) == 0x000260, "Member 'ARCRealEventCheckSubLevelScriptActor::OnEventCheck' has a wrong offset!");

// Class RC.RCRealEventManager
// 0x0020 (0x0048 - 0x0028)
class URCRealEventManager final : public UObject
{
public:
	class URCRealEventSettingManager*             EventSettingManager;                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCRealMapConnectManager*               MapConnectManager;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCRealEventAllMapInfo*                 AllMapInfo;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInfoChange;                                       // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventManager">();
	}
	static class URCRealEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealEventManager>();
	}
};
static_assert(alignof(URCRealEventManager) == 0x000008, "Wrong alignment on URCRealEventManager");
static_assert(sizeof(URCRealEventManager) == 0x000048, "Wrong size on URCRealEventManager");
static_assert(offsetof(URCRealEventManager, EventSettingManager) == 0x000028, "Member 'URCRealEventManager::EventSettingManager' has a wrong offset!");
static_assert(offsetof(URCRealEventManager, MapConnectManager) == 0x000030, "Member 'URCRealEventManager::MapConnectManager' has a wrong offset!");
static_assert(offsetof(URCRealEventManager, AllMapInfo) == 0x000038, "Member 'URCRealEventManager::AllMapInfo' has a wrong offset!");
static_assert(offsetof(URCRealEventManager, bInfoChange) == 0x000040, "Member 'URCRealEventManager::bInfoChange' has a wrong offset!");

// Class RC.SCVariable
// 0x0048 (0x0070 - 0x0028)
class USCVariable final : public UObject
{
public:
	int32                                         SCChapter;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SCScene;                                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SCArea;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SCBg;                                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SCBgType;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SCGameTable;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SCChapterTable;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SCSceneTable;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCVariable">();
	}
	static class USCVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCVariable>();
	}
};
static_assert(alignof(USCVariable) == 0x000008, "Wrong alignment on USCVariable");
static_assert(sizeof(USCVariable) == 0x000070, "Wrong size on USCVariable");
static_assert(offsetof(USCVariable, SCChapter) == 0x000028, "Member 'USCVariable::SCChapter' has a wrong offset!");
static_assert(offsetof(USCVariable, SCScene) == 0x00002C, "Member 'USCVariable::SCScene' has a wrong offset!");
static_assert(offsetof(USCVariable, SCArea) == 0x000030, "Member 'USCVariable::SCArea' has a wrong offset!");
static_assert(offsetof(USCVariable, SCBg) == 0x000034, "Member 'USCVariable::SCBg' has a wrong offset!");
static_assert(offsetof(USCVariable, SCBgType) == 0x000038, "Member 'USCVariable::SCBgType' has a wrong offset!");
static_assert(offsetof(USCVariable, SCGameTable) == 0x000040, "Member 'USCVariable::SCGameTable' has a wrong offset!");
static_assert(offsetof(USCVariable, SCChapterTable) == 0x000050, "Member 'USCVariable::SCChapterTable' has a wrong offset!");
static_assert(offsetof(USCVariable, SCSceneTable) == 0x000060, "Member 'USCVariable::SCSceneTable' has a wrong offset!");

// Class RC.RCRealEventAllMapInfo
// 0x0010 (0x0038 - 0x0028)
class URCRealEventAllMapInfo final : public UObject
{
public:
	TArray<struct FRCRealEventMapInfo>            MapInfo;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventAllMapInfo">();
	}
	static class URCRealEventAllMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealEventAllMapInfo>();
	}
};
static_assert(alignof(URCRealEventAllMapInfo) == 0x000008, "Wrong alignment on URCRealEventAllMapInfo");
static_assert(sizeof(URCRealEventAllMapInfo) == 0x000038, "Wrong size on URCRealEventAllMapInfo");
static_assert(offsetof(URCRealEventAllMapInfo, MapInfo) == 0x000028, "Member 'URCRealEventAllMapInfo::MapInfo' has a wrong offset!");

// Class RC.RCRealEventMapMoveSubLevelScriptActor
// 0x0030 (0x0280 - 0x0250)
class ARCRealEventMapMoveSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	class FName                                   MapMoveTriggerName;                                // 0x0250(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEventThrough;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventMapMove;                                    // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventMapMoveStop;                                // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClearEventThrough();
	class FName GetMapMoveTriggerName();
	bool IsEventThrough();
	void SetEventThrough();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventMapMoveSubLevelScriptActor">();
	}
	static class ARCRealEventMapMoveSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventMapMoveSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventMapMoveSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventMapMoveSubLevelScriptActor");
static_assert(sizeof(ARCRealEventMapMoveSubLevelScriptActor) == 0x000280, "Wrong size on ARCRealEventMapMoveSubLevelScriptActor");
static_assert(offsetof(ARCRealEventMapMoveSubLevelScriptActor, MapMoveTriggerName) == 0x000250, "Member 'ARCRealEventMapMoveSubLevelScriptActor::MapMoveTriggerName' has a wrong offset!");
static_assert(offsetof(ARCRealEventMapMoveSubLevelScriptActor, bEventThrough) == 0x000258, "Member 'ARCRealEventMapMoveSubLevelScriptActor::bEventThrough' has a wrong offset!");
static_assert(offsetof(ARCRealEventMapMoveSubLevelScriptActor, OnEventMapMove) == 0x000260, "Member 'ARCRealEventMapMoveSubLevelScriptActor::OnEventMapMove' has a wrong offset!");
static_assert(offsetof(ARCRealEventMapMoveSubLevelScriptActor, OnEventMapMoveStop) == 0x000270, "Member 'ARCRealEventMapMoveSubLevelScriptActor::OnEventMapMoveStop' has a wrong offset!");

// Class RC.RCRealEventResearchExitSubLevelScriptActor
// 0x0040 (0x0290 - 0x0250)
class ARCRealEventResearchExitSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	TMulticastInlineDelegate<void()>              OnEventResearchExit;                               // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventResearch2ndExit;                            // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventResearchVisionExit;                         // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEventResearchVisionChange;                       // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventResearchExitSubLevelScriptActor">();
	}
	static class ARCRealEventResearchExitSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventResearchExitSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventResearchExitSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventResearchExitSubLevelScriptActor");
static_assert(sizeof(ARCRealEventResearchExitSubLevelScriptActor) == 0x000290, "Wrong size on ARCRealEventResearchExitSubLevelScriptActor");
static_assert(offsetof(ARCRealEventResearchExitSubLevelScriptActor, OnEventResearchExit) == 0x000250, "Member 'ARCRealEventResearchExitSubLevelScriptActor::OnEventResearchExit' has a wrong offset!");
static_assert(offsetof(ARCRealEventResearchExitSubLevelScriptActor, OnEventResearch2ndExit) == 0x000260, "Member 'ARCRealEventResearchExitSubLevelScriptActor::OnEventResearch2ndExit' has a wrong offset!");
static_assert(offsetof(ARCRealEventResearchExitSubLevelScriptActor, OnEventResearchVisionExit) == 0x000270, "Member 'ARCRealEventResearchExitSubLevelScriptActor::OnEventResearchVisionExit' has a wrong offset!");
static_assert(offsetof(ARCRealEventResearchExitSubLevelScriptActor, OnEventResearchVisionChange) == 0x000280, "Member 'ARCRealEventResearchExitSubLevelScriptActor::OnEventResearchVisionChange' has a wrong offset!");

// Class RC.RCRealEventSettingManager
// 0x0020 (0x0048 - 0x0028)
class URCRealEventSettingManager final : public UObject
{
public:
	TArray<class URCParamRealEventSettingDataAsset*> SettingList;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         SettingChapterNum;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SettingSceneID;                                    // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventSettingManager">();
	}
	static class URCRealEventSettingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealEventSettingManager>();
	}
};
static_assert(alignof(URCRealEventSettingManager) == 0x000008, "Wrong alignment on URCRealEventSettingManager");
static_assert(sizeof(URCRealEventSettingManager) == 0x000048, "Wrong size on URCRealEventSettingManager");
static_assert(offsetof(URCRealEventSettingManager, SettingList) == 0x000028, "Member 'URCRealEventSettingManager::SettingList' has a wrong offset!");
static_assert(offsetof(URCRealEventSettingManager, SettingChapterNum) == 0x000038, "Member 'URCRealEventSettingManager::SettingChapterNum' has a wrong offset!");
static_assert(offsetof(URCRealEventSettingManager, SettingSceneID) == 0x00003C, "Member 'URCRealEventSettingManager::SettingSceneID' has a wrong offset!");

// Class RC.RCSequenceBFL
// 0x0000 (0x0028 - 0x0028)
class URCSequenceBFL final : public UBlueprintFunctionLibrary
{
public:
	static void CancelShinigamiSequencer(bool* bSucceeded, class UObject* WorldContextObject);
	static void CheckPlayingShinigamiSequencer(bool* bPlaying);
	static void GetSequenceManager(class URCSequenceManager** SequenceManager);
	static void GetShinigamiSequenceActor(class ALevelSequenceActor** OutLSA);
	static void InitShinigamiSequencerLS(bool* bSucceeded, class ALevelSequenceActor** OutLSA, class UObject* WorldContextObject, class ULevelSequence* LS, bool bSpawn, ERCSequenceShinigamiTransformTypeLS TransformType, class AActor* Actor, const struct FTransform& Transform, ERCSequenceShinigamiFollowType FollowType, ERCSequenceShinigamiFollowTarget FollowTarget, class AActor* FollowTargetActor, class ARCSequenceFollowTarget* FollowDummyActor);
	static void InitShinigamiSequencerLSA(bool* bSucceeded, class UObject* WorldContextObject, class ALevelSequenceActor* LSA, bool bSpawn, ERCSequenceShinigamiTransformTypeLSA TransformType, class AActor* Actor, const struct FTransform& Transform, ERCSequenceShinigamiFollowType FollowType, ERCSequenceShinigamiFollowTarget FollowTarget, class AActor* FollowTargetActor, class ARCSequenceFollowTarget* FollowDummyActor);
	static void PlayShinigamiSequencer(bool* bSucceeded, class ALevelSequenceActor* LSA, bool bSpawn);
	static void SetLSATransform(bool* bSucceeded, class ALevelSequenceActor* LSA, const struct FTransform& Transform);
	static void SetLSATransformActor(bool* bSucceeded, class ALevelSequenceActor* LSA, class AActor* TransformActor);
	static void StartShinigamiSequencerLS(bool* bSucceeded, class ALevelSequenceActor** OutLSA, class UObject* WorldContextObject, class ULevelSequence* LS, bool bSpawn, ERCSequenceShinigamiTransformTypeLS TransformType, class AActor* Actor, const struct FTransform& Transform, ERCSequenceShinigamiFollowType FollowType, ERCSequenceShinigamiFollowTarget FollowTarget, class AActor* FollowTargetActor);
	static void StartShinigamiSequencerLSA(bool* bSucceeded, class UObject* WorldContextObject, class ALevelSequenceActor* LSA, bool bSpawn, ERCSequenceShinigamiTransformTypeLSA TransformType, class AActor* Actor, const struct FTransform& Transform, ERCSequenceShinigamiFollowType FollowType, ERCSequenceShinigamiFollowTarget FollowTarget, class AActor* FollowTargetActor);
	static void StartShinigamiSequencerLSA2(bool* bSucceeded, class UObject* WorldContextObject, class ARCShinigamiLevelSequenceActor* ShinigamiLSA);
	static void StopShinigamiSequencer(bool* bSucceeded, class ALevelSequenceActor* LSA, bool bSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSequenceBFL">();
	}
	static class URCSequenceBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSequenceBFL>();
	}
};
static_assert(alignof(URCSequenceBFL) == 0x000008, "Wrong alignment on URCSequenceBFL");
static_assert(sizeof(URCSequenceBFL) == 0x000028, "Wrong size on URCSequenceBFL");

// Class RC.RCRealEventShinigamiSubLevelScriptActor
// 0x0010 (0x0260 - 0x0250)
class ARCRealEventShinigamiSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	TMulticastInlineDelegate<void()>              OnEventShinigami;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventShinigamiSubLevelScriptActor">();
	}
	static class ARCRealEventShinigamiSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventShinigamiSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventShinigamiSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventShinigamiSubLevelScriptActor");
static_assert(sizeof(ARCRealEventShinigamiSubLevelScriptActor) == 0x000260, "Wrong size on ARCRealEventShinigamiSubLevelScriptActor");
static_assert(offsetof(ARCRealEventShinigamiSubLevelScriptActor, OnEventShinigami) == 0x000250, "Member 'ARCRealEventShinigamiSubLevelScriptActor::OnEventShinigami' has a wrong offset!");

// Class RC.RCRealEventTalkSubLevelScriptActor
// 0x0020 (0x0270 - 0x0250)
class ARCRealEventTalkSubLevelScriptActor final : public ARCRealEventSubLevelScriptActor
{
public:
	class FName                                   TalkCharacterName;                                 // 0x0250(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEventThrough;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventTalk;                                       // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClearEventThrough();
	class FName GetTalkCharacterName();
	bool IsEventThrough();
	void SetEventThrough();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealEventTalkSubLevelScriptActor">();
	}
	static class ARCRealEventTalkSubLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCRealEventTalkSubLevelScriptActor>();
	}
};
static_assert(alignof(ARCRealEventTalkSubLevelScriptActor) == 0x000008, "Wrong alignment on ARCRealEventTalkSubLevelScriptActor");
static_assert(sizeof(ARCRealEventTalkSubLevelScriptActor) == 0x000270, "Wrong size on ARCRealEventTalkSubLevelScriptActor");
static_assert(offsetof(ARCRealEventTalkSubLevelScriptActor, TalkCharacterName) == 0x000250, "Member 'ARCRealEventTalkSubLevelScriptActor::TalkCharacterName' has a wrong offset!");
static_assert(offsetof(ARCRealEventTalkSubLevelScriptActor, bEventThrough) == 0x000258, "Member 'ARCRealEventTalkSubLevelScriptActor::bEventThrough' has a wrong offset!");
static_assert(offsetof(ARCRealEventTalkSubLevelScriptActor, OnEventTalk) == 0x000260, "Member 'ARCRealEventTalkSubLevelScriptActor::OnEventTalk' has a wrong offset!");

// Class RC.RCRealHUDBFL
// 0x0000 (0x0028 - 0x0028)
class URCRealHUDBFL final : public UBlueprintFunctionLibrary
{
public:
	static void CheckSoundNovelFinished(bool* bFinished);
	static void CloseMessageWindow();
	static void EndFreeMove();
	static class ARCReHUD* GetReHUD();
	static int32 GetSelectResult();
	static bool IsCloseMessageWindowSync();
	static bool IsEndMessageWindowSync();
	static bool IsOpenMessageWindowSync();
	static bool IsTalkStart();
	static void OpenMessageWindow2(ERCAdvHUDTalkWindowType WindowType);
	static void SetSelectSetting(int32 SelectNum, class FName InSelectTextID, bool bCheckMark);
	static void SoundNovelShowBackgroundFade(bool* bSucceeded, bool bShow);
	static void SoundNovelStart(bool* bSucceeded, class UDataTable* SoundNovelDataTable, bool bShowBackgroundFade);
	static void StartFreeMove();
	static void StartMessage2(int32 InCharacterFaceID, int32 InCharacterFacialID, class FName InMassageTextID, class FName InPartVoiceID);
	static void StartSelect(int32 SelectMax, class FName QuestionTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealHUDBFL">();
	}
	static class URCRealHUDBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealHUDBFL>();
	}
};
static_assert(alignof(URCRealHUDBFL) == 0x000008, "Wrong alignment on URCRealHUDBFL");
static_assert(sizeof(URCRealHUDBFL) == 0x000028, "Wrong size on URCRealHUDBFL");

// Class RC.RCRealLevelScriptActorBFL
// 0x0000 (0x0028 - 0x0028)
class URCRealLevelScriptActorBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEndBusstopEvent();
	static bool IsSubLevelLoadingWait();
	static bool IsSubLevelLoadSync();
	static void OnBusIn();
	static void OnBusOut();
	static void OnNextLevel(ERCGameMode InNextGameMode);
	static void SetSubLevelLoadingWait(bool flag);
	static void SetSubLevelLoadSync(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealLevelScriptActorBFL">();
	}
	static class URCRealLevelScriptActorBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealLevelScriptActorBFL>();
	}
};
static_assert(alignof(URCRealLevelScriptActorBFL) == 0x000008, "Wrong alignment on URCRealLevelScriptActorBFL");
static_assert(sizeof(URCRealLevelScriptActorBFL) == 0x000028, "Wrong size on URCRealLevelScriptActorBFL");

// Class RC.RCTitleLanguageWindow
// 0x0018 (0x0310 - 0x02F8)
class URCTitleLanguageWindow : public URCMenuManager
{
public:
	TArray<class URCTItleLanguageWindowItem*>     itemArray;                                         // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDecide;                                          // 0x0309(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A[0x2];                                      // 0x030A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectIndex;                                       // 0x030C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UWidget* LanguageWindowListSelectNavigation(EUINavigation InNavigation);
	void OnDecide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleLanguageWindow">();
	}
	static class URCTitleLanguageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleLanguageWindow>();
	}
};
static_assert(alignof(URCTitleLanguageWindow) == 0x000008, "Wrong alignment on URCTitleLanguageWindow");
static_assert(sizeof(URCTitleLanguageWindow) == 0x000310, "Wrong size on URCTitleLanguageWindow");
static_assert(offsetof(URCTitleLanguageWindow, itemArray) == 0x0002F8, "Member 'URCTitleLanguageWindow::itemArray' has a wrong offset!");
static_assert(offsetof(URCTitleLanguageWindow, bListLoop) == 0x000308, "Member 'URCTitleLanguageWindow::bListLoop' has a wrong offset!");
static_assert(offsetof(URCTitleLanguageWindow, isDecide) == 0x000309, "Member 'URCTitleLanguageWindow::isDecide' has a wrong offset!");
static_assert(offsetof(URCTitleLanguageWindow, SelectIndex) == 0x00030C, "Member 'URCTitleLanguageWindow::SelectIndex' has a wrong offset!");

// Class RC.RCRealMapConnectManager
// 0x0028 (0x0050 - 0x0028)
class URCRealMapConnectManager final : public UObject
{
public:
	int32                                         Chapter;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SceneID;                                           // 0x002C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapID;                                             // 0x0034(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERCCSVDataAssetIndex>                  EventSceneMapConnectInfoIndexList;                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealMapConnectManager">();
	}
	static class URCRealMapConnectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealMapConnectManager>();
	}
};
static_assert(alignof(URCRealMapConnectManager) == 0x000008, "Wrong alignment on URCRealMapConnectManager");
static_assert(sizeof(URCRealMapConnectManager) == 0x000050, "Wrong size on URCRealMapConnectManager");
static_assert(offsetof(URCRealMapConnectManager, Chapter) == 0x000028, "Member 'URCRealMapConnectManager::Chapter' has a wrong offset!");
static_assert(offsetof(URCRealMapConnectManager, SceneID) == 0x00002C, "Member 'URCRealMapConnectManager::SceneID' has a wrong offset!");
static_assert(offsetof(URCRealMapConnectManager, MapID) == 0x000034, "Member 'URCRealMapConnectManager::MapID' has a wrong offset!");
static_assert(offsetof(URCRealMapConnectManager, EventSceneMapConnectInfoIndexList) == 0x000040, "Member 'URCRealMapConnectManager::EventSceneMapConnectInfoIndexList' has a wrong offset!");

// Class RC.RCRealPlayerControllerBFL
// 0x0000 (0x0028 - 0x0028)
class URCRealPlayerControllerBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsMouseOverEnable();
	static bool IsSkipEnable();
	static void SetMouseOverEnable(bool bInMouseOverEnable);
	static void SetSkipEnable(bool bInSkipEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCRealPlayerControllerBFL">();
	}
	static class URCRealPlayerControllerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCRealPlayerControllerBFL>();
	}
};
static_assert(alignof(URCRealPlayerControllerBFL) == 0x000008, "Wrong alignment on URCRealPlayerControllerBFL");
static_assert(sizeof(URCRealPlayerControllerBFL) == 0x000028, "Wrong size on URCRealPlayerControllerBFL");

// Class RC.RCReproduceCloseRoomUIDataAsset
// 0x0008 (0x0038 - 0x0030)
class URCReproduceCloseRoomUIDataAsset final : public UDataAsset
{
public:
	float                                         WaitTime;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReproduceCloseRoomUIDataAsset">();
	}
	static class URCReproduceCloseRoomUIDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReproduceCloseRoomUIDataAsset>();
	}
};
static_assert(alignof(URCReproduceCloseRoomUIDataAsset) == 0x000008, "Wrong alignment on URCReproduceCloseRoomUIDataAsset");
static_assert(sizeof(URCReproduceCloseRoomUIDataAsset) == 0x000038, "Wrong size on URCReproduceCloseRoomUIDataAsset");
static_assert(offsetof(URCReproduceCloseRoomUIDataAsset, WaitTime) == 0x000030, "Member 'URCReproduceCloseRoomUIDataAsset::WaitTime' has a wrong offset!");

// Class RC.RCReSceneChangeLoadingScreen
// 0x0030 (0x0058 - 0x0028)
class URCReSceneChangeLoadingScreen final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReSceneChangeLoadingWidget*          FadeWidget;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReSceneChangeLoadingScreen">();
	}
	static class URCReSceneChangeLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReSceneChangeLoadingScreen>();
	}
};
static_assert(alignof(URCReSceneChangeLoadingScreen) == 0x000008, "Wrong alignment on URCReSceneChangeLoadingScreen");
static_assert(sizeof(URCReSceneChangeLoadingScreen) == 0x000058, "Wrong size on URCReSceneChangeLoadingScreen");
static_assert(offsetof(URCReSceneChangeLoadingScreen, FadeWidget) == 0x000048, "Member 'URCReSceneChangeLoadingScreen::FadeWidget' has a wrong offset!");

// Class RC.RCTitleLogoPressButton
// 0x0038 (0x0330 - 0x02F8)
class URCTitleLogoPressButton : public URCMenuManager
{
public:
	class UImage*                                 Text_PressButton;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Loop;                                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        PressButtonImagePath;                              // 0x0310(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoadingPressButtonImage;                        // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleLogoPressButton">();
	}
	static class URCTitleLogoPressButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleLogoPressButton>();
	}
};
static_assert(alignof(URCTitleLogoPressButton) == 0x000008, "Wrong alignment on URCTitleLogoPressButton");
static_assert(sizeof(URCTitleLogoPressButton) == 0x000330, "Wrong size on URCTitleLogoPressButton");
static_assert(offsetof(URCTitleLogoPressButton, Text_PressButton) == 0x0002F8, "Member 'URCTitleLogoPressButton::Text_PressButton' has a wrong offset!");
static_assert(offsetof(URCTitleLogoPressButton, AN_Loop) == 0x000300, "Member 'URCTitleLogoPressButton::AN_Loop' has a wrong offset!");
static_assert(offsetof(URCTitleLogoPressButton, AN_Push) == 0x000308, "Member 'URCTitleLogoPressButton::AN_Push' has a wrong offset!");
static_assert(offsetof(URCTitleLogoPressButton, PressButtonImagePath) == 0x000310, "Member 'URCTitleLogoPressButton::PressButtonImagePath' has a wrong offset!");
static_assert(offsetof(URCTitleLogoPressButton, bIsLoadingPressButtonImage) == 0x000328, "Member 'URCTitleLogoPressButton::bIsLoadingPressButtonImage' has a wrong offset!");

// Class RC.RCReSubQuest
// 0x0038 (0x0310 - 0x02D8)
class URCReSubQuest final : public URCUiWidgetBase
{
public:
	class USpTextBlock*                           SpText_StaticMess;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpTextBlock*                           SpText_SubQuestTitle;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         dispSecond;                                        // 0x02E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReSubQuest">();
	}
	static class URCReSubQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReSubQuest>();
	}
};
static_assert(alignof(URCReSubQuest) == 0x000008, "Wrong alignment on URCReSubQuest");
static_assert(sizeof(URCReSubQuest) == 0x000310, "Wrong size on URCReSubQuest");
static_assert(offsetof(URCReSubQuest, SpText_StaticMess) == 0x0002D8, "Member 'URCReSubQuest::SpText_StaticMess' has a wrong offset!");
static_assert(offsetof(URCReSubQuest, SpText_SubQuestTitle) == 0x0002E0, "Member 'URCReSubQuest::SpText_SubQuestTitle' has a wrong offset!");
static_assert(offsetof(URCReSubQuest, dispSecond) == 0x0002E8, "Member 'URCReSubQuest::dispSecond' has a wrong offset!");
static_assert(offsetof(URCReSubQuest, AN_Start) == 0x0002F0, "Member 'URCReSubQuest::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReSubQuest, AN_Wait) == 0x0002F8, "Member 'URCReSubQuest::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReSubQuest, AN_Finish) == 0x000300, "Member 'URCReSubQuest::AN_Finish' has a wrong offset!");

// Class RC.RCUiWidgetAccessable
// 0x0008 (0x02E0 - 0x02D8)
class URCUiWidgetAccessable : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PushButton();
	void ShowButton(bool bInIsShowable);
	void WaitOutside();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiWidgetAccessable">();
	}
	static class URCUiWidgetAccessable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiWidgetAccessable>();
	}
};
static_assert(alignof(URCUiWidgetAccessable) == 0x000008, "Wrong alignment on URCUiWidgetAccessable");
static_assert(sizeof(URCUiWidgetAccessable) == 0x0002E0, "Wrong size on URCUiWidgetAccessable");

// Class RC.RCReUiBalloon
// 0x0058 (0x0338 - 0x02E0)
class URCReUiBalloon final : public URCUiWidgetAccessable
{
public:
	uint8                                         Pad_2E0[0x58];                                     // 0x02E0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void Enlarge();
	void InitializeBalloon();
	void OpenLarge();
	void OpenSmall();
	void Reduce();
	void SetBalloonData(ESCBaloonFrame InFrame, ESCBaloonType InIcon, const class FString& inString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloon">();
	}
	static class URCReUiBalloon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloon>();
	}
};
static_assert(alignof(URCReUiBalloon) == 0x000008, "Wrong alignment on URCReUiBalloon");
static_assert(sizeof(URCReUiBalloon) == 0x000338, "Wrong size on URCReUiBalloon");

// Class RC.RCUiWidget3D
// 0x0000 (0x02D8 - 0x02D8)
class URCUiWidget3D : public URCUiWidgetBase
{
public:
	void WaitOutside();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiWidget3D">();
	}
	static class URCUiWidget3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiWidget3D>();
	}
};
static_assert(alignof(URCUiWidget3D) == 0x000008, "Wrong alignment on URCUiWidget3D");
static_assert(sizeof(URCUiWidget3D) == 0x0002D8, "Wrong size on URCUiWidget3D");

// Class RC.RCTitleMenuListItem
// 0x0030 (0x0350 - 0x0320)
class URCTitleMenuListItem : public URCMenuButton
{
public:
	class UWidgetSwitcher*                        SwitcherItem;                                      // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Def;                                            // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentMouseSelect;                              // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isDecide;                                          // 0x0349(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleMenuListItem">();
	}
	static class URCTitleMenuListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleMenuListItem>();
	}
};
static_assert(alignof(URCTitleMenuListItem) == 0x000008, "Wrong alignment on URCTitleMenuListItem");
static_assert(sizeof(URCTitleMenuListItem) == 0x000350, "Wrong size on URCTitleMenuListItem");
static_assert(offsetof(URCTitleMenuListItem, SwitcherItem) == 0x000320, "Member 'URCTitleMenuListItem::SwitcherItem' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, AN_Def) == 0x000328, "Member 'URCTitleMenuListItem::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, AN_Off) == 0x000330, "Member 'URCTitleMenuListItem::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, AN_Cursor_On) == 0x000338, "Member 'URCTitleMenuListItem::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, AN_Cursor_Out) == 0x000340, "Member 'URCTitleMenuListItem::AN_Cursor_Out' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, isCurrentMouseSelect) == 0x000348, "Member 'URCTitleMenuListItem::isCurrentMouseSelect' has a wrong offset!");
static_assert(offsetof(URCTitleMenuListItem, isDecide) == 0x000349, "Member 'URCTitleMenuListItem::isDecide' has a wrong offset!");

// Class RC.RCReUiBalloonFar
// 0x0030 (0x0308 - 0x02D8)
class URCReUiBalloonFar final : public URCUiWidget3D
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	int32 GetFarBalloonStatusInt();
	void InitializeBalloon();
	void Open();
	void SetBalloonData(ESCBaloonFrame InFrame, ESCBaloonType InIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonFar">();
	}
	static class URCReUiBalloonFar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonFar>();
	}
};
static_assert(alignof(URCReUiBalloonFar) == 0x000008, "Wrong alignment on URCReUiBalloonFar");
static_assert(sizeof(URCReUiBalloonFar) == 0x000308, "Wrong size on URCReUiBalloonFar");

// Class RC.RCReUiBalloonIcon
// 0x0020 (0x02F8 - 0x02D8)
class URCReUiBalloonIcon final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonIcon">();
	}
	static class URCReUiBalloonIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonIcon>();
	}
};
static_assert(alignof(URCReUiBalloonIcon) == 0x000008, "Wrong alignment on URCReUiBalloonIcon");
static_assert(sizeof(URCReUiBalloonIcon) == 0x0002F8, "Wrong size on URCReUiBalloonIcon");
static_assert(offsetof(URCReUiBalloonIcon, AN_Start) == 0x0002D8, "Member 'URCReUiBalloonIcon::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonIcon, AN_Wait) == 0x0002E0, "Member 'URCReUiBalloonIcon::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonIcon, AN_Finish) == 0x0002E8, "Member 'URCReUiBalloonIcon::AN_Finish' has a wrong offset!");

// Class RC.RCReUiBalloonLargeCloud
// 0x0028 (0x0300 - 0x02D8)
class URCReUiBalloonLargeCloud final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change_LtoS;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change_StoL;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonLargeCloud">();
	}
	static class URCReUiBalloonLargeCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonLargeCloud>();
	}
};
static_assert(alignof(URCReUiBalloonLargeCloud) == 0x000008, "Wrong alignment on URCReUiBalloonLargeCloud");
static_assert(sizeof(URCReUiBalloonLargeCloud) == 0x000300, "Wrong size on URCReUiBalloonLargeCloud");
static_assert(offsetof(URCReUiBalloonLargeCloud, AN_Start) == 0x0002D8, "Member 'URCReUiBalloonLargeCloud::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonLargeCloud, AN_Wait) == 0x0002E0, "Member 'URCReUiBalloonLargeCloud::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonLargeCloud, AN_Finish) == 0x0002E8, "Member 'URCReUiBalloonLargeCloud::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonLargeCloud, AN_Change_LtoS) == 0x0002F0, "Member 'URCReUiBalloonLargeCloud::AN_Change_LtoS' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonLargeCloud, AN_Change_StoL) == 0x0002F8, "Member 'URCReUiBalloonLargeCloud::AN_Change_StoL' has a wrong offset!");

// Class RC.RCReUiBalloonNear
// 0x0030 (0x0310 - 0x02E0)
class URCReUiBalloonNear final : public URCUiWidgetAccessable
{
public:
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void Enlarge();
	int32 GetBalloonStatusNum();
	void InitializeBalloon();
	void Open();
	void Reduce();
	void SetBalloonData(ESCBaloonFrame InFrame, const class FString& inString);
	void SetShakeData(float InWidthX, float InWidthY, float InInterval);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonNear">();
	}
	static class URCReUiBalloonNear* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonNear>();
	}
};
static_assert(alignof(URCReUiBalloonNear) == 0x000008, "Wrong alignment on URCReUiBalloonNear");
static_assert(sizeof(URCReUiBalloonNear) == 0x000310, "Wrong size on URCReUiBalloonNear");

// Class RC.RCTitleProtManager
// 0x0088 (0x0380 - 0x02F8)
class URCTitleProtManager final : public URCMenuManager
{
public:
	class UTextLayoutWidget*                      TextBlock_00;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextBlock_01;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextBlock_02;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextBlock_03;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x68];                                     // 0x0318(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClockButton();
	void OnClockTowerButton();
	void OnGinmaButton();
	void OnKamasakiButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleProtManager">();
	}
	static class URCTitleProtManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleProtManager>();
	}
};
static_assert(alignof(URCTitleProtManager) == 0x000008, "Wrong alignment on URCTitleProtManager");
static_assert(sizeof(URCTitleProtManager) == 0x000380, "Wrong size on URCTitleProtManager");
static_assert(offsetof(URCTitleProtManager, TextBlock_00) == 0x0002F8, "Member 'URCTitleProtManager::TextBlock_00' has a wrong offset!");
static_assert(offsetof(URCTitleProtManager, TextBlock_01) == 0x000300, "Member 'URCTitleProtManager::TextBlock_01' has a wrong offset!");
static_assert(offsetof(URCTitleProtManager, TextBlock_02) == 0x000308, "Member 'URCTitleProtManager::TextBlock_02' has a wrong offset!");
static_assert(offsetof(URCTitleProtManager, TextBlock_03) == 0x000310, "Member 'URCTitleProtManager::TextBlock_03' has a wrong offset!");

// Class RC.RCReUiBalloonSmallCloud
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiBalloonSmallCloud final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonSmallCloud">();
	}
	static class URCReUiBalloonSmallCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonSmallCloud>();
	}
};
static_assert(alignof(URCReUiBalloonSmallCloud) == 0x000008, "Wrong alignment on URCReUiBalloonSmallCloud");
static_assert(sizeof(URCReUiBalloonSmallCloud) == 0x0002F0, "Wrong size on URCReUiBalloonSmallCloud");
static_assert(offsetof(URCReUiBalloonSmallCloud, AN_Start) == 0x0002D8, "Member 'URCReUiBalloonSmallCloud::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonSmallCloud, AN_Wait) == 0x0002E0, "Member 'URCReUiBalloonSmallCloud::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonSmallCloud, AN_Finish) == 0x0002E8, "Member 'URCReUiBalloonSmallCloud::AN_Finish' has a wrong offset!");

// Class RC.RCReUiBalloonText
// 0x00D0 (0x03A8 - 0x02D8)
class URCReUiBalloonText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change_LtoS;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change_StoL;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScriptString;                                      // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         StringLine;                                        // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine1;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine2;                                         // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine3;                                         // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x30];                                     // 0x0338(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WholeTag;                                          // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShake;                                          // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShakeType;                                         // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeInterval;                                     // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ShakeWidth;                                        // 0x039C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiBalloonText">();
	}
	static class URCReUiBalloonText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiBalloonText>();
	}
};
static_assert(alignof(URCReUiBalloonText) == 0x000008, "Wrong alignment on URCReUiBalloonText");
static_assert(sizeof(URCReUiBalloonText) == 0x0003A8, "Wrong size on URCReUiBalloonText");
static_assert(offsetof(URCReUiBalloonText, AN_Start) == 0x0002D8, "Member 'URCReUiBalloonText::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, AN_Wait) == 0x0002E0, "Member 'URCReUiBalloonText::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, AN_Finish) == 0x0002E8, "Member 'URCReUiBalloonText::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, AN_Change_LtoS) == 0x0002F0, "Member 'URCReUiBalloonText::AN_Change_LtoS' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, AN_Change_StoL) == 0x0002F8, "Member 'URCReUiBalloonText::AN_Change_StoL' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, ScriptString) == 0x000300, "Member 'URCReUiBalloonText::ScriptString' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, StringLine) == 0x000310, "Member 'URCReUiBalloonText::StringLine' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, TextLine1) == 0x000320, "Member 'URCReUiBalloonText::TextLine1' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, TextLine2) == 0x000328, "Member 'URCReUiBalloonText::TextLine2' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, TextLine3) == 0x000330, "Member 'URCReUiBalloonText::TextLine3' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, WholeTag) == 0x000368, "Member 'URCReUiBalloonText::WholeTag' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, bIsShake) == 0x000378, "Member 'URCReUiBalloonText::bIsShake' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, ShakeType) == 0x000380, "Member 'URCReUiBalloonText::ShakeType' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, ShakeInterval) == 0x000398, "Member 'URCReUiBalloonText::ShakeInterval' has a wrong offset!");
static_assert(offsetof(URCReUiBalloonText, ShakeWidth) == 0x00039C, "Member 'URCReUiBalloonText::ShakeWidth' has a wrong offset!");

// Class RC.RCReUiButtonGuide
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiButtonGuide final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiButtonGuide">();
	}
	static class URCReUiButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiButtonGuide>();
	}
};
static_assert(alignof(URCReUiButtonGuide) == 0x000008, "Wrong alignment on URCReUiButtonGuide");
static_assert(sizeof(URCReUiButtonGuide) == 0x0002F0, "Wrong size on URCReUiButtonGuide");
static_assert(offsetof(URCReUiButtonGuide, AN_Start) == 0x0002D8, "Member 'URCReUiButtonGuide::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiButtonGuide, AN_Wait) == 0x0002E0, "Member 'URCReUiButtonGuide::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiButtonGuide, AN_Finish) == 0x0002E8, "Member 'URCReUiButtonGuide::AN_Finish' has a wrong offset!");

// Class RC.RCReUiChousaButtonGuide
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiChousaButtonGuide final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeChousaButtonGuide(bool bInIsResearch);
	void Open();
	void SetGuideParts(bool bInIsResearch);
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaButtonGuide">();
	}
	static class URCReUiChousaButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaButtonGuide>();
	}
};
static_assert(alignof(URCReUiChousaButtonGuide) == 0x000008, "Wrong alignment on URCReUiChousaButtonGuide");
static_assert(sizeof(URCReUiChousaButtonGuide) == 0x0002F0, "Wrong size on URCReUiChousaButtonGuide");
static_assert(offsetof(URCReUiChousaButtonGuide, AN_Start) == 0x0002D8, "Member 'URCReUiChousaButtonGuide::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaButtonGuide, AN_Wait) == 0x0002E0, "Member 'URCReUiChousaButtonGuide::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaButtonGuide, AN_Finish) == 0x0002E8, "Member 'URCReUiChousaButtonGuide::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuCharacterSelect
// 0x00A0 (0x0398 - 0x02F8)
class URCUiMenuCharacterSelect final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_On;                                             // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideIn_L;                                      // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideIn_R;                                      // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideOut_L;                                     // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideOut_R;                                     // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCUiMenuCharacterSelectSlideType             CurrentSlideType;                                  // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCUiMenuCharacterFace*>         FaceList;                                          // 0x0338(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  FaceVisibleList;                                   // 0x0348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         FaceVisibleCount;                                  // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContactCharacterCategoryNumber;                    // 0x035C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContactUpperCharacterFaceNum;                      // 0x0360(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContactRowerCharacterFaceNum;                      // 0x0364(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFocusFaceIndex;                             // 0x0368(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCUiMenuCharacterSelectRowType               CurrentFocusRowType;                               // 0x036C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCVariableGameMenuCharacterInfo> CharacterInfoList;                                 // 0x0370(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiMenuCharacter*                     ParentWidget;                                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterSelectButtonCustomNavigation(EUINavigation InNavigation, class APlayerController* InPlayerController);
	void StartPush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterSelect">();
	}
	static class URCUiMenuCharacterSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterSelect>();
	}
};
static_assert(alignof(URCUiMenuCharacterSelect) == 0x000008, "Wrong alignment on URCUiMenuCharacterSelect");
static_assert(sizeof(URCUiMenuCharacterSelect) == 0x000398, "Wrong size on URCUiMenuCharacterSelect");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_On) == 0x000300, "Member 'URCUiMenuCharacterSelect::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_Off) == 0x000308, "Member 'URCUiMenuCharacterSelect::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_SlideIn_L) == 0x000310, "Member 'URCUiMenuCharacterSelect::AN_SlideIn_L' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_SlideIn_R) == 0x000318, "Member 'URCUiMenuCharacterSelect::AN_SlideIn_R' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_SlideOut_L) == 0x000320, "Member 'URCUiMenuCharacterSelect::AN_SlideOut_L' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, AN_SlideOut_R) == 0x000328, "Member 'URCUiMenuCharacterSelect::AN_SlideOut_R' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, CurrentSlideType) == 0x000330, "Member 'URCUiMenuCharacterSelect::CurrentSlideType' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, FaceList) == 0x000338, "Member 'URCUiMenuCharacterSelect::FaceList' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, FaceVisibleList) == 0x000348, "Member 'URCUiMenuCharacterSelect::FaceVisibleList' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, FaceVisibleCount) == 0x000358, "Member 'URCUiMenuCharacterSelect::FaceVisibleCount' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, ContactCharacterCategoryNumber) == 0x00035C, "Member 'URCUiMenuCharacterSelect::ContactCharacterCategoryNumber' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, ContactUpperCharacterFaceNum) == 0x000360, "Member 'URCUiMenuCharacterSelect::ContactUpperCharacterFaceNum' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, ContactRowerCharacterFaceNum) == 0x000364, "Member 'URCUiMenuCharacterSelect::ContactRowerCharacterFaceNum' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, CurrentFocusFaceIndex) == 0x000368, "Member 'URCUiMenuCharacterSelect::CurrentFocusFaceIndex' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, CurrentFocusRowType) == 0x00036C, "Member 'URCUiMenuCharacterSelect::CurrentFocusRowType' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, CharacterInfoList) == 0x000370, "Member 'URCUiMenuCharacterSelect::CharacterInfoList' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterSelect, ParentWidget) == 0x000388, "Member 'URCUiMenuCharacterSelect::ParentWidget' has a wrong offset!");

// Class RC.RCReUiChousaEndButtonGuide
// 0x0028 (0x0300 - 0x02D8)
class URCReUiChousaEndButtonGuide final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChousaEndButtonGuideID;                            // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeChousaEndButtonGuide();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaEndButtonGuide">();
	}
	static class URCReUiChousaEndButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaEndButtonGuide>();
	}
};
static_assert(alignof(URCReUiChousaEndButtonGuide) == 0x000008, "Wrong alignment on URCReUiChousaEndButtonGuide");
static_assert(sizeof(URCReUiChousaEndButtonGuide) == 0x000300, "Wrong size on URCReUiChousaEndButtonGuide");
static_assert(offsetof(URCReUiChousaEndButtonGuide, AN_Start) == 0x0002D8, "Member 'URCReUiChousaEndButtonGuide::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaEndButtonGuide, AN_Wait) == 0x0002E0, "Member 'URCReUiChousaEndButtonGuide::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaEndButtonGuide, AN_Finish) == 0x0002E8, "Member 'URCReUiChousaEndButtonGuide::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaEndButtonGuide, WBP_ButtonGuide) == 0x0002F0, "Member 'URCReUiChousaEndButtonGuide::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCReUiChousaEndButtonGuide, ChousaEndButtonGuideID) == 0x0002F8, "Member 'URCReUiChousaEndButtonGuide::ChousaEndButtonGuideID' has a wrong offset!");

// Class RC.RCReUiChousaFPSCameraLimit
// 0x0060 (0x0338 - 0x02D8)
class URCReUiChousaFPSCameraLimit final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Initialize;                                     // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Left_In;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Left_Out;                                 // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Top_In;                                   // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Top_Out;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Right_In;                                 // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Right_Out;                                // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Bottom_In;                                // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Limit_Bottom_Out;                               // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaFPSCameraLimit">();
	}
	static class URCReUiChousaFPSCameraLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaFPSCameraLimit>();
	}
};
static_assert(alignof(URCReUiChousaFPSCameraLimit) == 0x000008, "Wrong alignment on URCReUiChousaFPSCameraLimit");
static_assert(sizeof(URCReUiChousaFPSCameraLimit) == 0x000338, "Wrong size on URCReUiChousaFPSCameraLimit");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Initialize) == 0x0002E0, "Member 'URCReUiChousaFPSCameraLimit::AN_Initialize' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Left_In) == 0x0002E8, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Left_In' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Left_Out) == 0x0002F0, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Left_Out' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Top_In) == 0x0002F8, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Top_In' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Top_Out) == 0x000300, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Top_Out' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Right_In) == 0x000308, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Right_In' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Right_Out) == 0x000310, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Right_Out' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Bottom_In) == 0x000318, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Bottom_In' has a wrong offset!");
static_assert(offsetof(URCReUiChousaFPSCameraLimit, AN_Limit_Bottom_Out) == 0x000320, "Member 'URCReUiChousaFPSCameraLimit::AN_Limit_Bottom_Out' has a wrong offset!");

// Class RC.RCReUiChousaGetKagi
// 0x00B8 (0x0390 - 0x02D8)
class URCReUiChousaGetKagi final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Update_Start;                                   // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Update_Wait;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Update_Finish;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_KagiName;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_KagiCaption;                                  // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   KagiName;                                          // 0x0318(0x0018)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class FText                                   KagiCaption;                                       // 0x0330(0x0018)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class FString                                 TexturePath;                                       // 0x0348(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Chapter;                                           // 0x0358(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KagiID;                                            // 0x035C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeChousaGetKagi();
	void Open();
	void SetData(class FName InKagiImage, const class FString& InKagiName, const class FString& InKagiCaption);
	void SetKagiData(class FName InKagiID, int32 InPhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaGetKagi">();
	}
	static class URCReUiChousaGetKagi* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaGetKagi>();
	}
};
static_assert(alignof(URCReUiChousaGetKagi) == 0x000008, "Wrong alignment on URCReUiChousaGetKagi");
static_assert(sizeof(URCReUiChousaGetKagi) == 0x000390, "Wrong size on URCReUiChousaGetKagi");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Start) == 0x0002D8, "Member 'URCReUiChousaGetKagi::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Wait) == 0x0002E0, "Member 'URCReUiChousaGetKagi::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Finish) == 0x0002E8, "Member 'URCReUiChousaGetKagi::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Update_Start) == 0x0002F0, "Member 'URCReUiChousaGetKagi::AN_Update_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Update_Wait) == 0x0002F8, "Member 'URCReUiChousaGetKagi::AN_Update_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, AN_Update_Finish) == 0x000300, "Member 'URCReUiChousaGetKagi::AN_Update_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, Text_KagiName) == 0x000308, "Member 'URCReUiChousaGetKagi::Text_KagiName' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, Text_KagiCaption) == 0x000310, "Member 'URCReUiChousaGetKagi::Text_KagiCaption' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, KagiName) == 0x000318, "Member 'URCReUiChousaGetKagi::KagiName' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, KagiCaption) == 0x000330, "Member 'URCReUiChousaGetKagi::KagiCaption' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, TexturePath) == 0x000348, "Member 'URCReUiChousaGetKagi::TexturePath' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, Chapter) == 0x000358, "Member 'URCReUiChousaGetKagi::Chapter' has a wrong offset!");
static_assert(offsetof(URCReUiChousaGetKagi, KagiID) == 0x00035C, "Member 'URCReUiChousaGetKagi::KagiID' has a wrong offset!");

// Class RC.RCReUiChousaPlace
// 0x0038 (0x0310 - 0x02D8)
class URCReUiChousaPlace final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Place;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeChousaPlace();
	void Open(class FName InMapID, class FName InAreaNameID);
	bool SetChousaPlace(class FName InMapID, class FName InAreaNameID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaPlace">();
	}
	static class URCReUiChousaPlace* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaPlace>();
	}
};
static_assert(alignof(URCReUiChousaPlace) == 0x000008, "Wrong alignment on URCReUiChousaPlace");
static_assert(sizeof(URCReUiChousaPlace) == 0x000310, "Wrong size on URCReUiChousaPlace");
static_assert(offsetof(URCReUiChousaPlace, AN_Start) == 0x0002D8, "Member 'URCReUiChousaPlace::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPlace, AN_Wait) == 0x0002E0, "Member 'URCReUiChousaPlace::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPlace, AN_Finish) == 0x0002E8, "Member 'URCReUiChousaPlace::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPlace, Text_Place) == 0x0002F0, "Member 'URCReUiChousaPlace::Text_Place' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewerCaption
// 0x0040 (0x0318 - 0x02D8)
class URCUiMenuCharacterViewerCaption final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Profile_Caption;                              // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiMenuCommonIcon*                    Icon_ListNew;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuCommonIcon*                    Icon_ListUpdate;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerCaption">();
	}
	static class URCUiMenuCharacterViewerCaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerCaption>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerCaption) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerCaption");
static_assert(sizeof(URCUiMenuCharacterViewerCaption) == 0x000318, "Wrong size on URCUiMenuCharacterViewerCaption");
static_assert(offsetof(URCUiMenuCharacterViewerCaption, Text_Profile_Caption) == 0x0002D8, "Member 'URCUiMenuCharacterViewerCaption::Text_Profile_Caption' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerCaption, Icon_ListNew) == 0x000300, "Member 'URCUiMenuCharacterViewerCaption::Icon_ListNew' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerCaption, Icon_ListUpdate) == 0x000308, "Member 'URCUiMenuCharacterViewerCaption::Icon_ListUpdate' has a wrong offset!");

// Class RC.RCReUiChousaPointer
// 0x00A8 (0x0380 - 0x02D8)
class URCReUiChousaPointer final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Def_Start;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Def;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Def_Finish;                                     // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Start;                                       // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On;                                             // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Out;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Finish;                                      // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Question_Start;                                 // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Question;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Question_Out;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Question_Push;                                  // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Question_Finish;                                // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x38];                                     // 0x0348(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decided();
	void FinishCursor();
	void FinishDefault();
	void FinishOverlap();
	struct FVector2D GetCursorDirection();
	struct FVector2D GetMousePos();
	float GetWidgetRadius();
	void InitializeChousaPointer();
	void OffMark();
	void OnMark();
	void SetQuestionFlag(bool bInQuestion);
	void SetTargetPosition(const struct FVector2D& In2DPosition);
	void SetTracingPosition(const struct FVector2D& In2DPosition, float InRadius);
	void StartDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaPointer">();
	}
	static class URCReUiChousaPointer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaPointer>();
	}
};
static_assert(alignof(URCReUiChousaPointer) == 0x000008, "Wrong alignment on URCReUiChousaPointer");
static_assert(sizeof(URCReUiChousaPointer) == 0x000380, "Wrong size on URCReUiChousaPointer");
static_assert(offsetof(URCReUiChousaPointer, AN_Def_Start) == 0x0002E0, "Member 'URCReUiChousaPointer::AN_Def_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Def) == 0x0002E8, "Member 'URCReUiChousaPointer::AN_Def' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Def_Finish) == 0x0002F0, "Member 'URCReUiChousaPointer::AN_Def_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_On_Start) == 0x0002F8, "Member 'URCReUiChousaPointer::AN_On_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_On) == 0x000300, "Member 'URCReUiChousaPointer::AN_On' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_On_Out) == 0x000308, "Member 'URCReUiChousaPointer::AN_On_Out' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Push) == 0x000310, "Member 'URCReUiChousaPointer::AN_Push' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_On_Finish) == 0x000318, "Member 'URCReUiChousaPointer::AN_On_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Question_Start) == 0x000320, "Member 'URCReUiChousaPointer::AN_Question_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Question) == 0x000328, "Member 'URCReUiChousaPointer::AN_Question' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Question_Out) == 0x000330, "Member 'URCReUiChousaPointer::AN_Question_Out' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Question_Push) == 0x000338, "Member 'URCReUiChousaPointer::AN_Question_Push' has a wrong offset!");
static_assert(offsetof(URCReUiChousaPointer, AN_Question_Finish) == 0x000340, "Member 'URCReUiChousaPointer::AN_Question_Finish' has a wrong offset!");

// Class RC.RCReUiChousaPointerParts
// 0x0008 (0x02E0 - 0x02D8)
class URCReUiChousaPointerParts final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Loop;                                           // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaPointerParts">();
	}
	static class URCReUiChousaPointerParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaPointerParts>();
	}
};
static_assert(alignof(URCReUiChousaPointerParts) == 0x000008, "Wrong alignment on URCReUiChousaPointerParts");
static_assert(sizeof(URCReUiChousaPointerParts) == 0x0002E0, "Wrong size on URCReUiChousaPointerParts");
static_assert(offsetof(URCReUiChousaPointerParts, AN_Loop) == 0x0002D8, "Member 'URCReUiChousaPointerParts::AN_Loop' has a wrong offset!");

// Class RC.RCReUiChousaQuestionText
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiChousaQuestionText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpTextBlock*                           SpText_Question;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaQuestionText">();
	}
	static class URCReUiChousaQuestionText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaQuestionText>();
	}
};
static_assert(alignof(URCReUiChousaQuestionText) == 0x000008, "Wrong alignment on URCReUiChousaQuestionText");
static_assert(sizeof(URCReUiChousaQuestionText) == 0x0002F0, "Wrong size on URCReUiChousaQuestionText");
static_assert(offsetof(URCReUiChousaQuestionText, AN_Start) == 0x0002D8, "Member 'URCReUiChousaQuestionText::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaQuestionText, AN_Finish) == 0x0002E0, "Member 'URCReUiChousaQuestionText::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaQuestionText, SpText_Question) == 0x0002E8, "Member 'URCReUiChousaQuestionText::SpText_Question' has a wrong offset!");

// Class RC.RCReUiChousaSpotSelectTelop
// 0x0010 (0x02E8 - 0x02D8)
class URCReUiChousaSpotSelectTelop final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeSpotSelectTelop();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaSpotSelectTelop">();
	}
	static class URCReUiChousaSpotSelectTelop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaSpotSelectTelop>();
	}
};
static_assert(alignof(URCReUiChousaSpotSelectTelop) == 0x000008, "Wrong alignment on URCReUiChousaSpotSelectTelop");
static_assert(sizeof(URCReUiChousaSpotSelectTelop) == 0x0002E8, "Wrong size on URCReUiChousaSpotSelectTelop");
static_assert(offsetof(URCReUiChousaSpotSelectTelop, AN_Start) == 0x0002D8, "Member 'URCReUiChousaSpotSelectTelop::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaSpotSelectTelop, AN_Finish) == 0x0002E0, "Member 'URCReUiChousaSpotSelectTelop::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewerPage
// 0x0040 (0x0318 - 0x02D8)
class URCUiMenuCharacterViewerPage final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Page_00;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_Page_01;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerPage">();
	}
	static class URCUiMenuCharacterViewerPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerPage>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerPage) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerPage");
static_assert(sizeof(URCUiMenuCharacterViewerPage) == 0x000318, "Wrong size on URCUiMenuCharacterViewerPage");
static_assert(offsetof(URCUiMenuCharacterViewerPage, Text_Page_00) == 0x0002D8, "Member 'URCUiMenuCharacterViewerPage::Text_Page_00' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerPage, Text_Page_01) == 0x0002F8, "Member 'URCUiMenuCharacterViewerPage::Text_Page_01' has a wrong offset!");

// Class RC.RCReUiChousaTarget
// 0x0048 (0x0320 - 0x02D8)
class URCReUiChousaTarget final : public URCUiWidget3D
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnSelection;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OffSelection;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInvestigated;                                   // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAccessible;                                     // 0x0309(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSelectClose;                                    // 0x030A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30B[0x15];                                     // 0x030B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void FinishSelect();
	float GetWidgetRadius();
	void InitializeChousaTarget();
	void Open(bool bInIsInvestigated);
	void StartSelect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaTarget">();
	}
	static class URCReUiChousaTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaTarget>();
	}
};
static_assert(alignof(URCReUiChousaTarget) == 0x000008, "Wrong alignment on URCReUiChousaTarget");
static_assert(sizeof(URCReUiChousaTarget) == 0x000320, "Wrong size on URCReUiChousaTarget");
static_assert(offsetof(URCReUiChousaTarget, AN_Start) == 0x0002E0, "Member 'URCReUiChousaTarget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, AN_Wait) == 0x0002E8, "Member 'URCReUiChousaTarget::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, AN_Finish) == 0x0002F0, "Member 'URCReUiChousaTarget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, AN_OnSelection) == 0x0002F8, "Member 'URCReUiChousaTarget::AN_OnSelection' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, AN_OffSelection) == 0x000300, "Member 'URCReUiChousaTarget::AN_OffSelection' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, bIsInvestigated) == 0x000308, "Member 'URCReUiChousaTarget::bIsInvestigated' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, bIsAccessible) == 0x000309, "Member 'URCReUiChousaTarget::bIsAccessible' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTarget, bIsSelectClose) == 0x00030A, "Member 'URCReUiChousaTarget::bIsSelectClose' has a wrong offset!");

// Class RC.RCReUiChousaTargetName
// 0x0078 (0x0358 - 0x02E0)
class URCReUiChousaTargetName final : public URCUiWidgetAccessable
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_TargetName;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_TargetName;                                // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TargetName_Line;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TargetName_PL;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x48];                                     // 0x0310(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTargetNamePosition();
	struct FVector2D GetTargetNameSize();
	void InitializeChousaTargetName();
	void InitializeChousaTargetName2(const struct FVector2D& InTargetNameDefaultPosition, float InTargetNameMoveSpeed);
	void SetTargetName(const class FString& InTargetName);
	void SetTargetNameDefaultPosition(const struct FVector2D& InTargetNameDefaultPosition);
	void SetTargetNameMoveSpeed(float InTargetNameMoveSpeed);
	void SetTargetNamePosition(const struct FVector2D& InTargetNamePosition);
	void SetTargetNamePositionDefault();
	void TargetOff();
	void TargetOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaTargetName">();
	}
	static class URCReUiChousaTargetName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaTargetName>();
	}
};
static_assert(alignof(URCReUiChousaTargetName) == 0x000008, "Wrong alignment on URCReUiChousaTargetName");
static_assert(sizeof(URCReUiChousaTargetName) == 0x000358, "Wrong size on URCReUiChousaTargetName");
static_assert(offsetof(URCReUiChousaTargetName, AN_On) == 0x0002E0, "Member 'URCReUiChousaTargetName::AN_On' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTargetName, AN_Off) == 0x0002E8, "Member 'URCReUiChousaTargetName::AN_Off' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTargetName, Text_TargetName) == 0x0002F0, "Member 'URCReUiChousaTargetName::Text_TargetName' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTargetName, Overlay_TargetName) == 0x0002F8, "Member 'URCReUiChousaTargetName::Overlay_TargetName' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTargetName, TargetName_Line) == 0x000300, "Member 'URCReUiChousaTargetName::TargetName_Line' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTargetName, TargetName_PL) == 0x000308, "Member 'URCReUiChousaTargetName::TargetName_PL' has a wrong offset!");

// Class RC.RCReUiChousaTelop
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiChousaTelop final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeChousaTelop();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaTelop">();
	}
	static class URCReUiChousaTelop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaTelop>();
	}
};
static_assert(alignof(URCReUiChousaTelop) == 0x000008, "Wrong alignment on URCReUiChousaTelop");
static_assert(sizeof(URCReUiChousaTelop) == 0x0002F0, "Wrong size on URCReUiChousaTelop");
static_assert(offsetof(URCReUiChousaTelop, AN_Start) == 0x0002D8, "Member 'URCReUiChousaTelop::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTelop, AN_Wait) == 0x0002E0, "Member 'URCReUiChousaTelop::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTelop, AN_Finish) == 0x0002E8, "Member 'URCReUiChousaTelop::AN_Finish' has a wrong offset!");

// Class RC.RCReUiChousaTelopSpotJudge
// 0x0028 (0x0300 - 0x02D8)
class URCReUiChousaTelopSpotJudge final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Mistake_Start;                                  // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Mistake_Finish;                                 // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Correct_Start;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Correct_Finish;                                 // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenCorrect();
	void OpenMistake();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiChousaTelopSpotJudge">();
	}
	static class URCReUiChousaTelopSpotJudge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiChousaTelopSpotJudge>();
	}
};
static_assert(alignof(URCReUiChousaTelopSpotJudge) == 0x000008, "Wrong alignment on URCReUiChousaTelopSpotJudge");
static_assert(sizeof(URCReUiChousaTelopSpotJudge) == 0x000300, "Wrong size on URCReUiChousaTelopSpotJudge");
static_assert(offsetof(URCReUiChousaTelopSpotJudge, AN_Mistake_Start) == 0x0002D8, "Member 'URCReUiChousaTelopSpotJudge::AN_Mistake_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTelopSpotJudge, AN_Mistake_Finish) == 0x0002E0, "Member 'URCReUiChousaTelopSpotJudge::AN_Mistake_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTelopSpotJudge, AN_Correct_Start) == 0x0002E8, "Member 'URCReUiChousaTelopSpotJudge::AN_Correct_Start' has a wrong offset!");
static_assert(offsetof(URCReUiChousaTelopSpotJudge, AN_Correct_Finish) == 0x0002F0, "Member 'URCReUiChousaTelopSpotJudge::AN_Correct_Finish' has a wrong offset!");

// Class RC.RCUiMenuCommonTabSet
// 0x0040 (0x0320 - 0x02E0)
class URCUiMenuCommonTabSet : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_UnSelect;                                       // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Switch_Select;                                  // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select;                                         // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Switch_Unselect;                                // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCommonTabSet">();
	}
	static class URCUiMenuCommonTabSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCommonTabSet>();
	}
};
static_assert(alignof(URCUiMenuCommonTabSet) == 0x000008, "Wrong alignment on URCUiMenuCommonTabSet");
static_assert(sizeof(URCUiMenuCommonTabSet) == 0x000320, "Wrong size on URCUiMenuCommonTabSet");
static_assert(offsetof(URCUiMenuCommonTabSet, AN_UnSelect) == 0x0002F0, "Member 'URCUiMenuCommonTabSet::AN_UnSelect' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonTabSet, AN_Switch_Select) == 0x0002F8, "Member 'URCUiMenuCommonTabSet::AN_Switch_Select' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonTabSet, AN_Select) == 0x000300, "Member 'URCUiMenuCommonTabSet::AN_Select' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonTabSet, AN_Switch_Unselect) == 0x000308, "Member 'URCUiMenuCommonTabSet::AN_Switch_Unselect' has a wrong offset!");
static_assert(offsetof(URCUiMenuCommonTabSet, AN_Off) == 0x000310, "Member 'URCUiMenuCommonTabSet::AN_Off' has a wrong offset!");

// Class RC.RCReUiFigureInformation
// 0x0048 (0x0320 - 0x02D8)
class URCReUiFigureInformation final : public URCUiWidgetBase
{
public:
	class UImage*                                 Img_Replace_Figure;                                // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpTextBlock*                           Txt_HintMessage;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpTextBlock*                           Txt_FigureName;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageCursor*                   ReTalk_Cursor;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   currentCharaID;                                    // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         countDispTime;                                     // 0x0318(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDispCheck;                                       // 0x031C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiFigureInformation">();
	}
	static class URCReUiFigureInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiFigureInformation>();
	}
};
static_assert(alignof(URCReUiFigureInformation) == 0x000008, "Wrong alignment on URCReUiFigureInformation");
static_assert(sizeof(URCReUiFigureInformation) == 0x000320, "Wrong size on URCReUiFigureInformation");
static_assert(offsetof(URCReUiFigureInformation, Img_Replace_Figure) == 0x0002D8, "Member 'URCReUiFigureInformation::Img_Replace_Figure' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, Txt_HintMessage) == 0x0002E0, "Member 'URCReUiFigureInformation::Txt_HintMessage' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, Txt_FigureName) == 0x0002E8, "Member 'URCReUiFigureInformation::Txt_FigureName' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, ReTalk_Cursor) == 0x0002F0, "Member 'URCReUiFigureInformation::ReTalk_Cursor' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, AN_Wait) == 0x0002F8, "Member 'URCReUiFigureInformation::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, AN_Start) == 0x000300, "Member 'URCReUiFigureInformation::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, AN_Finish) == 0x000308, "Member 'URCReUiFigureInformation::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, currentCharaID) == 0x000310, "Member 'URCReUiFigureInformation::currentCharaID' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, countDispTime) == 0x000318, "Member 'URCReUiFigureInformation::countDispTime' has a wrong offset!");
static_assert(offsetof(URCReUiFigureInformation, isDispCheck) == 0x00031C, "Member 'URCReUiFigureInformation::isDispCheck' has a wrong offset!");

// Class RC.RCReUiLocation
// 0x0038 (0x0310 - 0x02D8)
class URCReUiLocation final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeLocation();
	void Open();
	bool SetLocation(class FName InMapID, class FName InAreaNameID);
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiLocation">();
	}
	static class URCReUiLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiLocation>();
	}
};
static_assert(alignof(URCReUiLocation) == 0x000008, "Wrong alignment on URCReUiLocation");
static_assert(sizeof(URCReUiLocation) == 0x000310, "Wrong size on URCReUiLocation");
static_assert(offsetof(URCReUiLocation, AN_Start) == 0x0002D8, "Member 'URCReUiLocation::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiLocation, AN_Wait) == 0x0002E0, "Member 'URCReUiLocation::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiLocation, AN_Finish) == 0x0002E8, "Member 'URCReUiLocation::AN_Finish' has a wrong offset!");

// Class RC.RCReUiMarker
// 0x0038 (0x0318 - 0x02E0)
class URCReUiMarker final : public URCUiWidgetAccessable
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Text;                                              // 0x02F8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_PlaceName;                                    // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMarker">();
	}
	static class URCReUiMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMarker>();
	}
};
static_assert(alignof(URCReUiMarker) == 0x000008, "Wrong alignment on URCReUiMarker");
static_assert(sizeof(URCReUiMarker) == 0x000318, "Wrong size on URCReUiMarker");
static_assert(offsetof(URCReUiMarker, AN_Start) == 0x0002E0, "Member 'URCReUiMarker::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMarker, AN_Wait) == 0x0002E8, "Member 'URCReUiMarker::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMarker, AN_Finish) == 0x0002F0, "Member 'URCReUiMarker::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMarker, Text) == 0x0002F8, "Member 'URCReUiMarker::Text' has a wrong offset!");
static_assert(offsetof(URCReUiMarker, Text_PlaceName) == 0x000310, "Member 'URCReUiMarker::Text_PlaceName' has a wrong offset!");

// Class RC.RCReUiMessageCursor
// 0x0050 (0x0328 - 0x02D8)
class URCReUiMessageCursor final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x30];                                     // 0x02F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPushStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageCursor">();
	}
	static class URCReUiMessageCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageCursor>();
	}
};
static_assert(alignof(URCReUiMessageCursor) == 0x000008, "Wrong alignment on URCReUiMessageCursor");
static_assert(sizeof(URCReUiMessageCursor) == 0x000328, "Wrong size on URCReUiMessageCursor");
static_assert(offsetof(URCReUiMessageCursor, AN_Start) == 0x0002D8, "Member 'URCReUiMessageCursor::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursor, AN_Wait) == 0x0002E0, "Member 'URCReUiMessageCursor::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursor, AN_Finish) == 0x0002E8, "Member 'URCReUiMessageCursor::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursor, AN_Push) == 0x0002F0, "Member 'URCReUiMessageCursor::AN_Push' has a wrong offset!");

// Class RC.RCReUiMessageCursorAuto
// 0x0020 (0x02F8 - 0x02D8)
class URCReUiMessageCursorAuto final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageCursorAuto">();
	}
	static class URCReUiMessageCursorAuto* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageCursorAuto>();
	}
};
static_assert(alignof(URCReUiMessageCursorAuto) == 0x000008, "Wrong alignment on URCReUiMessageCursorAuto");
static_assert(sizeof(URCReUiMessageCursorAuto) == 0x0002F8, "Wrong size on URCReUiMessageCursorAuto");
static_assert(offsetof(URCReUiMessageCursorAuto, AN_Start) == 0x0002D8, "Member 'URCReUiMessageCursorAuto::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursorAuto, AN_Wait) == 0x0002E0, "Member 'URCReUiMessageCursorAuto::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursorAuto, AN_Finish) == 0x0002E8, "Member 'URCReUiMessageCursorAuto::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageCursorAuto, WBP_ButtonGuide) == 0x0002F0, "Member 'URCReUiMessageCursorAuto::WBP_ButtonGuide' has a wrong offset!");

// Class RC.RCReUiMessageCursorParts
// 0x0008 (0x02E0 - 0x02D8)
class URCReUiMessageCursorParts : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Loop;                                           // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageCursorParts">();
	}
	static class URCReUiMessageCursorParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageCursorParts>();
	}
};
static_assert(alignof(URCReUiMessageCursorParts) == 0x000008, "Wrong alignment on URCReUiMessageCursorParts");
static_assert(sizeof(URCReUiMessageCursorParts) == 0x0002E0, "Wrong size on URCReUiMessageCursorParts");
static_assert(offsetof(URCReUiMessageCursorParts, AN_Loop) == 0x0002D8, "Member 'URCReUiMessageCursorParts::AN_Loop' has a wrong offset!");

// Class RC.RCReUiMessageFace
// 0x0080 (0x0358 - 0x02D8)
class URCReUiMessageFace final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x60];                                     // 0x02F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadAheadRequest(int32 InCharaFaceID, int32 InFacialID);
	void SetFace(int32 InCharaFaceID, int32 InFacialID, bool bInPlayEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageFace">();
	}
	static class URCReUiMessageFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageFace>();
	}
};
static_assert(alignof(URCReUiMessageFace) == 0x000008, "Wrong alignment on URCReUiMessageFace");
static_assert(sizeof(URCReUiMessageFace) == 0x000358, "Wrong size on URCReUiMessageFace");
static_assert(offsetof(URCReUiMessageFace, AN_Start) == 0x0002D8, "Member 'URCReUiMessageFace::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFace, AN_Wait) == 0x0002E0, "Member 'URCReUiMessageFace::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFace, AN_Finish) == 0x0002E8, "Member 'URCReUiMessageFace::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFace, AN_Change) == 0x0002F0, "Member 'URCReUiMessageFace::AN_Change' has a wrong offset!");

// Class RC.RCReUiMessageFastForward
// 0x0030 (0x0308 - 0x02D8)
class URCReUiMessageFastForward final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Fastforward_Icon;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageFastForward">();
	}
	static class URCReUiMessageFastForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageFastForward>();
	}
};
static_assert(alignof(URCReUiMessageFastForward) == 0x000008, "Wrong alignment on URCReUiMessageFastForward");
static_assert(sizeof(URCReUiMessageFastForward) == 0x000308, "Wrong size on URCReUiMessageFastForward");
static_assert(offsetof(URCReUiMessageFastForward, AN_Start) == 0x0002D8, "Member 'URCReUiMessageFastForward::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFastForward, AN_Wait) == 0x0002E0, "Member 'URCReUiMessageFastForward::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFastForward, AN_Finish) == 0x0002E8, "Member 'URCReUiMessageFastForward::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFastForward, WBP_ButtonGuide) == 0x0002F0, "Member 'URCReUiMessageFastForward::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCReUiMessageFastForward, Fastforward_Icon) == 0x0002F8, "Member 'URCReUiMessageFastForward::Fastforward_Icon' has a wrong offset!");

// Class RC.RCUiButtonGuide
// 0x0038 (0x0310 - 0x02D8)
class URCUiButtonGuide : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeButtonGuide();
	void Open(class FName InModeID, bool bInShowSingleLine);
	void SetGuideText(class FName InModeID, bool bInShowSingleLine);
	void SetInputFromButtonGuide(ERCInputKeyType InType);
	void StartRun();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiButtonGuide">();
	}
	static class URCUiButtonGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiButtonGuide>();
	}
};
static_assert(alignof(URCUiButtonGuide) == 0x000008, "Wrong alignment on URCUiButtonGuide");
static_assert(sizeof(URCUiButtonGuide) == 0x000310, "Wrong size on URCUiButtonGuide");
static_assert(offsetof(URCUiButtonGuide, AN_Start) == 0x0002D8, "Member 'URCUiButtonGuide::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiButtonGuide, AN_Wait) == 0x0002E0, "Member 'URCUiButtonGuide::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiButtonGuide, AN_Finish) == 0x0002E8, "Member 'URCUiButtonGuide::AN_Finish' has a wrong offset!");

// Class RC.RCReUiMessageNameplate
// 0x0088 (0x0360 - 0x02D8)
class URCReUiMessageNameplate final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Change;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      SpText_CharacterName_SysText;                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x60];                                     // 0x0300(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadAheadRequest(int32 InCharaNameID, int32 InNameSubID);
	void SetNameplate(int32 InCharaNameID, int32 InNameSubID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageNameplate">();
	}
	static class URCReUiMessageNameplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageNameplate>();
	}
};
static_assert(alignof(URCReUiMessageNameplate) == 0x000008, "Wrong alignment on URCReUiMessageNameplate");
static_assert(sizeof(URCReUiMessageNameplate) == 0x000360, "Wrong size on URCReUiMessageNameplate");
static_assert(offsetof(URCReUiMessageNameplate, AN_Start) == 0x0002D8, "Member 'URCReUiMessageNameplate::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageNameplate, AN_Wait) == 0x0002E0, "Member 'URCReUiMessageNameplate::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageNameplate, AN_Finish) == 0x0002E8, "Member 'URCReUiMessageNameplate::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageNameplate, AN_Change) == 0x0002F0, "Member 'URCReUiMessageNameplate::AN_Change' has a wrong offset!");
static_assert(offsetof(URCReUiMessageNameplate, SpText_CharacterName_SysText) == 0x0002F8, "Member 'URCReUiMessageNameplate::SpText_CharacterName_SysText' has a wrong offset!");

// Class RC.RCReUiMessageWindow
// 0x0190 (0x0468 - 0x02D8)
class URCReUiMessageWindow final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScriptString;                                      // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         StringLine;                                        // 0x0308(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TextInterval;                                      // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HandleTimer;                                       // 0x0320(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEndOfText;                                      // 0x0328(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCReUiMessageCursor*                   MsgCursor;                                         // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageNameplate*                Nameplate;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageFace*                     FaceWidget;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TalkDelay;                                         // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0xC];                                      // 0x034C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoPlay;                                       // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoWaitPushTimer;                                 // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoDelay;                                         // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoDelayFromBP;                                   // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                TalkWindow;                                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_EffectsArea_FullScreen;                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                TextLines;                                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      R_TextLine_01;                                     // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      R_TextLine_02;                                     // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0xC0];                                     // 0x03A8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMessage();
	void Close();
	int32 GetMessStatusInt();
	bool GetSkipTyping();
	void InitializeMessageWindow();
	void Open(int32 InCharaNameID, int32 InNameSubID, int32 InCharaFaceID, int32 InFacialID);
	void SetForceAutoFlag(bool bForceAuto, bool bShowAutoIcon);
	void SetForceTextSpeedSettings(bool bInIsForceTextSpeed, int32 InForceTextSpeed);
	void SetMessageSpeed();
	void SetShakeData(float InWidthX, float InWidthY, float InInterval);
	void SetText(int32 InCharaNameID, int32 InNameSubID, int32 InCharaFaceID, int32 InFacialID, const class FString& inString, float InDelay);
	void SetTextData(int32 InCharaNameID, int32 InNameSubID, int32 InCharaFaceID, int32 InFacialID, class FName InSpeakerID, const class FString& inString, float InDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMessageWindow">();
	}
	static class URCReUiMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMessageWindow>();
	}
};
static_assert(alignof(URCReUiMessageWindow) == 0x000008, "Wrong alignment on URCReUiMessageWindow");
static_assert(sizeof(URCReUiMessageWindow) == 0x000468, "Wrong size on URCReUiMessageWindow");
static_assert(offsetof(URCReUiMessageWindow, AN_Start) == 0x0002E0, "Member 'URCReUiMessageWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, AN_Wait) == 0x0002E8, "Member 'URCReUiMessageWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, AN_Finish) == 0x0002F0, "Member 'URCReUiMessageWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, ScriptString) == 0x0002F8, "Member 'URCReUiMessageWindow::ScriptString' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, StringLine) == 0x000308, "Member 'URCReUiMessageWindow::StringLine' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, TextInterval) == 0x000318, "Member 'URCReUiMessageWindow::TextInterval' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, HandleTimer) == 0x000320, "Member 'URCReUiMessageWindow::HandleTimer' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, bIsEndOfText) == 0x000328, "Member 'URCReUiMessageWindow::bIsEndOfText' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, MsgCursor) == 0x000330, "Member 'URCReUiMessageWindow::MsgCursor' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, Nameplate) == 0x000338, "Member 'URCReUiMessageWindow::Nameplate' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, FaceWidget) == 0x000340, "Member 'URCReUiMessageWindow::FaceWidget' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, TalkDelay) == 0x000348, "Member 'URCReUiMessageWindow::TalkDelay' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, bIsAutoPlay) == 0x000358, "Member 'URCReUiMessageWindow::bIsAutoPlay' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, AutoWaitPushTimer) == 0x00035C, "Member 'URCReUiMessageWindow::AutoWaitPushTimer' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, AutoDelay) == 0x000360, "Member 'URCReUiMessageWindow::AutoDelay' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, AutoDelayFromBP) == 0x000364, "Member 'URCReUiMessageWindow::AutoDelayFromBP' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, TalkWindow) == 0x000380, "Member 'URCReUiMessageWindow::TalkWindow' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, IMG_EffectsArea_FullScreen) == 0x000388, "Member 'URCReUiMessageWindow::IMG_EffectsArea_FullScreen' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, TextLines) == 0x000390, "Member 'URCReUiMessageWindow::TextLines' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, R_TextLine_01) == 0x000398, "Member 'URCReUiMessageWindow::R_TextLine_01' has a wrong offset!");
static_assert(offsetof(URCReUiMessageWindow, R_TextLine_02) == 0x0003A0, "Member 'URCReUiMessageWindow::R_TextLine_02' has a wrong offset!");

// Class RC.RCReUiMiniMap
// 0x0248 (0x0520 - 0x02D8)
class URCReUiMiniMap final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x90];                                     // 0x02F0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TexturePath;                                       // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x190];                                    // 0x0390(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void CreateIcon();
	void InitializeMiniMap();
	void Open();
	bool SetLocation(class FName InMapID, class FName InAreaNameID);
	void SetMapMode(bool bInIsFixNorth);
	void SetMapScale(float InScale);
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMiniMap">();
	}
	static class URCReUiMiniMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMiniMap>();
	}
};
static_assert(alignof(URCReUiMiniMap) == 0x000008, "Wrong alignment on URCReUiMiniMap");
static_assert(sizeof(URCReUiMiniMap) == 0x000520, "Wrong size on URCReUiMiniMap");
static_assert(offsetof(URCReUiMiniMap, AN_Start) == 0x0002D8, "Member 'URCReUiMiniMap::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiMiniMap, AN_Wait) == 0x0002E0, "Member 'URCReUiMiniMap::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiMiniMap, AN_Finish) == 0x0002E8, "Member 'URCReUiMiniMap::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiMiniMap, TexturePath) == 0x000380, "Member 'URCReUiMiniMap::TexturePath' has a wrong offset!");

// Class RC.RCReUiMiniMapGoal
// 0x0010 (0x02E8 - 0x02D8)
class URCReUiMiniMapGoal final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMiniMapGoal">();
	}
	static class URCReUiMiniMapGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMiniMapGoal>();
	}
};
static_assert(alignof(URCReUiMiniMapGoal) == 0x000008, "Wrong alignment on URCReUiMiniMapGoal");
static_assert(sizeof(URCReUiMiniMapGoal) == 0x0002E8, "Wrong size on URCReUiMiniMapGoal");

// Class RC.RCUiCutInText
// 0x0040 (0x0318 - 0x02D8)
class URCUiCutInText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_TextField;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeCutIn();
	void Open();
	void SetCutInText(class FName InCutInID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiCutInText">();
	}
	static class URCUiCutInText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiCutInText>();
	}
};
static_assert(alignof(URCUiCutInText) == 0x000008, "Wrong alignment on URCUiCutInText");
static_assert(sizeof(URCUiCutInText) == 0x000318, "Wrong size on URCUiCutInText");
static_assert(offsetof(URCUiCutInText, AN_Start) == 0x0002D8, "Member 'URCUiCutInText::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiCutInText, AN_Wait) == 0x0002E0, "Member 'URCUiCutInText::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiCutInText, AN_Finish) == 0x0002E8, "Member 'URCUiCutInText::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiCutInText, Txt_TextField) == 0x0002F0, "Member 'URCUiCutInText::Txt_TextField' has a wrong offset!");

// Class RC.RCReUiMiniMapIcon
// 0x0008 (0x02E0 - 0x02D8)
class URCReUiMiniMapIcon final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiMiniMapIcon">();
	}
	static class URCReUiMiniMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiMiniMapIcon>();
	}
};
static_assert(alignof(URCReUiMiniMapIcon) == 0x000008, "Wrong alignment on URCReUiMiniMapIcon");
static_assert(sizeof(URCReUiMiniMapIcon) == 0x0002E0, "Wrong size on URCReUiMiniMapIcon");

// Class RC.RCReUiSelectBar
// 0x0040 (0x0360 - 0x0320)
class URCReUiSelectBar final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OffCursor;                                      // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_000;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiSelectBar">();
	}
	static class URCReUiSelectBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiSelectBar>();
	}
};
static_assert(alignof(URCReUiSelectBar) == 0x000008, "Wrong alignment on URCReUiSelectBar");
static_assert(sizeof(URCReUiSelectBar) == 0x000360, "Wrong size on URCReUiSelectBar");
static_assert(offsetof(URCReUiSelectBar, AN_OnCursor) == 0x000320, "Member 'URCReUiSelectBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCReUiSelectBar, AN_Push) == 0x000328, "Member 'URCReUiSelectBar::AN_Push' has a wrong offset!");
static_assert(offsetof(URCReUiSelectBar, AN_OffCursor) == 0x000330, "Member 'URCReUiSelectBar::AN_OffCursor' has a wrong offset!");
static_assert(offsetof(URCReUiSelectBar, Text_000) == 0x000338, "Member 'URCReUiSelectBar::Text_000' has a wrong offset!");

// Class RC.RCReUiSelectWindow
// 0x0088 (0x0380 - 0x02F8)
class URCReUiSelectWindow final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_Question;                                      // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x60];                                     // 0x0320(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeSelectBar();
	void NativeTick(const struct FGeometry& MyGeometry, float InDeltaTime);
	void Open(int32 SelectNum, class FName InTextID);
	void SelectWindowCustomNavigation(EUINavigation InNavigation, class APlayerController* InPlayerController);
	void StartPush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiSelectWindow">();
	}
	static class URCReUiSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiSelectWindow>();
	}
};
static_assert(alignof(URCReUiSelectWindow) == 0x000008, "Wrong alignment on URCReUiSelectWindow");
static_assert(sizeof(URCReUiSelectWindow) == 0x000380, "Wrong size on URCReUiSelectWindow");
static_assert(offsetof(URCReUiSelectWindow, AN_Start) == 0x000300, "Member 'URCReUiSelectWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiSelectWindow, AN_Wait) == 0x000308, "Member 'URCReUiSelectWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiSelectWindow, AN_Finish) == 0x000310, "Member 'URCReUiSelectWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiSelectWindow, Txt_Question) == 0x000318, "Member 'URCReUiSelectWindow::Txt_Question' has a wrong offset!");

// Class RC.RCReUiShinigamiBalloon
// 0x0028 (0x0300 - 0x02D8)
class URCReUiShinigamiBalloon final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSetText;                                        // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAutoPlay;                                       // 0x02E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA[0x16];                                     // 0x02EA(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearText();
	void Close();
	void InitializeShinigamiBalloon();
	void Open();
	void SetAuto(bool bInIsAutoPlay);
	void SetBalloonData(const class FString& inString);
	void SetShakeData(float InWidthX, float InWidthY, float InInterval);
	void WaitOutside();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiShinigamiBalloon">();
	}
	static class URCReUiShinigamiBalloon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiShinigamiBalloon>();
	}
};
static_assert(alignof(URCReUiShinigamiBalloon) == 0x000008, "Wrong alignment on URCReUiShinigamiBalloon");
static_assert(sizeof(URCReUiShinigamiBalloon) == 0x000300, "Wrong size on URCReUiShinigamiBalloon");
static_assert(offsetof(URCReUiShinigamiBalloon, bIsSetText) == 0x0002E8, "Member 'URCReUiShinigamiBalloon::bIsSetText' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloon, bIsAutoPlay) == 0x0002E9, "Member 'URCReUiShinigamiBalloon::bIsAutoPlay' has a wrong offset!");

// Class RC.RCUiGenericButtonParts
// 0x0020 (0x0340 - 0x0320)
class URCUiGenericButtonParts : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On;                                             // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Center;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiGenericButtonParts">();
	}
	static class URCUiGenericButtonParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiGenericButtonParts>();
	}
};
static_assert(alignof(URCUiGenericButtonParts) == 0x000008, "Wrong alignment on URCUiGenericButtonParts");
static_assert(sizeof(URCUiGenericButtonParts) == 0x000340, "Wrong size on URCUiGenericButtonParts");
static_assert(offsetof(URCUiGenericButtonParts, AN_Def) == 0x000320, "Member 'URCUiGenericButtonParts::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiGenericButtonParts, AN_On) == 0x000328, "Member 'URCUiGenericButtonParts::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiGenericButtonParts, AN_Push) == 0x000330, "Member 'URCUiGenericButtonParts::AN_Push' has a wrong offset!");
static_assert(offsetof(URCUiGenericButtonParts, Text_Center) == 0x000338, "Member 'URCUiGenericButtonParts::Text_Center' has a wrong offset!");

// Class RC.RCReUiShinigamiBalloonCloud
// 0x0018 (0x02F0 - 0x02D8)
class URCReUiShinigamiBalloonCloud final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiShinigamiBalloonCloud">();
	}
	static class URCReUiShinigamiBalloonCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiShinigamiBalloonCloud>();
	}
};
static_assert(alignof(URCReUiShinigamiBalloonCloud) == 0x000008, "Wrong alignment on URCReUiShinigamiBalloonCloud");
static_assert(sizeof(URCReUiShinigamiBalloonCloud) == 0x0002F0, "Wrong size on URCReUiShinigamiBalloonCloud");
static_assert(offsetof(URCReUiShinigamiBalloonCloud, AN_Start) == 0x0002D8, "Member 'URCReUiShinigamiBalloonCloud::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonCloud, AN_Wait) == 0x0002E0, "Member 'URCReUiShinigamiBalloonCloud::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonCloud, AN_Finish) == 0x0002E8, "Member 'URCReUiShinigamiBalloonCloud::AN_Finish' has a wrong offset!");

// Class RC.RCReUiShinigamiBalloonText
// 0x00F0 (0x03C8 - 0x02D8)
class URCReUiShinigamiBalloonText final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScriptString;                                      // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         StringLine;                                        // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine1;                                         // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine2;                                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine3;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine4;                                         // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine5;                                         // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine6;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x48];                                     // 0x0340(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WholeTag;                                          // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShake;                                          // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShakeType;                                         // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeInterval;                                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ShakeWidth;                                        // 0x03BC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCReUiShinigamiBalloonText">();
	}
	static class URCReUiShinigamiBalloonText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCReUiShinigamiBalloonText>();
	}
};
static_assert(alignof(URCReUiShinigamiBalloonText) == 0x000008, "Wrong alignment on URCReUiShinigamiBalloonText");
static_assert(sizeof(URCReUiShinigamiBalloonText) == 0x0003C8, "Wrong size on URCReUiShinigamiBalloonText");
static_assert(offsetof(URCReUiShinigamiBalloonText, AN_Start) == 0x0002D8, "Member 'URCReUiShinigamiBalloonText::AN_Start' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, AN_Wait) == 0x0002E0, "Member 'URCReUiShinigamiBalloonText::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, AN_Finish) == 0x0002E8, "Member 'URCReUiShinigamiBalloonText::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, ScriptString) == 0x0002F0, "Member 'URCReUiShinigamiBalloonText::ScriptString' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, StringLine) == 0x000300, "Member 'URCReUiShinigamiBalloonText::StringLine' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine1) == 0x000310, "Member 'URCReUiShinigamiBalloonText::TextLine1' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine2) == 0x000318, "Member 'URCReUiShinigamiBalloonText::TextLine2' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine3) == 0x000320, "Member 'URCReUiShinigamiBalloonText::TextLine3' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine4) == 0x000328, "Member 'URCReUiShinigamiBalloonText::TextLine4' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine5) == 0x000330, "Member 'URCReUiShinigamiBalloonText::TextLine5' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, TextLine6) == 0x000338, "Member 'URCReUiShinigamiBalloonText::TextLine6' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, WholeTag) == 0x000388, "Member 'URCReUiShinigamiBalloonText::WholeTag' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, bIsShake) == 0x000398, "Member 'URCReUiShinigamiBalloonText::bIsShake' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, ShakeType) == 0x0003A0, "Member 'URCReUiShinigamiBalloonText::ShakeType' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, ShakeInterval) == 0x0003B8, "Member 'URCReUiShinigamiBalloonText::ShakeInterval' has a wrong offset!");
static_assert(offsetof(URCReUiShinigamiBalloonText, ShakeWidth) == 0x0003BC, "Member 'URCReUiShinigamiBalloonText::ShakeWidth' has a wrong offset!");

// Class RC.RCSaveDevelopment
// 0x0038 (0x0070 - 0x0038)
class URCSaveDevelopment final : public URCSaveGame
{
public:
	struct FRCDevelopmentSave                     DevelopmentSave;                                   // 0x0038(0x0034)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveDevelopment">();
	}
	static class URCSaveDevelopment* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveDevelopment>();
	}
};
static_assert(alignof(URCSaveDevelopment) == 0x000008, "Wrong alignment on URCSaveDevelopment");
static_assert(sizeof(URCSaveDevelopment) == 0x000070, "Wrong size on URCSaveDevelopment");
static_assert(offsetof(URCSaveDevelopment, DevelopmentSave) == 0x000038, "Member 'URCSaveDevelopment::DevelopmentSave' has a wrong offset!");

// Class RC.RCTitleEvalPlayerController
// 0x0008 (0x05A8 - 0x05A0)
class ARCTitleEvalPlayerController final : public ARCMenuPlayerController
{
public:
	class URCEvaluationTitle*                     TitleEvalWidget;                                   // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleEvalPlayerController">();
	}
	static class ARCTitleEvalPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitleEvalPlayerController>();
	}
};
static_assert(alignof(ARCTitleEvalPlayerController) == 0x000008, "Wrong alignment on ARCTitleEvalPlayerController");
static_assert(sizeof(ARCTitleEvalPlayerController) == 0x0005A8, "Wrong size on ARCTitleEvalPlayerController");
static_assert(offsetof(ARCTitleEvalPlayerController, TitleEvalWidget) == 0x0005A0, "Member 'ARCTitleEvalPlayerController::TitleEvalWidget' has a wrong offset!");

// Class RC.RCSaveGameBFL
// 0x0000 (0x0028 - 0x0028)
class URCSaveGameBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool Check_SaveGameData();
	static bool Check_SaveGameDataStoryMode(ERCStoryMode InStoryMode);
	static int32 Get_SaveGameDataList(TArray<struct FRCSaveSlotInfo>* OutSlotList);
	static class FString GetErrorText();
	static ERCOptionCharacterDraw GetOptionCharacterDraw();
	static bool GetOptionFinaleSkipEnable();
	static ERCOptionMobQuality GetOptionMobQuality();
	static ERCMovieQuality GetOptionMovieQuality();
	static ERCOptionSubLevel GetOptionSubLevelQuality();
	static ERCOptionUiQuality GetOptionUiQuality();
	static ERCVoiceLanguage GetOptionVoiceLanguage();
	static bool IsError();
	static bool IsFinished();
	static bool IsPlayerMove();
	static void RestartPlayerMove();
	static void SetOptionCharacterDraw(ERCOptionCharacterDraw InOptionCharacterDraw);
	static void SetOptionMobQuality(ERCOptionMobQuality InMobQuality);
	static void SetOptionMovieQuality(ERCMovieQuality InMovieQuality);
	static void SetOptionSubLevelQuality(ERCOptionSubLevel InOptionSubLevel);
	static void SetPlayerControllerInfo();
	static bool StartLoad_DevelopmentData();
	static bool StartLoad_LastSaveGameData(ERCStoryMode InStoryMode);
	static bool StartLoad_SaveGameData(ERCSaveDataType InType, int32 InSlot);
	static bool StartLoad_SaveGameDataMemory();
	static bool StartLoad_SaveGameDataStoryMode(ERCStoryMode InStoryMode, ERCSaveDataType InType, int32 InSlot);
	static bool StartLoad_SystemeData();
	static bool StartSave_AutoSaveGameData();
	static bool StartSave_AutoSaveGameDataStoryMode(ERCStoryMode InStoryMode);
	static bool StartSave_DevelopmentData();
	static bool StartSave_SaveGameData(ERCSaveDataType InType, int32 InSlot);
	static bool StartSave_SaveGameDataMemory();
	static bool StartSave_SaveGameDataNazoManualSave(ERCSaveDataType InType, int32 InSlot);
	static bool StartSave_SaveGameDataStoryMode(ERCStoryMode InStoryMode, ERCSaveDataType InType, int32 InSlot);
	static bool StartSave_SystemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveGameBFL">();
	}
	static class URCSaveGameBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveGameBFL>();
	}
};
static_assert(alignof(URCSaveGameBFL) == 0x000008, "Wrong alignment on URCSaveGameBFL");
static_assert(sizeof(URCSaveGameBFL) == 0x000028, "Wrong size on URCSaveGameBFL");

// Class RC.RCSaveGameData
// 0x0310 (0x0348 - 0x0038)
class URCSaveGameData final : public URCSaveGame
{
public:
	struct FRCVariableSave                        VariableSave;                                      // 0x0038(0x0280)(NativeAccessSpecifierPrivate)
	struct FRCPlayerSave                          PlayerSave;                                        // 0x02B8(0x0048)(NativeAccessSpecifierPrivate)
	struct FRCLevelSave                           LevelSave;                                         // 0x0300(0x0048)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveGameData">();
	}
	static class URCSaveGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveGameData>();
	}
};
static_assert(alignof(URCSaveGameData) == 0x000008, "Wrong alignment on URCSaveGameData");
static_assert(sizeof(URCSaveGameData) == 0x000348, "Wrong size on URCSaveGameData");
static_assert(offsetof(URCSaveGameData, VariableSave) == 0x000038, "Member 'URCSaveGameData::VariableSave' has a wrong offset!");
static_assert(offsetof(URCSaveGameData, PlayerSave) == 0x0002B8, "Member 'URCSaveGameData::PlayerSave' has a wrong offset!");
static_assert(offsetof(URCSaveGameData, LevelSave) == 0x000300, "Member 'URCSaveGameData::LevelSave' has a wrong offset!");

// Class RC.RCSaveGameManager
// 0x0100 (0x0128 - 0x0028)
class URCSaveGameManager final : public UObject
{
public:
	class URCDevelopmentSaveSetting*              DevelopmentSetting;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCOptionSetting*                       OptionSetting;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableSaveSetting*                 VariableSaveSetting;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCPlayerSaveSetting*                   PlayerSaveSetting;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCLevelSaveSetting*                    LevelSaveSetting;                                  // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCSaveLoadExec>                ExecSaveLoadInfoList;                              // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	struct FRCSaveLoadExec                        ExecSaveLoadInfo;                                  // 0x0060(0x0008)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	ERCSaveLoadStatus                             Status;                                            // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCSaveDevelopment*                     SaveDevelopmentData;                               // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCSaveSystem*                          SaveSystemData;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCSaveGameData*                        SaveGameData;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRCSaveSlotInfo>                SaveGameDataList;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         UserIndex;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastAutoSaveNum;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AutoSaveNum;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SaveNum;                                           // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSaveDataType                               LastSaveDataType;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastSaveNum;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              LastAutoSaveTime;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              LastSaveTime;                                      // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSystemSaveLoad;                                   // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDemoSavedata;                                     // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCSaveSlotInfo>                DemoSaveGameDataList;                              // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bMargeDemoSavedata;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResultError;                                      // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateExec;                                       // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DB[0x5];                                       // 0x00DB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	ERCSaveLoadErrorType                          RCResult;                                          // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorText;                                         // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x30];                                      // 0x00F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveGameManager">();
	}
	static class URCSaveGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveGameManager>();
	}
};
static_assert(alignof(URCSaveGameManager) == 0x000008, "Wrong alignment on URCSaveGameManager");
static_assert(sizeof(URCSaveGameManager) == 0x000128, "Wrong size on URCSaveGameManager");
static_assert(offsetof(URCSaveGameManager, DevelopmentSetting) == 0x000028, "Member 'URCSaveGameManager::DevelopmentSetting' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, OptionSetting) == 0x000030, "Member 'URCSaveGameManager::OptionSetting' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, VariableSaveSetting) == 0x000038, "Member 'URCSaveGameManager::VariableSaveSetting' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, PlayerSaveSetting) == 0x000040, "Member 'URCSaveGameManager::PlayerSaveSetting' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LevelSaveSetting) == 0x000048, "Member 'URCSaveGameManager::LevelSaveSetting' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, ExecSaveLoadInfoList) == 0x000050, "Member 'URCSaveGameManager::ExecSaveLoadInfoList' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, ExecSaveLoadInfo) == 0x000060, "Member 'URCSaveGameManager::ExecSaveLoadInfo' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, Status) == 0x000068, "Member 'URCSaveGameManager::Status' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, SaveDevelopmentData) == 0x000070, "Member 'URCSaveGameManager::SaveDevelopmentData' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, SaveSystemData) == 0x000078, "Member 'URCSaveGameManager::SaveSystemData' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, SaveGameData) == 0x000080, "Member 'URCSaveGameManager::SaveGameData' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, SaveGameDataList) == 0x000088, "Member 'URCSaveGameManager::SaveGameDataList' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, UserIndex) == 0x000098, "Member 'URCSaveGameManager::UserIndex' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LastAutoSaveNum) == 0x00009C, "Member 'URCSaveGameManager::LastAutoSaveNum' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, AutoSaveNum) == 0x0000A0, "Member 'URCSaveGameManager::AutoSaveNum' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, SaveNum) == 0x0000A4, "Member 'URCSaveGameManager::SaveNum' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LastSaveDataType) == 0x0000A8, "Member 'URCSaveGameManager::LastSaveDataType' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LastSaveNum) == 0x0000AC, "Member 'URCSaveGameManager::LastSaveNum' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LastAutoSaveTime) == 0x0000B0, "Member 'URCSaveGameManager::LastAutoSaveTime' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, LastSaveTime) == 0x0000B8, "Member 'URCSaveGameManager::LastSaveTime' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, bSystemSaveLoad) == 0x0000C0, "Member 'URCSaveGameManager::bSystemSaveLoad' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, bDemoSavedata) == 0x0000C1, "Member 'URCSaveGameManager::bDemoSavedata' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, DemoSaveGameDataList) == 0x0000C8, "Member 'URCSaveGameManager::DemoSaveGameDataList' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, bMargeDemoSavedata) == 0x0000D8, "Member 'URCSaveGameManager::bMargeDemoSavedata' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, bResultError) == 0x0000D9, "Member 'URCSaveGameManager::bResultError' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, bUpdateExec) == 0x0000DA, "Member 'URCSaveGameManager::bUpdateExec' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, RCResult) == 0x0000E0, "Member 'URCSaveGameManager::RCResult' has a wrong offset!");
static_assert(offsetof(URCSaveGameManager, ErrorText) == 0x0000E8, "Member 'URCSaveGameManager::ErrorText' has a wrong offset!");

// Class RC.RCSaveLoadBFL
// 0x0000 (0x0028 - 0x0028)
class URCSaveLoadBFL final : public URCBlueprintFunctionLibrary
{
public:
	static bool IsFinished();
	static void OpenLoad();
	static void OpenSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadBFL">();
	}
	static class URCSaveLoadBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadBFL>();
	}
};
static_assert(alignof(URCSaveLoadBFL) == 0x000008, "Wrong alignment on URCSaveLoadBFL");
static_assert(sizeof(URCSaveLoadBFL) == 0x000028, "Wrong size on URCSaveLoadBFL");

// Class RC.RCTitleGalleryBGMListBar
// 0x0088 (0x03A8 - 0x0320)
class URCTitleGalleryBGMListBar : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnPlay;                                         // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutPlay;                                        // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnPlay_OutCursor;                               // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Number;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x40];                                     // 0x0368(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryBGMListBar">();
	}
	static class URCTitleGalleryBGMListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryBGMListBar>();
	}
};
static_assert(alignof(URCTitleGalleryBGMListBar) == 0x000008, "Wrong alignment on URCTitleGalleryBGMListBar");
static_assert(sizeof(URCTitleGalleryBGMListBar) == 0x0003A8, "Wrong size on URCTitleGalleryBGMListBar");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_Default) == 0x000320, "Member 'URCTitleGalleryBGMListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OnCursor) == 0x000328, "Member 'URCTitleGalleryBGMListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OnCursor_Wait) == 0x000330, "Member 'URCTitleGalleryBGMListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OutCursor) == 0x000338, "Member 'URCTitleGalleryBGMListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OnPlay) == 0x000340, "Member 'URCTitleGalleryBGMListBar::AN_OnPlay' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OutPlay) == 0x000348, "Member 'URCTitleGalleryBGMListBar::AN_OutPlay' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, AN_OnPlay_OutCursor) == 0x000350, "Member 'URCTitleGalleryBGMListBar::AN_OnPlay_OutCursor' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, Text_Number) == 0x000358, "Member 'URCTitleGalleryBGMListBar::Text_Number' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGMListBar, Text_ListName) == 0x000360, "Member 'URCTitleGalleryBGMListBar::Text_ListName' has a wrong offset!");

// Class RC.RCSaveLoadLayout
// 0x0038 (0x0310 - 0x02D8)
class URCSaveLoadLayout : public URCUiWidgetBase
{
public:
	class URCUiMenuTitleName*                     Menu_TitleName;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadWidget*                      Menu_SaveLoad;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadSelect*                      Menu_SaveLoad_Select;                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuHelp*                          Menu_Help;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       Menu_BTNGuide;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESAVELOADMENU_STATE                           prevState;                                         // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESAVELOADMENU_STATE                           State;                                             // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isTopMenu;                                         // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isSubStory;                                        // 0x0309(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isBp;                                              // 0x030A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isTitleBack;                                       // 0x030B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFooterAnimtion;                                  // 0x030C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadLayout">();
	}
	static class URCSaveLoadLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadLayout>();
	}
};
static_assert(alignof(URCSaveLoadLayout) == 0x000008, "Wrong alignment on URCSaveLoadLayout");
static_assert(sizeof(URCSaveLoadLayout) == 0x000310, "Wrong size on URCSaveLoadLayout");
static_assert(offsetof(URCSaveLoadLayout, Menu_TitleName) == 0x0002D8, "Member 'URCSaveLoadLayout::Menu_TitleName' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, Menu_SaveLoad) == 0x0002E0, "Member 'URCSaveLoadLayout::Menu_SaveLoad' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, Menu_SaveLoad_Select) == 0x0002E8, "Member 'URCSaveLoadLayout::Menu_SaveLoad_Select' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, Menu_Help) == 0x0002F0, "Member 'URCSaveLoadLayout::Menu_Help' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, Menu_BTNGuide) == 0x0002F8, "Member 'URCSaveLoadLayout::Menu_BTNGuide' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, prevState) == 0x000300, "Member 'URCSaveLoadLayout::prevState' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, State) == 0x000304, "Member 'URCSaveLoadLayout::State' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, isTopMenu) == 0x000308, "Member 'URCSaveLoadLayout::isTopMenu' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, isSubStory) == 0x000309, "Member 'URCSaveLoadLayout::isSubStory' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, isBp) == 0x00030A, "Member 'URCSaveLoadLayout::isBp' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, isTitleBack) == 0x00030B, "Member 'URCSaveLoadLayout::isTitleBack' has a wrong offset!");
static_assert(offsetof(URCSaveLoadLayout, isFooterAnimtion) == 0x00030C, "Member 'URCSaveLoadLayout::isFooterAnimtion' has a wrong offset!");

// Class RC.RCSaveLoadList
// 0x00F0 (0x03E8 - 0x02F8)
class URCSaveLoadList : public URCMenuManager
{
public:
	class USpUIScrollBox*                         ScrollBox_List;                                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SvLd_ListBar_Grp;                                  // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadListBar*                     SvLd_ListBar_00;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadListBar*                     SvLd_ListBar_01;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadListBar*                     SvLd_ListBar_02;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadListBar*                     SvLd_ListBar_03;                                   // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCSaveLoadListBar*>             listBarArray;                                      // 0x0328(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URCSaveLoadListBar*>             enableListBarArray;                                // 0x0338(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FString                                 listBarWidgetPath;                                 // 0x0348(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         baseListNum;                                       // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         listBarPath;                                       // 0x0360(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         scrollSize;                                        // 0x0378(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isSaveMode;                                        // 0x037C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDlcMode;                                         // 0x037D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37E[0x2];                                      // 0x037E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        mapIDStrNum;                                       // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UTexture2D*>                chapterImageMap;                                   // 0x0388(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FRCSaveSlotInfo>                saveSlotInfoArray;                                 // 0x03D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadList">();
	}
	static class URCSaveLoadList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadList>();
	}
};
static_assert(alignof(URCSaveLoadList) == 0x000008, "Wrong alignment on URCSaveLoadList");
static_assert(sizeof(URCSaveLoadList) == 0x0003E8, "Wrong size on URCSaveLoadList");
static_assert(offsetof(URCSaveLoadList, ScrollBox_List) == 0x0002F8, "Member 'URCSaveLoadList::ScrollBox_List' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, SvLd_ListBar_Grp) == 0x000300, "Member 'URCSaveLoadList::SvLd_ListBar_Grp' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, SvLd_ListBar_00) == 0x000308, "Member 'URCSaveLoadList::SvLd_ListBar_00' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, SvLd_ListBar_01) == 0x000310, "Member 'URCSaveLoadList::SvLd_ListBar_01' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, SvLd_ListBar_02) == 0x000318, "Member 'URCSaveLoadList::SvLd_ListBar_02' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, SvLd_ListBar_03) == 0x000320, "Member 'URCSaveLoadList::SvLd_ListBar_03' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, listBarArray) == 0x000328, "Member 'URCSaveLoadList::listBarArray' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, enableListBarArray) == 0x000338, "Member 'URCSaveLoadList::enableListBarArray' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, listBarWidgetPath) == 0x000348, "Member 'URCSaveLoadList::listBarWidgetPath' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, baseListNum) == 0x000358, "Member 'URCSaveLoadList::baseListNum' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, listBarPath) == 0x000360, "Member 'URCSaveLoadList::listBarPath' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, scrollSize) == 0x000378, "Member 'URCSaveLoadList::scrollSize' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, isSaveMode) == 0x00037C, "Member 'URCSaveLoadList::isSaveMode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, isDlcMode) == 0x00037D, "Member 'URCSaveLoadList::isDlcMode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, mapIDStrNum) == 0x000380, "Member 'URCSaveLoadList::mapIDStrNum' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, chapterImageMap) == 0x000388, "Member 'URCSaveLoadList::chapterImageMap' has a wrong offset!");
static_assert(offsetof(URCSaveLoadList, saveSlotInfoArray) == 0x0003D8, "Member 'URCSaveLoadList::saveSlotInfoArray' has a wrong offset!");

// Class RC.RCSaveLoadListBar
// 0x0090 (0x03B0 - 0x0320)
class URCSaveLoadListBar : public URCMenuButton
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCSaveLoadListBarBase*                 SvLd_ListBar_Base;                                 // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ListNo;                                       // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_SaveType;                           // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_EpNo;                                         // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_EpTitle;                                      // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_SavePoint;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Date;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Time;                                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Empty;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadListImage*                   SvLd_Imag;                                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Default;                                        // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isSaveMode;                                        // 0x03A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentSelect;                                   // 0x03A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isFocus;                                           // 0x03AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AB[0x5];                                      // 0x03AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadListBar">();
	}
	static class URCSaveLoadListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadListBar>();
	}
};
static_assert(alignof(URCSaveLoadListBar) == 0x000008, "Wrong alignment on URCSaveLoadListBar");
static_assert(sizeof(URCSaveLoadListBar) == 0x0003B0, "Wrong size on URCSaveLoadListBar");
static_assert(offsetof(URCSaveLoadListBar, SvLd_ListBar_Base) == 0x000330, "Member 'URCSaveLoadListBar::SvLd_ListBar_Base' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_ListNo) == 0x000338, "Member 'URCSaveLoadListBar::Text_ListNo' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, WidgetSwitcher_SaveType) == 0x000340, "Member 'URCSaveLoadListBar::WidgetSwitcher_SaveType' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_EpNo) == 0x000348, "Member 'URCSaveLoadListBar::Text_EpNo' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_EpTitle) == 0x000350, "Member 'URCSaveLoadListBar::Text_EpTitle' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_SavePoint) == 0x000358, "Member 'URCSaveLoadListBar::Text_SavePoint' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_Date) == 0x000360, "Member 'URCSaveLoadListBar::Text_Date' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_Time) == 0x000368, "Member 'URCSaveLoadListBar::Text_Time' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, Text_Empty) == 0x000370, "Member 'URCSaveLoadListBar::Text_Empty' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, SvLd_Imag) == 0x000378, "Member 'URCSaveLoadListBar::SvLd_Imag' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, AN_Default) == 0x000380, "Member 'URCSaveLoadListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, AN_OnCursor) == 0x000388, "Member 'URCSaveLoadListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, AN_OnCursor_Wait) == 0x000390, "Member 'URCSaveLoadListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, AN_OutCursor) == 0x000398, "Member 'URCSaveLoadListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, AN_Push) == 0x0003A0, "Member 'URCSaveLoadListBar::AN_Push' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, isSaveMode) == 0x0003A8, "Member 'URCSaveLoadListBar::isSaveMode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, isCurrentSelect) == 0x0003A9, "Member 'URCSaveLoadListBar::isCurrentSelect' has a wrong offset!");
static_assert(offsetof(URCSaveLoadListBar, isFocus) == 0x0003AA, "Member 'URCSaveLoadListBar::isFocus' has a wrong offset!");

// Class RC.RCSaveLoadListBarBase
// 0x0008 (0x0278 - 0x0270)
class URCSaveLoadListBarBase : public URCUserWidget
{
public:
	class UImage*                                 SvLd_ListBar_Base;                                 // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadListBarBase">();
	}
	static class URCSaveLoadListBarBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadListBarBase>();
	}
};
static_assert(alignof(URCSaveLoadListBarBase) == 0x000008, "Wrong alignment on URCSaveLoadListBarBase");
static_assert(sizeof(URCSaveLoadListBarBase) == 0x000278, "Wrong size on URCSaveLoadListBarBase");
static_assert(offsetof(URCSaveLoadListBarBase, SvLd_ListBar_Base) == 0x000270, "Member 'URCSaveLoadListBarBase::SvLd_ListBar_Base' has a wrong offset!");

// Class RC.RCTitleGalleryMovieList
// 0x00D0 (0x03C8 - 0x02F8)
class URCTitleGalleryMovieList : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0xA8];                                     // 0x02F8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x24];                                     // 0x03A4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* MovieNavigation(EUINavigation InNavigation);
	void SelectMovie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryMovieList">();
	}
	static class URCTitleGalleryMovieList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryMovieList>();
	}
};
static_assert(alignof(URCTitleGalleryMovieList) == 0x000008, "Wrong alignment on URCTitleGalleryMovieList");
static_assert(sizeof(URCTitleGalleryMovieList) == 0x0003C8, "Wrong size on URCTitleGalleryMovieList");
static_assert(offsetof(URCTitleGalleryMovieList, MaxBarOfPage) == 0x0003A0, "Member 'URCTitleGalleryMovieList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCSaveLoadListImage
// 0x0008 (0x0278 - 0x0270)
class URCSaveLoadListImage : public URCUserWidget
{
public:
	class UImage*                                 Chara_Face_Dummy_000;                              // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadListImage">();
	}
	static class URCSaveLoadListImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadListImage>();
	}
};
static_assert(alignof(URCSaveLoadListImage) == 0x000008, "Wrong alignment on URCSaveLoadListImage");
static_assert(sizeof(URCSaveLoadListImage) == 0x000278, "Wrong size on URCSaveLoadListImage");
static_assert(offsetof(URCSaveLoadListImage, Chara_Face_Dummy_000) == 0x000270, "Member 'URCSaveLoadListImage::Chara_Face_Dummy_000' has a wrong offset!");

// Class RC.RCSaveLoadSelect
// 0x0058 (0x0350 - 0x02F8)
class URCSaveLoadSelect : public URCMenuManager
{
public:
	class URCSaveLoadSelectButtonSave*            Button_Save;                                       // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadSelectButtonLoad*            Button_Load;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCSaveLoadSelectButtonTitle*           Button_Title;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESaveLoadSelectState                          State;                                             // 0x0328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESaveLoadMode                                 selectedMode;                                      // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0330(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCSaveLoadSelectButtonBase*>    buttonArray;                                       // 0x0338(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelectLoopAnimation;                              // 0x0349(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPushDecideKey;                                    // 0x034A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PushCancel();
	void PushCancelWrap(ERCInputKeyType InKeyType);
	void PushDecide();
	void PushDecideWrap(ERCInputKeyType InKeyType);
	class UWidget* SaveLoadSelectNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelect">();
	}
	static class URCSaveLoadSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelect>();
	}
};
static_assert(alignof(URCSaveLoadSelect) == 0x000008, "Wrong alignment on URCSaveLoadSelect");
static_assert(sizeof(URCSaveLoadSelect) == 0x000350, "Wrong size on URCSaveLoadSelect");
static_assert(offsetof(URCSaveLoadSelect, Button_Save) == 0x0002F8, "Member 'URCSaveLoadSelect::Button_Save' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, Button_Load) == 0x000300, "Member 'URCSaveLoadSelect::Button_Load' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, Button_Title) == 0x000308, "Member 'URCSaveLoadSelect::Button_Title' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, AN_Start) == 0x000310, "Member 'URCSaveLoadSelect::AN_Start' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, AN_Wait) == 0x000318, "Member 'URCSaveLoadSelect::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, AN_Finish) == 0x000320, "Member 'URCSaveLoadSelect::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, State) == 0x000328, "Member 'URCSaveLoadSelect::State' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, selectedMode) == 0x00032C, "Member 'URCSaveLoadSelect::selectedMode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, SelectIndex) == 0x000330, "Member 'URCSaveLoadSelect::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, buttonArray) == 0x000338, "Member 'URCSaveLoadSelect::buttonArray' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, bListLoop) == 0x000348, "Member 'URCSaveLoadSelect::bListLoop' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, bSelectLoopAnimation) == 0x000349, "Member 'URCSaveLoadSelect::bSelectLoopAnimation' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelect, bPushDecideKey) == 0x00034A, "Member 'URCSaveLoadSelect::bPushDecideKey' has a wrong offset!");

// Class RC.RCSaveLoadSelectButtonBase
// 0x0038 (0x0358 - 0x0320)
class URCSaveLoadSelectButtonBase : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect;                                      // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurrentMouseSelect;                              // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelectButtonBase">();
	}
	static class URCSaveLoadSelectButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelectButtonBase>();
	}
};
static_assert(alignof(URCSaveLoadSelectButtonBase) == 0x000008, "Wrong alignment on URCSaveLoadSelectButtonBase");
static_assert(sizeof(URCSaveLoadSelectButtonBase) == 0x000358, "Wrong size on URCSaveLoadSelectButtonBase");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_Def) == 0x000320, "Member 'URCSaveLoadSelectButtonBase::AN_Def' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_OnCursor) == 0x000328, "Member 'URCSaveLoadSelectButtonBase::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_OutCursor) == 0x000330, "Member 'URCSaveLoadSelectButtonBase::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_Push) == 0x000338, "Member 'URCSaveLoadSelectButtonBase::AN_Push' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_NotSelect) == 0x000340, "Member 'URCSaveLoadSelectButtonBase::AN_NotSelect' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, AN_Off) == 0x000348, "Member 'URCSaveLoadSelectButtonBase::AN_Off' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectButtonBase, isCurrentMouseSelect) == 0x000350, "Member 'URCSaveLoadSelectButtonBase::isCurrentMouseSelect' has a wrong offset!");

// Class RC.RCSaveLoadSelectButtonLoad
// 0x0008 (0x0360 - 0x0358)
class URCSaveLoadSelectButtonLoad : public URCSaveLoadSelectButtonBase
{
public:
	class URCSaveLoadSelectLoopBase*              Button_Load_On;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelectButtonLoad">();
	}
	static class URCSaveLoadSelectButtonLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelectButtonLoad>();
	}
};
static_assert(alignof(URCSaveLoadSelectButtonLoad) == 0x000008, "Wrong alignment on URCSaveLoadSelectButtonLoad");
static_assert(sizeof(URCSaveLoadSelectButtonLoad) == 0x000360, "Wrong size on URCSaveLoadSelectButtonLoad");
static_assert(offsetof(URCSaveLoadSelectButtonLoad, Button_Load_On) == 0x000358, "Member 'URCSaveLoadSelectButtonLoad::Button_Load_On' has a wrong offset!");

// Class RC.RCTitleHelp
// 0x0008 (0x02E0 - 0x02D8)
class URCTitleHelp : public URCUiWidgetBase
{
public:
	class UTextBlock*                             HelpText;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleHelp">();
	}
	static class URCTitleHelp* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleHelp>();
	}
};
static_assert(alignof(URCTitleHelp) == 0x000008, "Wrong alignment on URCTitleHelp");
static_assert(sizeof(URCTitleHelp) == 0x0002E0, "Wrong size on URCTitleHelp");
static_assert(offsetof(URCTitleHelp, HelpText) == 0x0002D8, "Member 'URCTitleHelp::HelpText' has a wrong offset!");

// Class RC.RCSaveLoadSelectButtonSave
// 0x0008 (0x0360 - 0x0358)
class URCSaveLoadSelectButtonSave : public URCSaveLoadSelectButtonBase
{
public:
	class URCSaveLoadSelectLoopBase*              Button_Save_On;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelectButtonSave">();
	}
	static class URCSaveLoadSelectButtonSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelectButtonSave>();
	}
};
static_assert(alignof(URCSaveLoadSelectButtonSave) == 0x000008, "Wrong alignment on URCSaveLoadSelectButtonSave");
static_assert(sizeof(URCSaveLoadSelectButtonSave) == 0x000360, "Wrong size on URCSaveLoadSelectButtonSave");
static_assert(offsetof(URCSaveLoadSelectButtonSave, Button_Save_On) == 0x000358, "Member 'URCSaveLoadSelectButtonSave::Button_Save_On' has a wrong offset!");

// Class RC.RCSaveLoadSelectButtonTitle
// 0x0008 (0x0360 - 0x0358)
class URCSaveLoadSelectButtonTitle : public URCSaveLoadSelectButtonBase
{
public:
	class URCSaveLoadSelectLoopBase*              Button_Title_On;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelectButtonTitle">();
	}
	static class URCSaveLoadSelectButtonTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelectButtonTitle>();
	}
};
static_assert(alignof(URCSaveLoadSelectButtonTitle) == 0x000008, "Wrong alignment on URCSaveLoadSelectButtonTitle");
static_assert(sizeof(URCSaveLoadSelectButtonTitle) == 0x000360, "Wrong size on URCSaveLoadSelectButtonTitle");
static_assert(offsetof(URCSaveLoadSelectButtonTitle, Button_Title_On) == 0x000358, "Member 'URCSaveLoadSelectButtonTitle::Button_Title_On' has a wrong offset!");

// Class RC.RCSaveLoadSelectLoopBase
// 0x0010 (0x0280 - 0x0270)
class URCSaveLoadSelectLoopBase : public URCUserWidget
{
public:
	class UWidgetAnimation*                       AN_Loop;                                           // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isLoopAnimation;                                   // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadSelectLoopBase">();
	}
	static class URCSaveLoadSelectLoopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadSelectLoopBase>();
	}
};
static_assert(alignof(URCSaveLoadSelectLoopBase) == 0x000008, "Wrong alignment on URCSaveLoadSelectLoopBase");
static_assert(sizeof(URCSaveLoadSelectLoopBase) == 0x000280, "Wrong size on URCSaveLoadSelectLoopBase");
static_assert(offsetof(URCSaveLoadSelectLoopBase, AN_Loop) == 0x000270, "Member 'URCSaveLoadSelectLoopBase::AN_Loop' has a wrong offset!");
static_assert(offsetof(URCSaveLoadSelectLoopBase, isLoopAnimation) == 0x000278, "Member 'URCSaveLoadSelectLoopBase::isLoopAnimation' has a wrong offset!");

// Class RC.RCSaveLoadWidget
// 0x0070 (0x0368 - 0x02F8)
class URCSaveLoadWidget : public URCMenuManager
{
public:
	class URCSaveLoadList*                        SaveLoad_List;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESaveLoadState                                State;                                             // 0x0318(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ESaveLoadMode                                 Mode;                                              // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0324(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         dispTopIndex;                                      // 0x0328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCSaveSlotInfo                        selectSaveSlotInfo;                                // 0x0330(0x0030)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0360(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSaveLoadFailed;                                   // 0x0361(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoSaveNG;                                       // 0x0362(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCStoryMode                                  StoryMode;                                         // 0x0363(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoadClose;                                        // 0x0364(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAfterSave;                                        // 0x0365(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListSelectInitialized;                            // 0x0366(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInstallingDialog;                               // 0x0367(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PushCancel();
	void PushCancelWrap(ERCInputKeyType InKeyType);
	void PushDecide();
	void PushDecideWrap(ERCInputKeyType InKeyType);
	class UWidget* SaveLoadWidgetNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSaveLoadWidget">();
	}
	static class URCSaveLoadWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSaveLoadWidget>();
	}
};
static_assert(alignof(URCSaveLoadWidget) == 0x000008, "Wrong alignment on URCSaveLoadWidget");
static_assert(sizeof(URCSaveLoadWidget) == 0x000368, "Wrong size on URCSaveLoadWidget");
static_assert(offsetof(URCSaveLoadWidget, SaveLoad_List) == 0x0002F8, "Member 'URCSaveLoadWidget::SaveLoad_List' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, AN_Start) == 0x000300, "Member 'URCSaveLoadWidget::AN_Start' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, AN_Wait) == 0x000308, "Member 'URCSaveLoadWidget::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, AN_Finish) == 0x000310, "Member 'URCSaveLoadWidget::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, State) == 0x000318, "Member 'URCSaveLoadWidget::State' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, Mode) == 0x000320, "Member 'URCSaveLoadWidget::Mode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, SelectIndex) == 0x000324, "Member 'URCSaveLoadWidget::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, dispTopIndex) == 0x000328, "Member 'URCSaveLoadWidget::dispTopIndex' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, selectSaveSlotInfo) == 0x000330, "Member 'URCSaveLoadWidget::selectSaveSlotInfo' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bListLoop) == 0x000360, "Member 'URCSaveLoadWidget::bListLoop' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bSaveLoadFailed) == 0x000361, "Member 'URCSaveLoadWidget::bSaveLoadFailed' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bAutoSaveNG) == 0x000362, "Member 'URCSaveLoadWidget::bAutoSaveNG' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, StoryMode) == 0x000363, "Member 'URCSaveLoadWidget::StoryMode' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bLoadClose) == 0x000364, "Member 'URCSaveLoadWidget::bLoadClose' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bAfterSave) == 0x000365, "Member 'URCSaveLoadWidget::bAfterSave' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bListSelectInitialized) == 0x000366, "Member 'URCSaveLoadWidget::bListSelectInitialized' has a wrong offset!");
static_assert(offsetof(URCSaveLoadWidget, bIsInstallingDialog) == 0x000367, "Member 'URCSaveLoadWidget::bIsInstallingDialog' has a wrong offset!");

// Class RC.RCSceneChangeMediator
// 0x0168 (0x0190 - 0x0028)
class alignas(0x10) URCSceneChangeMediator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiReSceneChangeLoading*              ReSceneChangeLoading;                              // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiReSceneChange*                     ReSceneChange;                                     // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiNzSceneChangeLoading*              NzSceneChangeLoading;                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiNzSceneChange*                     NzSceneChange;                                     // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSceneChange*                       SceneChangeNormal;                                 // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSceneChange*                       SceneChangeLoading;                                // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReSceneChangeLoadingScreen*          ReSceneChangeLoadingScreen;                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCNzSceneChangeLoadingScreen*          NzSceneChangeLoadingScreen;                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                OpenedSceneChangeObject;                           // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ExtendSceneChangeObjectList;                       // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0xE0];                                      // 0x00B0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSceneChangeMediator">();
	}
	static class URCSceneChangeMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSceneChangeMediator>();
	}
};
static_assert(alignof(URCSceneChangeMediator) == 0x000010, "Wrong alignment on URCSceneChangeMediator");
static_assert(sizeof(URCSceneChangeMediator) == 0x000190, "Wrong size on URCSceneChangeMediator");
static_assert(offsetof(URCSceneChangeMediator, ReSceneChangeLoading) == 0x000030, "Member 'URCSceneChangeMediator::ReSceneChangeLoading' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, ReSceneChange) == 0x000038, "Member 'URCSceneChangeMediator::ReSceneChange' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, NzSceneChangeLoading) == 0x000040, "Member 'URCSceneChangeMediator::NzSceneChangeLoading' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, NzSceneChange) == 0x000048, "Member 'URCSceneChangeMediator::NzSceneChange' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, SceneChangeNormal) == 0x000050, "Member 'URCSceneChangeMediator::SceneChangeNormal' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, SceneChangeLoading) == 0x000058, "Member 'URCSceneChangeMediator::SceneChangeLoading' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, ReSceneChangeLoadingScreen) == 0x000060, "Member 'URCSceneChangeMediator::ReSceneChangeLoadingScreen' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, NzSceneChangeLoadingScreen) == 0x000068, "Member 'URCSceneChangeMediator::NzSceneChangeLoadingScreen' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, OpenedSceneChangeObject) == 0x000070, "Member 'URCSceneChangeMediator::OpenedSceneChangeObject' has a wrong offset!");
static_assert(offsetof(URCSceneChangeMediator, ExtendSceneChangeObjectList) == 0x0000A0, "Member 'URCSceneChangeMediator::ExtendSceneChangeObjectList' has a wrong offset!");

// Class RC.RCScriptActorStatus
// 0x0118 (0x0140 - 0x0028)
class URCScriptActorStatus final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVisible;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraNearFade;                                   // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCCharactreTag                               CharacterTag;                                      // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeed;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMove;                                             // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveFirstWarp;                                    // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveLoop;                                         // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovePositionNum;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRCScriptActorMoveInfo>         MovePositionList;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMoveEndChangeYaw;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveEndChangeYawPosition;                          // 0x006C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEndOffetYaw;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovePlayerCheck;                                  // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveSplineName;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSplineDistance;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveSplineReverse;                                // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveOnSpline;                                     // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeYawSpeed;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveWait;                                          // 0x0094(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovePause;                                        // 0x0098(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveFadeOut;                                      // 0x0099(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalk;                                             // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLookAtFace;                                 // 0x009B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkLabelName;                                     // 0x009C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BalloonFrameType;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BalloonType;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelifTextId;                                       // 0x00AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TalkLength;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelifLength;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BalloonLength;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BalloonHeightOffset;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BalloonAngleOffset;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BalloonLengthOffset;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCActorQuestType                             QuestType;                                         // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestTitleName;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x68];                                      // 0x00D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCScriptActorStatus">();
	}
	static class URCScriptActorStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCScriptActorStatus>();
	}
};
static_assert(alignof(URCScriptActorStatus) == 0x000008, "Wrong alignment on URCScriptActorStatus");
static_assert(sizeof(URCScriptActorStatus) == 0x000140, "Wrong size on URCScriptActorStatus");
static_assert(offsetof(URCScriptActorStatus, bVisible) == 0x000030, "Member 'URCScriptActorStatus::bVisible' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bPause) == 0x000031, "Member 'URCScriptActorStatus::bPause' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bCameraNearFade) == 0x000032, "Member 'URCScriptActorStatus::bCameraNearFade' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, CharacterTag) == 0x000033, "Member 'URCScriptActorStatus::CharacterTag' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, WalkSpeed) == 0x000034, "Member 'URCScriptActorStatus::WalkSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, RunSpeed) == 0x000038, "Member 'URCScriptActorStatus::RunSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, Position) == 0x00003C, "Member 'URCScriptActorStatus::Position' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, Yaw) == 0x000048, "Member 'URCScriptActorStatus::Yaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMove) == 0x00004C, "Member 'URCScriptActorStatus::bMove' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveFirstWarp) == 0x00004D, "Member 'URCScriptActorStatus::bMoveFirstWarp' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveLoop) == 0x00004E, "Member 'URCScriptActorStatus::bMoveLoop' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MovePositionNum) == 0x000050, "Member 'URCScriptActorStatus::MovePositionNum' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MovePositionList) == 0x000058, "Member 'URCScriptActorStatus::MovePositionList' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveEndChangeYaw) == 0x000068, "Member 'URCScriptActorStatus::bMoveEndChangeYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MoveEndChangeYawPosition) == 0x00006C, "Member 'URCScriptActorStatus::MoveEndChangeYawPosition' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MoveEndOffetYaw) == 0x000078, "Member 'URCScriptActorStatus::MoveEndOffetYaw' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMovePlayerCheck) == 0x00007C, "Member 'URCScriptActorStatus::bMovePlayerCheck' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MoveSplineName) == 0x000080, "Member 'URCScriptActorStatus::MoveSplineName' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MoveSplineDistance) == 0x000088, "Member 'URCScriptActorStatus::MoveSplineDistance' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveSplineReverse) == 0x00008C, "Member 'URCScriptActorStatus::bMoveSplineReverse' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveOnSpline) == 0x00008D, "Member 'URCScriptActorStatus::bMoveOnSpline' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, ChangeYawSpeed) == 0x000090, "Member 'URCScriptActorStatus::ChangeYawSpeed' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, MoveWait) == 0x000094, "Member 'URCScriptActorStatus::MoveWait' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMovePause) == 0x000098, "Member 'URCScriptActorStatus::bMovePause' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bMoveFadeOut) == 0x000099, "Member 'URCScriptActorStatus::bMoveFadeOut' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bTalk) == 0x00009A, "Member 'URCScriptActorStatus::bTalk' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, bPlayerLookAtFace) == 0x00009B, "Member 'URCScriptActorStatus::bPlayerLookAtFace' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, TalkLabelName) == 0x00009C, "Member 'URCScriptActorStatus::TalkLabelName' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonFrameType) == 0x0000A4, "Member 'URCScriptActorStatus::BalloonFrameType' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonType) == 0x0000A8, "Member 'URCScriptActorStatus::BalloonType' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, SelifTextId) == 0x0000AC, "Member 'URCScriptActorStatus::SelifTextId' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, TalkLength) == 0x0000B4, "Member 'URCScriptActorStatus::TalkLength' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, SelifLength) == 0x0000B8, "Member 'URCScriptActorStatus::SelifLength' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonLength) == 0x0000BC, "Member 'URCScriptActorStatus::BalloonLength' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonHeightOffset) == 0x0000C0, "Member 'URCScriptActorStatus::BalloonHeightOffset' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonAngleOffset) == 0x0000C4, "Member 'URCScriptActorStatus::BalloonAngleOffset' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, BalloonLengthOffset) == 0x0000C8, "Member 'URCScriptActorStatus::BalloonLengthOffset' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, QuestType) == 0x0000CC, "Member 'URCScriptActorStatus::QuestType' has a wrong offset!");
static_assert(offsetof(URCScriptActorStatus, QuestTitleName) == 0x0000D0, "Member 'URCScriptActorStatus::QuestTitleName' has a wrong offset!");

// Class RC.RCSelectText3DActor
// 0x00A0 (0x02E8 - 0x0248)
class ARCSelectText3DActor final : public ARCLocalizeText3DActor
{
public:
	ERCSelectTextExpressionType                   ExpressionType;                                    // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     NormalFrontMaterial;                               // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     SelectFrontMaterial;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     NonSelectFrontMaterial;                            // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     EdgeMaterial;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FrontMaterialInstance;                             // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSelectTextTargetType                       TargetType;                                        // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SelectCheckActorName;                              // 0x027C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NonSelectCheckActorNameList;                       // 0x0288(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TextColor;                                         // 0x0298(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColorScale_Normal;                                 // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColorScale_Select;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColorScale_NonSelect;                              // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCSelectTextSelectStatus                     SelectStatus;                                      // 0x02B4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckActorInit;                                   // 0x02B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B6[0x2];                                      // 0x02B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCCheckActor*                          SelectCheckActor;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARCCheckActor*>                  NonSelectCheckActorList;                           // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class ARCSelectEventTrigger*                  SelectEventTrigger;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARCSelectEventTrigger*>          NonSelectEventTriggerList;                         // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	ERCSelectTextSelectStatus GetSelectStatus();
	void SetSelectStatus(ERCSelectTextSelectStatus InStatus);
	void SetTextColor(const struct FLinearColor& InTextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSelectText3DActor">();
	}
	static class ARCSelectText3DActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSelectText3DActor>();
	}
};
static_assert(alignof(ARCSelectText3DActor) == 0x000008, "Wrong alignment on ARCSelectText3DActor");
static_assert(sizeof(ARCSelectText3DActor) == 0x0002E8, "Wrong size on ARCSelectText3DActor");
static_assert(offsetof(ARCSelectText3DActor, ExpressionType) == 0x000248, "Member 'ARCSelectText3DActor::ExpressionType' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, NormalFrontMaterial) == 0x000250, "Member 'ARCSelectText3DActor::NormalFrontMaterial' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, SelectFrontMaterial) == 0x000258, "Member 'ARCSelectText3DActor::SelectFrontMaterial' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, NonSelectFrontMaterial) == 0x000260, "Member 'ARCSelectText3DActor::NonSelectFrontMaterial' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, EdgeMaterial) == 0x000268, "Member 'ARCSelectText3DActor::EdgeMaterial' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, FrontMaterialInstance) == 0x000270, "Member 'ARCSelectText3DActor::FrontMaterialInstance' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, TargetType) == 0x000278, "Member 'ARCSelectText3DActor::TargetType' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, SelectCheckActorName) == 0x00027C, "Member 'ARCSelectText3DActor::SelectCheckActorName' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, NonSelectCheckActorNameList) == 0x000288, "Member 'ARCSelectText3DActor::NonSelectCheckActorNameList' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, TextColor) == 0x000298, "Member 'ARCSelectText3DActor::TextColor' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, ColorScale_Normal) == 0x0002A8, "Member 'ARCSelectText3DActor::ColorScale_Normal' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, ColorScale_Select) == 0x0002AC, "Member 'ARCSelectText3DActor::ColorScale_Select' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, ColorScale_NonSelect) == 0x0002B0, "Member 'ARCSelectText3DActor::ColorScale_NonSelect' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, SelectStatus) == 0x0002B4, "Member 'ARCSelectText3DActor::SelectStatus' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, bCheckActorInit) == 0x0002B5, "Member 'ARCSelectText3DActor::bCheckActorInit' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, SelectCheckActor) == 0x0002B8, "Member 'ARCSelectText3DActor::SelectCheckActor' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, NonSelectCheckActorList) == 0x0002C0, "Member 'ARCSelectText3DActor::NonSelectCheckActorList' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, SelectEventTrigger) == 0x0002D0, "Member 'ARCSelectText3DActor::SelectEventTrigger' has a wrong offset!");
static_assert(offsetof(ARCSelectText3DActor, NonSelectEventTriggerList) == 0x0002D8, "Member 'ARCSelectText3DActor::NonSelectEventTriggerList' has a wrong offset!");

// Class RC.RCSequenceManager
// 0x0128 (0x0150 - 0x0028)
class URCSequenceManager final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequencePlayer*                   TalkSequencePlayer;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCSequenceSectionEndData_Talk         TalkSectionEndData;                                // 0x0070(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   SubtitleSequencePlayer;                            // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRCSequenceSectionEndData_Subtitle     SubtitleSectionEndData;                            // 0x0098(0x0020)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    ShinigamiSequenceActor;                            // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShinigamiSequencerPlayDelay;                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCSequenceFollowTarget*                ShinigamiSequenceFollowTarget;                     // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCSequenceSectionEndData_Base         LightOffsetSectionEndData;                         // 0x00E0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCSequenceSectionEndData_Character> FacialColorSectionEndDataList;                     // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCSequenceSectionEndData_Character> EmissiveSectionEndDataList;                        // 0x0100(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCSequenceSectionEndData_Character> HairSpecularSectionEndDataList;                    // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class ALevelSequenceActor* LSA)> OnShinigamiSequencerFinished;                      // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ALevelSequenceActor* LSA)> OnShinigamiSequencerCanceled;                      // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ARCLevelSequenceActor*>          LevelSequenceActorList;                            // 0x0140(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	void ShinigamiSequencer_Finished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSequenceManager">();
	}
	static class URCSequenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSequenceManager>();
	}
};
static_assert(alignof(URCSequenceManager) == 0x000008, "Wrong alignment on URCSequenceManager");
static_assert(sizeof(URCSequenceManager) == 0x000150, "Wrong size on URCSequenceManager");
static_assert(offsetof(URCSequenceManager, TalkSequencePlayer) == 0x000060, "Member 'URCSequenceManager::TalkSequencePlayer' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, TalkSectionEndData) == 0x000070, "Member 'URCSequenceManager::TalkSectionEndData' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, SubtitleSequencePlayer) == 0x000088, "Member 'URCSequenceManager::SubtitleSequencePlayer' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, SubtitleSectionEndData) == 0x000098, "Member 'URCSequenceManager::SubtitleSectionEndData' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, ShinigamiSequenceActor) == 0x0000B8, "Member 'URCSequenceManager::ShinigamiSequenceActor' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, ShinigamiSequencerPlayDelay) == 0x0000D0, "Member 'URCSequenceManager::ShinigamiSequencerPlayDelay' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, ShinigamiSequenceFollowTarget) == 0x0000D8, "Member 'URCSequenceManager::ShinigamiSequenceFollowTarget' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, LightOffsetSectionEndData) == 0x0000E0, "Member 'URCSequenceManager::LightOffsetSectionEndData' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, FacialColorSectionEndDataList) == 0x0000F0, "Member 'URCSequenceManager::FacialColorSectionEndDataList' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, EmissiveSectionEndDataList) == 0x000100, "Member 'URCSequenceManager::EmissiveSectionEndDataList' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, HairSpecularSectionEndDataList) == 0x000110, "Member 'URCSequenceManager::HairSpecularSectionEndDataList' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, OnShinigamiSequencerFinished) == 0x000120, "Member 'URCSequenceManager::OnShinigamiSequencerFinished' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, OnShinigamiSequencerCanceled) == 0x000130, "Member 'URCSequenceManager::OnShinigamiSequencerCanceled' has a wrong offset!");
static_assert(offsetof(URCSequenceManager, LevelSequenceActorList) == 0x000140, "Member 'URCSequenceManager::LevelSequenceActorList' has a wrong offset!");

// Class RC.RCShinigamiAIFollow
// 0x01A8 (0x01D0 - 0x0028)
class URCShinigamiAIFollow final : public UObject
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PlayerActor;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiAIComponent*                ParrentComponent;                                  // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCShinigamiMovement*                   Movement;                                          // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                FollowCenterOffset;                                // 0x00E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowRadius;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                FollowMoveCenterOffset;                            // 0x00F0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowMoveRadius;                                  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowFrontLength;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowFrontFarLength;                              // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowHiSpeedLength;                               // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMin;                                     // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiWaitTimeMax;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiMoveWaitTimeMin;                                 // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiMoveWaitTimeMax;                                 // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiMoveWaitFontTimeMin;                             // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiMoveWaitFontTimeMax;                             // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerCollisionLength;                             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveNearLength;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontLength;                               // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontLengthEthereal;                       // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontRadius;                               // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontYaw;                                  // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontYawEthereal;                          // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontPitch;                                // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AiFollowFrontPitchEthereal;                        // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WaitAngryCenterOffset;                             // 0x0148(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitAngryRadiusMin;                                // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitAngryRadiusMax;                                // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WaitAngryIndoorCenterOffset;                       // 0x015C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitAngryIndoorRadiusMin;                          // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitAngryIndoorRadiusMax;                          // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiAiFollowType                      FollowType;                                        // 0x0170(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiEmotionType                       EmotionType;                                       // 0x0171(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_172[0x2];                                      // 0x0172(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AiWaitTime;                                        // 0x0174(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ActorsToIgnoreList;                                // 0x0178(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bRandomFollowPositon;                              // 0x0188(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomFollowNextRadius;                            // 0x018C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RandomFollowNextYaw;                               // 0x0190(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RandomFollowNextPitch;                             // 0x0194(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerOnVehicle;                                  // 0x0198(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerOnVehicleSpeedMax;                           // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                OldPlayerPosition;                                 // 0x01A0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExIdleSequenceName;                                // 0x01AC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARCLevelSequenceActor*                  ExIdleSequence;                                    // 0x01B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCTimer*                               CheckTimer;                                        // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiAIFollow">();
	}
	static class URCShinigamiAIFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiAIFollow>();
	}
};
static_assert(alignof(URCShinigamiAIFollow) == 0x000008, "Wrong alignment on URCShinigamiAIFollow");
static_assert(sizeof(URCShinigamiAIFollow) == 0x0001D0, "Wrong size on URCShinigamiAIFollow");
static_assert(offsetof(URCShinigamiAIFollow, ShinigamiActor) == 0x0000C0, "Member 'URCShinigamiAIFollow::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, PlayerActor) == 0x0000C8, "Member 'URCShinigamiAIFollow::PlayerActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, ParrentComponent) == 0x0000D0, "Member 'URCShinigamiAIFollow::ParrentComponent' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, Movement) == 0x0000D8, "Member 'URCShinigamiAIFollow::Movement' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowCenterOffset) == 0x0000E0, "Member 'URCShinigamiAIFollow::FollowCenterOffset' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowRadius) == 0x0000EC, "Member 'URCShinigamiAIFollow::FollowRadius' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowMoveCenterOffset) == 0x0000F0, "Member 'URCShinigamiAIFollow::FollowMoveCenterOffset' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowMoveRadius) == 0x0000FC, "Member 'URCShinigamiAIFollow::FollowMoveRadius' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowFrontLength) == 0x000100, "Member 'URCShinigamiAIFollow::FollowFrontLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowFrontFarLength) == 0x000104, "Member 'URCShinigamiAIFollow::FollowFrontFarLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowHiSpeedLength) == 0x000108, "Member 'URCShinigamiAIFollow::FollowHiSpeedLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiWaitTimeMin) == 0x00010C, "Member 'URCShinigamiAIFollow::AiWaitTimeMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiWaitTimeMax) == 0x000110, "Member 'URCShinigamiAIFollow::AiWaitTimeMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiMoveWaitTimeMin) == 0x000114, "Member 'URCShinigamiAIFollow::AiMoveWaitTimeMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiMoveWaitTimeMax) == 0x000118, "Member 'URCShinigamiAIFollow::AiMoveWaitTimeMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiMoveWaitFontTimeMin) == 0x00011C, "Member 'URCShinigamiAIFollow::AiMoveWaitFontTimeMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiMoveWaitFontTimeMax) == 0x000120, "Member 'URCShinigamiAIFollow::AiMoveWaitFontTimeMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, PlayerCollisionLength) == 0x000124, "Member 'URCShinigamiAIFollow::PlayerCollisionLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, MoveNearLength) == 0x000128, "Member 'URCShinigamiAIFollow::MoveNearLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontLength) == 0x00012C, "Member 'URCShinigamiAIFollow::AiFollowFrontLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontLengthEthereal) == 0x000130, "Member 'URCShinigamiAIFollow::AiFollowFrontLengthEthereal' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontRadius) == 0x000134, "Member 'URCShinigamiAIFollow::AiFollowFrontRadius' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontYaw) == 0x000138, "Member 'URCShinigamiAIFollow::AiFollowFrontYaw' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontYawEthereal) == 0x00013C, "Member 'URCShinigamiAIFollow::AiFollowFrontYawEthereal' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontPitch) == 0x000140, "Member 'URCShinigamiAIFollow::AiFollowFrontPitch' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiFollowFrontPitchEthereal) == 0x000144, "Member 'URCShinigamiAIFollow::AiFollowFrontPitchEthereal' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryCenterOffset) == 0x000148, "Member 'URCShinigamiAIFollow::WaitAngryCenterOffset' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryRadiusMin) == 0x000154, "Member 'URCShinigamiAIFollow::WaitAngryRadiusMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryRadiusMax) == 0x000158, "Member 'URCShinigamiAIFollow::WaitAngryRadiusMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryIndoorCenterOffset) == 0x00015C, "Member 'URCShinigamiAIFollow::WaitAngryIndoorCenterOffset' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryIndoorRadiusMin) == 0x000168, "Member 'URCShinigamiAIFollow::WaitAngryIndoorRadiusMin' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, WaitAngryIndoorRadiusMax) == 0x00016C, "Member 'URCShinigamiAIFollow::WaitAngryIndoorRadiusMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, FollowType) == 0x000170, "Member 'URCShinigamiAIFollow::FollowType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, EmotionType) == 0x000171, "Member 'URCShinigamiAIFollow::EmotionType' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, AiWaitTime) == 0x000174, "Member 'URCShinigamiAIFollow::AiWaitTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, ActorsToIgnoreList) == 0x000178, "Member 'URCShinigamiAIFollow::ActorsToIgnoreList' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, bRandomFollowPositon) == 0x000188, "Member 'URCShinigamiAIFollow::bRandomFollowPositon' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, RandomFollowNextRadius) == 0x00018C, "Member 'URCShinigamiAIFollow::RandomFollowNextRadius' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, RandomFollowNextYaw) == 0x000190, "Member 'URCShinigamiAIFollow::RandomFollowNextYaw' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, RandomFollowNextPitch) == 0x000194, "Member 'URCShinigamiAIFollow::RandomFollowNextPitch' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, bPlayerOnVehicle) == 0x000198, "Member 'URCShinigamiAIFollow::bPlayerOnVehicle' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, PlayerOnVehicleSpeedMax) == 0x00019C, "Member 'URCShinigamiAIFollow::PlayerOnVehicleSpeedMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, OldPlayerPosition) == 0x0001A0, "Member 'URCShinigamiAIFollow::OldPlayerPosition' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, ExIdleSequenceName) == 0x0001AC, "Member 'URCShinigamiAIFollow::ExIdleSequenceName' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, ExIdleSequence) == 0x0001B8, "Member 'URCShinigamiAIFollow::ExIdleSequence' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, bDebugDraw) == 0x0001C0, "Member 'URCShinigamiAIFollow::bDebugDraw' has a wrong offset!");
static_assert(offsetof(URCShinigamiAIFollow, CheckTimer) == 0x0001C8, "Member 'URCShinigamiAIFollow::CheckTimer' has a wrong offset!");

// Class RC.RCShinigamiEffectComponent
// 0x0098 (0x0170 - 0x00D8)
class URCShinigamiEffectComponent final : public URCEffectComponent
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0xC];                                       // 0x00E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComponentNo;                                       // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachPointName;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 AuraEffectData_Always;                             // 0x0100(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 AuraEffectData_Stop;                               // 0x011C(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 AuraEffectData_Move0;                              // 0x0138(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRCEffectComponentData                 AuraEffectData_Move1;                              // 0x0154(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool EffectSpawn(struct FRCEffectComponentData& InEffectData);
	bool EffectStart(struct FRCEffectComponentData& InEffectData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiEffectComponent">();
	}
	static class URCShinigamiEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiEffectComponent>();
	}
};
static_assert(alignof(URCShinigamiEffectComponent) == 0x000008, "Wrong alignment on URCShinigamiEffectComponent");
static_assert(sizeof(URCShinigamiEffectComponent) == 0x000170, "Wrong size on URCShinigamiEffectComponent");
static_assert(offsetof(URCShinigamiEffectComponent, OwnerCharacter) == 0x0000D8, "Member 'URCShinigamiEffectComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, OwnerMesh) == 0x0000E0, "Member 'URCShinigamiEffectComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, ComponentNo) == 0x0000F4, "Member 'URCShinigamiEffectComponent::ComponentNo' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, AttachPointName) == 0x0000F8, "Member 'URCShinigamiEffectComponent::AttachPointName' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, AuraEffectData_Always) == 0x000100, "Member 'URCShinigamiEffectComponent::AuraEffectData_Always' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, AuraEffectData_Stop) == 0x00011C, "Member 'URCShinigamiEffectComponent::AuraEffectData_Stop' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, AuraEffectData_Move0) == 0x000138, "Member 'URCShinigamiEffectComponent::AuraEffectData_Move0' has a wrong offset!");
static_assert(offsetof(URCShinigamiEffectComponent, AuraEffectData_Move1) == 0x000154, "Member 'URCShinigamiEffectComponent::AuraEffectData_Move1' has a wrong offset!");

// Class RC.RCShinigamiMovement
// 0x0158 (0x0180 - 0x0028)
class URCShinigamiMovement final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShinigamiActor;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         WarpEfffect;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Brakepeed;                                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeed;                                         // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveFastSpeed;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveTurboSpeed;                                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Accele;                                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FastAccele;                                        // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TurboAccele;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Brake;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               RotatorSpeed;                                      // 0x00B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         RotatorNearLength;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotatorFarLength;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotatorFastSpeed;                                  // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotatorSpeedMulti;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BrakeUpLength;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveFastSpeedLength;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveHiSpeedLength;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveWarpLength;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreakTickMax;                                      // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeeTypePlayerMidLength;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeeTypePlayerMaxLength;                           // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMove;                                             // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMoveTargetStop;                                   // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NextPosition;                                      // 0x00EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveTargetLength;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLastRotation;                                     // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               NextRotation;                                      // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	ERCShinigamiSpeedType                         SpeedType;                                         // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastTargetActor;                                   // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NowPosition;                                       // 0x0118(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NowVelocity;                                       // 0x0124(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               NowRotator;                                        // 0x0130(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               NowRotatorVelocity;                                // 0x013C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bMoveBrake;                                        // 0x0148(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowMoveSpeed;                                      // 0x014C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               NowMoveRotator;                                    // 0x0150(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         NextLength;                                        // 0x015C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BrakeLength;                                       // 0x0160(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreakTick;                                         // 0x0164(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WarpTime;                                          // 0x0168(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WarpNextPosition;                                  // 0x016C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeedMagnification;                            // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCShinigamiWarpType                          MoveWarpType;                                      // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDraw;                                        // 0x017D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17E[0x2];                                      // 0x017E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCShinigamiMovement">();
	}
	static class URCShinigamiMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCShinigamiMovement>();
	}
};
static_assert(alignof(URCShinigamiMovement) == 0x000008, "Wrong alignment on URCShinigamiMovement");
static_assert(sizeof(URCShinigamiMovement) == 0x000180, "Wrong size on URCShinigamiMovement");
static_assert(offsetof(URCShinigamiMovement, ShinigamiActor) == 0x000080, "Member 'URCShinigamiMovement::ShinigamiActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, WarpEfffect) == 0x000088, "Member 'URCShinigamiMovement::WarpEfffect' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, Brakepeed) == 0x000090, "Member 'URCShinigamiMovement::Brakepeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveSpeed) == 0x000094, "Member 'URCShinigamiMovement::MoveSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveFastSpeed) == 0x000098, "Member 'URCShinigamiMovement::MoveFastSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveTurboSpeed) == 0x00009C, "Member 'URCShinigamiMovement::MoveTurboSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, Accele) == 0x0000A0, "Member 'URCShinigamiMovement::Accele' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, FastAccele) == 0x0000A4, "Member 'URCShinigamiMovement::FastAccele' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, TurboAccele) == 0x0000A8, "Member 'URCShinigamiMovement::TurboAccele' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, Brake) == 0x0000AC, "Member 'URCShinigamiMovement::Brake' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, RotatorSpeed) == 0x0000B0, "Member 'URCShinigamiMovement::RotatorSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, RotatorNearLength) == 0x0000BC, "Member 'URCShinigamiMovement::RotatorNearLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, RotatorFarLength) == 0x0000C0, "Member 'URCShinigamiMovement::RotatorFarLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, RotatorFastSpeed) == 0x0000C4, "Member 'URCShinigamiMovement::RotatorFastSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, RotatorSpeedMulti) == 0x0000C8, "Member 'URCShinigamiMovement::RotatorSpeedMulti' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, BrakeUpLength) == 0x0000CC, "Member 'URCShinigamiMovement::BrakeUpLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveFastSpeedLength) == 0x0000D0, "Member 'URCShinigamiMovement::MoveFastSpeedLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveHiSpeedLength) == 0x0000D4, "Member 'URCShinigamiMovement::MoveHiSpeedLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveWarpLength) == 0x0000D8, "Member 'URCShinigamiMovement::MoveWarpLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, BreakTickMax) == 0x0000DC, "Member 'URCShinigamiMovement::BreakTickMax' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, SpeeTypePlayerMidLength) == 0x0000E0, "Member 'URCShinigamiMovement::SpeeTypePlayerMidLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, SpeeTypePlayerMaxLength) == 0x0000E4, "Member 'URCShinigamiMovement::SpeeTypePlayerMaxLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, bMove) == 0x0000E8, "Member 'URCShinigamiMovement::bMove' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, bMoveTargetStop) == 0x0000E9, "Member 'URCShinigamiMovement::bMoveTargetStop' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NextPosition) == 0x0000EC, "Member 'URCShinigamiMovement::NextPosition' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveTargetLength) == 0x0000F8, "Member 'URCShinigamiMovement::MoveTargetLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, bLastRotation) == 0x0000FC, "Member 'URCShinigamiMovement::bLastRotation' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NextRotation) == 0x000100, "Member 'URCShinigamiMovement::NextRotation' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, SpeedType) == 0x00010C, "Member 'URCShinigamiMovement::SpeedType' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, LastTargetActor) == 0x000110, "Member 'URCShinigamiMovement::LastTargetActor' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowPosition) == 0x000118, "Member 'URCShinigamiMovement::NowPosition' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowVelocity) == 0x000124, "Member 'URCShinigamiMovement::NowVelocity' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowRotator) == 0x000130, "Member 'URCShinigamiMovement::NowRotator' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowRotatorVelocity) == 0x00013C, "Member 'URCShinigamiMovement::NowRotatorVelocity' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, bMoveBrake) == 0x000148, "Member 'URCShinigamiMovement::bMoveBrake' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowMoveSpeed) == 0x00014C, "Member 'URCShinigamiMovement::NowMoveSpeed' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NowMoveRotator) == 0x000150, "Member 'URCShinigamiMovement::NowMoveRotator' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, NextLength) == 0x00015C, "Member 'URCShinigamiMovement::NextLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, BrakeLength) == 0x000160, "Member 'URCShinigamiMovement::BrakeLength' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, BreakTick) == 0x000164, "Member 'URCShinigamiMovement::BreakTick' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, WarpTime) == 0x000168, "Member 'URCShinigamiMovement::WarpTime' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, WarpNextPosition) == 0x00016C, "Member 'URCShinigamiMovement::WarpNextPosition' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveSpeedMagnification) == 0x000178, "Member 'URCShinigamiMovement::MoveSpeedMagnification' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, MoveWarpType) == 0x00017C, "Member 'URCShinigamiMovement::MoveWarpType' has a wrong offset!");
static_assert(offsetof(URCShinigamiMovement, bDebugDraw) == 0x00017D, "Member 'URCShinigamiMovement::bDebugDraw' has a wrong offset!");

// Class RC.RCSoundManagerBFL
// 0x0000 (0x0028 - 0x0028)
class URCSoundManagerBFL final : public URCBlueprintFunctionLibrary
{
public:
	static void ActionSequencerSound(const struct FRCParamSequencerSoundTemplateTableRow& SoundData, bool bMovie);
	static void ChangeMapEnvSoundVolume(float Volume, float FadeTime);
	static void CrossFade(ERCSoundType SoundType, int32 Index_0, float fadeOutTime);
	static void CrossFadeForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, float fadeOutTime);
	static void FadeIn(ERCSoundType SoundType, int32 Index_0, float fadeInTime, float StartTime, float finishVolume);
	static void FadeInForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, float fadeInTime, float StartTime, float finishVolume);
	static void FadeOut(ERCSoundType SoundType, int32 Index_0, float fadeOutTime, float finishVolume);
	static void FadeOutForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, float fadeOutTime, float finishVolume);
	static TArray<class FString> GetPlayingBgmIDArray();
	static TArray<class FString> GetPlayingEnvIDArray();
	static TArray<class FString> GetPlayingSeIDArray();
	static class ARCSoundManager* GetSoundManager();
	static void GetSoundParameter(ERCSoundType SoundType, const class FString& ParamSoundID, int32* soundIndex, class FString* SoundId, class FString* CharaID, int32* OptionType);
	static ERCSoundType GetSoundType(ERCSoundType SoundType, int32 OptionType);
	static class FName GetVoiceID(class FName TextID, int32 Chapter);
	static bool IsDeathMatchBattle();
	static bool IsLoadCompleteNonResidentSheet(ERCSoundType SoundType);
	static bool IsPlaying(ERCSoundType SoundType, const class FString& ParamSoundID);
	static void LoadNonResidentSheet(const class FString& SheetID);
	static void Pause();
	static void PauseForSoundType(ERCSoundType SoundType);
	static void PauseSingle(ERCSoundType SoundType, int32 soundIndex, class AActor* Actor);
	static void PauseSingleForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, class AActor* Actor);
	static void ReloadVoiceSheet();
	static void ResetAreaChange();
	static void ResetDisableLipSyncCharaID();
	static void ResetVoiceCharaFacial();
	static void ResetVoiceCharaFacialOfActor(class AActor* InActor);
	static void Resume();
	static void ResumeFieldSound();
	static void ResumeForSoundType(ERCSoundType SoundType);
	static void ResumeSingle(ERCSoundType SoundType, int32 soundIndex, class AActor* Actor);
	static void ResumeSingleForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, class AActor* Actor);
	static void Set3DSoundPlayFlag(const class FString& ActorName, bool IsPause_0);
	static void SetBackLogFlag(bool IsEnable);
	static void SetDisableLipSyncCharaID(class FName CharaID);
	static void SetEnableLipSync(bool IsEnable);
	static void SetFadeSoundForPosition(ERCSoundType soundType1, int32 soundIndex1, class AActor* actor1, ERCSoundType soundType2, int32 soundIndex2, class AActor* actor2);
	static void SetFadeSoundForSoundIDPosition(ERCSoundType soundType1, const class FString& paramSoundID1, class AActor* actor1, ERCSoundType soundType2, const class FString& paramSoundID2, class AActor* actor2);
	static void SetLipSyncCharaArray(const TArray<class ACharacter*>& charaArray);
	static void SetPlayAmatanVoice(class FName VoiceID);
	static void SetPlaySound(ERCSoundType SoundType, int32 soundIndex, bool IsLoop, const class FString& CharaID, bool isFadeIn);
	static void SetPlaySoundForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, bool IsLoop, const class FString& CharaID, bool isFadeIn);
	static void SetPlaySoundForParamSoundIDVolume(ERCSoundType SoundType, const class FString& ParamSoundID, bool IsLoop, const class FString& CharaID, bool isFadeIn, float volumeRate);
	static void SetPlaySoundForVoiceID(class FName VoiceID, class FName voiceCharaID, class FName FacialName, class FName useMorph, bool bAllowfacialFlowLiquid, float volumeRate);
	static void SetRunningSQC(bool isFlag);
	static void SetSQCTime(float Time);
	static void SpawnSound(ERCSoundType SoundType, int32 soundIndex, const class FString& CharaID, const struct FVector& Location, float RangeMin, float RangeMax, bool IsLoop, class AActor* Actor, class USoundAttenuation* SoundAttenuation);
	static void SpawnSoundForMovingActor(ERCSoundType SoundType, int32 soundIndex, class AActor* Actor, float RangeMin, float RangeMax, bool IsLoop, const class FString& CharaID);
	static void SpawnSoundForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, const class FString& CharaID, const struct FVector& Location, float RangeMin, float RangeMax, bool IsLoop, class AActor* Actor, class USoundAttenuation* SoundAttenuation);
	static void SpawnSoundForSoundIDMovingActor(ERCSoundType SoundType, const class FString& ParamSoundID, class AActor* Actor, float RangeMin, float RangeMax, bool IsLoop, const class FString& CharaID);
	static void Stop(ERCSoundType SoundType);
	static void StopSingle(ERCSoundType SoundType, int32 soundIndex, class AActor* Actor);
	static void StopSingleForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, class AActor* Actor, bool is3DSound);
	static void StopSoundBeforeLoading();
	static void UpdataSingleVolume(ERCSoundType SoundType, int32 soundIndex, float volumeRate);
	static void UpdataSingleVolumeForParamSoundID(ERCSoundType SoundType, const class FString& ParamSoundID, float volumeRate);
	static void UpdataVolume(ERCSoundType SoundType, float Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSoundManagerBFL">();
	}
	static class URCSoundManagerBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSoundManagerBFL>();
	}
};
static_assert(alignof(URCSoundManagerBFL) == 0x000008, "Wrong alignment on URCSoundManagerBFL");
static_assert(sizeof(URCSoundManagerBFL) == 0x000028, "Wrong size on URCSoundManagerBFL");

// Class RC.RCSplineActor
// 0x0008 (0x0290 - 0x0288)
class ARCSplineActor final : public ARCActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetSplineDistanceMax();
	bool GetSplineLocation(struct FVector* OutLocation, float* InOutDistance, float InSpeed, bool bInLoop);
	bool GetSplineLocationAndRotate(struct FVector* OutLocation, struct FRotator* OutRotate, float* InOutDistance, float InSpeed, bool bInLoop);
	bool GetSplineTransform(struct FTransform* OutTransform, float* InOutDistance, float InSpeed, bool bInLoop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSplineActor">();
	}
	static class ARCSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCSplineActor>();
	}
};
static_assert(alignof(ARCSplineActor) == 0x000008, "Wrong alignment on ARCSplineActor");
static_assert(sizeof(ARCSplineActor) == 0x000290, "Wrong size on ARCSplineActor");
static_assert(offsetof(ARCSplineActor, SplineComponent) == 0x000288, "Member 'ARCSplineActor::SplineComponent' has a wrong offset!");

// Class RC.RCSubStoryStartupAutoSave
// 0x0018 (0x02D8 - 0x02C0)
class URCSubStoryStartupAutoSave final : public URCStartupWidget
{
public:
	class UTextBlock*                             Text;                                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSavingIcon*                        SavingIcon;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isFinish;                                          // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SaveIconFinish();
	void SetText(class FName InTextID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCSubStoryStartupAutoSave">();
	}
	static class URCSubStoryStartupAutoSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCSubStoryStartupAutoSave>();
	}
};
static_assert(alignof(URCSubStoryStartupAutoSave) == 0x000008, "Wrong alignment on URCSubStoryStartupAutoSave");
static_assert(sizeof(URCSubStoryStartupAutoSave) == 0x0002D8, "Wrong size on URCSubStoryStartupAutoSave");
static_assert(offsetof(URCSubStoryStartupAutoSave, Text) == 0x0002C0, "Member 'URCSubStoryStartupAutoSave::Text' has a wrong offset!");
static_assert(offsetof(URCSubStoryStartupAutoSave, SavingIcon) == 0x0002C8, "Member 'URCSubStoryStartupAutoSave::SavingIcon' has a wrong offset!");
static_assert(offsetof(URCSubStoryStartupAutoSave, isFinish) == 0x0002D0, "Member 'URCSubStoryStartupAutoSave::isFinish' has a wrong offset!");

// Class RC.RCText3DComponent
// 0x0000 (0x02E0 - 0x02E0)
class URCText3DComponent final : public UText3DComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCText3DComponent">();
	}
	static class URCText3DComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCText3DComponent>();
	}
};
static_assert(alignof(URCText3DComponent) == 0x000010, "Wrong alignment on URCText3DComponent");
static_assert(sizeof(URCText3DComponent) == 0x0002E0, "Wrong size on URCText3DComponent");

// Class RC.RCTextBFL
// 0x0000 (0x0028 - 0x0028)
class URCTextBFL final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetText(class FName InTextID);
	static ERCTextLanguage GetTextLanguage();
	static bool IsText(class FName InTextID);
	static void LoadDlcTextLanguage();
	static void SetTextLanguage(ERCTextLanguage Language);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTextBFL">();
	}
	static class URCTextBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTextBFL>();
	}
};
static_assert(alignof(URCTextBFL) == 0x000008, "Wrong alignment on URCTextBFL");
static_assert(sizeof(URCTextBFL) == 0x000028, "Wrong size on URCTextBFL");

// Class RC.RCTimeBFL
// 0x0000 (0x0028 - 0x0028)
class URCTimeBFL final : public UBlueprintFunctionLibrary
{
public:
	static float GetGameSpeed();
	static float GetNowSpeed();
	static float GetSkipSpeed();
	static bool IsMenuPause();
	static void SetGameSpeed(float InSpeed);
	static void SetMenuPause(bool bFlag);
	static void SetSkipSpeed(float InSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTimeBFL">();
	}
	static class URCTimeBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTimeBFL>();
	}
};
static_assert(alignof(URCTimeBFL) == 0x000008, "Wrong alignment on URCTimeBFL");
static_assert(sizeof(URCTimeBFL) == 0x000028, "Wrong size on URCTimeBFL");

// Class RC.RCTimer
// 0x0028 (0x0050 - 0x0028)
class URCTimer final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTimer">();
	}
	static class URCTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTimer>();
	}
};
static_assert(alignof(URCTimer) == 0x000008, "Wrong alignment on URCTimer");
static_assert(sizeof(URCTimer) == 0x000050, "Wrong size on URCTimer");

// Class RC.RCTitleChapterSelectCaption
// 0x0010 (0x02E8 - 0x02D8)
class URCTitleChapterSelectCaption : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectCaption">();
	}
	static class URCTitleChapterSelectCaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectCaption>();
	}
};
static_assert(alignof(URCTitleChapterSelectCaption) == 0x000008, "Wrong alignment on URCTitleChapterSelectCaption");
static_assert(sizeof(URCTitleChapterSelectCaption) == 0x0002E8, "Wrong size on URCTitleChapterSelectCaption");

// Class RC.RCTitleChapterSelectQuestImage
// 0x0000 (0x02D8 - 0x02D8)
class URCTitleChapterSelectQuestImage final : public URCUiWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectQuestImage">();
	}
	static class URCTitleChapterSelectQuestImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectQuestImage>();
	}
};
static_assert(alignof(URCTitleChapterSelectQuestImage) == 0x000008, "Wrong alignment on URCTitleChapterSelectQuestImage");
static_assert(sizeof(URCTitleChapterSelectQuestImage) == 0x0002D8, "Wrong size on URCTitleChapterSelectQuestImage");

// Class RC.RCTitleChapterSelectWindow
// 0x0030 (0x0328 - 0x02F8)
class URCTitleChapterSelectWindow : public URCMenuManager
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URCTitleChapterSelectWindowItem*> listItemArray;                                     // 0x0310(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bListLoop;                                         // 0x0324(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFinished;                                         // 0x0325(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelected;                                         // 0x0326(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDecided;                                          // 0x0327(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UWidget* ChapterSelectWindowSelectNavigation(EUINavigation InNavigation);
	void SelectListItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectWindow">();
	}
	static class URCTitleChapterSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectWindow>();
	}
};
static_assert(alignof(URCTitleChapterSelectWindow) == 0x000008, "Wrong alignment on URCTitleChapterSelectWindow");
static_assert(sizeof(URCTitleChapterSelectWindow) == 0x000328, "Wrong size on URCTitleChapterSelectWindow");
static_assert(offsetof(URCTitleChapterSelectWindow, AN_Start) == 0x0002F8, "Member 'URCTitleChapterSelectWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, AN_Wait) == 0x000300, "Member 'URCTitleChapterSelectWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, AN_Finish) == 0x000308, "Member 'URCTitleChapterSelectWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, listItemArray) == 0x000310, "Member 'URCTitleChapterSelectWindow::listItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, SelectIndex) == 0x000320, "Member 'URCTitleChapterSelectWindow::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, bListLoop) == 0x000324, "Member 'URCTitleChapterSelectWindow::bListLoop' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, bFinished) == 0x000325, "Member 'URCTitleChapterSelectWindow::bFinished' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, bSelected) == 0x000326, "Member 'URCTitleChapterSelectWindow::bSelected' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindow, bDecided) == 0x000327, "Member 'URCTitleChapterSelectWindow::bDecided' has a wrong offset!");

// Class RC.RCTitleChapterSelectWindowItem
// 0x0038 (0x0358 - 0x0320)
class URCTitleChapterSelectWindowItem : public URCMenuButton
{
public:
	class UTextBlock*                             TextBlock;                                         // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Def;                                            // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCurrentMouseSelect;                              // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isPressDecide;                                     // 0x0351(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isNotSelect;                                       // 0x0352(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_353[0x5];                                      // 0x0353(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleChapterSelectWindowItem">();
	}
	static class URCTitleChapterSelectWindowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleChapterSelectWindowItem>();
	}
};
static_assert(alignof(URCTitleChapterSelectWindowItem) == 0x000008, "Wrong alignment on URCTitleChapterSelectWindowItem");
static_assert(sizeof(URCTitleChapterSelectWindowItem) == 0x000358, "Wrong size on URCTitleChapterSelectWindowItem");
static_assert(offsetof(URCTitleChapterSelectWindowItem, TextBlock) == 0x000320, "Member 'URCTitleChapterSelectWindowItem::TextBlock' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, AN_Def) == 0x000328, "Member 'URCTitleChapterSelectWindowItem::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, AN_Off) == 0x000330, "Member 'URCTitleChapterSelectWindowItem::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, AN_Cursor_On) == 0x000338, "Member 'URCTitleChapterSelectWindowItem::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, AN_Cursor_Out) == 0x000340, "Member 'URCTitleChapterSelectWindowItem::AN_Cursor_Out' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, AN_Push) == 0x000348, "Member 'URCTitleChapterSelectWindowItem::AN_Push' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, isCurrentMouseSelect) == 0x000350, "Member 'URCTitleChapterSelectWindowItem::isCurrentMouseSelect' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, isPressDecide) == 0x000351, "Member 'URCTitleChapterSelectWindowItem::isPressDecide' has a wrong offset!");
static_assert(offsetof(URCTitleChapterSelectWindowItem, isNotSelect) == 0x000352, "Member 'URCTitleChapterSelectWindowItem::isNotSelect' has a wrong offset!");

// Class RC.RCTitleGalleryBase
// 0x0070 (0x0348 - 0x02D8)
class URCTitleGalleryBase : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x70];                                     // 0x02D8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeGallery();
	void Open(bool bBackFromGalleryMovie);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryBase">();
	}
	static class URCTitleGalleryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryBase>();
	}
};
static_assert(alignof(URCTitleGalleryBase) == 0x000008, "Wrong alignment on URCTitleGalleryBase");
static_assert(sizeof(URCTitleGalleryBase) == 0x000348, "Wrong size on URCTitleGalleryBase");

// Class RC.RCTitleGalleryBGM
// 0x0038 (0x0310 - 0x02D8)
class URCTitleGalleryBGM : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_In;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Flame_Out;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryBGM">();
	}
	static class URCTitleGalleryBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryBGM>();
	}
};
static_assert(alignof(URCTitleGalleryBGM) == 0x000008, "Wrong alignment on URCTitleGalleryBGM");
static_assert(sizeof(URCTitleGalleryBGM) == 0x000310, "Wrong size on URCTitleGalleryBGM");
static_assert(offsetof(URCTitleGalleryBGM, AN_On) == 0x0002D8, "Member 'URCTitleGalleryBGM::AN_On' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGM, AN_Off) == 0x0002E0, "Member 'URCTitleGalleryBGM::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGM, AN_Flame_In) == 0x0002E8, "Member 'URCTitleGalleryBGM::AN_Flame_In' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryBGM, AN_Flame_Out) == 0x0002F0, "Member 'URCTitleGalleryBGM::AN_Flame_Out' has a wrong offset!");

// Class RC.RCTitleGalleryMovieImage
// 0x0020 (0x02F8 - 0x02D8)
class URCTitleGalleryMovieImage : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryMovieImage">();
	}
	static class URCTitleGalleryMovieImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryMovieImage>();
	}
};
static_assert(alignof(URCTitleGalleryMovieImage) == 0x000008, "Wrong alignment on URCTitleGalleryMovieImage");
static_assert(sizeof(URCTitleGalleryMovieImage) == 0x0002F8, "Wrong size on URCTitleGalleryMovieImage");

// Class RC.RCTitleGalleryMovieImageName
// 0x0040 (0x0318 - 0x02D8)
class URCTitleGalleryMovieImageName : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Gallery_Name;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Gallery_Name_1;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x30];                                     // 0x02E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryMovieImageName">();
	}
	static class URCTitleGalleryMovieImageName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryMovieImageName>();
	}
};
static_assert(alignof(URCTitleGalleryMovieImageName) == 0x000008, "Wrong alignment on URCTitleGalleryMovieImageName");
static_assert(sizeof(URCTitleGalleryMovieImageName) == 0x000318, "Wrong size on URCTitleGalleryMovieImageName");
static_assert(offsetof(URCTitleGalleryMovieImageName, Text_Gallery_Name) == 0x0002D8, "Member 'URCTitleGalleryMovieImageName::Text_Gallery_Name' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovieImageName, Text_Gallery_Name_1) == 0x0002E0, "Member 'URCTitleGalleryMovieImageName::Text_Gallery_Name_1' has a wrong offset!");

// Class RC.RCTitleGalleryMovieListBar
// 0x0048 (0x0368 - 0x0320)
class URCTitleGalleryMovieListBar : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x20];                                     // 0x0348(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecidedProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryMovieListBar">();
	}
	static class URCTitleGalleryMovieListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryMovieListBar>();
	}
};
static_assert(alignof(URCTitleGalleryMovieListBar) == 0x000008, "Wrong alignment on URCTitleGalleryMovieListBar");
static_assert(sizeof(URCTitleGalleryMovieListBar) == 0x000368, "Wrong size on URCTitleGalleryMovieListBar");
static_assert(offsetof(URCTitleGalleryMovieListBar, AN_Default) == 0x000320, "Member 'URCTitleGalleryMovieListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovieListBar, AN_OnCursor) == 0x000328, "Member 'URCTitleGalleryMovieListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovieListBar, AN_OnCursor_Wait) == 0x000330, "Member 'URCTitleGalleryMovieListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovieListBar, AN_OutCursor) == 0x000338, "Member 'URCTitleGalleryMovieListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryMovieListBar, Text_ListName) == 0x000340, "Member 'URCTitleGalleryMovieListBar::Text_ListName' has a wrong offset!");

// Class RC.RCTitleGalleryName
// 0x0018 (0x02F0 - 0x02D8)
class URCTitleGalleryName : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeGalleryName();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleGalleryName">();
	}
	static class URCTitleGalleryName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleGalleryName>();
	}
};
static_assert(alignof(URCTitleGalleryName) == 0x000008, "Wrong alignment on URCTitleGalleryName");
static_assert(sizeof(URCTitleGalleryName) == 0x0002F0, "Wrong size on URCTitleGalleryName");
static_assert(offsetof(URCTitleGalleryName, AN_Start) == 0x0002D8, "Member 'URCTitleGalleryName::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryName, AN_Wait) == 0x0002E0, "Member 'URCTitleGalleryName::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleGalleryName, AN_Finish) == 0x0002E8, "Member 'URCTitleGalleryName::AN_Finish' has a wrong offset!");

// Class RC.RCTitleHUDBFL
// 0x0000 (0x0028 - 0x0028)
class URCTitleHUDBFL final : public URCBlueprintFunctionLibrary
{
public:
	static void EndGalleryMovie();
	static class UDataTable* GetGalleryMovieSoundTable();
	static class FName GetGalleryPlayMovieID();
	static bool GetTitleGalleryMovieEvent();
	static class ARCTitleHUD* GetTitleHUD();
	static bool IsStartGalleryMovie();
	static void SetTitleGalleryMovieEvent(bool bInMovieEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleHUDBFL">();
	}
	static class URCTitleHUDBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleHUDBFL>();
	}
};
static_assert(alignof(URCTitleHUDBFL) == 0x000008, "Wrong alignment on URCTitleHUDBFL");
static_assert(sizeof(URCTitleHUDBFL) == 0x000028, "Wrong size on URCTitleHUDBFL");

// Class RC.RCTItleLanguageWindowItem
// 0x0038 (0x0358 - 0x0320)
class URCTItleLanguageWindowItem : public URCMenuButton
{
public:
	class UTextBlock*                             textLine;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Def;                                            // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_On;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Cursor_Out;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTItleLanguageWindowItem">();
	}
	static class URCTItleLanguageWindowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTItleLanguageWindowItem>();
	}
};
static_assert(alignof(URCTItleLanguageWindowItem) == 0x000008, "Wrong alignment on URCTItleLanguageWindowItem");
static_assert(sizeof(URCTItleLanguageWindowItem) == 0x000358, "Wrong size on URCTItleLanguageWindowItem");
static_assert(offsetof(URCTItleLanguageWindowItem, textLine) == 0x000320, "Member 'URCTItleLanguageWindowItem::textLine' has a wrong offset!");
static_assert(offsetof(URCTItleLanguageWindowItem, AN_Def) == 0x000328, "Member 'URCTItleLanguageWindowItem::AN_Def' has a wrong offset!");
static_assert(offsetof(URCTItleLanguageWindowItem, AN_Off) == 0x000330, "Member 'URCTItleLanguageWindowItem::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTItleLanguageWindowItem, AN_Cursor_On) == 0x000338, "Member 'URCTItleLanguageWindowItem::AN_Cursor_On' has a wrong offset!");
static_assert(offsetof(URCTItleLanguageWindowItem, AN_Cursor_Out) == 0x000340, "Member 'URCTItleLanguageWindowItem::AN_Cursor_Out' has a wrong offset!");
static_assert(offsetof(URCTItleLanguageWindowItem, AN_Push) == 0x000348, "Member 'URCTItleLanguageWindowItem::AN_Push' has a wrong offset!");

// Class RC.RCTitleLicense
// 0x0048 (0x0320 - 0x02D8)
class URCTitleLicense : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Left;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x28];                                     // 0x02F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeLicense();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleLicense">();
	}
	static class URCTitleLicense* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleLicense>();
	}
};
static_assert(alignof(URCTitleLicense) == 0x000008, "Wrong alignment on URCTitleLicense");
static_assert(sizeof(URCTitleLicense) == 0x000320, "Wrong size on URCTitleLicense");
static_assert(offsetof(URCTitleLicense, AN_Start) == 0x0002D8, "Member 'URCTitleLicense::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleLicense, AN_Wait) == 0x0002E0, "Member 'URCTitleLicense::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleLicense, AN_Finish) == 0x0002E8, "Member 'URCTitleLicense::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleLicense, Text_Left) == 0x0002F0, "Member 'URCTitleLicense::Text_Left' has a wrong offset!");

// Class RC.RCTitleMenu
// 0x0068 (0x0360 - 0x02F8)
class URCTitleMenu : public URCMenuManager
{
public:
	class UImage*                                 bgImage01;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 bgImage00;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleMenuList*                       menuList00;                                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleMenuList*                       menuList01;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCTitleHelp*                           titleHelp;                                         // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       buttonGuide;                                       // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_List_Change;                                    // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_List_ChangeReverse;                             // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCTitleMenuState                             State;                                             // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERCTitleListType                              selectListType;                                    // 0x0351(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCheckPushKey;                                    // 0x0352(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_353[0x1];                                      // 0x0353(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         currentSelectIndex;                                // 0x0354(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isSaveData;                                        // 0x0358(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isFrontList;                                       // 0x0359(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isReturnTitleLogo;                                 // 0x035A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isChangeList;                                      // 0x035B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelWrap(ERCInputKeyType InKeyType);
	void DecideWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleMenu">();
	}
	static class URCTitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleMenu>();
	}
};
static_assert(alignof(URCTitleMenu) == 0x000008, "Wrong alignment on URCTitleMenu");
static_assert(sizeof(URCTitleMenu) == 0x000360, "Wrong size on URCTitleMenu");
static_assert(offsetof(URCTitleMenu, bgImage01) == 0x0002F8, "Member 'URCTitleMenu::bgImage01' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, bgImage00) == 0x000300, "Member 'URCTitleMenu::bgImage00' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, menuList00) == 0x000308, "Member 'URCTitleMenu::menuList00' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, menuList01) == 0x000310, "Member 'URCTitleMenu::menuList01' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, titleHelp) == 0x000318, "Member 'URCTitleMenu::titleHelp' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, buttonGuide) == 0x000320, "Member 'URCTitleMenu::buttonGuide' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, AN_Start) == 0x000328, "Member 'URCTitleMenu::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, AN_Wait) == 0x000330, "Member 'URCTitleMenu::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, AN_Finish) == 0x000338, "Member 'URCTitleMenu::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, AN_List_Change) == 0x000340, "Member 'URCTitleMenu::AN_List_Change' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, AN_List_ChangeReverse) == 0x000348, "Member 'URCTitleMenu::AN_List_ChangeReverse' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, State) == 0x000350, "Member 'URCTitleMenu::State' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, selectListType) == 0x000351, "Member 'URCTitleMenu::selectListType' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, isCheckPushKey) == 0x000352, "Member 'URCTitleMenu::isCheckPushKey' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, currentSelectIndex) == 0x000354, "Member 'URCTitleMenu::currentSelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, isSaveData) == 0x000358, "Member 'URCTitleMenu::isSaveData' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, isFrontList) == 0x000359, "Member 'URCTitleMenu::isFrontList' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, isReturnTitleLogo) == 0x00035A, "Member 'URCTitleMenu::isReturnTitleLogo' has a wrong offset!");
static_assert(offsetof(URCTitleMenu, isChangeList) == 0x00035B, "Member 'URCTitleMenu::isChangeList' has a wrong offset!");

// Class RC.RCTitlePlayerController
// 0x0010 (0x05B0 - 0x05A0)
class ARCTitlePlayerController final : public ARCMenuPlayerController
{
public:
	class URCTitleManager*                        titleManager;                                      // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitlePlayerController">();
	}
	static class ARCTitlePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCTitlePlayerController>();
	}
};
static_assert(alignof(ARCTitlePlayerController) == 0x000008, "Wrong alignment on ARCTitlePlayerController");
static_assert(sizeof(ARCTitlePlayerController) == 0x0005B0, "Wrong size on ARCTitlePlayerController");
static_assert(offsetof(ARCTitlePlayerController, titleManager) == 0x0005A0, "Member 'ARCTitlePlayerController::titleManager' has a wrong offset!");

// Class RC.RCTitleProtChoice
// 0x0020 (0x0340 - 0x0320)
class URCTitleProtChoice final : public URCMenuButton
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleProtChoice">();
	}
	static class URCTitleProtChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleProtChoice>();
	}
};
static_assert(alignof(URCTitleProtChoice) == 0x000008, "Wrong alignment on URCTitleProtChoice");
static_assert(sizeof(URCTitleProtChoice) == 0x000340, "Wrong size on URCTitleProtChoice");
static_assert(offsetof(URCTitleProtChoice, AN_Start) == 0x000320, "Member 'URCTitleProtChoice::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleProtChoice, AN_Finish) == 0x000328, "Member 'URCTitleProtChoice::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleProtChoice, AN_Wait) == 0x000330, "Member 'URCTitleProtChoice::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleProtChoice, AN_Push) == 0x000338, "Member 'URCTitleProtChoice::AN_Push' has a wrong offset!");

// Class RC.RCTitleSaveCheck
// 0x0030 (0x0310 - 0x02E0)
class URCTitleSaveCheck : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isFinishedSaveCheck;                               // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCTitleCheckType                             currentCheckType;                                  // 0x0309(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSaveCheck">();
	}
	static class URCTitleSaveCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSaveCheck>();
	}
};
static_assert(alignof(URCTitleSaveCheck) == 0x000008, "Wrong alignment on URCTitleSaveCheck");
static_assert(sizeof(URCTitleSaveCheck) == 0x000310, "Wrong size on URCTitleSaveCheck");
static_assert(offsetof(URCTitleSaveCheck, AN_Start) == 0x0002F0, "Member 'URCTitleSaveCheck::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheck, AN_Wait) == 0x0002F8, "Member 'URCTitleSaveCheck::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheck, AN_Finish) == 0x000300, "Member 'URCTitleSaveCheck::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheck, isFinishedSaveCheck) == 0x000308, "Member 'URCTitleSaveCheck::isFinishedSaveCheck' has a wrong offset!");
static_assert(offsetof(URCTitleSaveCheck, currentCheckType) == 0x000309, "Member 'URCTitleSaveCheck::currentCheckType' has a wrong offset!");

// Class RC.RCTitleSubStory
// 0x0080 (0x0358 - 0x02D8)
class URCTitleSubStory : public URCUiWidgetBase
{
public:
	class UImage*                                 subStoryText;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleSubStoryImage*                  subStoryImage;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTItleSubStoryList*                   subStoryList;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleChapterSelectCaption*           Caption;                                           // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleHelp*                           titleHelp;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCUiButtonGuide*                       Title_BTNGuide;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCTitleSubStoryWindow*                 Window;                                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EURCTitleSubStoryState                        State;                                             // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCheckFinish;                                     // 0x0329(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isReturnLoad;                                      // 0x032A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B[0x5];                                      // 0x032B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SaveCheckChapterIDList;                            // 0x0330(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<bool>                                  IsEnableSaveDataList;                              // 0x0340(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         NowSaveCheckIndex;                                 // 0x0350(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelWrap(ERCInputKeyType InKeyType);
	void DecideWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStory">();
	}
	static class URCTitleSubStory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStory>();
	}
};
static_assert(alignof(URCTitleSubStory) == 0x000008, "Wrong alignment on URCTitleSubStory");
static_assert(sizeof(URCTitleSubStory) == 0x000358, "Wrong size on URCTitleSubStory");
static_assert(offsetof(URCTitleSubStory, subStoryText) == 0x0002D8, "Member 'URCTitleSubStory::subStoryText' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, subStoryImage) == 0x0002E0, "Member 'URCTitleSubStory::subStoryImage' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, subStoryList) == 0x0002E8, "Member 'URCTitleSubStory::subStoryList' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, Caption) == 0x0002F0, "Member 'URCTitleSubStory::Caption' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, titleHelp) == 0x0002F8, "Member 'URCTitleSubStory::titleHelp' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, Title_BTNGuide) == 0x000300, "Member 'URCTitleSubStory::Title_BTNGuide' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, Window) == 0x000308, "Member 'URCTitleSubStory::Window' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, AN_Start) == 0x000310, "Member 'URCTitleSubStory::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, AN_Wait) == 0x000318, "Member 'URCTitleSubStory::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, AN_Finish) == 0x000320, "Member 'URCTitleSubStory::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, State) == 0x000328, "Member 'URCTitleSubStory::State' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, IsCheckFinish) == 0x000329, "Member 'URCTitleSubStory::IsCheckFinish' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, isReturnLoad) == 0x00032A, "Member 'URCTitleSubStory::isReturnLoad' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, SaveCheckChapterIDList) == 0x000330, "Member 'URCTitleSubStory::SaveCheckChapterIDList' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, IsEnableSaveDataList) == 0x000340, "Member 'URCTitleSubStory::IsEnableSaveDataList' has a wrong offset!");
static_assert(offsetof(URCTitleSubStory, NowSaveCheckIndex) == 0x000350, "Member 'URCTitleSubStory::NowSaveCheckIndex' has a wrong offset!");

// Class RC.RCTitleSubStoryWindow
// 0x0060 (0x0358 - 0x02F8)
class URCTitleSubStoryWindow : public URCMenuManager
{
public:
	TArray<class URCTitleChapterSelectWindowItem*> itemArray;                                         // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URCTitleChapterSelectWindowItem*> useItemArray;                                      // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<ERCTitleSubStoryWindowSelectState>     itemStateArray;                                    // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Start;                                          // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x0348(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         enableListMax;                                     // 0x034C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isCheckFinished;                                   // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isListLoop;                                        // 0x0351(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isDecide;                                          // 0x0352(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEnableSaveData;                                  // 0x0353(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectListItem();
	class UWidget* SubStoryWindowSelectNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCTitleSubStoryWindow">();
	}
	static class URCTitleSubStoryWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCTitleSubStoryWindow>();
	}
};
static_assert(alignof(URCTitleSubStoryWindow) == 0x000008, "Wrong alignment on URCTitleSubStoryWindow");
static_assert(sizeof(URCTitleSubStoryWindow) == 0x000358, "Wrong size on URCTitleSubStoryWindow");
static_assert(offsetof(URCTitleSubStoryWindow, itemArray) == 0x0002F8, "Member 'URCTitleSubStoryWindow::itemArray' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, useItemArray) == 0x000308, "Member 'URCTitleSubStoryWindow::useItemArray' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, itemStateArray) == 0x000318, "Member 'URCTitleSubStoryWindow::itemStateArray' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, AN_Start) == 0x000328, "Member 'URCTitleSubStoryWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, AN_Wait) == 0x000330, "Member 'URCTitleSubStoryWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, AN_Finish) == 0x000338, "Member 'URCTitleSubStoryWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, AN_Off) == 0x000340, "Member 'URCTitleSubStoryWindow::AN_Off' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, SelectIndex) == 0x000348, "Member 'URCTitleSubStoryWindow::SelectIndex' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, enableListMax) == 0x00034C, "Member 'URCTitleSubStoryWindow::enableListMax' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, isCheckFinished) == 0x000350, "Member 'URCTitleSubStoryWindow::isCheckFinished' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, isListLoop) == 0x000351, "Member 'URCTitleSubStoryWindow::isListLoop' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, isDecide) == 0x000352, "Member 'URCTitleSubStoryWindow::isDecide' has a wrong offset!");
static_assert(offsetof(URCTitleSubStoryWindow, IsEnableSaveData) == 0x000353, "Member 'URCTitleSubStoryWindow::IsEnableSaveData' has a wrong offset!");

// Class RC.RCUiBackLog
// 0x0088 (0x0360 - 0x02D8)
class URCUiBackLog final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishBackLog();
	void OnButtonGuideCloseClick(ERCInputKeyType KeyType);
	void OnButtonGuidePlayVoiceClick(ERCInputKeyType KeyType);
	void StartBackLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiBackLog">();
	}
	static class URCUiBackLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiBackLog>();
	}
};
static_assert(alignof(URCUiBackLog) == 0x000008, "Wrong alignment on URCUiBackLog");
static_assert(sizeof(URCUiBackLog) == 0x000360, "Wrong size on URCUiBackLog");
static_assert(offsetof(URCUiBackLog, AN_Start) == 0x0002F8, "Member 'URCUiBackLog::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiBackLog, AN_Wait) == 0x000300, "Member 'URCUiBackLog::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiBackLog, AN_Finish) == 0x000308, "Member 'URCUiBackLog::AN_Finish' has a wrong offset!");

// Class RC.RCUiCutIn
// 0x0040 (0x0318 - 0x02D8)
class URCUiCutIn final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TexturePath;                                       // 0x02F8(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeCutIn();
	void Open();
	void SetData(class FName InCutInImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiCutIn">();
	}
	static class URCUiCutIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiCutIn>();
	}
};
static_assert(alignof(URCUiCutIn) == 0x000008, "Wrong alignment on URCUiCutIn");
static_assert(sizeof(URCUiCutIn) == 0x000318, "Wrong size on URCUiCutIn");
static_assert(offsetof(URCUiCutIn, AN_Start) == 0x0002D8, "Member 'URCUiCutIn::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiCutIn, AN_Wait) == 0x0002E0, "Member 'URCUiCutIn::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiCutIn, AN_Finish) == 0x0002E8, "Member 'URCUiCutIn::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiCutIn, TexturePath) == 0x0002F8, "Member 'URCUiCutIn::TexturePath' has a wrong offset!");

// Class RC.RCUiFaderHUDBFL
// 0x0000 (0x0028 - 0x0028)
class URCUiFaderHUDBFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsAllWidgetsHidden();
	static bool IsAllWidgetsHiddenEnable();
	static bool SetAllWidgetsHidden(bool bAllWidgetsHidden);
	static void SetAllWidgetsHiddenEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiFaderHUDBFL">();
	}
	static class URCUiFaderHUDBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiFaderHUDBFL>();
	}
};
static_assert(alignof(URCUiFaderHUDBFL) == 0x000008, "Wrong alignment on URCUiFaderHUDBFL");
static_assert(sizeof(URCUiFaderHUDBFL) == 0x000028, "Wrong size on URCUiFaderHUDBFL");

// Class RC.RCUiWidgetInteractive
// 0x0080 (0x0358 - 0x02D8)
class URCUiWidgetInteractive : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnSelection;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OffSelection;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnSelection_Start;                              // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnSelection_Finish;                             // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_Start;                                    // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_Wait;                                     // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_Finish;                                   // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_OnSelection;                              // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_OffSelection;                             // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_OnSelection_Start;                        // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close_OnSelection_Finish;                       // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAccessible;                                     // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void CloseSelectable();
	void FinishSelectable();
	int32 GetInteractStatusInt();
	void InitAnimKey();
	void InitializeInteractIcon();
	void Open(bool bInMoveable);
	void OpenSelectable(bool bInMoveable);
	void StartSelectable();
	void WaitOutside();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiWidgetInteractive">();
	}
	static class URCUiWidgetInteractive* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiWidgetInteractive>();
	}
};
static_assert(alignof(URCUiWidgetInteractive) == 0x000008, "Wrong alignment on URCUiWidgetInteractive");
static_assert(sizeof(URCUiWidgetInteractive) == 0x000358, "Wrong size on URCUiWidgetInteractive");
static_assert(offsetof(URCUiWidgetInteractive, AN_Start) == 0x0002E0, "Member 'URCUiWidgetInteractive::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Wait) == 0x0002E8, "Member 'URCUiWidgetInteractive::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Finish) == 0x0002F0, "Member 'URCUiWidgetInteractive::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_OnSelection) == 0x0002F8, "Member 'URCUiWidgetInteractive::AN_OnSelection' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_OffSelection) == 0x000300, "Member 'URCUiWidgetInteractive::AN_OffSelection' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_OnSelection_Start) == 0x000308, "Member 'URCUiWidgetInteractive::AN_OnSelection_Start' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_OnSelection_Finish) == 0x000310, "Member 'URCUiWidgetInteractive::AN_OnSelection_Finish' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_Start) == 0x000318, "Member 'URCUiWidgetInteractive::AN_Close_Start' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_Wait) == 0x000320, "Member 'URCUiWidgetInteractive::AN_Close_Wait' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_Finish) == 0x000328, "Member 'URCUiWidgetInteractive::AN_Close_Finish' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_OnSelection) == 0x000330, "Member 'URCUiWidgetInteractive::AN_Close_OnSelection' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_OffSelection) == 0x000338, "Member 'URCUiWidgetInteractive::AN_Close_OffSelection' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_OnSelection_Start) == 0x000340, "Member 'URCUiWidgetInteractive::AN_Close_OnSelection_Start' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, AN_Close_OnSelection_Finish) == 0x000348, "Member 'URCUiWidgetInteractive::AN_Close_OnSelection_Finish' has a wrong offset!");
static_assert(offsetof(URCUiWidgetInteractive, bIsAccessible) == 0x000350, "Member 'URCUiWidgetInteractive::bIsAccessible' has a wrong offset!");

// Class RC.RCUiInteractArea
// 0x0010 (0x0368 - 0x0358)
class URCUiInteractArea final : public URCUiWidgetInteractive
{
public:
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractArea">();
	}
	static class URCUiInteractArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractArea>();
	}
};
static_assert(alignof(URCUiInteractArea) == 0x000008, "Wrong alignment on URCUiInteractArea");
static_assert(sizeof(URCUiInteractArea) == 0x000368, "Wrong size on URCUiInteractArea");

// Class RC.RCUiInteractDef
// 0x0030 (0x0308 - 0x02D8)
class URCUiInteractDef final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractDef">();
	}
	static class URCUiInteractDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractDef>();
	}
};
static_assert(alignof(URCUiInteractDef) == 0x000008, "Wrong alignment on URCUiInteractDef");
static_assert(sizeof(URCUiInteractDef) == 0x000308, "Wrong size on URCUiInteractDef");

// Class RC.RCUiInteractJoint
// 0x0010 (0x0368 - 0x0358)
class URCUiInteractJoint final : public URCUiWidgetInteractive
{
public:
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBusIcon();
	void SetDoorIcon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractJoint">();
	}
	static class URCUiInteractJoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractJoint>();
	}
};
static_assert(alignof(URCUiInteractJoint) == 0x000008, "Wrong alignment on URCUiInteractJoint");
static_assert(sizeof(URCUiInteractJoint) == 0x000368, "Wrong size on URCUiInteractJoint");

// Class RC.RCUiInteractJointDef
// 0x0038 (0x0310 - 0x02D8)
class URCUiInteractJointDef final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x38];                                     // 0x02D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractJointDef">();
	}
	static class URCUiInteractJointDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractJointDef>();
	}
};
static_assert(alignof(URCUiInteractJointDef) == 0x000008, "Wrong alignment on URCUiInteractJointDef");
static_assert(sizeof(URCUiInteractJointDef) == 0x000310, "Wrong size on URCUiInteractJointDef");

// Class RC.RCUiInteractJointOn
// 0x0038 (0x0310 - 0x02D8)
class URCUiInteractJointOn final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x38];                                     // 0x02D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractJointOn">();
	}
	static class URCUiInteractJointOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractJointOn>();
	}
};
static_assert(alignof(URCUiInteractJointOn) == 0x000008, "Wrong alignment on URCUiInteractJointOn");
static_assert(sizeof(URCUiInteractJointOn) == 0x000310, "Wrong size on URCUiInteractJointOn");

// Class RC.RCUiInteractSubQuest
// 0x0010 (0x0368 - 0x0358)
class URCUiInteractSubQuest final : public URCUiWidgetInteractive
{
public:
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractSubQuest">();
	}
	static class URCUiInteractSubQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractSubQuest>();
	}
};
static_assert(alignof(URCUiInteractSubQuest) == 0x000008, "Wrong alignment on URCUiInteractSubQuest");
static_assert(sizeof(URCUiInteractSubQuest) == 0x000368, "Wrong size on URCUiInteractSubQuest");

// Class RC.RCUiInteractTalk
// 0x0018 (0x0370 - 0x0358)
class URCUiInteractTalk final : public URCUiWidgetInteractive
{
public:
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTalkImg(bool bInIsNzWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTalk">();
	}
	static class URCUiInteractTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTalk>();
	}
};
static_assert(alignof(URCUiInteractTalk) == 0x000008, "Wrong alignment on URCUiInteractTalk");
static_assert(sizeof(URCUiInteractTalk) == 0x000370, "Wrong size on URCUiInteractTalk");

// Class RC.RCUiInteractTalkDot
// 0x0010 (0x0320 - 0x0310)
class URCUiInteractTalkDot final : public URCUiInteractIconParts
{
public:
	class UWidgetAnimation*                       AN_Loop;                                           // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTalkDot">();
	}
	static class URCUiInteractTalkDot* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTalkDot>();
	}
};
static_assert(alignof(URCUiInteractTalkDot) == 0x000008, "Wrong alignment on URCUiInteractTalkDot");
static_assert(sizeof(URCUiInteractTalkDot) == 0x000320, "Wrong size on URCUiInteractTalkDot");
static_assert(offsetof(URCUiInteractTalkDot, AN_Loop) == 0x000310, "Member 'URCUiInteractTalkDot::AN_Loop' has a wrong offset!");

// Class RC.RCUiInteractTarget
// 0x0018 (0x0370 - 0x0358)
class URCUiInteractTarget final : public URCUiWidgetInteractive
{
public:
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetImg(bool bInIsNzWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTarget">();
	}
	static class URCUiInteractTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTarget>();
	}
};
static_assert(alignof(URCUiInteractTarget) == 0x000008, "Wrong alignment on URCUiInteractTarget");
static_assert(sizeof(URCUiInteractTarget) == 0x000370, "Wrong size on URCUiInteractTarget");

// Class RC.RCUiInteractTargetDef
// 0x0000 (0x0310 - 0x0310)
class URCUiInteractTargetDef final : public URCUiInteractIconParts
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTargetDef">();
	}
	static class URCUiInteractTargetDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTargetDef>();
	}
};
static_assert(alignof(URCUiInteractTargetDef) == 0x000008, "Wrong alignment on URCUiInteractTargetDef");
static_assert(sizeof(URCUiInteractTargetDef) == 0x000310, "Wrong size on URCUiInteractTargetDef");

// Class RC.RCUiInteractTargetOn
// 0x0000 (0x0310 - 0x0310)
class URCUiInteractTargetOn final : public URCUiInteractIconParts
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiInteractTargetOn">();
	}
	static class URCUiInteractTargetOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiInteractTargetOn>();
	}
};
static_assert(alignof(URCUiInteractTargetOn) == 0x000008, "Wrong alignment on URCUiInteractTargetOn");
static_assert(sizeof(URCUiInteractTargetOn) == 0x000310, "Wrong size on URCUiInteractTargetOn");

// Class RC.RCUiIntSubQuest
// 0x0000 (0x02F8 - 0x02F8)
class URCUiIntSubQuest final : public URCUiInteractIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiIntSubQuest">();
	}
	static class URCUiIntSubQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiIntSubQuest>();
	}
};
static_assert(alignof(URCUiIntSubQuest) == 0x000008, "Wrong alignment on URCUiIntSubQuest");
static_assert(sizeof(URCUiIntSubQuest) == 0x0002F8, "Wrong size on URCUiIntSubQuest");

// Class RC.RCUiIntTalk
// 0x0008 (0x0300 - 0x02F8)
class URCUiIntTalk final : public URCUiInteractIcon
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTalkImg(bool bInIsNzWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiIntTalk">();
	}
	static class URCUiIntTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiIntTalk>();
	}
};
static_assert(alignof(URCUiIntTalk) == 0x000008, "Wrong alignment on URCUiIntTalk");
static_assert(sizeof(URCUiIntTalk) == 0x000300, "Wrong size on URCUiIntTalk");

// Class RC.RCUiMenuAreaMap
// 0x0110 (0x03E8 - 0x02D8)
class URCUiMenuAreaMap final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Txt_AreaName;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCParamMenuWorldMapListData*           WorldMapData;                                      // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WorldMapTable;                                     // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DataTablePath;                                     // 0x0308(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0xD0];                                     // 0x0318(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeAreaMap();
	void Open();
	void SetLocation(class FName InMapID);
	void StartCloseProcWrap(ERCInputKeyType InKeyType);
	void StartFastTravelProcWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMap">();
	}
	static class URCUiMenuAreaMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMap>();
	}
};
static_assert(alignof(URCUiMenuAreaMap) == 0x000008, "Wrong alignment on URCUiMenuAreaMap");
static_assert(sizeof(URCUiMenuAreaMap) == 0x0003E8, "Wrong size on URCUiMenuAreaMap");
static_assert(offsetof(URCUiMenuAreaMap, AN_Start) == 0x0002D8, "Member 'URCUiMenuAreaMap::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, AN_Wait) == 0x0002E0, "Member 'URCUiMenuAreaMap::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, AN_Finish) == 0x0002E8, "Member 'URCUiMenuAreaMap::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, Txt_AreaName) == 0x0002F0, "Member 'URCUiMenuAreaMap::Txt_AreaName' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, WorldMapData) == 0x0002F8, "Member 'URCUiMenuAreaMap::WorldMapData' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, WorldMapTable) == 0x000300, "Member 'URCUiMenuAreaMap::WorldMapTable' has a wrong offset!");
static_assert(offsetof(URCUiMenuAreaMap, DataTablePath) == 0x000308, "Member 'URCUiMenuAreaMap::DataTablePath' has a wrong offset!");

// Class RC.RCUiMenuAreaMapPager
// 0x0050 (0x0328 - 0x02D8)
class URCUiMenuAreaMapPager final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x50];                                     // 0x02D8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInputFromButtonGuide(ERCInputKeyType InType);
	void SetPagerItemActive(int32 InActiveIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapPager">();
	}
	static class URCUiMenuAreaMapPager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapPager>();
	}
};
static_assert(alignof(URCUiMenuAreaMapPager) == 0x000008, "Wrong alignment on URCUiMenuAreaMapPager");
static_assert(sizeof(URCUiMenuAreaMapPager) == 0x000328, "Wrong size on URCUiMenuAreaMapPager");

// Class RC.RCUiMenuAreaMapPagerItem
// 0x0020 (0x0300 - 0x02E0)
class URCUiMenuAreaMapPagerItem final : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuAreaMapPagerItem">();
	}
	static class URCUiMenuAreaMapPagerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuAreaMapPagerItem>();
	}
};
static_assert(alignof(URCUiMenuAreaMapPagerItem) == 0x000008, "Wrong alignment on URCUiMenuAreaMapPagerItem");
static_assert(sizeof(URCUiMenuAreaMapPagerItem) == 0x000300, "Wrong size on URCUiMenuAreaMapPagerItem");

// Class RC.RCUiMenuBackground
// 0x0018 (0x02F0 - 0x02D8)
class URCUiMenuBackground : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Close();
	void InitializeMenuBackground();
	void Open();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuBackground">();
	}
	static class URCUiMenuBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuBackground>();
	}
};
static_assert(alignof(URCUiMenuBackground) == 0x000008, "Wrong alignment on URCUiMenuBackground");
static_assert(sizeof(URCUiMenuBackground) == 0x0002F0, "Wrong size on URCUiMenuBackground");
static_assert(offsetof(URCUiMenuBackground, AN_Start) == 0x0002D8, "Member 'URCUiMenuBackground::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuBackground, AN_Wait) == 0x0002E0, "Member 'URCUiMenuBackground::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuBackground, AN_Finish) == 0x0002E8, "Member 'URCUiMenuBackground::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuBusStopGuide
// 0x0028 (0x0300 - 0x02D8)
class URCUiMenuBusStopGuide final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuBusStopGuide">();
	}
	static class URCUiMenuBusStopGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuBusStopGuide>();
	}
};
static_assert(alignof(URCUiMenuBusStopGuide) == 0x000008, "Wrong alignment on URCUiMenuBusStopGuide");
static_assert(sizeof(URCUiMenuBusStopGuide) == 0x000300, "Wrong size on URCUiMenuBusStopGuide");
static_assert(offsetof(URCUiMenuBusStopGuide, AN_Start) == 0x0002D8, "Member 'URCUiMenuBusStopGuide::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuBusStopGuide, AN_Wait) == 0x0002E0, "Member 'URCUiMenuBusStopGuide::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuBusStopGuide, AN_Finish) == 0x0002E8, "Member 'URCUiMenuBusStopGuide::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuBusStopGuide, AN_Off) == 0x0002F0, "Member 'URCUiMenuBusStopGuide::AN_Off' has a wrong offset!");

// Class RC.RCUiMenuCharacter
// 0x0050 (0x0328 - 0x02D8)
class URCUiMenuCharacter final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterSelectIndex;                              // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectVisibleCount;                                // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MenuCharacterSelectStartPushWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacter">();
	}
	static class URCUiMenuCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacter>();
	}
};
static_assert(alignof(URCUiMenuCharacter) == 0x000008, "Wrong alignment on URCUiMenuCharacter");
static_assert(sizeof(URCUiMenuCharacter) == 0x000328, "Wrong size on URCUiMenuCharacter");
static_assert(offsetof(URCUiMenuCharacter, AN_Start) == 0x0002D8, "Member 'URCUiMenuCharacter::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacter, AN_Wait) == 0x0002E0, "Member 'URCUiMenuCharacter::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacter, AN_Finish) == 0x0002E8, "Member 'URCUiMenuCharacter::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacter, CharacterSelectIndex) == 0x000300, "Member 'URCUiMenuCharacter::CharacterSelectIndex' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacter, SelectVisibleCount) == 0x000304, "Member 'URCUiMenuCharacter::SelectVisibleCount' has a wrong offset!");

// Class RC.RCUiMenuCharacterSelectSideButton
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuCharacterSelectSideButton final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterSelectSideButton">();
	}
	static class URCUiMenuCharacterSelectSideButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterSelectSideButton>();
	}
};
static_assert(alignof(URCUiMenuCharacterSelectSideButton) == 0x000008, "Wrong alignment on URCUiMenuCharacterSelectSideButton");
static_assert(sizeof(URCUiMenuCharacterSelectSideButton) == 0x0002E8, "Wrong size on URCUiMenuCharacterSelectSideButton");

// Class RC.RCUiMenuCharacterTop
// 0x0040 (0x0318 - 0x02D8)
class URCUiMenuCharacterTop final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedCharacterViewer();
	void NotifyCloseCharacterMenuWrap(ERCInputKeyType InKeyType);
	void NotifyCloseCharacterViewerWrap(ERCInputKeyType InKeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterTop">();
	}
	static class URCUiMenuCharacterTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterTop>();
	}
};
static_assert(alignof(URCUiMenuCharacterTop) == 0x000008, "Wrong alignment on URCUiMenuCharacterTop");
static_assert(sizeof(URCUiMenuCharacterTop) == 0x000318, "Wrong size on URCUiMenuCharacterTop");

// Class RC.RCUiMenuCharacterViewerModelUnit
// 0x0018 (0x02F0 - 0x02D8)
class URCUiMenuCharacterViewerModelUnit final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_On;                                             // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Chara_Model_000;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerModelUnit">();
	}
	static class URCUiMenuCharacterViewerModelUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerModelUnit>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerModelUnit) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerModelUnit");
static_assert(sizeof(URCUiMenuCharacterViewerModelUnit) == 0x0002F0, "Wrong size on URCUiMenuCharacterViewerModelUnit");
static_assert(offsetof(URCUiMenuCharacterViewerModelUnit, AN_On) == 0x0002D8, "Member 'URCUiMenuCharacterViewerModelUnit::AN_On' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModelUnit, AN_Off) == 0x0002E0, "Member 'URCUiMenuCharacterViewerModelUnit::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerModelUnit, Chara_Model_000) == 0x0002E8, "Member 'URCUiMenuCharacterViewerModelUnit::Chara_Model_000' has a wrong offset!");

// Class RC.RCUiMenuCharacterViewerProfile
// 0x0110 (0x03E8 - 0x02D8)
class URCUiMenuCharacterViewerProfile final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x58];                                     // 0x02D8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_Profile_Title_00;                             // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_01;                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_02;                             // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_03;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_04;                             // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_05;                             // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_06;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_Title_07;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_Profile_00;                                   // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_01;                                   // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_02;                                   // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_03;                                   // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_04;                                   // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_05;                                   // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_06;                                   // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Profile_07;                                   // 0x03B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiMenuCommonIcon*                    Icon_ListNew;                                      // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuCommonIcon*                    Icon_ListUpdate;                                   // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuCharacterViewerProfile">();
	}
	static class URCUiMenuCharacterViewerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuCharacterViewerProfile>();
	}
};
static_assert(alignof(URCUiMenuCharacterViewerProfile) == 0x000008, "Wrong alignment on URCUiMenuCharacterViewerProfile");
static_assert(sizeof(URCUiMenuCharacterViewerProfile) == 0x0003E8, "Wrong size on URCUiMenuCharacterViewerProfile");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_00) == 0x000330, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_00' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_01) == 0x000338, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_01' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_02) == 0x000340, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_02' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_03) == 0x000348, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_03' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_04) == 0x000350, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_04' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_05) == 0x000358, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_05' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_06) == 0x000360, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_06' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_Title_07) == 0x000368, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_Title_07' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_00) == 0x000380, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_00' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_01) == 0x000388, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_01' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_02) == 0x000390, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_02' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_03) == 0x000398, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_03' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_04) == 0x0003A0, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_04' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_05) == 0x0003A8, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_05' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_06) == 0x0003B0, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_06' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Text_Profile_07) == 0x0003B8, "Member 'URCUiMenuCharacterViewerProfile::Text_Profile_07' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Icon_ListNew) == 0x0003D0, "Member 'URCUiMenuCharacterViewerProfile::Icon_ListNew' has a wrong offset!");
static_assert(offsetof(URCUiMenuCharacterViewerProfile, Icon_ListUpdate) == 0x0003D8, "Member 'URCUiMenuCharacterViewerProfile::Icon_ListUpdate' has a wrong offset!");

// Class RC.RCUiMenuContents
// 0x0068 (0x0360 - 0x02F8)
class URCUiMenuContents final : public URCMenuManager
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URCParamMenuContentsListData*           ContentsData;                                      // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ContentsTable;                                     // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DataTablePath;                                     // 0x0330(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void ContentsButtonCustomNavigation(EUINavigation InNavigation, class APlayerController* InPlayerController);
	void InitializeMenuContents();
	void Open(bool bInSelectDefault);
	void StartPush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuContents">();
	}
	static class URCUiMenuContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuContents>();
	}
};
static_assert(alignof(URCUiMenuContents) == 0x000008, "Wrong alignment on URCUiMenuContents");
static_assert(sizeof(URCUiMenuContents) == 0x000360, "Wrong size on URCUiMenuContents");
static_assert(offsetof(URCUiMenuContents, AN_Start) == 0x0002F8, "Member 'URCUiMenuContents::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuContents, AN_Wait) == 0x000300, "Member 'URCUiMenuContents::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuContents, AN_Finish) == 0x000308, "Member 'URCUiMenuContents::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuContents, ContentsData) == 0x000320, "Member 'URCUiMenuContents::ContentsData' has a wrong offset!");
static_assert(offsetof(URCUiMenuContents, ContentsTable) == 0x000328, "Member 'URCUiMenuContents::ContentsTable' has a wrong offset!");
static_assert(offsetof(URCUiMenuContents, DataTablePath) == 0x000330, "Member 'URCUiMenuContents::DataTablePath' has a wrong offset!");

// Class RC.RCUiMenuContentsButtonIcon
// 0x0000 (0x02E8 - 0x02E8)
class URCUiMenuContentsButtonIcon final : public URCUiMenuCommonIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuContentsButtonIcon">();
	}
	static class URCUiMenuContentsButtonIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuContentsButtonIcon>();
	}
};
static_assert(alignof(URCUiMenuContentsButtonIcon) == 0x000008, "Wrong alignment on URCUiMenuContentsButtonIcon");
static_assert(sizeof(URCUiMenuContentsButtonIcon) == 0x0002E8, "Wrong size on URCUiMenuContentsButtonIcon");

// Class RC.RCUiMenuDetectivePoint
// 0x0060 (0x0338 - 0x02D8)
class URCUiMenuDetectivePoint final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuDetectivePoint();
	void Open();
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuDetectivePoint">();
	}
	static class URCUiMenuDetectivePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuDetectivePoint>();
	}
};
static_assert(alignof(URCUiMenuDetectivePoint) == 0x000008, "Wrong alignment on URCUiMenuDetectivePoint");
static_assert(sizeof(URCUiMenuDetectivePoint) == 0x000338, "Wrong size on URCUiMenuDetectivePoint");
static_assert(offsetof(URCUiMenuDetectivePoint, AN_Start) == 0x0002D8, "Member 'URCUiMenuDetectivePoint::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuDetectivePoint, AN_Wait) == 0x0002E0, "Member 'URCUiMenuDetectivePoint::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuDetectivePoint, AN_Finish) == 0x0002E8, "Member 'URCUiMenuDetectivePoint::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuDetectiveRank
// 0x0060 (0x0338 - 0x02D8)
class URCUiMenuDetectiveRank final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuDetectiveRank();
	void Open();
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuDetectiveRank">();
	}
	static class URCUiMenuDetectiveRank* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuDetectiveRank>();
	}
};
static_assert(alignof(URCUiMenuDetectiveRank) == 0x000008, "Wrong alignment on URCUiMenuDetectiveRank");
static_assert(sizeof(URCUiMenuDetectiveRank) == 0x000338, "Wrong size on URCUiMenuDetectiveRank");
static_assert(offsetof(URCUiMenuDetectiveRank, AN_Start) == 0x0002D8, "Member 'URCUiMenuDetectiveRank::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuDetectiveRank, AN_Wait) == 0x0002E0, "Member 'URCUiMenuDetectiveRank::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuDetectiveRank, AN_Finish) == 0x0002E8, "Member 'URCUiMenuDetectiveRank::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuGlossaryBase
// 0x0048 (0x0320 - 0x02D8)
class URCUiMenuGlossaryBase final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x30];                                     // 0x02F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossaryBase">();
	}
	static class URCUiMenuGlossaryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossaryBase>();
	}
};
static_assert(alignof(URCUiMenuGlossaryBase) == 0x000008, "Wrong alignment on URCUiMenuGlossaryBase");
static_assert(sizeof(URCUiMenuGlossaryBase) == 0x000320, "Wrong size on URCUiMenuGlossaryBase");
static_assert(offsetof(URCUiMenuGlossaryBase, AN_Start) == 0x0002D8, "Member 'URCUiMenuGlossaryBase::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryBase, AN_Wait) == 0x0002E0, "Member 'URCUiMenuGlossaryBase::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuGlossaryBase, AN_Finish) == 0x0002E8, "Member 'URCUiMenuGlossaryBase::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuGlossaryCaption
// 0x0028 (0x0300 - 0x02D8)
class URCUiMenuGlossaryCaption final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Glossary_Caption;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossaryCaption">();
	}
	static class URCUiMenuGlossaryCaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossaryCaption>();
	}
};
static_assert(alignof(URCUiMenuGlossaryCaption) == 0x000008, "Wrong alignment on URCUiMenuGlossaryCaption");
static_assert(sizeof(URCUiMenuGlossaryCaption) == 0x000300, "Wrong size on URCUiMenuGlossaryCaption");
static_assert(offsetof(URCUiMenuGlossaryCaption, Text_Glossary_Caption) == 0x0002D8, "Member 'URCUiMenuGlossaryCaption::Text_Glossary_Caption' has a wrong offset!");

// Class RC.RCUiMenuGlossaryList
// 0x00A0 (0x0398 - 0x02F8)
class URCUiMenuGlossaryList final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x78];                                     // 0x02F8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x24];                                     // 0x0374(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* GlossaryNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossaryList">();
	}
	static class URCUiMenuGlossaryList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossaryList>();
	}
};
static_assert(alignof(URCUiMenuGlossaryList) == 0x000008, "Wrong alignment on URCUiMenuGlossaryList");
static_assert(sizeof(URCUiMenuGlossaryList) == 0x000398, "Wrong size on URCUiMenuGlossaryList");
static_assert(offsetof(URCUiMenuGlossaryList, MaxBarOfPage) == 0x000370, "Member 'URCUiMenuGlossaryList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCUiMenuGlossaryName
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuGlossaryName final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Glossary_Name;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGlossaryName">();
	}
	static class URCUiMenuGlossaryName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGlossaryName>();
	}
};
static_assert(alignof(URCUiMenuGlossaryName) == 0x000008, "Wrong alignment on URCUiMenuGlossaryName");
static_assert(sizeof(URCUiMenuGlossaryName) == 0x0002F8, "Wrong size on URCUiMenuGlossaryName");
static_assert(offsetof(URCUiMenuGlossaryName, Text_Glossary_Name) == 0x0002D8, "Member 'URCUiMenuGlossaryName::Text_Glossary_Name' has a wrong offset!");

// Class RC.RCUiMenuGuide
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuGuide final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuGuide">();
	}
	static class URCUiMenuGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuGuide>();
	}
};
static_assert(alignof(URCUiMenuGuide) == 0x000008, "Wrong alignment on URCUiMenuGuide");
static_assert(sizeof(URCUiMenuGuide) == 0x0002E8, "Wrong size on URCUiMenuGuide");

// Class RC.RCUiMenuHelp
// 0x0038 (0x0310 - 0x02D8)
class URCUiMenuHelp : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_Help;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuHelp();
	void Open();
	void StartRun();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuHelp">();
	}
	static class URCUiMenuHelp* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuHelp>();
	}
};
static_assert(alignof(URCUiMenuHelp) == 0x000008, "Wrong alignment on URCUiMenuHelp");
static_assert(sizeof(URCUiMenuHelp) == 0x000310, "Wrong size on URCUiMenuHelp");
static_assert(offsetof(URCUiMenuHelp, AN_Start) == 0x0002D8, "Member 'URCUiMenuHelp::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuHelp, AN_Wait) == 0x0002E0, "Member 'URCUiMenuHelp::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuHelp, AN_Finish) == 0x0002E8, "Member 'URCUiMenuHelp::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuHelp, Text_Help) == 0x0002F0, "Member 'URCUiMenuHelp::Text_Help' has a wrong offset!");

// Class RC.RCUiMenuKagiCaption
// 0x0028 (0x0300 - 0x02D8)
class URCUiMenuKagiCaption final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Kagi_Caption;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuKagiCaption">();
	}
	static class URCUiMenuKagiCaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuKagiCaption>();
	}
};
static_assert(alignof(URCUiMenuKagiCaption) == 0x000008, "Wrong alignment on URCUiMenuKagiCaption");
static_assert(sizeof(URCUiMenuKagiCaption) == 0x000300, "Wrong size on URCUiMenuKagiCaption");
static_assert(offsetof(URCUiMenuKagiCaption, Text_Kagi_Caption) == 0x0002D8, "Member 'URCUiMenuKagiCaption::Text_Kagi_Caption' has a wrong offset!");

// Class RC.RCUiMenuKagiImage
// 0x0030 (0x0310 - 0x02E0)
class URCUiMenuKagiImage final : public URCMenuWidget
{
public:
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuKagiImage">();
	}
	static class URCUiMenuKagiImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuKagiImage>();
	}
};
static_assert(alignof(URCUiMenuKagiImage) == 0x000008, "Wrong alignment on URCUiMenuKagiImage");
static_assert(sizeof(URCUiMenuKagiImage) == 0x000310, "Wrong size on URCUiMenuKagiImage");

// Class RC.RCUiMenuKagiList
// 0x00A0 (0x0398 - 0x02F8)
class URCUiMenuKagiList final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x68];                                     // 0x02F8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBarOfPage;                                      // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x34];                                     // 0x0364(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecideKagi();
	void KagiMenuCustomNavigation(EUINavigation InNavigation, class APlayerController* InPlayerController);
	class UWidget* KagiNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuKagiList">();
	}
	static class URCUiMenuKagiList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuKagiList>();
	}
};
static_assert(alignof(URCUiMenuKagiList) == 0x000008, "Wrong alignment on URCUiMenuKagiList");
static_assert(sizeof(URCUiMenuKagiList) == 0x000398, "Wrong size on URCUiMenuKagiList");
static_assert(offsetof(URCUiMenuKagiList, MaxBarOfPage) == 0x000360, "Member 'URCUiMenuKagiList::MaxBarOfPage' has a wrong offset!");

// Class RC.RCUiMenuMainQuest
// 0x0008 (0x0308 - 0x0300)
class URCUiMenuMainQuest final : public URCUiMenuQuest
{
public:
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuMainQuest">();
	}
	static class URCUiMenuMainQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuMainQuest>();
	}
};
static_assert(alignof(URCUiMenuMainQuest) == 0x000008, "Wrong alignment on URCUiMenuMainQuest");
static_assert(sizeof(URCUiMenuMainQuest) == 0x000308, "Wrong size on URCUiMenuMainQuest");

// Class RC.RCUiMenuNextTarget
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuNextTarget final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_NextTarget;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuNextTarget();
	void Open();
	void SetNextTargetID(class FName InTargetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuNextTarget">();
	}
	static class URCUiMenuNextTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuNextTarget>();
	}
};
static_assert(alignof(URCUiMenuNextTarget) == 0x000008, "Wrong alignment on URCUiMenuNextTarget");
static_assert(sizeof(URCUiMenuNextTarget) == 0x0002F8, "Wrong size on URCUiMenuNextTarget");
static_assert(offsetof(URCUiMenuNextTarget, Text_NextTarget) == 0x0002D8, "Member 'URCUiMenuNextTarget::Text_NextTarget' has a wrong offset!");

// Class RC.RCUiMenuQuestListBar
// 0x0080 (0x0358 - 0x02D8)
class URCUiMenuQuestListBar : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Default;                                        // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor_Wait;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_EpNumber;                                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Text_ListName;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x50];                                     // 0x0308(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestListBar">();
	}
	static class URCUiMenuQuestListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestListBar>();
	}
};
static_assert(alignof(URCUiMenuQuestListBar) == 0x000008, "Wrong alignment on URCUiMenuQuestListBar");
static_assert(sizeof(URCUiMenuQuestListBar) == 0x000358, "Wrong size on URCUiMenuQuestListBar");
static_assert(offsetof(URCUiMenuQuestListBar, AN_Default) == 0x0002D8, "Member 'URCUiMenuQuestListBar::AN_Default' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListBar, AN_OnCursor) == 0x0002E0, "Member 'URCUiMenuQuestListBar::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListBar, AN_OnCursor_Wait) == 0x0002E8, "Member 'URCUiMenuQuestListBar::AN_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListBar, AN_OutCursor) == 0x0002F0, "Member 'URCUiMenuQuestListBar::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListBar, Text_EpNumber) == 0x0002F8, "Member 'URCUiMenuQuestListBar::Text_EpNumber' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListBar, Text_ListName) == 0x000300, "Member 'URCUiMenuQuestListBar::Text_ListName' has a wrong offset!");

// Class RC.RCUiMenuQuestListGrp
// 0x0048 (0x0368 - 0x0320)
class URCUiMenuQuestListGrp final : public URCMenuButton
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Going;                                          // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Clear;                                          // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close;                                          // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x20];                                     // 0x0348(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuQuestListGrp">();
	}
	static class URCUiMenuQuestListGrp* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuQuestListGrp>();
	}
};
static_assert(alignof(URCUiMenuQuestListGrp) == 0x000008, "Wrong alignment on URCUiMenuQuestListGrp");
static_assert(sizeof(URCUiMenuQuestListGrp) == 0x000368, "Wrong size on URCUiMenuQuestListGrp");
static_assert(offsetof(URCUiMenuQuestListGrp, AN_Going) == 0x000330, "Member 'URCUiMenuQuestListGrp::AN_Going' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListGrp, AN_Clear) == 0x000338, "Member 'URCUiMenuQuestListGrp::AN_Clear' has a wrong offset!");
static_assert(offsetof(URCUiMenuQuestListGrp, AN_Close) == 0x000340, "Member 'URCUiMenuQuestListGrp::AN_Close' has a wrong offset!");

// Class RC.RCUiMenuSkillTree
// 0x00B8 (0x03B0 - 0x02F8)
class URCUiMenuSkillTree final : public URCMenuManager
{
public:
	class UWidgetAnimation*                       AN_In;                                             // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Out;                                            // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0xA0];                                     // 0x0310(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseSkillTreeWrap(ERCInputKeyType KeyType);
	void DecideSkill();
	void DecideSkillWrap(ERCInputKeyType KeyType);
	void RemoveAllSkillsWrap(ERCInputKeyType KeyType);
	class UWidget* SkillNavigation(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTree">();
	}
	static class URCUiMenuSkillTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTree>();
	}
};
static_assert(alignof(URCUiMenuSkillTree) == 0x000008, "Wrong alignment on URCUiMenuSkillTree");
static_assert(sizeof(URCUiMenuSkillTree) == 0x0003B0, "Wrong size on URCUiMenuSkillTree");
static_assert(offsetof(URCUiMenuSkillTree, AN_In) == 0x0002F8, "Member 'URCUiMenuSkillTree::AN_In' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTree, AN_Wait) == 0x000300, "Member 'URCUiMenuSkillTree::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuSkillTree, AN_Out) == 0x000308, "Member 'URCUiMenuSkillTree::AN_Out' has a wrong offset!");

// Class RC.RCUiMenuSkillTreeInfoOff
// 0x0020 (0x0308 - 0x02E8)
class URCUiMenuSkillTreeInfoOff final : public URCUiMenuCommonIcon
{
public:
	class UTextLayoutWidget*                      Text_Order_Condition;                              // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSkillTreeInfoOff">();
	}
	static class URCUiMenuSkillTreeInfoOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSkillTreeInfoOff>();
	}
};
static_assert(alignof(URCUiMenuSkillTreeInfoOff) == 0x000008, "Wrong alignment on URCUiMenuSkillTreeInfoOff");
static_assert(sizeof(URCUiMenuSkillTreeInfoOff) == 0x000308, "Wrong size on URCUiMenuSkillTreeInfoOff");
static_assert(offsetof(URCUiMenuSkillTreeInfoOff, Text_Order_Condition) == 0x0002E8, "Member 'URCUiMenuSkillTreeInfoOff::Text_Order_Condition' has a wrong offset!");

// Class RC.RCUiMenuStatusCheck
// 0x0010 (0x02E8 - 0x02D8)
class URCUiMenuStatusCheck final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Check_Off;                                      // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Check_On;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuStatusCheck">();
	}
	static class URCUiMenuStatusCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuStatusCheck>();
	}
};
static_assert(alignof(URCUiMenuStatusCheck) == 0x000008, "Wrong alignment on URCUiMenuStatusCheck");
static_assert(sizeof(URCUiMenuStatusCheck) == 0x0002E8, "Wrong size on URCUiMenuStatusCheck");
static_assert(offsetof(URCUiMenuStatusCheck, AN_Check_Off) == 0x0002D8, "Member 'URCUiMenuStatusCheck::AN_Check_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuStatusCheck, AN_Check_On) == 0x0002E0, "Member 'URCUiMenuStatusCheck::AN_Check_On' has a wrong offset!");

// Class RC.RCUiMenuSubQuestClient
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuSubQuestClient final : public URCUiWidgetBase
{
public:
	class UTextLayoutWidget*                      Text_Client;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSubQuestClient">();
	}
	static class URCUiMenuSubQuestClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSubQuestClient>();
	}
};
static_assert(alignof(URCUiMenuSubQuestClient) == 0x000008, "Wrong alignment on URCUiMenuSubQuestClient");
static_assert(sizeof(URCUiMenuSubQuestClient) == 0x0002F8, "Wrong size on URCUiMenuSubQuestClient");
static_assert(offsetof(URCUiMenuSubQuestClient, Text_Client) == 0x0002D8, "Member 'URCUiMenuSubQuestClient::Text_Client' has a wrong offset!");

// Class RC.RCUiMenuSubQuestDetail
// 0x0018 (0x0300 - 0x02E8)
class URCUiMenuSubQuestDetail final : public URCUiMenuQuestDetail
{
public:
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuSubQuestDetail">();
	}
	static class URCUiMenuSubQuestDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuSubQuestDetail>();
	}
};
static_assert(alignof(URCUiMenuSubQuestDetail) == 0x000008, "Wrong alignment on URCUiMenuSubQuestDetail");
static_assert(sizeof(URCUiMenuSubQuestDetail) == 0x000300, "Wrong size on URCUiMenuSubQuestDetail");

// Class RC.RCUiMenuTitleName
// 0x0140 (0x0418 - 0x02D8)
class URCUiMenuTitleName : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Menu_Start;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Menu_Wait;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Menu_Finish;                                    // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_WMap_Start;                                     // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_WMap_Wait;                                      // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_WMap_Finish;                                    // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Kagi_Start;                                     // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Kagi_Wait;                                      // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Kagi_Finish;                                    // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Quest_Start;                                    // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Quest_Wait;                                     // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Quest_Finish;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SubQuest_Start;                                 // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SubQuest_Wait;                                  // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SubQuest_Finish;                                // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Skill_Start;                                    // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Skill_Wait;                                     // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Skill_Finish;                                   // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Character_Start;                                // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Character_Wait;                                 // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Character_Finish;                               // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Glossary_Start;                                 // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Glossary_Wait;                                  // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Glossary_Finish;                                // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SaveLoad_Start;                                 // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SaveLoad_Wait;                                  // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SaveLoad_Finish;                                // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Tegakari_Start;                                 // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Tegakari_Wait;                                  // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Tegakari_Finish;                                // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Collection_Start;                               // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Collection_Wait;                                // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Collection_Finish;                              // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Save_Start;                                     // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Save_Wait;                                      // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Save_Finish;                                    // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Load_Start;                                     // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Load_Wait;                                      // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Load_Finish;                                    // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void InitializeMenuTitleName();
	void Open(ERCGameMenuSelectType InMenuType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuTitleName">();
	}
	static class URCUiMenuTitleName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuTitleName>();
	}
};
static_assert(alignof(URCUiMenuTitleName) == 0x000008, "Wrong alignment on URCUiMenuTitleName");
static_assert(sizeof(URCUiMenuTitleName) == 0x000418, "Wrong size on URCUiMenuTitleName");
static_assert(offsetof(URCUiMenuTitleName, AN_Menu_Start) == 0x0002D8, "Member 'URCUiMenuTitleName::AN_Menu_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Menu_Wait) == 0x0002E0, "Member 'URCUiMenuTitleName::AN_Menu_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Menu_Finish) == 0x0002E8, "Member 'URCUiMenuTitleName::AN_Menu_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_WMap_Start) == 0x0002F0, "Member 'URCUiMenuTitleName::AN_WMap_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_WMap_Wait) == 0x0002F8, "Member 'URCUiMenuTitleName::AN_WMap_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_WMap_Finish) == 0x000300, "Member 'URCUiMenuTitleName::AN_WMap_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Kagi_Start) == 0x000308, "Member 'URCUiMenuTitleName::AN_Kagi_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Kagi_Wait) == 0x000310, "Member 'URCUiMenuTitleName::AN_Kagi_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Kagi_Finish) == 0x000318, "Member 'URCUiMenuTitleName::AN_Kagi_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Quest_Start) == 0x000320, "Member 'URCUiMenuTitleName::AN_Quest_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Quest_Wait) == 0x000328, "Member 'URCUiMenuTitleName::AN_Quest_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Quest_Finish) == 0x000330, "Member 'URCUiMenuTitleName::AN_Quest_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SubQuest_Start) == 0x000338, "Member 'URCUiMenuTitleName::AN_SubQuest_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SubQuest_Wait) == 0x000340, "Member 'URCUiMenuTitleName::AN_SubQuest_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SubQuest_Finish) == 0x000348, "Member 'URCUiMenuTitleName::AN_SubQuest_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Skill_Start) == 0x000350, "Member 'URCUiMenuTitleName::AN_Skill_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Skill_Wait) == 0x000358, "Member 'URCUiMenuTitleName::AN_Skill_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Skill_Finish) == 0x000360, "Member 'URCUiMenuTitleName::AN_Skill_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Character_Start) == 0x000368, "Member 'URCUiMenuTitleName::AN_Character_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Character_Wait) == 0x000370, "Member 'URCUiMenuTitleName::AN_Character_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Character_Finish) == 0x000378, "Member 'URCUiMenuTitleName::AN_Character_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Glossary_Start) == 0x000380, "Member 'URCUiMenuTitleName::AN_Glossary_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Glossary_Wait) == 0x000388, "Member 'URCUiMenuTitleName::AN_Glossary_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Glossary_Finish) == 0x000390, "Member 'URCUiMenuTitleName::AN_Glossary_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SaveLoad_Start) == 0x000398, "Member 'URCUiMenuTitleName::AN_SaveLoad_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SaveLoad_Wait) == 0x0003A0, "Member 'URCUiMenuTitleName::AN_SaveLoad_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_SaveLoad_Finish) == 0x0003A8, "Member 'URCUiMenuTitleName::AN_SaveLoad_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Tegakari_Start) == 0x0003B0, "Member 'URCUiMenuTitleName::AN_Tegakari_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Tegakari_Wait) == 0x0003B8, "Member 'URCUiMenuTitleName::AN_Tegakari_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Tegakari_Finish) == 0x0003C0, "Member 'URCUiMenuTitleName::AN_Tegakari_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Collection_Start) == 0x0003C8, "Member 'URCUiMenuTitleName::AN_Collection_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Collection_Wait) == 0x0003D0, "Member 'URCUiMenuTitleName::AN_Collection_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Collection_Finish) == 0x0003D8, "Member 'URCUiMenuTitleName::AN_Collection_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Save_Start) == 0x0003E0, "Member 'URCUiMenuTitleName::AN_Save_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Save_Wait) == 0x0003E8, "Member 'URCUiMenuTitleName::AN_Save_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Save_Finish) == 0x0003F0, "Member 'URCUiMenuTitleName::AN_Save_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Load_Start) == 0x0003F8, "Member 'URCUiMenuTitleName::AN_Load_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Load_Wait) == 0x000400, "Member 'URCUiMenuTitleName::AN_Load_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuTitleName, AN_Load_Finish) == 0x000408, "Member 'URCUiMenuTitleName::AN_Load_Finish' has a wrong offset!");

// Class RC.RCUiMenuWorldMap
// 0x01E0 (0x04D8 - 0x02F8)
class URCUiMenuWorldMap final : public URCMenuManager
{
public:
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_Start;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_Wait;                                    // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_Finish;                                  // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_OnCursor;                                // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_OutCursor;                               // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Select_OnCursor_Wait;                           // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x38];                                     // 0x0360(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class URCParamMenuWorldMapListData*           WorldMapData;                                      // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WorldMapTable;                                     // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DataTablePath;                                     // 0x03A8(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x78];                                     // 0x03B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WorldMapClickableArea;                             // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x6C];                                     // 0x0438(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointerMoveSpeed;                                  // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            SoftwareCursor;                                    // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            BufferCursor;                                      // 0x04C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void CloseAreaSelect();
	void FinishTutorial();
	void InitializeMenuWorldMap();
	void OnButtonGuideBackButtonClick(ERCInputKeyType InKeyType);
	void OnChangeInputPlatform(ERCInputPlatform InInputPlatform);
	void OnFinishGenericWindow(bool bResult);
	void OnFinishOnCursorAnim();
	void OnFinishSelectStartAnim();
	void Open();
	void OpenAreaSelect(bool bInIsBusMenu);
	void StartPush();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMap">();
	}
	static class URCUiMenuWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMap>();
	}
};
static_assert(alignof(URCUiMenuWorldMap) == 0x000008, "Wrong alignment on URCUiMenuWorldMap");
static_assert(sizeof(URCUiMenuWorldMap) == 0x0004D8, "Wrong size on URCUiMenuWorldMap");
static_assert(offsetof(URCUiMenuWorldMap, AN_Start) == 0x000318, "Member 'URCUiMenuWorldMap::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Wait) == 0x000320, "Member 'URCUiMenuWorldMap::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Finish) == 0x000328, "Member 'URCUiMenuWorldMap::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_Start) == 0x000330, "Member 'URCUiMenuWorldMap::AN_Select_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_Wait) == 0x000338, "Member 'URCUiMenuWorldMap::AN_Select_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_Finish) == 0x000340, "Member 'URCUiMenuWorldMap::AN_Select_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_OnCursor) == 0x000348, "Member 'URCUiMenuWorldMap::AN_Select_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_OutCursor) == 0x000350, "Member 'URCUiMenuWorldMap::AN_Select_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, AN_Select_OnCursor_Wait) == 0x000358, "Member 'URCUiMenuWorldMap::AN_Select_OnCursor_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, WorldMapData) == 0x000398, "Member 'URCUiMenuWorldMap::WorldMapData' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, WorldMapTable) == 0x0003A0, "Member 'URCUiMenuWorldMap::WorldMapTable' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, DataTablePath) == 0x0003A8, "Member 'URCUiMenuWorldMap::DataTablePath' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, WorldMapClickableArea) == 0x000430, "Member 'URCUiMenuWorldMap::WorldMapClickableArea' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, PointerMoveSpeed) == 0x0004A4, "Member 'URCUiMenuWorldMap::PointerMoveSpeed' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, SoftwareCursor) == 0x0004B8, "Member 'URCUiMenuWorldMap::SoftwareCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMap, BufferCursor) == 0x0004C0, "Member 'URCUiMenuWorldMap::BufferCursor' has a wrong offset!");

// Class RC.RCUiMenuWorldMapArea
// 0x0080 (0x0358 - 0x02D8)
class URCUiMenuWorldMapArea final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Def;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OnCursor;                                       // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_OutCursor;                                      // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Push;                                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect;                                      // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_New_Start;                                      // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_NotSelect_Shadow;                               // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeMenuWorldMapArea();
	void NotSelect();
	void NotSelectShadow();
	void OnCursor();
	void OutCursor();
	void Push();
	void ShowDefault();
	void ShowNewArea();
	void ShowOff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapArea">();
	}
	static class URCUiMenuWorldMapArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapArea>();
	}
};
static_assert(alignof(URCUiMenuWorldMapArea) == 0x000008, "Wrong alignment on URCUiMenuWorldMapArea");
static_assert(sizeof(URCUiMenuWorldMapArea) == 0x000358, "Wrong size on URCUiMenuWorldMapArea");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_Def) == 0x0002E8, "Member 'URCUiMenuWorldMapArea::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_OnCursor) == 0x0002F0, "Member 'URCUiMenuWorldMapArea::AN_OnCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_OutCursor) == 0x0002F8, "Member 'URCUiMenuWorldMapArea::AN_OutCursor' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_Push) == 0x000300, "Member 'URCUiMenuWorldMapArea::AN_Push' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_NotSelect) == 0x000308, "Member 'URCUiMenuWorldMapArea::AN_NotSelect' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_Off) == 0x000310, "Member 'URCUiMenuWorldMapArea::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_New_Start) == 0x000318, "Member 'URCUiMenuWorldMapArea::AN_New_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapArea, AN_NotSelect_Shadow) == 0x000320, "Member 'URCUiMenuWorldMapArea::AN_NotSelect_Shadow' has a wrong offset!");

// Class RC.RCUiMenuWorldMapHidden
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuWorldMapHidden final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapHidden">();
	}
	static class URCUiMenuWorldMapHidden* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapHidden>();
	}
};
static_assert(alignof(URCUiMenuWorldMapHidden) == 0x000008, "Wrong alignment on URCUiMenuWorldMapHidden");
static_assert(sizeof(URCUiMenuWorldMapHidden) == 0x0002F8, "Wrong size on URCUiMenuWorldMapHidden");
static_assert(offsetof(URCUiMenuWorldMapHidden, AN_Start) == 0x0002D8, "Member 'URCUiMenuWorldMapHidden::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapHidden, AN_Wait) == 0x0002E0, "Member 'URCUiMenuWorldMapHidden::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapHidden, AN_Finish) == 0x0002E8, "Member 'URCUiMenuWorldMapHidden::AN_Finish' has a wrong offset!");

// Class RC.RCUiMenuWorldMapIcon
// 0x0008 (0x02F0 - 0x02E8)
class URCUiMenuWorldMapIcon final : public URCUiMenuCommonIcon
{
public:
	class UWidgetAnimation*                       AN_Close;                                          // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapIcon">();
	}
	static class URCUiMenuWorldMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapIcon>();
	}
};
static_assert(alignof(URCUiMenuWorldMapIcon) == 0x000008, "Wrong alignment on URCUiMenuWorldMapIcon");
static_assert(sizeof(URCUiMenuWorldMapIcon) == 0x0002F0, "Wrong size on URCUiMenuWorldMapIcon");
static_assert(offsetof(URCUiMenuWorldMapIcon, AN_Close) == 0x0002E8, "Member 'URCUiMenuWorldMapIcon::AN_Close' has a wrong offset!");

// Class RC.RCUiMenuWorldMapPointer
// 0x0020 (0x02F8 - 0x02D8)
class URCUiMenuWorldMapPointer final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Idle;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Point;                                          // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Pointer;                                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishCursor();
	void FinishDefault();
	void FinishOverlap();
	void InitializeWorldMapPointer();
	void OffMark();
	void OnMark();
	void StartDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMenuWorldMapPointer">();
	}
	static class URCUiMenuWorldMapPointer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMenuWorldMapPointer>();
	}
};
static_assert(alignof(URCUiMenuWorldMapPointer) == 0x000008, "Wrong alignment on URCUiMenuWorldMapPointer");
static_assert(sizeof(URCUiMenuWorldMapPointer) == 0x0002F8, "Wrong size on URCUiMenuWorldMapPointer");
static_assert(offsetof(URCUiMenuWorldMapPointer, AN_Idle) == 0x0002E0, "Member 'URCUiMenuWorldMapPointer::AN_Idle' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapPointer, AN_Point) == 0x0002E8, "Member 'URCUiMenuWorldMapPointer::AN_Point' has a wrong offset!");
static_assert(offsetof(URCUiMenuWorldMapPointer, Img_Pointer) == 0x0002F0, "Member 'URCUiMenuWorldMapPointer::Img_Pointer' has a wrong offset!");

// Class RC.RCUiMovieSkip
// 0x0038 (0x0310 - 0x02D8)
class URCUiMovieSkip final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AN_Completed;                                      // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpUICircleGauge*                       CircleGauge_Skip;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isFinishAnimation;                                 // 0x0308(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiMovieSkip">();
	}
	static class URCUiMovieSkip* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiMovieSkip>();
	}
};
static_assert(alignof(URCUiMovieSkip) == 0x000008, "Wrong alignment on URCUiMovieSkip");
static_assert(sizeof(URCUiMovieSkip) == 0x000310, "Wrong size on URCUiMovieSkip");
static_assert(offsetof(URCUiMovieSkip, AN_Start) == 0x0002D8, "Member 'URCUiMovieSkip::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, AN_Wait) == 0x0002E0, "Member 'URCUiMovieSkip::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, AN_Finish) == 0x0002E8, "Member 'URCUiMovieSkip::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, AN_Completed) == 0x0002F0, "Member 'URCUiMovieSkip::AN_Completed' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, CircleGauge_Skip) == 0x0002F8, "Member 'URCUiMovieSkip::CircleGauge_Skip' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, WBP_ButtonGuide) == 0x000300, "Member 'URCUiMovieSkip::WBP_ButtonGuide' has a wrong offset!");
static_assert(offsetof(URCUiMovieSkip, isFinishAnimation) == 0x000308, "Member 'URCUiMovieSkip::isFinishAnimation' has a wrong offset!");

// Class RC.RCUiNzSceneChange
// 0x0030 (0x0340 - 0x0310)
class URCUiNzSceneChange final : public URCUiSceneChange
{
public:
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiNzSceneChange">();
	}
	static class URCUiNzSceneChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiNzSceneChange>();
	}
};
static_assert(alignof(URCUiNzSceneChange) == 0x000008, "Wrong alignment on URCUiNzSceneChange");
static_assert(sizeof(URCUiNzSceneChange) == 0x000340, "Wrong size on URCUiNzSceneChange");

// Class RC.RCUiNzSceneChangeLoading
// 0x0030 (0x0340 - 0x0310)
class URCUiNzSceneChangeLoading final : public URCUiSceneChange
{
public:
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiNzSceneChangeLoading">();
	}
	static class URCUiNzSceneChangeLoading* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiNzSceneChangeLoading>();
	}
};
static_assert(alignof(URCUiNzSceneChangeLoading) == 0x000008, "Wrong alignment on URCUiNzSceneChangeLoading");
static_assert(sizeof(URCUiNzSceneChangeLoading) == 0x000340, "Wrong size on URCUiNzSceneChangeLoading");

// Class RC.RCUiOptionBar_Choice
// 0x0028 (0x0368 - 0x0340)
class URCUiOptionBar_Choice final : public URCUiOptionBar
{
public:
	uint8                                         Pad_340[0x28];                                     // 0x0340(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComboBoxValueChangedEvent(int32 ind);
	void OnWindowModeChangeEvent(ERCOptionWindowMode Mode, int32 dispNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBar_Choice">();
	}
	static class URCUiOptionBar_Choice* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBar_Choice>();
	}
};
static_assert(alignof(URCUiOptionBar_Choice) == 0x000008, "Wrong alignment on URCUiOptionBar_Choice");
static_assert(sizeof(URCUiOptionBar_Choice) == 0x000368, "Wrong size on URCUiOptionBar_Choice");

// Class RC.RCUiOptionBar_Text
// 0x0030 (0x0370 - 0x0340)
class URCUiOptionBar_Text final : public URCUiOptionBar
{
public:
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBar_Text">();
	}
	static class URCUiOptionBar_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBar_Text>();
	}
};
static_assert(alignof(URCUiOptionBar_Text) == 0x000008, "Wrong alignment on URCUiOptionBar_Text");
static_assert(sizeof(URCUiOptionBar_Text) == 0x000370, "Wrong size on URCUiOptionBar_Text");

// Class RC.RCUiOptionBar_Volume
// 0x0018 (0x0358 - 0x0340)
class URCUiOptionBar_Volume final : public URCUiOptionBar
{
public:
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 SynchronizeToSlider(int32 ind);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBar_Volume">();
	}
	static class URCUiOptionBar_Volume* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBar_Volume>();
	}
};
static_assert(alignof(URCUiOptionBar_Volume) == 0x000008, "Wrong alignment on URCUiOptionBar_Volume");
static_assert(sizeof(URCUiOptionBar_Volume) == 0x000358, "Wrong size on URCUiOptionBar_Volume");

// Class RC.RCUiOptionBarComboBox
// 0x0068 (0x0340 - 0x02D8)
class URCUiOptionBarComboBox final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Open;                                           // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Close;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideOn;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_SlideOff;                                       // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URCUiOptionBarComboBoxItemList*         MenuItemList;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x38];                                     // 0x0308(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* GetComboBoxListWidget();
	void OnButtonClickEvent();
	void OnClickItemEvent(int32 ind);
	void OnMenuOpenChangedEvent(bool bIsOpen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarComboBox">();
	}
	static class URCUiOptionBarComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarComboBox>();
	}
};
static_assert(alignof(URCUiOptionBarComboBox) == 0x000008, "Wrong alignment on URCUiOptionBarComboBox");
static_assert(sizeof(URCUiOptionBarComboBox) == 0x000340, "Wrong size on URCUiOptionBarComboBox");
static_assert(offsetof(URCUiOptionBarComboBox, AN_Open) == 0x0002D8, "Member 'URCUiOptionBarComboBox::AN_Open' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarComboBox, AN_Close) == 0x0002E0, "Member 'URCUiOptionBarComboBox::AN_Close' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarComboBox, AN_SlideOn) == 0x0002E8, "Member 'URCUiOptionBarComboBox::AN_SlideOn' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarComboBox, AN_SlideOff) == 0x0002F0, "Member 'URCUiOptionBarComboBox::AN_SlideOff' has a wrong offset!");
static_assert(offsetof(URCUiOptionBarComboBox, MenuItemList) == 0x000300, "Member 'URCUiOptionBarComboBox::MenuItemList' has a wrong offset!");

// Class RC.RCUiOptionBarComboBoxItem
// 0x0040 (0x0318 - 0x02D8)
class URCUiOptionBarComboBoxItem final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClickEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarComboBoxItem">();
	}
	static class URCUiOptionBarComboBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarComboBoxItem>();
	}
};
static_assert(alignof(URCUiOptionBarComboBoxItem) == 0x000008, "Wrong alignment on URCUiOptionBarComboBoxItem");
static_assert(sizeof(URCUiOptionBarComboBoxItem) == 0x000318, "Wrong size on URCUiOptionBarComboBoxItem");

// Class RC.RCUiOptionBarComboBoxItemList
// 0x0028 (0x0300 - 0x02D8)
class URCUiOptionBarComboBoxItemList final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0xC];                                      // 0x02D8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ListMaxNum;                                        // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemEnterEvent(int32 ind);
	void SyncListSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarComboBoxItemList">();
	}
	static class URCUiOptionBarComboBoxItemList* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarComboBoxItemList>();
	}
};
static_assert(alignof(URCUiOptionBarComboBoxItemList) == 0x000008, "Wrong alignment on URCUiOptionBarComboBoxItemList");
static_assert(sizeof(URCUiOptionBarComboBoxItemList) == 0x000300, "Wrong size on URCUiOptionBarComboBoxItemList");
static_assert(offsetof(URCUiOptionBarComboBoxItemList, ListMaxNum) == 0x0002E4, "Member 'URCUiOptionBarComboBoxItemList::ListMaxNum' has a wrong offset!");

// Class RC.RCUiOptionBarWrapper
// 0x0040 (0x0318 - 0x02D8)
class URCUiOptionBarWrapper final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionBarWrapper">();
	}
	static class URCUiOptionBarWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionBarWrapper>();
	}
};
static_assert(alignof(URCUiOptionBarWrapper) == 0x000008, "Wrong alignment on URCUiOptionBarWrapper");
static_assert(sizeof(URCUiOptionBarWrapper) == 0x000318, "Wrong size on URCUiOptionBarWrapper");

// Class RC.RCUiOptionKey
// 0x0040 (0x0318 - 0x02D8)
class URCUiOptionKey final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKey">();
	}
	static class URCUiOptionKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKey>();
	}
};
static_assert(alignof(URCUiOptionKey) == 0x000008, "Wrong alignment on URCUiOptionKey");
static_assert(sizeof(URCUiOptionKey) == 0x000318, "Wrong size on URCUiOptionKey");

// Class RC.RCUiOptionKeyBox
// 0x0098 (0x0370 - 0x02D8)
class URCUiOptionKeyBox final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Cursor;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x80];                                     // 0x02F0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKeyBox">();
	}
	static class URCUiOptionKeyBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKeyBox>();
	}
};
static_assert(alignof(URCUiOptionKeyBox) == 0x000008, "Wrong alignment on URCUiOptionKeyBox");
static_assert(sizeof(URCUiOptionKeyBox) == 0x000370, "Wrong size on URCUiOptionKeyBox");
static_assert(offsetof(URCUiOptionKeyBox, AN_Def) == 0x0002D8, "Member 'URCUiOptionKeyBox::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiOptionKeyBox, AN_On_Cursor) == 0x0002E0, "Member 'URCUiOptionKeyBox::AN_On_Cursor' has a wrong offset!");
static_assert(offsetof(URCUiOptionKeyBox, AN_Off) == 0x0002E8, "Member 'URCUiOptionKeyBox::AN_Off' has a wrong offset!");

// Class RC.RCUiOptionKeyHeader
// 0x0030 (0x0308 - 0x02D8)
class URCUiOptionKeyHeader final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKeyHeader">();
	}
	static class URCUiOptionKeyHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKeyHeader>();
	}
};
static_assert(alignof(URCUiOptionKeyHeader) == 0x000008, "Wrong alignment on URCUiOptionKeyHeader");
static_assert(sizeof(URCUiOptionKeyHeader) == 0x000308, "Wrong size on URCUiOptionKeyHeader");

// Class RC.RCUiOptionKeySetWindow
// 0x0028 (0x0300 - 0x02D8)
class URCUiOptionKeySetWindow final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Off;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On;                                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionKeySetWindow">();
	}
	static class URCUiOptionKeySetWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionKeySetWindow>();
	}
};
static_assert(alignof(URCUiOptionKeySetWindow) == 0x000008, "Wrong alignment on URCUiOptionKeySetWindow");
static_assert(sizeof(URCUiOptionKeySetWindow) == 0x000300, "Wrong size on URCUiOptionKeySetWindow");
static_assert(offsetof(URCUiOptionKeySetWindow, AN_Off) == 0x0002D8, "Member 'URCUiOptionKeySetWindow::AN_Off' has a wrong offset!");
static_assert(offsetof(URCUiOptionKeySetWindow, AN_On) == 0x0002E0, "Member 'URCUiOptionKeySetWindow::AN_On' has a wrong offset!");

// Class RC.RCUiOptionLayout
// 0x0160 (0x0438 - 0x02D8)
class URCUiOptionLayout final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x160];                                    // 0x02D8(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonGuideClose(ERCInputKeyType KeyType);
	void OnButtonGuideInitializeBar(ERCInputKeyType KeyType);
	void OnButtonGuideInitializeKey(ERCInputKeyType KeyType);
	void OnButtonGuideOptionEnter(ERCInputKeyType KeyType);
	void OnButtonGuideSelectKey(ERCInputKeyType KeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionLayout">();
	}
	static class URCUiOptionLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionLayout>();
	}
};
static_assert(alignof(URCUiOptionLayout) == 0x000008, "Wrong alignment on URCUiOptionLayout");
static_assert(sizeof(URCUiOptionLayout) == 0x000438, "Wrong size on URCUiOptionLayout");

// Class RC.RCUiOptionListBar
// 0x0068 (0x0340 - 0x02D8)
class URCUiOptionListBar final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x68];                                     // 0x02D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BarArrowButtonDownEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionListBar">();
	}
	static class URCUiOptionListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionListBar>();
	}
};
static_assert(alignof(URCUiOptionListBar) == 0x000008, "Wrong alignment on URCUiOptionListBar");
static_assert(sizeof(URCUiOptionListBar) == 0x000340, "Wrong size on URCUiOptionListBar");

// Class RC.RCUiOptionPagerSet
// 0x0020 (0x02F8 - 0x02D8)
class URCUiOptionPagerSet final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionPagerSet">();
	}
	static class URCUiOptionPagerSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionPagerSet>();
	}
};
static_assert(alignof(URCUiOptionPagerSet) == 0x000008, "Wrong alignment on URCUiOptionPagerSet");
static_assert(sizeof(URCUiOptionPagerSet) == 0x0002F8, "Wrong size on URCUiOptionPagerSet");

// Class RC.RCUiOptionTab
// 0x0050 (0x0328 - 0x02D8)
class URCUiOptionTab final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Def;                                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_On_Cursor;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Off;                                            // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x38];                                     // 0x02F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiOptionTab">();
	}
	static class URCUiOptionTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiOptionTab>();
	}
};
static_assert(alignof(URCUiOptionTab) == 0x000008, "Wrong alignment on URCUiOptionTab");
static_assert(sizeof(URCUiOptionTab) == 0x000328, "Wrong size on URCUiOptionTab");
static_assert(offsetof(URCUiOptionTab, AN_Def) == 0x0002D8, "Member 'URCUiOptionTab::AN_Def' has a wrong offset!");
static_assert(offsetof(URCUiOptionTab, AN_On_Cursor) == 0x0002E0, "Member 'URCUiOptionTab::AN_On_Cursor' has a wrong offset!");
static_assert(offsetof(URCUiOptionTab, AN_Off) == 0x0002E8, "Member 'URCUiOptionTab::AN_Off' has a wrong offset!");

// Class RC.RCUiPauseScreen
// 0x0038 (0x0310 - 0x02D8)
class URCUiPauseScreen final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiPauseScreen">();
	}
	static class URCUiPauseScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiPauseScreen>();
	}
};
static_assert(alignof(URCUiPauseScreen) == 0x000008, "Wrong alignment on URCUiPauseScreen");
static_assert(sizeof(URCUiPauseScreen) == 0x000310, "Wrong size on URCUiPauseScreen");
static_assert(offsetof(URCUiPauseScreen, AN_Start) == 0x0002D8, "Member 'URCUiPauseScreen::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiPauseScreen, AN_Wait) == 0x0002E0, "Member 'URCUiPauseScreen::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiPauseScreen, AN_Finish) == 0x0002E8, "Member 'URCUiPauseScreen::AN_Finish' has a wrong offset!");

// Class RC.RCUiReSceneChange
// 0x0020 (0x0330 - 0x0310)
class URCUiReSceneChange final : public URCUiSceneChange
{
public:
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiReSceneChange">();
	}
	static class URCUiReSceneChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiReSceneChange>();
	}
};
static_assert(alignof(URCUiReSceneChange) == 0x000008, "Wrong alignment on URCUiReSceneChange");
static_assert(sizeof(URCUiReSceneChange) == 0x000330, "Wrong size on URCUiReSceneChange");

// Class RC.RCUiReSceneChangeLoading
// 0x0030 (0x0340 - 0x0310)
class URCUiReSceneChangeLoading final : public URCUiSceneChange
{
public:
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiReSceneChangeLoading">();
	}
	static class URCUiReSceneChangeLoading* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiReSceneChangeLoading>();
	}
};
static_assert(alignof(URCUiReSceneChangeLoading) == 0x000008, "Wrong alignment on URCUiReSceneChangeLoading");
static_assert(sizeof(URCUiReSceneChangeLoading) == 0x000340, "Wrong size on URCUiReSceneChangeLoading");

// Class RC.RCUiSavingIcon
// 0x0028 (0x0300 - 0x02D8)
class URCUiSavingIcon : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSave();
	void SetAutoCloseFlag(bool bFlag);
	void StartSave();

	bool IsSaving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiSavingIcon">();
	}
	static class URCUiSavingIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiSavingIcon>();
	}
};
static_assert(alignof(URCUiSavingIcon) == 0x000008, "Wrong alignment on URCUiSavingIcon");
static_assert(sizeof(URCUiSavingIcon) == 0x000300, "Wrong size on URCUiSavingIcon");
static_assert(offsetof(URCUiSavingIcon, AN_Start) == 0x0002D8, "Member 'URCUiSavingIcon::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiSavingIcon, AN_Wait) == 0x0002E0, "Member 'URCUiSavingIcon::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiSavingIcon, AN_Finish) == 0x0002E8, "Member 'URCUiSavingIcon::AN_Finish' has a wrong offset!");

// Class RC.RCUiSoundNovel
// 0x00F0 (0x03C8 - 0x02D8)
class URCUiSoundNovel final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiSoundNovelBack*                    BackWidget;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NovelText;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageCursor*                   MsgCursor;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextInterval;                                      // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HandleTimer;                                       // 0x0340(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEndOfText;                                      // 0x0348(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TalkDelay;                                         // 0x034C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoPlay;                                       // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoWaitPushTimer;                                 // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoDelay;                                         // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x64];                                     // 0x0364(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSpace(int32 InSpaceNum);
	void AddText(const class FString& inString, float InDelay);
	void ClearText();
	void Close();
	int32 GetMessStatusInt();
	bool GetSkipTyping();
	ESoundNovelStatus GetSoundNovelStatus();
	void HideBackgroundFade();
	void InitializeSoundNovel();
	void Open();
	void SetForceAutoFlag(bool bForceAuto, bool bShowAutoIcon);
	void SetForceTextSpeedSettings(bool bInIsForceTextSpeed, int32 InForceTextSpeed);
	void SetMessageSpeed();
	void SetShakeData(float InWidthX, float InWidthY, float InInterval);
	void ShowBackgroundFade();
	void WaitingOpenBackgroundFade();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiSoundNovel">();
	}
	static class URCUiSoundNovel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiSoundNovel>();
	}
};
static_assert(alignof(URCUiSoundNovel) == 0x000008, "Wrong alignment on URCUiSoundNovel");
static_assert(sizeof(URCUiSoundNovel) == 0x0003C8, "Wrong size on URCUiSoundNovel");
static_assert(offsetof(URCUiSoundNovel, AN_Start) == 0x0002D8, "Member 'URCUiSoundNovel::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, AN_Wait) == 0x0002E0, "Member 'URCUiSoundNovel::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, AN_Finish) == 0x0002E8, "Member 'URCUiSoundNovel::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, BackWidget) == 0x0002F0, "Member 'URCUiSoundNovel::BackWidget' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, NovelText) == 0x0002F8, "Member 'URCUiSoundNovel::NovelText' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, MsgCursor) == 0x000300, "Member 'URCUiSoundNovel::MsgCursor' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, TextInterval) == 0x000338, "Member 'URCUiSoundNovel::TextInterval' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, HandleTimer) == 0x000340, "Member 'URCUiSoundNovel::HandleTimer' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, bIsEndOfText) == 0x000348, "Member 'URCUiSoundNovel::bIsEndOfText' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, TalkDelay) == 0x00034C, "Member 'URCUiSoundNovel::TalkDelay' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, bIsAutoPlay) == 0x000358, "Member 'URCUiSoundNovel::bIsAutoPlay' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, AutoWaitPushTimer) == 0x00035C, "Member 'URCUiSoundNovel::AutoWaitPushTimer' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovel, AutoDelay) == 0x000360, "Member 'URCUiSoundNovel::AutoDelay' has a wrong offset!");

// Class RC.RCUiSoundNovelBack
// 0x0018 (0x02F0 - 0x02D8)
class URCUiSoundNovelBack final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiSoundNovelBack">();
	}
	static class URCUiSoundNovelBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiSoundNovelBack>();
	}
};
static_assert(alignof(URCUiSoundNovelBack) == 0x000008, "Wrong alignment on URCUiSoundNovelBack");
static_assert(sizeof(URCUiSoundNovelBack) == 0x0002F0, "Wrong size on URCUiSoundNovelBack");
static_assert(offsetof(URCUiSoundNovelBack, AN_Start) == 0x0002D8, "Member 'URCUiSoundNovelBack::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovelBack, AN_Wait) == 0x0002E0, "Member 'URCUiSoundNovelBack::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiSoundNovelBack, AN_Finish) == 0x0002E8, "Member 'URCUiSoundNovelBack::AN_Finish' has a wrong offset!");

// Class RC.RCUiStaffRoll
// 0x01A8 (0x0480 - 0x02D8)
class URCUiStaffRoll final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x68];                                     // 0x02D8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MainCanvas;                                        // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiStaffRollBackground*               Background;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x60];                                     // 0x0350(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URCUiStaffRollItem*>             AllItems;                                          // 0x03B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0xB8];                                     // 0x03C0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class URCStaffRollDataAsset*                  SettingData;                                       // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishStaffRoll();
	void InitStaffRoll(float StartTime, float EndTime, float SpaceSize);
	void MovieFinishEvent();
	void SetStaffRollDataAsset(class URCStaffRollDataAsset* Data);
	void StartMovie();
	void StartStaffRoll();

	float GetFinishTime() const;
	float GetMovieStartTime() const;
	bool IsEndScroll() const;
	bool IsFinished() const;
	bool IsInitializedStaffRoll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRoll">();
	}
	static class URCUiStaffRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRoll>();
	}
};
static_assert(alignof(URCUiStaffRoll) == 0x000008, "Wrong alignment on URCUiStaffRoll");
static_assert(sizeof(URCUiStaffRoll) == 0x000480, "Wrong size on URCUiStaffRoll");
static_assert(offsetof(URCUiStaffRoll, MainCanvas) == 0x000340, "Member 'URCUiStaffRoll::MainCanvas' has a wrong offset!");
static_assert(offsetof(URCUiStaffRoll, Background) == 0x000348, "Member 'URCUiStaffRoll::Background' has a wrong offset!");
static_assert(offsetof(URCUiStaffRoll, AllItems) == 0x0003B0, "Member 'URCUiStaffRoll::AllItems' has a wrong offset!");
static_assert(offsetof(URCUiStaffRoll, SettingData) == 0x000478, "Member 'URCUiStaffRoll::SettingData' has a wrong offset!");

// Class RC.RCUiStaffRollItem_Actor
// 0x0018 (0x02F8 - 0x02E0)
class URCUiStaffRollItem_Actor final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_Actor">();
	}
	static class URCUiStaffRollItem_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_Actor>();
	}
};
static_assert(alignof(URCUiStaffRollItem_Actor) == 0x000008, "Wrong alignment on URCUiStaffRollItem_Actor");
static_assert(sizeof(URCUiStaffRollItem_Actor) == 0x0002F8, "Wrong size on URCUiStaffRollItem_Actor");

// Class RC.RCUiStaffRollItem_AllInOneText
// 0x0000 (0x02E0 - 0x02E0)
class URCUiStaffRollItem_AllInOneText final : public URCUiStaffRollItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_AllInOneText">();
	}
	static class URCUiStaffRollItem_AllInOneText* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_AllInOneText>();
	}
};
static_assert(alignof(URCUiStaffRollItem_AllInOneText) == 0x000008, "Wrong alignment on URCUiStaffRollItem_AllInOneText");
static_assert(sizeof(URCUiStaffRollItem_AllInOneText) == 0x0002E0, "Wrong size on URCUiStaffRollItem_AllInOneText");

// Class RC.RCUiStaffRollItem_Name
// 0x0010 (0x02F0 - 0x02E0)
class URCUiStaffRollItem_Name final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_Name">();
	}
	static class URCUiStaffRollItem_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_Name>();
	}
};
static_assert(alignof(URCUiStaffRollItem_Name) == 0x000008, "Wrong alignment on URCUiStaffRollItem_Name");
static_assert(sizeof(URCUiStaffRollItem_Name) == 0x0002F0, "Wrong size on URCUiStaffRollItem_Name");

// Class RC.RCUiStaffRollItem_NameLarge
// 0x0010 (0x02F0 - 0x02E0)
class URCUiStaffRollItem_NameLarge final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_NameLarge">();
	}
	static class URCUiStaffRollItem_NameLarge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_NameLarge>();
	}
};
static_assert(alignof(URCUiStaffRollItem_NameLarge) == 0x000008, "Wrong alignment on URCUiStaffRollItem_NameLarge");
static_assert(sizeof(URCUiStaffRollItem_NameLarge) == 0x0002F0, "Wrong size on URCUiStaffRollItem_NameLarge");

// Class RC.RCUiStaffRollItem_Position
// 0x0010 (0x02F0 - 0x02E0)
class URCUiStaffRollItem_Position final : public URCUiStaffRollItem
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiStaffRollItem_Position">();
	}
	static class URCUiStaffRollItem_Position* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiStaffRollItem_Position>();
	}
};
static_assert(alignof(URCUiStaffRollItem_Position) == 0x000008, "Wrong alignment on URCUiStaffRollItem_Position");
static_assert(sizeof(URCUiStaffRollItem_Position) == 0x0002F0, "Wrong size on URCUiStaffRollItem_Position");

// Class RC.RCUiSubtitle
// 0x0098 (0x0370 - 0x02D8)
class URCUiSubtitle final : public URCUiWidgetBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AN_Start;                                          // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x30];                                     // 0x02F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextLayoutWidget*                      Text_Name;                                         // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      TextLine_01;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCReUiMessageCursor*                   MsgCursor;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           Nag_Message_Grp;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallDelay();
	void CallEndVoice();
	void Close();
	void DisplaceSubtitle(const struct FVector2D& InVector);
	bool GetSkipVoice();
	int32 GetSubtitleStatusNum();
	void InitializeSubtitle();
	void Open();
	void Open_WaitPush(bool bInEnableSkipVoice);
	void SetText(const class FString& InName, const class FString& inString, float InDelay, bool bInOnlyCursor);
	void StartDelay();
	void StartShow();
	void UndoDisplaceSubtitle();
	void Wait();
	void WaitingOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiSubtitle">();
	}
	static class URCUiSubtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiSubtitle>();
	}
};
static_assert(alignof(URCUiSubtitle) == 0x000008, "Wrong alignment on URCUiSubtitle");
static_assert(sizeof(URCUiSubtitle) == 0x000370, "Wrong size on URCUiSubtitle");
static_assert(offsetof(URCUiSubtitle, AN_Start) == 0x0002E0, "Member 'URCUiSubtitle::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, AN_Wait) == 0x0002E8, "Member 'URCUiSubtitle::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, AN_Finish) == 0x0002F0, "Member 'URCUiSubtitle::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, Text_Name) == 0x000328, "Member 'URCUiSubtitle::Text_Name' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, TextLine_01) == 0x000330, "Member 'URCUiSubtitle::TextLine_01' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, MsgCursor) == 0x000338, "Member 'URCUiSubtitle::MsgCursor' has a wrong offset!");
static_assert(offsetof(URCUiSubtitle, Nag_Message_Grp) == 0x000358, "Member 'URCUiSubtitle::Nag_Message_Grp' has a wrong offset!");

// Class RC.RCUiTalkFaceEffects
// 0x0010 (0x02E8 - 0x02D8)
class URCUiTalkFaceEffects final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiTalkFaceEffects">();
	}
	static class URCUiTalkFaceEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiTalkFaceEffects>();
	}
};
static_assert(alignof(URCUiTalkFaceEffects) == 0x000008, "Wrong alignment on URCUiTalkFaceEffects");
static_assert(sizeof(URCUiTalkFaceEffects) == 0x0002E8, "Wrong size on URCUiTalkFaceEffects");
static_assert(offsetof(URCUiTalkFaceEffects, AN_Start) == 0x0002D8, "Member 'URCUiTalkFaceEffects::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiTalkFaceEffects, AN_Finish) == 0x0002E0, "Member 'URCUiTalkFaceEffects::AN_Finish' has a wrong offset!");

// Class RC.RCUiTipsScreenProgressBar
// 0x0008 (0x02E0 - 0x02D8)
class URCUiTipsScreenProgressBar : public URCUiWidgetBase
{
public:
	class USpUIGauge*                             SpGauge_ProgressBar;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiTipsScreenProgressBar">();
	}
	static class URCUiTipsScreenProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiTipsScreenProgressBar>();
	}
};
static_assert(alignof(URCUiTipsScreenProgressBar) == 0x000008, "Wrong alignment on URCUiTipsScreenProgressBar");
static_assert(sizeof(URCUiTipsScreenProgressBar) == 0x0002E0, "Wrong size on URCUiTipsScreenProgressBar");
static_assert(offsetof(URCUiTipsScreenProgressBar, SpGauge_ProgressBar) == 0x0002D8, "Member 'URCUiTipsScreenProgressBar::SpGauge_ProgressBar' has a wrong offset!");

// Class RC.RCUiTutorialPager
// 0x0040 (0x0318 - 0x02D8)
class URCUiTutorialPager final : public URCUiWidgetBase
{
public:
	class URCUiButtonGuideParts*                  WBP_ButtonGuide_L;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  WBP_ButtonGuide_R;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ItemHorizontalBox;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuAreaMapPagerItem*              WBP_UI_Pager_Item_0;                               // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuAreaMapPagerItem*              WBP_UI_Pager_Item_1;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiMenuAreaMapPagerItem*              WBP_UI_Pager_Item_2;                               // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCUiMenuAreaMapPagerItem*>      PagerItemList;                                     // 0x0308(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiTutorialPager">();
	}
	static class URCUiTutorialPager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiTutorialPager>();
	}
};
static_assert(alignof(URCUiTutorialPager) == 0x000008, "Wrong alignment on URCUiTutorialPager");
static_assert(sizeof(URCUiTutorialPager) == 0x000318, "Wrong size on URCUiTutorialPager");
static_assert(offsetof(URCUiTutorialPager, WBP_ButtonGuide_L) == 0x0002D8, "Member 'URCUiTutorialPager::WBP_ButtonGuide_L' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, WBP_ButtonGuide_R) == 0x0002E0, "Member 'URCUiTutorialPager::WBP_ButtonGuide_R' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, ItemHorizontalBox) == 0x0002E8, "Member 'URCUiTutorialPager::ItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, WBP_UI_Pager_Item_0) == 0x0002F0, "Member 'URCUiTutorialPager::WBP_UI_Pager_Item_0' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, WBP_UI_Pager_Item_1) == 0x0002F8, "Member 'URCUiTutorialPager::WBP_UI_Pager_Item_1' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, WBP_UI_Pager_Item_2) == 0x000300, "Member 'URCUiTutorialPager::WBP_UI_Pager_Item_2' has a wrong offset!");
static_assert(offsetof(URCUiTutorialPager, PagerItemList) == 0x000308, "Member 'URCUiTutorialPager::PagerItemList' has a wrong offset!");

// Class RC.RCUiTutorialWindow
// 0x0148 (0x0420 - 0x02D8)
class URCUiTutorialWindow final : public URCUiWidgetBase
{
public:
	class UWidgetAnimation*                       AN_Start;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Wait;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AN_Finish;                                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TitleText;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DescText;                                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiTutorialPager*                     Pager;                                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DispImage;                                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URCUiButtonGuide*                       WBP_BTNGuide_Layout;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URCUiButtonGuideParts*>          ControlGuideList;                                  // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class URCUiButtonGuideParts*                  ControlGuide;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                Spacer_Layout;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0xE8];                                     // 0x0338(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonGuideCloseClick(ERCInputKeyType KeyType);
	void OnPagerButtonGuideClick(ERCInputKeyType KeyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUiTutorialWindow">();
	}
	static class URCUiTutorialWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUiTutorialWindow>();
	}
};
static_assert(alignof(URCUiTutorialWindow) == 0x000008, "Wrong alignment on URCUiTutorialWindow");
static_assert(sizeof(URCUiTutorialWindow) == 0x000420, "Wrong size on URCUiTutorialWindow");
static_assert(offsetof(URCUiTutorialWindow, AN_Start) == 0x0002D8, "Member 'URCUiTutorialWindow::AN_Start' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, AN_Wait) == 0x0002E0, "Member 'URCUiTutorialWindow::AN_Wait' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, AN_Finish) == 0x0002E8, "Member 'URCUiTutorialWindow::AN_Finish' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, TitleText) == 0x0002F0, "Member 'URCUiTutorialWindow::TitleText' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, DescText) == 0x0002F8, "Member 'URCUiTutorialWindow::DescText' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, Pager) == 0x000300, "Member 'URCUiTutorialWindow::Pager' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, DispImage) == 0x000308, "Member 'URCUiTutorialWindow::DispImage' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, WBP_BTNGuide_Layout) == 0x000310, "Member 'URCUiTutorialWindow::WBP_BTNGuide_Layout' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, ControlGuideList) == 0x000318, "Member 'URCUiTutorialWindow::ControlGuideList' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, ControlGuide) == 0x000328, "Member 'URCUiTutorialWindow::ControlGuide' has a wrong offset!");
static_assert(offsetof(URCUiTutorialWindow, Spacer_Layout) == 0x000330, "Member 'URCUiTutorialWindow::Spacer_Layout' has a wrong offset!");

// Class RC.RCUtilityFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCUtilityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ARCCameraManager* GeRCCameraManager();
	static class ARCPlayerCameraManager* GeRCPlayerCameraManager();
	static int32 GetCurrentArea();
	static class FString GetGameVersion();
	static class ARCPlayerController* GetRCPlayerController();
	static const struct FRotator GetToonDirectionalLightRotatorOffset();
	static bool IsCameraACtor(class AActor* act);
	static void ResetToonDirectionalLightInfo();
	static bool SetCascadeRainColor(class FName Map, class FName Name_0);
	static bool SetCascadeRainColorIndex(int32 Index_0);
	static void SetDrawRain(bool flag);
	static bool SetRainColorTable(class FName Name_0);
	static bool SetRainForce(int32 Force);
	static bool SetRainRot(const struct FRotator& Rot);
	static void SetToonDirectionalLightInfo(class AActor* InCameraActor, const struct FRotator& InRotatorOffset);
	static void SetToonDirectionalLightRotatorOffset(const struct FRotator& InRotatorOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCUtilityFunctionLibrary">();
	}
	static class URCUtilityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCUtilityFunctionLibrary>();
	}
};
static_assert(alignof(URCUtilityFunctionLibrary) == 0x000008, "Wrong alignment on URCUtilityFunctionLibrary");
static_assert(sizeof(URCUtilityFunctionLibrary) == 0x000028, "Wrong size on URCUtilityFunctionLibrary");

// Class RC.RCVariableFigure
// 0x0010 (0x0038 - 0x0028)
class URCVariableFigure final : public UObject
{
public:
	struct FRCVariableFigureAllInfo               FigureAllInfo;                                     // 0x0028(0x0010)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableFigure">();
	}
	static class URCVariableFigure* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableFigure>();
	}
};
static_assert(alignof(URCVariableFigure) == 0x000008, "Wrong alignment on URCVariableFigure");
static_assert(sizeof(URCVariableFigure) == 0x000038, "Wrong size on URCVariableFigure");
static_assert(offsetof(URCVariableFigure, FigureAllInfo) == 0x000028, "Member 'URCVariableFigure::FigureAllInfo' has a wrong offset!");

// Class RC.RCVariableFigureBFL
// 0x0000 (0x0028 - 0x0028)
class URCVariableFigureBFL final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetFigureNum(class FName InPersonID);
	static bool IsFigure(class FName InPersonID, int32 InFigureNum);
	static void SetFigure(class FName InPersonID, int32 InFigureNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableFigureBFL">();
	}
	static class URCVariableFigureBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableFigureBFL>();
	}
};
static_assert(alignof(URCVariableFigureBFL) == 0x000008, "Wrong alignment on URCVariableFigureBFL");
static_assert(sizeof(URCVariableFigureBFL) == 0x000028, "Wrong size on URCVariableFigureBFL");

// Class RC.RCVariableGameMenu
// 0x0040 (0x0068 - 0x0028)
class URCVariableGameMenu final : public UObject
{
public:
	class URCVariableGameMenuTop*                 Top;                                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuMap*                 Map;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuKaikagi*             kaikagi;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuQuest*               Quest;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuPersona*             Persona;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuCharacter*           Character;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuGlossary*            Glossary;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuCollection*          Collection;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenu">();
	}
	static class URCVariableGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenu>();
	}
};
static_assert(alignof(URCVariableGameMenu) == 0x000008, "Wrong alignment on URCVariableGameMenu");
static_assert(sizeof(URCVariableGameMenu) == 0x000068, "Wrong size on URCVariableGameMenu");
static_assert(offsetof(URCVariableGameMenu, Top) == 0x000028, "Member 'URCVariableGameMenu::Top' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Map) == 0x000030, "Member 'URCVariableGameMenu::Map' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, kaikagi) == 0x000038, "Member 'URCVariableGameMenu::kaikagi' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Quest) == 0x000040, "Member 'URCVariableGameMenu::Quest' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Persona) == 0x000048, "Member 'URCVariableGameMenu::Persona' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Character) == 0x000050, "Member 'URCVariableGameMenu::Character' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Glossary) == 0x000058, "Member 'URCVariableGameMenu::Glossary' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenu, Collection) == 0x000060, "Member 'URCVariableGameMenu::Collection' has a wrong offset!");

// Class RC.RCVariableGameMenuCharacter
// 0x0018 (0x0040 - 0x0028)
class URCVariableGameMenuCharacter final : public UObject
{
public:
	struct FRCVariableGameMenuCharacterMenuInfo   CharacterMenuInfo;                                 // 0x0028(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuCharacter">();
	}
	static class URCVariableGameMenuCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuCharacter>();
	}
};
static_assert(alignof(URCVariableGameMenuCharacter) == 0x000008, "Wrong alignment on URCVariableGameMenuCharacter");
static_assert(sizeof(URCVariableGameMenuCharacter) == 0x000040, "Wrong size on URCVariableGameMenuCharacter");
static_assert(offsetof(URCVariableGameMenuCharacter, CharacterMenuInfo) == 0x000028, "Member 'URCVariableGameMenuCharacter::CharacterMenuInfo' has a wrong offset!");

// Class RC.RCVariableGameMenuCollection
// 0x0018 (0x0040 - 0x0028)
class URCVariableGameMenuCollection final : public UObject
{
public:
	struct FRCVariableGameMenuCollectionMenuInfo  CollectionMenuInfo;                                // 0x0028(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuCollection">();
	}
	static class URCVariableGameMenuCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuCollection>();
	}
};
static_assert(alignof(URCVariableGameMenuCollection) == 0x000008, "Wrong alignment on URCVariableGameMenuCollection");
static_assert(sizeof(URCVariableGameMenuCollection) == 0x000040, "Wrong size on URCVariableGameMenuCollection");
static_assert(offsetof(URCVariableGameMenuCollection, CollectionMenuInfo) == 0x000028, "Member 'URCVariableGameMenuCollection::CollectionMenuInfo' has a wrong offset!");

// Class RC.RCVariableGameMenuGallery
// 0x0018 (0x0040 - 0x0028)
class URCVariableGameMenuGallery final : public UObject
{
public:
	struct FRCVariableGameMenuGalleryMenuInfo     GalleryMenuInfo;                                   // 0x0028(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URCVariableGameMenuGalleryBgm*          GalleryBgm;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuGalleryMovie*        GalleryMovie;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuGallery">();
	}
	static class URCVariableGameMenuGallery* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuGallery>();
	}
};
static_assert(alignof(URCVariableGameMenuGallery) == 0x000008, "Wrong alignment on URCVariableGameMenuGallery");
static_assert(sizeof(URCVariableGameMenuGallery) == 0x000040, "Wrong size on URCVariableGameMenuGallery");
static_assert(offsetof(URCVariableGameMenuGallery, GalleryMenuInfo) == 0x000028, "Member 'URCVariableGameMenuGallery::GalleryMenuInfo' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuGallery, GalleryBgm) == 0x000030, "Member 'URCVariableGameMenuGallery::GalleryBgm' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuGallery, GalleryMovie) == 0x000038, "Member 'URCVariableGameMenuGallery::GalleryMovie' has a wrong offset!");

// Class RC.RCVariableGameMenuGalleryMovie
// 0x0010 (0x0038 - 0x0028)
class URCVariableGameMenuGalleryMovie final : public UObject
{
public:
	struct FRCVariableGameMenuGalleryMovieMenuInfo MovieGalleryMenuInfo;                              // 0x0028(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuGalleryMovie">();
	}
	static class URCVariableGameMenuGalleryMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuGalleryMovie>();
	}
};
static_assert(alignof(URCVariableGameMenuGalleryMovie) == 0x000008, "Wrong alignment on URCVariableGameMenuGalleryMovie");
static_assert(sizeof(URCVariableGameMenuGalleryMovie) == 0x000038, "Wrong size on URCVariableGameMenuGalleryMovie");
static_assert(offsetof(URCVariableGameMenuGalleryMovie, MovieGalleryMenuInfo) == 0x000028, "Member 'URCVariableGameMenuGalleryMovie::MovieGalleryMenuInfo' has a wrong offset!");

// Class RC.RCVariableGameMenuGlossary
// 0x0050 (0x0078 - 0x0028)
class URCVariableGameMenuGlossary final : public UObject
{
public:
	struct FRCVariableGameMenuGlossaryMenuInfo    GlossaryMenuList;                                  // 0x0028(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FRCVariableGameMenuGlossaryMenuInfo    SubStoryGlossaryMenuList;                          // 0x0050(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuGlossary">();
	}
	static class URCVariableGameMenuGlossary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuGlossary>();
	}
};
static_assert(alignof(URCVariableGameMenuGlossary) == 0x000008, "Wrong alignment on URCVariableGameMenuGlossary");
static_assert(sizeof(URCVariableGameMenuGlossary) == 0x000078, "Wrong size on URCVariableGameMenuGlossary");
static_assert(offsetof(URCVariableGameMenuGlossary, GlossaryMenuList) == 0x000028, "Member 'URCVariableGameMenuGlossary::GlossaryMenuList' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuGlossary, SubStoryGlossaryMenuList) == 0x000050, "Member 'URCVariableGameMenuGlossary::SubStoryGlossaryMenuList' has a wrong offset!");

// Class RC.RCVariableGameMenuKaikagi
// 0x0018 (0x0040 - 0x0028)
class URCVariableGameMenuKaikagi final : public UObject
{
public:
	struct FRCVariableGameMenuKaikagiMenuInfo     KaikagiMenuInfo;                                   // 0x0028(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuKaikagi">();
	}
	static class URCVariableGameMenuKaikagi* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuKaikagi>();
	}
};
static_assert(alignof(URCVariableGameMenuKaikagi) == 0x000008, "Wrong alignment on URCVariableGameMenuKaikagi");
static_assert(sizeof(URCVariableGameMenuKaikagi) == 0x000040, "Wrong size on URCVariableGameMenuKaikagi");
static_assert(offsetof(URCVariableGameMenuKaikagi, KaikagiMenuInfo) == 0x000028, "Member 'URCVariableGameMenuKaikagi::KaikagiMenuInfo' has a wrong offset!");

// Class RC.RCVariableGameMenuPersona
// 0x0070 (0x0098 - 0x0028)
class URCVariableGameMenuPersona final : public UObject
{
public:
	struct FRCVariableGameMenuPersonaMenuInfo     PersonaMenuInfo;                                   // 0x0028(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FRCSkillStatusInfo                     SkillStatusInfo;                                   // 0x0048(0x0048)(Edit, NativeAccessSpecifierPrivate)
	int32                                         DefaultHp;                                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuPersona">();
	}
	static class URCVariableGameMenuPersona* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuPersona>();
	}
};
static_assert(alignof(URCVariableGameMenuPersona) == 0x000008, "Wrong alignment on URCVariableGameMenuPersona");
static_assert(sizeof(URCVariableGameMenuPersona) == 0x000098, "Wrong size on URCVariableGameMenuPersona");
static_assert(offsetof(URCVariableGameMenuPersona, PersonaMenuInfo) == 0x000028, "Member 'URCVariableGameMenuPersona::PersonaMenuInfo' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuPersona, SkillStatusInfo) == 0x000048, "Member 'URCVariableGameMenuPersona::SkillStatusInfo' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuPersona, DefaultHp) == 0x000090, "Member 'URCVariableGameMenuPersona::DefaultHp' has a wrong offset!");

// Class RC.RCVariableGameMenuQuest
// 0x0038 (0x0060 - 0x0028)
class URCVariableGameMenuQuest final : public UObject
{
public:
	struct FRCVariableGameMenuQuestMenuInfo       QuestMenuInfo;                                     // 0x0028(0x0038)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuQuest">();
	}
	static class URCVariableGameMenuQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuQuest>();
	}
};
static_assert(alignof(URCVariableGameMenuQuest) == 0x000008, "Wrong alignment on URCVariableGameMenuQuest");
static_assert(sizeof(URCVariableGameMenuQuest) == 0x000060, "Wrong size on URCVariableGameMenuQuest");
static_assert(offsetof(URCVariableGameMenuQuest, QuestMenuInfo) == 0x000028, "Member 'URCVariableGameMenuQuest::QuestMenuInfo' has a wrong offset!");

// Class RC.RCVariableGameMenuTop
// 0x0030 (0x0058 - 0x0028)
class URCVariableGameMenuTop final : public UObject
{
public:
	class URCVariableGameMenu*                    ParrentGameMenu;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRCVariableGameMenuTopMenuInfo         TopMenuInfo;                                       // 0x0030(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableGameMenuTop">();
	}
	static class URCVariableGameMenuTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableGameMenuTop>();
	}
};
static_assert(alignof(URCVariableGameMenuTop) == 0x000008, "Wrong alignment on URCVariableGameMenuTop");
static_assert(sizeof(URCVariableGameMenuTop) == 0x000058, "Wrong size on URCVariableGameMenuTop");
static_assert(offsetof(URCVariableGameMenuTop, ParrentGameMenu) == 0x000028, "Member 'URCVariableGameMenuTop::ParrentGameMenu' has a wrong offset!");
static_assert(offsetof(URCVariableGameMenuTop, TopMenuInfo) == 0x000030, "Member 'URCVariableGameMenuTop::TopMenuInfo' has a wrong offset!");

// Class RC.RCVariableManager
// 0x01B8 (0x01E0 - 0x0028)
class URCVariableManager final : public UObject
{
public:
	ERCGameMode                                   GameMode;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCGameMode                                   NextGameMode;                                      // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCStoryMode                                  StoryMode;                                         // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameLevelInfo                         NowGameLevelInfo;                                  // 0x002C(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameLevelInfo                         NextGameLevelInfo;                                 // 0x0050(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameLevelInfo                         OldGameLevelInfo;                                  // 0x0074(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameLevelInfo                         SaveGameLevelInfo;                                 // 0x0098(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GameVariable;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 ChapterVariable;                                   // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 SceneVariable;                                     // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsGameClear;                                      // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERCChapter>                            ClearChapterList;                                  // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         MainQuestPhase;                                    // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERCRealEventMapConnectStatus                  BusStopStatus;                                     // 0x010C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBusStopStatusFromAreamap>      BusStopStatusFromAreamap;                          // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsMoveBusStop;                                    // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTitleCollectionEvent;                           // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCollectionEvent;                                // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCollectionEventBack;                            // 0x0123(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CollectionMenuStorySceneName;                      // 0x0124(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CollectionMenuStoryChapterNum;                     // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CollectionMenuSelectCharaID;                       // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CollectionMenuSelectStoryIndex;                    // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMessageAuto;                                      // 0x013C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipEnable;                                       // 0x013D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFreeMoveSkipEnable;                               // 0x013E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMovieSkipEnable;                                  // 0x013F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecMenuSceneLoad;                                // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawDisableSubQuest;                              // 0x0141(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGalleryMode;                                    // 0x0142(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOpenGalleryMode;                                  // 0x0143(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GalleryMenuPlayingMovieID;                         // 0x0144(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             GalleryMenuMovieSoundTable;                        // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GalleryMenuMovieListIndex;                         // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SaveLoadMapName;                                   // 0x015C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTitleInitFrontList;                               // 0x0164(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TitleFrontListIndex;                               // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TitleBackListIndex;                                // 0x016C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEnableSaveData;                                  // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEnableSaveDataSubStory;                          // 0x0171(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_172[0x6];                                      // 0x0172(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URCVariableTanteiPoint*                 TanteiPoint;                                       // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableFigure*                      Figure;                                            // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableSelectAlready*               SelectAlready;                                     // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableNazoBattle*                  NazoBattle;                                        // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableNazoResult*                  NazoResult;                                        // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableNazoCountDown*               NazoCountDown;                                     // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenu*                    GameMenu;                                          // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableLog*                         Backlog;                                           // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URCVariableGameMenuGallery*             Gallery;                                           // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastAccessActorName;                               // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDataLoadReturn;                                   // 0x01C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartDebugMenuDraw;                               // 0x01C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSaveEnable;                                       // 0x01CA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB[0x1];                                      // 0x01CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastCameraTagName;                                 // 0x01CC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableManager">();
	}
	static class URCVariableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableManager>();
	}
};
static_assert(alignof(URCVariableManager) == 0x000008, "Wrong alignment on URCVariableManager");
static_assert(sizeof(URCVariableManager) == 0x0001E0, "Wrong size on URCVariableManager");
static_assert(offsetof(URCVariableManager, GameMode) == 0x000028, "Member 'URCVariableManager::GameMode' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NextGameMode) == 0x000029, "Member 'URCVariableManager::NextGameMode' has a wrong offset!");
static_assert(offsetof(URCVariableManager, StoryMode) == 0x00002A, "Member 'URCVariableManager::StoryMode' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NowGameLevelInfo) == 0x00002C, "Member 'URCVariableManager::NowGameLevelInfo' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NextGameLevelInfo) == 0x000050, "Member 'URCVariableManager::NextGameLevelInfo' has a wrong offset!");
static_assert(offsetof(URCVariableManager, OldGameLevelInfo) == 0x000074, "Member 'URCVariableManager::OldGameLevelInfo' has a wrong offset!");
static_assert(offsetof(URCVariableManager, SaveGameLevelInfo) == 0x000098, "Member 'URCVariableManager::SaveGameLevelInfo' has a wrong offset!");
static_assert(offsetof(URCVariableManager, GameVariable) == 0x0000C0, "Member 'URCVariableManager::GameVariable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, ChapterVariable) == 0x0000D0, "Member 'URCVariableManager::ChapterVariable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, SceneVariable) == 0x0000E0, "Member 'URCVariableManager::SceneVariable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsGameClear) == 0x0000F0, "Member 'URCVariableManager::bIsGameClear' has a wrong offset!");
static_assert(offsetof(URCVariableManager, ClearChapterList) == 0x0000F8, "Member 'URCVariableManager::ClearChapterList' has a wrong offset!");
static_assert(offsetof(URCVariableManager, MainQuestPhase) == 0x000108, "Member 'URCVariableManager::MainQuestPhase' has a wrong offset!");
static_assert(offsetof(URCVariableManager, BusStopStatus) == 0x00010C, "Member 'URCVariableManager::BusStopStatus' has a wrong offset!");
static_assert(offsetof(URCVariableManager, BusStopStatusFromAreamap) == 0x000110, "Member 'URCVariableManager::BusStopStatusFromAreamap' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsMoveBusStop) == 0x000120, "Member 'URCVariableManager::bIsMoveBusStop' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsTitleCollectionEvent) == 0x000121, "Member 'URCVariableManager::bIsTitleCollectionEvent' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsCollectionEvent) == 0x000122, "Member 'URCVariableManager::bIsCollectionEvent' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsCollectionEventBack) == 0x000123, "Member 'URCVariableManager::bIsCollectionEventBack' has a wrong offset!");
static_assert(offsetof(URCVariableManager, CollectionMenuStorySceneName) == 0x000124, "Member 'URCVariableManager::CollectionMenuStorySceneName' has a wrong offset!");
static_assert(offsetof(URCVariableManager, CollectionMenuStoryChapterNum) == 0x00012C, "Member 'URCVariableManager::CollectionMenuStoryChapterNum' has a wrong offset!");
static_assert(offsetof(URCVariableManager, CollectionMenuSelectCharaID) == 0x000130, "Member 'URCVariableManager::CollectionMenuSelectCharaID' has a wrong offset!");
static_assert(offsetof(URCVariableManager, CollectionMenuSelectStoryIndex) == 0x000138, "Member 'URCVariableManager::CollectionMenuSelectStoryIndex' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bMessageAuto) == 0x00013C, "Member 'URCVariableManager::bMessageAuto' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bSkipEnable) == 0x00013D, "Member 'URCVariableManager::bSkipEnable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bFreeMoveSkipEnable) == 0x00013E, "Member 'URCVariableManager::bFreeMoveSkipEnable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bMovieSkipEnable) == 0x00013F, "Member 'URCVariableManager::bMovieSkipEnable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bExecMenuSceneLoad) == 0x000140, "Member 'URCVariableManager::bExecMenuSceneLoad' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bDrawDisableSubQuest) == 0x000141, "Member 'URCVariableManager::bDrawDisableSubQuest' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bIsGalleryMode) == 0x000142, "Member 'URCVariableManager::bIsGalleryMode' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bOpenGalleryMode) == 0x000143, "Member 'URCVariableManager::bOpenGalleryMode' has a wrong offset!");
static_assert(offsetof(URCVariableManager, GalleryMenuPlayingMovieID) == 0x000144, "Member 'URCVariableManager::GalleryMenuPlayingMovieID' has a wrong offset!");
static_assert(offsetof(URCVariableManager, GalleryMenuMovieSoundTable) == 0x000150, "Member 'URCVariableManager::GalleryMenuMovieSoundTable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, GalleryMenuMovieListIndex) == 0x000158, "Member 'URCVariableManager::GalleryMenuMovieListIndex' has a wrong offset!");
static_assert(offsetof(URCVariableManager, SaveLoadMapName) == 0x00015C, "Member 'URCVariableManager::SaveLoadMapName' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bTitleInitFrontList) == 0x000164, "Member 'URCVariableManager::bTitleInitFrontList' has a wrong offset!");
static_assert(offsetof(URCVariableManager, TitleFrontListIndex) == 0x000168, "Member 'URCVariableManager::TitleFrontListIndex' has a wrong offset!");
static_assert(offsetof(URCVariableManager, TitleBackListIndex) == 0x00016C, "Member 'URCVariableManager::TitleBackListIndex' has a wrong offset!");
static_assert(offsetof(URCVariableManager, IsEnableSaveData) == 0x000170, "Member 'URCVariableManager::IsEnableSaveData' has a wrong offset!");
static_assert(offsetof(URCVariableManager, IsEnableSaveDataSubStory) == 0x000171, "Member 'URCVariableManager::IsEnableSaveDataSubStory' has a wrong offset!");
static_assert(offsetof(URCVariableManager, TanteiPoint) == 0x000178, "Member 'URCVariableManager::TanteiPoint' has a wrong offset!");
static_assert(offsetof(URCVariableManager, Figure) == 0x000180, "Member 'URCVariableManager::Figure' has a wrong offset!");
static_assert(offsetof(URCVariableManager, SelectAlready) == 0x000188, "Member 'URCVariableManager::SelectAlready' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NazoBattle) == 0x000190, "Member 'URCVariableManager::NazoBattle' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NazoResult) == 0x000198, "Member 'URCVariableManager::NazoResult' has a wrong offset!");
static_assert(offsetof(URCVariableManager, NazoCountDown) == 0x0001A0, "Member 'URCVariableManager::NazoCountDown' has a wrong offset!");
static_assert(offsetof(URCVariableManager, GameMenu) == 0x0001A8, "Member 'URCVariableManager::GameMenu' has a wrong offset!");
static_assert(offsetof(URCVariableManager, Backlog) == 0x0001B0, "Member 'URCVariableManager::Backlog' has a wrong offset!");
static_assert(offsetof(URCVariableManager, Gallery) == 0x0001B8, "Member 'URCVariableManager::Gallery' has a wrong offset!");
static_assert(offsetof(URCVariableManager, LastAccessActorName) == 0x0001C0, "Member 'URCVariableManager::LastAccessActorName' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bDataLoadReturn) == 0x0001C8, "Member 'URCVariableManager::bDataLoadReturn' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bStartDebugMenuDraw) == 0x0001C9, "Member 'URCVariableManager::bStartDebugMenuDraw' has a wrong offset!");
static_assert(offsetof(URCVariableManager, bSaveEnable) == 0x0001CA, "Member 'URCVariableManager::bSaveEnable' has a wrong offset!");
static_assert(offsetof(URCVariableManager, LastCameraTagName) == 0x0001CC, "Member 'URCVariableManager::LastCameraTagName' has a wrong offset!");

// Class RC.RCVariableNazoBattle
// 0x0018 (0x0040 - 0x0028)
class URCVariableNazoBattle final : public UObject
{
public:
	struct FRCVariableNazoBattleInfo              BattleInfo;                                        // 0x0028(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableNazoBattle">();
	}
	static class URCVariableNazoBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableNazoBattle>();
	}
};
static_assert(alignof(URCVariableNazoBattle) == 0x000008, "Wrong alignment on URCVariableNazoBattle");
static_assert(sizeof(URCVariableNazoBattle) == 0x000040, "Wrong size on URCVariableNazoBattle");
static_assert(offsetof(URCVariableNazoBattle, BattleInfo) == 0x000028, "Member 'URCVariableNazoBattle::BattleInfo' has a wrong offset!");

// Class RC.RCVariableNazoCountDown
// 0x0008 (0x0030 - 0x0028)
class URCVariableNazoCountDown final : public UObject
{
public:
	class URCTimer*                               CountdownTimer;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableNazoCountDown">();
	}
	static class URCVariableNazoCountDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableNazoCountDown>();
	}
};
static_assert(alignof(URCVariableNazoCountDown) == 0x000008, "Wrong alignment on URCVariableNazoCountDown");
static_assert(sizeof(URCVariableNazoCountDown) == 0x000030, "Wrong size on URCVariableNazoCountDown");
static_assert(offsetof(URCVariableNazoCountDown, CountdownTimer) == 0x000028, "Member 'URCVariableNazoCountDown::CountdownTimer' has a wrong offset!");

// Class RC.RCVariableSaveSetting
// 0x0380 (0x03A8 - 0x0028)
class URCVariableSaveSetting final : public UObject
{
public:
	struct FRCVariableSystemSave                  VariableSystemSave;                                // 0x0028(0x0100)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRCVariableSave                        VariableSave;                                      // 0x0128(0x0280)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableSaveSetting">();
	}
	static class URCVariableSaveSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableSaveSetting>();
	}
};
static_assert(alignof(URCVariableSaveSetting) == 0x000008, "Wrong alignment on URCVariableSaveSetting");
static_assert(sizeof(URCVariableSaveSetting) == 0x0003A8, "Wrong size on URCVariableSaveSetting");
static_assert(offsetof(URCVariableSaveSetting, VariableSystemSave) == 0x000028, "Member 'URCVariableSaveSetting::VariableSystemSave' has a wrong offset!");
static_assert(offsetof(URCVariableSaveSetting, VariableSave) == 0x000128, "Member 'URCVariableSaveSetting::VariableSave' has a wrong offset!");

// Class RC.RCVariableSelectAlready
// 0x0010 (0x0038 - 0x0028)
class URCVariableSelectAlready final : public UObject
{
public:
	struct FRCVariableSelectAlreadyAllInfo        SelectAlreadyAllInfo;                              // 0x0028(0x0010)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableSelectAlready">();
	}
	static class URCVariableSelectAlready* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableSelectAlready>();
	}
};
static_assert(alignof(URCVariableSelectAlready) == 0x000008, "Wrong alignment on URCVariableSelectAlready");
static_assert(sizeof(URCVariableSelectAlready) == 0x000038, "Wrong size on URCVariableSelectAlready");
static_assert(offsetof(URCVariableSelectAlready, SelectAlreadyAllInfo) == 0x000028, "Member 'URCVariableSelectAlready::SelectAlreadyAllInfo' has a wrong offset!");

// Class RC.RCVariableTanteiPoint
// 0x0040 (0x0068 - 0x0028)
class URCVariableTanteiPoint final : public UObject
{
public:
	struct FRCVariableTanteiSystemInfo            TanteiSystemInfo;                                  // 0x0028(0x0028)(NativeAccessSpecifierPrivate)
	int32                                         DebugTotalSkillPoint;                              // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugSkillSlot;                                    // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVariableTanteiPoint">();
	}
	static class URCVariableTanteiPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVariableTanteiPoint>();
	}
};
static_assert(alignof(URCVariableTanteiPoint) == 0x000008, "Wrong alignment on URCVariableTanteiPoint");
static_assert(sizeof(URCVariableTanteiPoint) == 0x000068, "Wrong size on URCVariableTanteiPoint");
static_assert(offsetof(URCVariableTanteiPoint, TanteiSystemInfo) == 0x000028, "Member 'URCVariableTanteiPoint::TanteiSystemInfo' has a wrong offset!");
static_assert(offsetof(URCVariableTanteiPoint, DebugTotalSkillPoint) == 0x000050, "Member 'URCVariableTanteiPoint::DebugTotalSkillPoint' has a wrong offset!");
static_assert(offsetof(URCVariableTanteiPoint, DebugSkillSlot) == 0x000054, "Member 'URCVariableTanteiPoint::DebugSkillSlot' has a wrong offset!");

// Class RC.RCVehicleBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URCVehicleBPFunctionLibrary final : public URCBlueprintFunctionLibrary
{
public:
	static ECrossWalkSignalType GetCrossWalkSignal();
	static class AActor* GetCrossWalkTriggerBox();
	static class AActor* GetPlayerActor();
	static void SetCrossWalkSignal(ECrossWalkSignalType signalType);
	static void SetCrossWalkTriggerBox(class AActor* crossWalkTrigger);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleBPFunctionLibrary">();
	}
	static class URCVehicleBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVehicleBPFunctionLibrary>();
	}
};
static_assert(alignof(URCVehicleBPFunctionLibrary) == 0x000008, "Wrong alignment on URCVehicleBPFunctionLibrary");
static_assert(sizeof(URCVehicleBPFunctionLibrary) == 0x000028, "Wrong size on URCVehicleBPFunctionLibrary");

// Class RC.RCVehicleControlComponent
// 0x00C0 (0x0170 - 0x00B0)
class URCVehicleControlComponent final : public UActorComponent
{
public:
	ERCVehicleType                                vehicleType;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bodyHalfLength;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 pVehicleActor;                                     // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           tiresMeshArray;                                    // 0x00C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   bodyMesh;                                          // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCVehicleTarget*                       pStartTarget;                                      // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARCVehicleTarget*                       pEndTarget;                                        // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ARCVehicleTarget*>               targetActorArray;                                  // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTargetIndex;                                // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         arrivalTargetLength;                               // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Acceleration;                                      // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         accelerationBase;                                  // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAcceleration;                                   // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         tireSpeed;                                         // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentState;                                      // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         curveLerpCount;                                    // 0x011C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurve;                                           // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         curveLerp;                                         // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                beforeForwardVector;                               // 0x0128(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               bodyRotate;                                        // 0x0134(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         bodyRotateEaseAlpha;                               // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         speedEaseAlpha;                                    // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isNearVehicle;                                     // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         nextStateForCrossWalk;                             // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isThroughCrossWalk;                                // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         curveInterpSpeed;                                  // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          isCurveRotManual;                                  // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         curveRotBaseValue;                                 // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rollEndValue;                                      // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         alphaResetCount;                                   // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         speedCorrectionValue;                              // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaTimeBuf;                                      // 0x016C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Accelerator();
	void Brake();
	void ChangeState(int32 mstate);
	void CheckNearTarget();
	EVehicleState GetCurrentState();
	class AActor* GetCurrentTarget();
	class AActor* GetNextTarget();
	void Initialize(class AActor* controlActor, class ARCVehicleTarget* startTarget, class ARCVehicleTarget* endTarget, const TArray<class ARCVehicleTarget*>& rootTargetArray);
	void Move(float DeltaTime);
	void RollTiresForPitch();
	void SetBodyMesh(class UStaticMeshComponent* pBodyMesh);
	void SetControlActor(class AActor* pControlActor);
	void SetStartTargetPos();
	void SetTiresMeshArray(const TArray<class UStaticMeshComponent*>& bpTiresMeshArray);
	void Slow();
	void SpeedControl(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleControlComponent">();
	}
	static class URCVehicleControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCVehicleControlComponent>();
	}
};
static_assert(alignof(URCVehicleControlComponent) == 0x000008, "Wrong alignment on URCVehicleControlComponent");
static_assert(sizeof(URCVehicleControlComponent) == 0x000170, "Wrong size on URCVehicleControlComponent");
static_assert(offsetof(URCVehicleControlComponent, vehicleType) == 0x0000B0, "Member 'URCVehicleControlComponent::vehicleType' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, bodyHalfLength) == 0x0000B4, "Member 'URCVehicleControlComponent::bodyHalfLength' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, pVehicleActor) == 0x0000B8, "Member 'URCVehicleControlComponent::pVehicleActor' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, tiresMeshArray) == 0x0000C0, "Member 'URCVehicleControlComponent::tiresMeshArray' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, bodyMesh) == 0x0000D0, "Member 'URCVehicleControlComponent::bodyMesh' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, pStartTarget) == 0x0000D8, "Member 'URCVehicleControlComponent::pStartTarget' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, pEndTarget) == 0x0000E0, "Member 'URCVehicleControlComponent::pEndTarget' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, targetActorArray) == 0x0000E8, "Member 'URCVehicleControlComponent::targetActorArray' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, CurrentTargetIndex) == 0x0000F8, "Member 'URCVehicleControlComponent::CurrentTargetIndex' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, arrivalTargetLength) == 0x0000FC, "Member 'URCVehicleControlComponent::arrivalTargetLength' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, Speed) == 0x000100, "Member 'URCVehicleControlComponent::Speed' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, MaxSpeed) == 0x000104, "Member 'URCVehicleControlComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, Acceleration) == 0x000108, "Member 'URCVehicleControlComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, accelerationBase) == 0x00010C, "Member 'URCVehicleControlComponent::accelerationBase' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, MaxAcceleration) == 0x000110, "Member 'URCVehicleControlComponent::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, tireSpeed) == 0x000114, "Member 'URCVehicleControlComponent::tireSpeed' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, CurrentState) == 0x000118, "Member 'URCVehicleControlComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, curveLerpCount) == 0x00011C, "Member 'URCVehicleControlComponent::curveLerpCount' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, isCurve) == 0x000120, "Member 'URCVehicleControlComponent::isCurve' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, curveLerp) == 0x000124, "Member 'URCVehicleControlComponent::curveLerp' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, beforeForwardVector) == 0x000128, "Member 'URCVehicleControlComponent::beforeForwardVector' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, bodyRotate) == 0x000134, "Member 'URCVehicleControlComponent::bodyRotate' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, bodyRotateEaseAlpha) == 0x000140, "Member 'URCVehicleControlComponent::bodyRotateEaseAlpha' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, speedEaseAlpha) == 0x000144, "Member 'URCVehicleControlComponent::speedEaseAlpha' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, isNearVehicle) == 0x000148, "Member 'URCVehicleControlComponent::isNearVehicle' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, nextStateForCrossWalk) == 0x00014C, "Member 'URCVehicleControlComponent::nextStateForCrossWalk' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, isThroughCrossWalk) == 0x000150, "Member 'URCVehicleControlComponent::isThroughCrossWalk' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, curveInterpSpeed) == 0x000154, "Member 'URCVehicleControlComponent::curveInterpSpeed' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, isCurveRotManual) == 0x000158, "Member 'URCVehicleControlComponent::isCurveRotManual' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, curveRotBaseValue) == 0x00015C, "Member 'URCVehicleControlComponent::curveRotBaseValue' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, rollEndValue) == 0x000160, "Member 'URCVehicleControlComponent::rollEndValue' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, alphaResetCount) == 0x000164, "Member 'URCVehicleControlComponent::alphaResetCount' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, speedCorrectionValue) == 0x000168, "Member 'URCVehicleControlComponent::speedCorrectionValue' has a wrong offset!");
static_assert(offsetof(URCVehicleControlComponent, DeltaTimeBuf) == 0x00016C, "Member 'URCVehicleControlComponent::DeltaTimeBuf' has a wrong offset!");

// Class RC.RCVehicleController
// 0x0070 (0x02F8 - 0x0288)
class ARCVehicleController final : public ARCActor
{
public:
	int32                                         popUpCountMax;                                     // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         popUpCountMin;                                     // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         runningVehicleMax;                                 // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   vehicleTag;                                        // 0x0294(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           vehicleRoadTagName;                                // 0x02A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           vehicleStartTargetTagName;                         // 0x02B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           vehicleEndTargetTagName;                           // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         movingCharacterArray;                              // 0x02D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ARCCrossWalkController*                 crossWalkController;                               // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARCVehicleManager*                      pVehicleManager;                                   // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         popUpCount;                                        // 0x02F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         prevPopUpLane;                                     // 0x02F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckCrossWalkLength();
	void CheckFinishVehicle();
	void CheckPopUpCount();
	EVehicleCrossWalkState GerNearCrossWalk(class AActor* pCheckActor);
	int32 GetVehicleRateIndex(const TArray<int32>& rateArray);
	void Initialize();
	bool isOpenCrossWalk();
	bool PopUpVehicle(class ARCVehicleTarget* pInitStartTarget, EVehicleLaneType laneType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleController">();
	}
	static class ARCVehicleController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCVehicleController>();
	}
};
static_assert(alignof(ARCVehicleController) == 0x000008, "Wrong alignment on ARCVehicleController");
static_assert(sizeof(ARCVehicleController) == 0x0002F8, "Wrong size on ARCVehicleController");
static_assert(offsetof(ARCVehicleController, popUpCountMax) == 0x000288, "Member 'ARCVehicleController::popUpCountMax' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, popUpCountMin) == 0x00028C, "Member 'ARCVehicleController::popUpCountMin' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, runningVehicleMax) == 0x000290, "Member 'ARCVehicleController::runningVehicleMax' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, vehicleTag) == 0x000294, "Member 'ARCVehicleController::vehicleTag' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, vehicleRoadTagName) == 0x0002A0, "Member 'ARCVehicleController::vehicleRoadTagName' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, vehicleStartTargetTagName) == 0x0002B0, "Member 'ARCVehicleController::vehicleStartTargetTagName' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, vehicleEndTargetTagName) == 0x0002C0, "Member 'ARCVehicleController::vehicleEndTargetTagName' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, movingCharacterArray) == 0x0002D0, "Member 'ARCVehicleController::movingCharacterArray' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, crossWalkController) == 0x0002E0, "Member 'ARCVehicleController::crossWalkController' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, pVehicleManager) == 0x0002E8, "Member 'ARCVehicleController::pVehicleManager' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, popUpCount) == 0x0002F0, "Member 'ARCVehicleController::popUpCount' has a wrong offset!");
static_assert(offsetof(ARCVehicleController, prevPopUpLane) == 0x0002F4, "Member 'ARCVehicleController::prevPopUpLane' has a wrong offset!");

// Class RC.RCVehicleManager
// 0x0080 (0x0308 - 0x0288)
class ARCVehicleManager final : public ARCActor
{
public:
	TArray<class AActor*>                         vehicleArray;                                      // 0x0288(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRCRunningVehicleData>          runningVehicleArray;                               // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane1Array;                                        // 0x02A8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane2Array;                                        // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane3Array;                                        // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane4Array;                                        // 0x02D8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane5Array;                                        // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         lane6Array;                                        // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddRunningVehicle(class AActor* pVehicle, EVehicleLaneType laneType);
	void CheckFinishedVehicle();
	TArray<class AActor*> GetEnabledVehicleArray();
	class ARCVehicleTarget* GetLaneEndTarget(EVehicleLaneType laneType);
	TArray<class ARCVehicleTarget*> GetLaneRootTargetArray(EVehicleLaneType laneType);
	class ARCVehicleTarget* GetLaneStartTarget(EVehicleLaneType laneType);
	TArray<struct FRCRunningVehicleData> GetRunningVehicleArray();
	TArray<class AActor*> GetRunningVehicleForLane(EVehicleLaneType laneType);
	void SetEnableEngineSound(bool IsEnable);
	void SetEnableVehicleArray(const TArray<class AActor*>& enableVehicleArray);
	void SetLaneTargetArray(EVehicleLaneType laneType, const TArray<class AActor*>& laneTargetArray);
	void SetVisible(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleManager">();
	}
	static class ARCVehicleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCVehicleManager>();
	}
};
static_assert(alignof(ARCVehicleManager) == 0x000008, "Wrong alignment on ARCVehicleManager");
static_assert(sizeof(ARCVehicleManager) == 0x000308, "Wrong size on ARCVehicleManager");
static_assert(offsetof(ARCVehicleManager, vehicleArray) == 0x000288, "Member 'ARCVehicleManager::vehicleArray' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, runningVehicleArray) == 0x000298, "Member 'ARCVehicleManager::runningVehicleArray' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane1Array) == 0x0002A8, "Member 'ARCVehicleManager::lane1Array' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane2Array) == 0x0002B8, "Member 'ARCVehicleManager::lane2Array' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane3Array) == 0x0002C8, "Member 'ARCVehicleManager::lane3Array' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane4Array) == 0x0002D8, "Member 'ARCVehicleManager::lane4Array' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane5Array) == 0x0002E8, "Member 'ARCVehicleManager::lane5Array' has a wrong offset!");
static_assert(offsetof(ARCVehicleManager, lane6Array) == 0x0002F8, "Member 'ARCVehicleManager::lane6Array' has a wrong offset!");

// Class RC.RCVehicleTarget
// 0x0020 (0x02A8 - 0x0288)
class ARCVehicleTarget final : public ARCActor
{
public:
	EVehicleInitPositionLaneType                  firstSpawnIndex;                                   // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         lootIndex;                                         // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         vehicleSpeed;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         vehicleAcceleration;                               // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         curveSpeed;                                        // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isCurveManual;                                     // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         curveRotValue;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRootIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCVehicleTarget">();
	}
	static class ARCVehicleTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARCVehicleTarget>();
	}
};
static_assert(alignof(ARCVehicleTarget) == 0x000008, "Wrong alignment on ARCVehicleTarget");
static_assert(sizeof(ARCVehicleTarget) == 0x0002A8, "Wrong size on ARCVehicleTarget");
static_assert(offsetof(ARCVehicleTarget, firstSpawnIndex) == 0x000288, "Member 'ARCVehicleTarget::firstSpawnIndex' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, lootIndex) == 0x00028C, "Member 'ARCVehicleTarget::lootIndex' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, vehicleSpeed) == 0x000290, "Member 'ARCVehicleTarget::vehicleSpeed' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, vehicleAcceleration) == 0x000294, "Member 'ARCVehicleTarget::vehicleAcceleration' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, curveSpeed) == 0x000298, "Member 'ARCVehicleTarget::curveSpeed' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, isCurveManual) == 0x00029C, "Member 'ARCVehicleTarget::isCurveManual' has a wrong offset!");
static_assert(offsetof(ARCVehicleTarget, curveRotValue) == 0x0002A0, "Member 'ARCVehicleTarget::curveRotValue' has a wrong offset!");

// Class RC.RCWanderingSpiritAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class URCWanderingSpiritAnimInstance final : public URCAnimInstance
{
public:
	ERCWanderingSpiritMotionType                  AnimMode;                                          // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x17];                                     // 0x02B9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetLoopFlag(bool flag);
	void SetMotionPart(ERCWanderingSpiritMotionPart part);
	bool StartInPart(bool bStart);
	bool StartLoopPart(bool bStart);
	bool StartOutPart(bool bStart);

	bool GetLoopFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCWanderingSpiritAnimInstance">();
	}
	static class URCWanderingSpiritAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCWanderingSpiritAnimInstance>();
	}
};
static_assert(alignof(URCWanderingSpiritAnimInstance) == 0x000010, "Wrong alignment on URCWanderingSpiritAnimInstance");
static_assert(sizeof(URCWanderingSpiritAnimInstance) == 0x0002D0, "Wrong size on URCWanderingSpiritAnimInstance");
static_assert(offsetof(URCWanderingSpiritAnimInstance, AnimMode) == 0x0002B8, "Member 'URCWanderingSpiritAnimInstance::AnimMode' has a wrong offset!");

}

