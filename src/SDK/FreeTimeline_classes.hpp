#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FreeTimeline

#include "Basic.hpp"

#include "FreeTimeline_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class FreeTimeline.SSLevelSequenceActor
// 0x0030 (0x02D8 - 0x02A8)
class ASSLevelSequenceActor final : public ALevelSequenceActor
{
public:
	class FName                                   ManagedID;                                         // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKoratSequencerRebindInfo>      RebindInfoList;                                    // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsDestroy;                                        // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         CancelLevelSequence;                               // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancelPlayEnable;                                 // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRebindInfo(const struct FMovieSceneObjectBindingID& InBindingId, const class FString& InName, uint32 InActorGUID);
	class USSLevelSequencePlayer* GetSSSequencePlayer();
	bool IsSequencePlayerPlaying();
	void KillMySelf();
	bool PlaySequencePlayer(int32 StartFrame, bool bPauseAtEnd);
	bool PlaySequencePlayerByInfo(class FName Label, float PlayRatio);
	bool PlaySequencePlayerInLooping(int32 StartFrame, bool bPauseAtEnd, int32 NumLoops);
	void SetCancelLevelSequence(class ULevelSequence* InCancelLevelSequence);
	void SetPlayInfo(TArray<struct FKoratSequencePlayInfo>* InPlayInfoList);
	void SetPlayInfoNextLabel(class FName Label, class FName NewNextLabel);
	bool SetRebind(const class FString& InNameRegexPattern, class AActor* RebindActor, bool DisableAnimTrack, bool DisableTransformTrack);
	void SetRebindsForGame(bool bRebindOwnerCharacter, bool bRebindCharacterCamera, bool bRebindFrontCamera, bool bRebindToonDirectionLight);
	void SetSequencePlayerAttachParam(const struct FKoratAttachParamInfo& AttachParam);
	void StartCharacterCameraFromPlayerOnPlay();
	void StopPlayerAndDestroy(bool bCancel);
	void StopSequencePlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SSLevelSequenceActor">();
	}
	static class ASSLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASSLevelSequenceActor>();
	}
};
static_assert(alignof(ASSLevelSequenceActor) == 0x000008, "Wrong alignment on ASSLevelSequenceActor");
static_assert(sizeof(ASSLevelSequenceActor) == 0x0002D8, "Wrong size on ASSLevelSequenceActor");
static_assert(offsetof(ASSLevelSequenceActor, ManagedID) == 0x0002A8, "Member 'ASSLevelSequenceActor::ManagedID' has a wrong offset!");
static_assert(offsetof(ASSLevelSequenceActor, RebindInfoList) == 0x0002B0, "Member 'ASSLevelSequenceActor::RebindInfoList' has a wrong offset!");
static_assert(offsetof(ASSLevelSequenceActor, bIsDestroy) == 0x0002C0, "Member 'ASSLevelSequenceActor::bIsDestroy' has a wrong offset!");
static_assert(offsetof(ASSLevelSequenceActor, CancelLevelSequence) == 0x0002C8, "Member 'ASSLevelSequenceActor::CancelLevelSequence' has a wrong offset!");
static_assert(offsetof(ASSLevelSequenceActor, bCancelPlayEnable) == 0x0002D0, "Member 'ASSLevelSequenceActor::bCancelPlayEnable' has a wrong offset!");

// Class FreeTimeline.KoratEmitter
// 0x0060 (0x02D0 - 0x0270)
class AKoratEmitter : public AEmitter
{
public:
	class FName                                   ManagedID;                                         // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ExecuteActor;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachRootCompo;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTerrainRay;                                    // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TerrainSocketName;                                 // 0x02AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OriginManagedId;                                   // 0x02B4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleCompo;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KoratEmitter">();
	}
	static class AKoratEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKoratEmitter>();
	}
};
static_assert(alignof(AKoratEmitter) == 0x000008, "Wrong alignment on AKoratEmitter");
static_assert(sizeof(AKoratEmitter) == 0x0002D0, "Wrong size on AKoratEmitter");
static_assert(offsetof(AKoratEmitter, ManagedID) == 0x000270, "Member 'AKoratEmitter::ManagedID' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, ExecuteActor) == 0x000278, "Member 'AKoratEmitter::ExecuteActor' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, AttachRootCompo) == 0x0002A0, "Member 'AKoratEmitter::AttachRootCompo' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, bUseTerrainRay) == 0x0002A8, "Member 'AKoratEmitter::bUseTerrainRay' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, TerrainSocketName) == 0x0002AC, "Member 'AKoratEmitter::TerrainSocketName' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, OriginManagedId) == 0x0002B4, "Member 'AKoratEmitter::OriginManagedId' has a wrong offset!");
static_assert(offsetof(AKoratEmitter, ParticleCompo) == 0x0002C0, "Member 'AKoratEmitter::ParticleCompo' has a wrong offset!");

// Class FreeTimeline.SSLevelSequencePlayer
// 0x0088 (0x0688 - 0x0600)
class USSLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	bool                                          bOverrideAttachParam;                              // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x27];                                     // 0x0601(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ExecuteActor;                                      // 0x0628(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         SelectedLevelSequence;                             // 0x0630(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKoratSequencerMarkerInfo>      MarkerInfoList;                                    // 0x0638(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultDuration;                                   // 0x0648(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKoratSequencePlayInfo>         SequencerPlayInfoList;                             // 0x0650(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PlayInfoIndex;                                     // 0x0660(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionDataKey;                                     // 0x0664(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoopCount;                                         // 0x066C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ManagedID;                                         // 0x0670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AEmitter>>        ExternalLoopingEmitterList;                        // 0x0678(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnFinishedForExternalParticle();
	void SetSequencerPlaySeqNextLabel(class FName Label, class FName NewNextLabel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SSLevelSequencePlayer">();
	}
	static class USSLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USSLevelSequencePlayer>();
	}
};
static_assert(alignof(USSLevelSequencePlayer) == 0x000008, "Wrong alignment on USSLevelSequencePlayer");
static_assert(sizeof(USSLevelSequencePlayer) == 0x000688, "Wrong size on USSLevelSequencePlayer");
static_assert(offsetof(USSLevelSequencePlayer, bOverrideAttachParam) == 0x000600, "Member 'USSLevelSequencePlayer::bOverrideAttachParam' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, ExecuteActor) == 0x000628, "Member 'USSLevelSequencePlayer::ExecuteActor' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, SelectedLevelSequence) == 0x000630, "Member 'USSLevelSequencePlayer::SelectedLevelSequence' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, MarkerInfoList) == 0x000638, "Member 'USSLevelSequencePlayer::MarkerInfoList' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, DefaultDuration) == 0x000648, "Member 'USSLevelSequencePlayer::DefaultDuration' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, SequencerPlayInfoList) == 0x000650, "Member 'USSLevelSequencePlayer::SequencerPlayInfoList' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, PlayInfoIndex) == 0x000660, "Member 'USSLevelSequencePlayer::PlayInfoIndex' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, ActionDataKey) == 0x000664, "Member 'USSLevelSequencePlayer::ActionDataKey' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, LoopCount) == 0x00066C, "Member 'USSLevelSequencePlayer::LoopCount' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, ManagedID) == 0x000670, "Member 'USSLevelSequencePlayer::ManagedID' has a wrong offset!");
static_assert(offsetof(USSLevelSequencePlayer, ExternalLoopingEmitterList) == 0x000678, "Member 'USSLevelSequencePlayer::ExternalLoopingEmitterList' has a wrong offset!");

// Class FreeTimeline.KoratFreeTimelineSpawn
// 0x0080 (0x02A0 - 0x0220)
class AKoratFreeTimelineSpawn : public AActor
{
public:
	class ULevelSequence*                         FreeTimeline;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PlayerActor;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRebind;                                           // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAttachParam;                              // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x26];                                     // 0x023A(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         TestBlastSkill1SequenceData;                       // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         TestAuraSequenceData;                              // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         TestMuzulleSequenceData;                           // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKoratFreeTimelinePlayType                    PreTimelinePlayType;                               // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASSLevelSequenceActor*                  SequenceActor;                                     // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         SequenceData;                                      // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         CancelSequenceData;                                // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USSLevelSequencePlayer>  OwnerPlayer;                                       // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KoratFreeTimelineSpawn">();
	}
	static class AKoratFreeTimelineSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKoratFreeTimelineSpawn>();
	}
};
static_assert(alignof(AKoratFreeTimelineSpawn) == 0x000008, "Wrong alignment on AKoratFreeTimelineSpawn");
static_assert(sizeof(AKoratFreeTimelineSpawn) == 0x0002A0, "Wrong size on AKoratFreeTimelineSpawn");
static_assert(offsetof(AKoratFreeTimelineSpawn, FreeTimeline) == 0x000220, "Member 'AKoratFreeTimelineSpawn::FreeTimeline' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, PlayerActor) == 0x000230, "Member 'AKoratFreeTimelineSpawn::PlayerActor' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, bRebind) == 0x000238, "Member 'AKoratFreeTimelineSpawn::bRebind' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, bOverrideAttachParam) == 0x000239, "Member 'AKoratFreeTimelineSpawn::bOverrideAttachParam' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, TestBlastSkill1SequenceData) == 0x000260, "Member 'AKoratFreeTimelineSpawn::TestBlastSkill1SequenceData' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, TestAuraSequenceData) == 0x000268, "Member 'AKoratFreeTimelineSpawn::TestAuraSequenceData' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, TestMuzulleSequenceData) == 0x000270, "Member 'AKoratFreeTimelineSpawn::TestMuzulleSequenceData' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, PreTimelinePlayType) == 0x000278, "Member 'AKoratFreeTimelineSpawn::PreTimelinePlayType' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, SequenceActor) == 0x000280, "Member 'AKoratFreeTimelineSpawn::SequenceActor' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, SequenceData) == 0x000288, "Member 'AKoratFreeTimelineSpawn::SequenceData' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, CancelSequenceData) == 0x000290, "Member 'AKoratFreeTimelineSpawn::CancelSequenceData' has a wrong offset!");
static_assert(offsetof(AKoratFreeTimelineSpawn, OwnerPlayer) == 0x000298, "Member 'AKoratFreeTimelineSpawn::OwnerPlayer' has a wrong offset!");

// Class FreeTimeline.SSEffectManager
// 0x0000 (0x0028 - 0x0028)
class USSEffectManager final : public UObject
{
public:
	static void AddEffect(class UWorld* World, class FName Key, class AActor* EffectActor, class FName SeqName);
	static void AddExternalActor(class AActor* Actor, class FName SeqName);
	static void AddSequencer(class UWorld* World, class FName Key, class ASSLevelSequenceActor* SequencerActor);
	static class AActor* GetEffect(class UWorld* World, class FName Key);
	static TArray<class AActor*> GetEffects(class UWorld* World, class FName Key, class FName SeqActorName);
	static class AActor* GetExternalActor(class UWorld* World, class FName Key);
	static class UMaterialInstanceDynamic* GetOutlineMaterialInstance(class AActor* InOwner);
	static class ASSLevelSequenceActor* GetSequencer(class UWorld* World, class FName Key);
	static bool IsExistExternalActorKey(class FName Key);
	static bool IsExistKey(class FName Key);
	static bool IsExistSequencerKey(class FName Key);
	static void OutputDebugInfo();
	static void RemoveEffectAll(class UObject* WorldContextObject);
	static bool RemoveEffectKey(class FName Key);
	static void RemoveExternalActorAll(class UObject* WorldContextObject);
	static bool RemoveExternalActorKey(class FName Key);
	static bool RemoveExternalActorKeyByActor(class AActor* ExtActor);
	static void RemoveSequencerAll(class UObject* WorldContextObject);
	static bool RemoveSequencerKey(class FName Key);
	static class ULevelSequence* SelectCharacterFreeTimeline(class AActor* OwnerActor, EKoratFreeTimelineType TimelineType, class ULevelSequence** CancelSequenceData);
	static class ULevelSequence* SelectCharacterFreeTimelineAtb(class AActor* OwnerActor, EKoratFreeTimelineAtbType TimelineType, class FName AtbName);
	static class ULevelSequence* SelectCharacterFreeTimelineAtbBrk(class AActor* OwnerActor, EKoratFreeTimelineAtbBrkType TimelineType, class FName AtbName);
	static void SetCharacterOutline(class AActor* InChara, bool bEnable, class FName InTypeName);
	static void SetCharacterOutlineFill(class AActor* InChara, bool bEnable);
	static void SetCharacterStencil(class AActor* InChara, int32 StencilIndex, bool bEnable);
	static class ASSLevelSequenceActor* SpawnSequenceActor(const struct FSequenceActorSpawnParameters& InParameters);
	static class ASSLevelSequenceActor* SpawnSequenceActorForFreeTimeline(class AActor* OwnerActor, EKoratFreeTimelineType TimelineType, const TArray<struct FKoratSequencePlayInfo>& PlaySeq, bool bLooped, bool bPauseAtEnd, class FName ManagedID, int32 StartFrame, bool bRebindPlayer);
	static class ASSLevelSequenceActor* SpawnSequenceActorForFreeTimelineAtb(class AActor* OwnerActor, EKoratFreeTimelineAtbType TimelineType, const TArray<struct FKoratSequencePlayInfo>& PlaySeq, bool bLooped, bool bPauseAtEnd, class FName ManagedID, int32 StartFrame, bool bRebindPlayer);
	static class ASSLevelSequenceActor* SpawnSequenceActorForFreeTimelineAtbBrk(class AActor* OwnerActor, EKoratFreeTimelineAtbBrkType TimelineType, const TArray<struct FKoratSequencePlayInfo>& PlaySeq, bool bLooped, bool bPauseAtEnd, class FName ManagedID, int32 StartFrame, bool bRebindPlayer);
	static class ASSLevelSequenceActor* SpawnSequenceActorForFreeTimelineDirect(class AActor* BaseActor, class ULevelSequence* LevelSequence, const struct FTransform& Transform, class FName ManagedID, bool bRebindPlayer);
	static class ASSLevelSequenceActor* SpawnSequenceActorSyncFreeTimeline(class AActor* OwnerActor, class ULevelSequence* LevelSequence, const TArray<struct FKoratSequencePlayInfo>& PlaySeq, bool bOverrideTransform, const struct FTransform& OverrideTransform, class FName ManagedID, bool bRebindPlayer, bool bPlayExec, class ULevelSequence* CancelSequence, const class FName ActionDataKey);
	static class ASSLevelSequenceActor* SpawnSequenceActorSyncMontage(class AActor* OwnerActor, class ULevelSequence* LevelSequence, const TArray<struct FKoratSequencePlayInfo>& PlaySeq, bool bLooped, bool bPauseAtEnd, class FName ManagedID, int32 StartFrame, bool bRebindPlayer, bool bPlayExec, class ULevelSequence* CancelSequence, const class FName ActionDataKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SSEffectManager">();
	}
	static class USSEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USSEffectManager>();
	}
};
static_assert(alignof(USSEffectManager) == 0x000008, "Wrong alignment on USSEffectManager");
static_assert(sizeof(USSEffectManager) == 0x000028, "Wrong size on USSEffectManager");

}

